\hypertarget{namespacescipy_1_1linalg_1_1basic}{}\section{scipy.\+linalg.\+basic Namespace Reference}
\label{namespacescipy_1_1linalg_1_1basic}\index{scipy.\+linalg.\+basic@{scipy.\+linalg.\+basic}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_a618dc480e14a814fd4a2395ba53b50e7}{solve}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_a017b69b8ff66f4b8757018bfadd02873}{solve\+\_\+triangular}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_a35092781d6681b7b40d8dd45f2a9790d}{solve\+\_\+banded}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_af5fd739c7537dc4779eb2e674d8b83a5}{solveh\+\_\+banded}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_ad2f6be11d92b6c15702a14760d933d53}{inv}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_a92ff1fe000b99eb230692b1ed4edfe0c}{det}
\begin{DoxyCompactList}\small\item\em Determinant. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_a866b938265017a8d18ba074a81ccd81b}{lstsq}
\begin{DoxyCompactList}\small\item\em Linear Least Squares. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_ab6ce4e24deea881fa02e1cab48cd4dc6}{pinv}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_a7686761d4c79362e6ad6a99bbc437465}{pinv2}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1basic_a3ad70f66a6c3436a94808defd328cbe0}{pinvh}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \hyperlink{namespacescipy_1_1linalg_1_1basic_a2a856b117fbb1d565e9d987460450e60}{\+\_\+\+\_\+all\+\_\+\+\_\+}
\item 
tuple \hyperlink{namespacescipy_1_1linalg_1_1basic_af1951fa4e079ed35213a43729a2e1466}{lwork} = \hyperlink{linalg_2src_2calc__lwork_8f_a0e2dbd8c022170c3b6b6690870c0765b}{calc\+\_\+lwork.\+getri}(getri.\+typecode, \hyperlink{shape_8h_a9d9da3dcaecbbde6cf1961063f2e838b}{a1.\+shape}\mbox{[}0\mbox{]})
\begin{DoxyCompactList}\small\item\em finv, = get\+\_\+flinalg\+\_\+funcs(('inv',),(a1,)) if finv is not None\+: a\+\_\+inv,info = finv(a1,overwrite\+\_\+a=overwrite\+\_\+a) if info==0\+: return a\+\_\+inv if info$>$0\+: raise Lin\+Alg\+Error, \char`\"{}singular matrix\char`\"{} if info$<$0\+: raise Value\+Error,\textbackslash{} 'illegal value in d-\/th argument of internal inv.\+getrf$\vert$getri'\%(-\/info) \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespacescipy_1_1linalg_1_1basic_a92ff1fe000b99eb230692b1ed4edfe0c}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!det@{det}}
\index{det@{det}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{det}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+det (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{overwrite\+\_\+a = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_a92ff1fe000b99eb230692b1ed4edfe0c}


Determinant. 

\begin{DoxyVerb}Compute the determinant of a matrix

The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.

The determinant for a 3x3 matrix, for example, is computed as follows::

    a    b    c
    d    e    f = A
    g    h    i

    det(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h

Parameters
----------
a : (M, M) array_like
    A square matrix.
overwrite_a : bool
    Allow overwriting data in a (may enhance performance).
check_finite : boolean, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
det : float or complex
    Determinant of `a`.

Notes
-----
The determinant is computed via LU factorization, LAPACK routine z/dgetrf.

Examples
--------
>>> a = np.array([[1,2,3],[4,5,6],[7,8,9]])
>>> linalg.det(a)
0.0
>>> a = np.array([[0,2,3],[4,5,6],[7,8,9]])
>>> linalg.det(a)
3.0\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_ad2f6be11d92b6c15702a14760d933d53}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!inv@{inv}}
\index{inv@{inv}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{inv}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+inv (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{overwrite\+\_\+a = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_ad2f6be11d92b6c15702a14760d933d53}
\begin{DoxyVerb}Compute the inverse of a matrix.

Parameters
----------
a : array_like
    Square matrix to be inverted.
overwrite_a : bool, optional
    Discard data in `a` (may improve performance). Default is False.
check_finite : boolean, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
ainv : ndarray
    Inverse of the matrix `a`.

Raises
------
LinAlgError :
    If `a` is singular.
ValueError :
    If `a` is not square, or not 2-dimensional.

Examples
--------
>>> a = np.array([[1., 2.], [3., 4.]])
>>> sp.linalg.inv(a)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
>>> np.dot(a, sp.linalg.inv(a))
array([[ 1.,  0.],
       [ 0.,  1.]])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_a866b938265017a8d18ba074a81ccd81b}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!lstsq@{lstsq}}
\index{lstsq@{lstsq}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{lstsq}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+lstsq (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b, }
\item[{}]{cond = {\ttfamily None}, }
\item[{}]{overwrite\+\_\+a = {\ttfamily {\bf False}}, }
\item[{}]{overwrite\+\_\+b = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_a866b938265017a8d18ba074a81ccd81b}


Linear Least Squares. 

\begin{DoxyVerb}Compute least-squares solution to equation Ax = b.

Compute a vector x such that the 2-norm ``|b - A x|`` is minimized.

Parameters
----------
a : (M, N) array_like
    Left hand side matrix (2-D array).
b : (M,) or (M, K) array_like
    Right hand side matrix or vector (1-D or 2-D array).
cond : float, optional
    Cutoff for 'small' singular values; used to determine effective
    rank of a. Singular values smaller than
    ``rcond * largest_singular_value`` are considered zero.
overwrite_a : bool, optional
    Discard data in `a` (may enhance performance). Default is False.
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance). Default is False.
check_finite : boolean, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (N,) or (N, K) ndarray
    Least-squares solution.  Return shape matches shape of `b`.
residues : () or (1,) or (K,) ndarray
    Sums of residues, squared 2-norm for each column in ``b - a x``.
    If rank of matrix a is < N or > M this is an empty array.
    If b was 1-D, this is an (1,) shape array, otherwise the shape is (K,).
rank : int
    Effective rank of matrix `a`.
s : (min(M,N),) ndarray
    Singular values of `a`. The condition number of a is
    ``abs(s[0]/s[-1])``.

Raises
------
LinAlgError :
    If computation does not converge.


See Also
--------
optimize.nnls : linear least squares with non-negativity constraint\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_ab6ce4e24deea881fa02e1cab48cd4dc6}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!pinv@{pinv}}
\index{pinv@{pinv}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{pinv}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+pinv (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{cond = {\ttfamily None}, }
\item[{}]{rcond = {\ttfamily None}, }
\item[{}]{return\+\_\+rank = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_ab6ce4e24deea881fa02e1cab48cd4dc6}
\begin{DoxyVerb}Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate a generalized inverse of a matrix using a least-squares
solver.

Parameters
----------
a : (M, N) array_like
    Matrix to be pseudo-inverted.
cond, rcond : float, optional
    Cutoff for 'small' singular values in the least-squares solver.
    Singular values smaller than ``rcond * largest_singular_value``
    are considered zero.
return_rank : bool, optional
    if True, return the effective rank of the matrix
check_finite : boolean, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, M) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if return_rank == True

Raises
------
LinAlgError
    If computation does not converge.

Examples
--------
>>> a = np.random.randn(9, 6)
>>> B = linalg.pinv(a)
>>> np.allclose(a, dot(a, dot(B, a)))
True
>>> np.allclose(B, dot(B, dot(a, B)))
True\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_a7686761d4c79362e6ad6a99bbc437465}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!pinv2@{pinv2}}
\index{pinv2@{pinv2}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{pinv2}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+pinv2 (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{cond = {\ttfamily None}, }
\item[{}]{rcond = {\ttfamily None}, }
\item[{}]{return\+\_\+rank = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_a7686761d4c79362e6ad6a99bbc437465}
\begin{DoxyVerb}Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate a generalized inverse of a matrix using its
singular-value decomposition and including all 'large' singular
values.

Parameters
----------
a : (M, N) array_like
    Matrix to be pseudo-inverted.
cond, rcond : float or None
    Cutoff for 'small' singular values.
    Singular values smaller than ``rcond*largest_singular_value``
    are considered zero.
    If None or -1, suitable machine precision is used.
return_rank : bool, optional
    if True, return the effective rank of the matrix
check_finite : boolean, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, M) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if return_rank == True

Raises
------
LinAlgError
    If SVD computation does not converge.

Examples
--------
>>> a = np.random.randn(9, 6)
>>> B = linalg.pinv2(a)
>>> np.allclose(a, dot(a, dot(B, a)))
True
>>> np.allclose(B, dot(B, dot(a, B)))
True\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_a3ad70f66a6c3436a94808defd328cbe0}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!pinvh@{pinvh}}
\index{pinvh@{pinvh}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{pinvh}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+pinvh (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{cond = {\ttfamily None}, }
\item[{}]{rcond = {\ttfamily None}, }
\item[{}]{lower = {\ttfamily {\bf True}}, }
\item[{}]{return\+\_\+rank = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_a3ad70f66a6c3436a94808defd328cbe0}
\begin{DoxyVerb}Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.

Calculate a generalized inverse of a Hermitian or real symmetric matrix
using its eigenvalue decomposition and including all eigenvalues with
'large' absolute value.

Parameters
----------
a : (N, N) array_like
    Real symmetric or complex hermetian matrix to be pseudo-inverted
cond, rcond : float or None
    Cutoff for 'small' eigenvalues.
    Singular values smaller than rcond * largest_eigenvalue are considered
    zero.

    If None or -1, suitable machine precision is used.
lower : bool
    Whether the pertinent array data is taken from the lower or upper
    triangle of a. (Default: lower)
return_rank : bool, optional
    if True, return the effective rank of the matrix
check_finite : boolean, optional
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
B : (N, N) ndarray
    The pseudo-inverse of matrix `a`.
rank : int
    The effective rank of the matrix.  Returned if return_rank == True

Raises
------
LinAlgError
    If eigenvalue does not converge

Examples
--------
>>> from numpy import *
>>> a = random.randn(9, 6)
>>> a = np.dot(a, a.T)
>>> B = pinvh(a)
>>> allclose(a, dot(a, dot(B, a)))
True
>>> allclose(B, dot(B, dot(a, B)))
True\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_a618dc480e14a814fd4a2395ba53b50e7}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!solve@{solve}}
\index{solve@{solve}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{solve}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+solve (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b, }
\item[{}]{sym\+\_\+pos = {\ttfamily {\bf False}}, }
\item[{}]{lower = {\ttfamily {\bf False}}, }
\item[{}]{overwrite\+\_\+a = {\ttfamily {\bf False}}, }
\item[{}]{overwrite\+\_\+b = {\ttfamily {\bf False}}, }
\item[{}]{debug = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_a618dc480e14a814fd4a2395ba53b50e7}
\begin{DoxyVerb}Solve the equation ``a x = b`` for ``x``.

Parameters
----------
a : (M, M) array_like
    A square matrix.
b : (M,) or (M, N) array_like
    Right-hand side matrix in ``a x = b``.
sym_pos : bool
    Assume `a` is symmetric and positive definite.
lower : boolean
    Use only data contained in the lower triangle of `a`, if `sym_pos` is
    true.  Default is to use upper triangle.
overwrite_a : bool
    Allow overwriting data in `a` (may enhance performance).
    Default is False.
overwrite_b : bool
    Allow overwriting data in `b` (may enhance performance).
    Default is False.
check_finite : boolean, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, N) ndarray
    Solution to the system ``a x = b``.  Shape of the return matches the
    shape of `b`.

Raises
------
LinAlgError
    If `a` is singular.

Examples
--------
Given `a` and `b`, solve for `x`:

>>> a = np.array([[3,2,0],[1,-1,0],[0,5,1]])
>>> b = np.array([2,4,-1])
>>> x = linalg.solve(a,b)
>>> x
array([ 2., -2.,  9.])
>>> np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_a35092781d6681b7b40d8dd45f2a9790d}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!solve\+\_\+banded@{solve\+\_\+banded}}
\index{solve\+\_\+banded@{solve\+\_\+banded}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{solve\+\_\+banded}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+solve\+\_\+banded (
\begin{DoxyParamCaption}
\item[{}]{l\+\_\+and\+\_\+u, }
\item[{}]{ab, }
\item[{}]{b, }
\item[{}]{overwrite\+\_\+ab = {\ttfamily {\bf False}}, }
\item[{}]{overwrite\+\_\+b = {\ttfamily {\bf False}}, }
\item[{}]{debug = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_a35092781d6681b7b40d8dd45f2a9790d}
\begin{DoxyVerb}Solve the equation a x = b for x, assuming a is banded matrix.

The matrix a is stored in `ab` using the matrix diagonal ordered form::

    ab[u + i - j, j] == a[i,j]

Example of `ab` (shape of a is (6,6), `u` =1, `l` =2)::

    *    a01  a12  a23  a34  a45
    a00  a11  a22  a33  a44  a55
    a10  a21  a32  a43  a54   *
    a20  a31  a42  a53   *    *

Parameters
----------
(l, u) : (integer, integer)
    Number of non-zero lower and upper diagonals
ab : (`l` + `u` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : boolean, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : boolean, optional
    Discard data in `b` (may enhance performance)
check_finite : boolean, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system a x = b.  Returned shape depends on the
    shape of `b`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_a017b69b8ff66f4b8757018bfadd02873}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!solve\+\_\+triangular@{solve\+\_\+triangular}}
\index{solve\+\_\+triangular@{solve\+\_\+triangular}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{solve\+\_\+triangular}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+solve\+\_\+triangular (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b, }
\item[{}]{trans = {\ttfamily 0}, }
\item[{}]{lower = {\ttfamily {\bf False}}, }
\item[{}]{unit\+\_\+diagonal = {\ttfamily {\bf False}}, }
\item[{}]{overwrite\+\_\+b = {\ttfamily {\bf False}}, }
\item[{}]{debug = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_a017b69b8ff66f4b8757018bfadd02873}
\begin{DoxyVerb}Solve the equation `a x = b` for `x`, assuming a is a triangular matrix.

Parameters
----------
a : (M, M) array_like
    A triangular matrix
b : (M,) or (M, N) array_like
    Right-hand side matrix in `a x = b`
lower : boolean
    Use only data contained in the lower triangle of `a`.
    Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
    Type of system to solve:

    ========  =========
    trans     system
    ========  =========
    0 or 'N'  a x  = b
    1 or 'T'  a^T x = b
    2 or 'C'  a^H x = b
    ========  =========
unit_diagonal : bool, optional
    If True, diagonal elements of `a` are assumed to be 1 and
    will not be referenced.
overwrite_b : bool, optional
    Allow overwriting data in `b` (may enhance performance)
check_finite : bool, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, N) ndarray
    Solution to the system `a x = b`.  Shape of return matches `b`.

Raises
------
LinAlgError
    If `a` is singular

Notes
-----
.. versionadded:: 0.9.0\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1basic_af5fd739c7537dc4779eb2e674d8b83a5}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!solveh\+\_\+banded@{solveh\+\_\+banded}}
\index{solveh\+\_\+banded@{solveh\+\_\+banded}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{solveh\+\_\+banded}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+basic.\+solveh\+\_\+banded (
\begin{DoxyParamCaption}
\item[{}]{ab, }
\item[{}]{b, }
\item[{}]{overwrite\+\_\+ab = {\ttfamily {\bf False}}, }
\item[{}]{overwrite\+\_\+b = {\ttfamily {\bf False}}, }
\item[{}]{lower = {\ttfamily {\bf False}}, }
\item[{}]{check\+\_\+finite = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1basic_af5fd739c7537dc4779eb2e674d8b83a5}
\begin{DoxyVerb}Solve equation a x = b. a is Hermitian positive-definite banded matrix.

The matrix a is stored in `ab` either in lower diagonal or upper
diagonal ordered form:

    ab[u + i - j, j] == a[i,j]        (if upper form; i <= j)
    ab[    i - j, j] == a[i,j]        (if lower form; i >= j)

Example of `ab` (shape of a is (6,6), `u` =2)::

    upper form:
    *   *   a02 a13 a24 a35
    *   a01 a12 a23 a34 a45
    a00 a11 a22 a33 a44 a55

    lower form:
    a00 a11 a22 a33 a44 a55
    a10 a21 a32 a43 a54 *
    a20 a31 a42 a53 *   *

Cells marked with * are not used.

Parameters
----------
ab : (`u` + 1, M) array_like
    Banded matrix
b : (M,) or (M, K) array_like
    Right-hand side
overwrite_ab : bool, optional
    Discard data in `ab` (may enhance performance)
overwrite_b : bool, optional
    Discard data in `b` (may enhance performance)
lower : bool, optional
    Is the matrix in the lower form. (Default is upper form)
check_finite : boolean, optional
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.

Returns
-------
x : (M,) or (M, K) ndarray
    The solution to the system a x = b.  Shape of return matches shape
    of `b`.\end{DoxyVerb}
 

\subsection{Variable Documentation}
\hypertarget{namespacescipy_1_1linalg_1_1basic_a2a856b117fbb1d565e9d987460450e60}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{\+\_\+\+\_\+all\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}list scipy.\+linalg.\+basic.\+\_\+\+\_\+all\+\_\+\+\_\+}\label{namespacescipy_1_1linalg_1_1basic_a2a856b117fbb1d565e9d987460450e60}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = [\textcolor{stringliteral}{'solve'}, \textcolor{stringliteral}{'solve\_triangular'}, \textcolor{stringliteral}{'solveh\_banded'}, \textcolor{stringliteral}{'solve\_banded'},
2             \textcolor{stringliteral}{'inv'}, \textcolor{stringliteral}{'det'}, \textcolor{stringliteral}{'lstsq'}, \textcolor{stringliteral}{'pinv'}, \textcolor{stringliteral}{'pinv2'}, \textcolor{stringliteral}{'pinvh'}]
\end{DoxyCode}
\hypertarget{namespacescipy_1_1linalg_1_1basic_af1951fa4e079ed35213a43729a2e1466}{}\index{scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}!lwork@{lwork}}
\index{lwork@{lwork}!scipy\+::linalg\+::basic@{scipy\+::linalg\+::basic}}
\subsubsection[{lwork}]{\setlength{\rightskip}{0pt plus 5cm}tuple scipy.\+linalg.\+basic.\+lwork = {\bf calc\+\_\+lwork.\+getri}(getri.\+typecode, {\bf a1.\+shape}\mbox{[}0\mbox{]})}\label{namespacescipy_1_1linalg_1_1basic_af1951fa4e079ed35213a43729a2e1466}


finv, = get\+\_\+flinalg\+\_\+funcs(('inv',),(a1,)) if finv is not None\+: a\+\_\+inv,info = finv(a1,overwrite\+\_\+a=overwrite\+\_\+a) if info==0\+: return a\+\_\+inv if info$>$0\+: raise Lin\+Alg\+Error, \char`\"{}singular matrix\char`\"{} if info$<$0\+: raise Value\+Error,\textbackslash{} 'illegal value in d-\/th argument of internal inv.\+getrf$\vert$getri'\%(-\/info) 

