\hypertarget{namespacescipy_1_1stats_1_1stats}{}\section{scipy.\+stats.\+stats Namespace Reference}
\label{namespacescipy_1_1stats_1_1stats}\index{scipy.\+stats.\+stats@{scipy.\+stats.\+stats}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a69c44b392136bf66869061d07d655f3e}{find\+\_\+repeats}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ab1638103f489bcc1a2fe06c806413da8}{nanmean}
\begin{DoxyCompactList}\small\item\em N\+A\+N friendly functions. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a4c3bc74fa7ca3f5f0d0cfbb5f97b79c3}{nanstd}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a9ea387540ef1b6b56a62088d3b38b3cb}{nanmedian}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a48fb267e94c5eb1b26a5c10776f3e2b4}{gmean}
\begin{DoxyCompactList}\small\item\em C\+E\+N\+T\+R\+A\+L T\+E\+N\+D\+E\+N\+C\+Y \#\#\#\#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_aac6c16e0d657f32648fc7c0e8a367336}{hmean}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a82088ab884e71ebc98dc6b05d1c0a6a0}{mode}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ab8a3087296c7f76c65fc2fa68a55e523}{mask\+\_\+to\+\_\+limits}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a3826e86ff6b9eb4b4596335bd2a0f47d}{tmean}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a3bc0c6247ce0aa3bdbe9bf5310d336c8}{masked\+\_\+var}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a83ca47e55ba2a93bb820b00ccb237d67}{tvar}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_aa0738b7e12963beee896c5f47db4fd4b}{tmin}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ab5ff5057b7e0f015c7a82a3fd300fb34}{tmax}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_aab06e06d1821e3622968f6c370eb7af2}{tstd}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a76bb263845b2f0def598dd16a59e5bd3}{tsem}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a254bd9c2c209d8ffc73376ebd700edfc}{moment}
\begin{DoxyCompactList}\small\item\em M\+O\+M\+E\+N\+T\+S \#\#\#\#\#\#\#\#\#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a90ddfd8c7688498b52f36a7e56f7c996}{variation}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a744ba715bda869ac6edbadbb3223c5d5}{skew}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a9d516fe8283e7c7a3bee49903bbf4c64}{kurtosis}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_af65c740b3d78e11bf6f87843a126d837}{describe}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_af83023d02b569b719ce5ae04cdb5caa0}{skewtest}
\begin{DoxyCompactList}\small\item\em N\+O\+R\+M\+A\+L\+I\+T\+Y T\+E\+S\+T\+S \#\#\#\#\#\#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a8a22cd6b7bca6bb0a1497c02cf69e981}{kurtosistest}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ab1d985f5480e2bb7b15612b8fcbcd08a}{normaltest}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a4431b91647766f533c7003141ad52efd}{jarque\+\_\+bera}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a973cd5f47a121bcabbc0c181a5c50fb9}{itemfreq}
\begin{DoxyCompactList}\small\item\em F\+R\+E\+Q\+U\+E\+N\+C\+Y F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a72a6f95981ff8c462388584ecbf1fdb3}{scoreatpercentile}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a5bfdda61db9243c3bbfea7bead760155}{percentileofscore}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a8a1c376b310589575a9ff49c01dd573e}{histogram2}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ad7bf370c4741b90596c8cecb021f2700}{histogram}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a4fa11e21b0bc19cae7fc92d8a4960462}{cumfreq}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a651c9a0a2dd7ea81ee73daf3bda40fde}{relfreq}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a1bd45b2af0f91d4eb96626caf14d2ea3}{obrientransform}
\begin{DoxyCompactList}\small\item\em V\+A\+R\+I\+A\+B\+I\+L\+I\+T\+Y F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a7bb1bd5893a4e236fe9c3da20acd31fe}{signaltonoise}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a60937a31f8ba30ec6197e9a24c124089}{sem}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_afb06bf21578e516d2bc0d9f09e9ce872}{zscore}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a90bce292719490568f8782fd2e5f4aa8}{zmap}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ab66a77dd455f02d880db0d592ff92bdd}{threshold}
\begin{DoxyCompactList}\small\item\em T\+R\+I\+M\+M\+I\+N\+G F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a8bc5d99927c5e160441e11270a1be982}{sigmaclip}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a1354a0d681b70e167d85e50408f58bb7}{trimboth}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a3bb9cd623c8771cf86301cbbe54dbbab}{trim1}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a89437599855e82f8fb127a272820db0e}{trim\+\_\+mean}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a9346383e181e93b1660d793d6081bd1a}{f\+\_\+oneway}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a807da91092280c6c409ba4dd7aecf0ae}{pearsonr}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_aff7e685424bb5315cb65e12ddb5260f4}{fisher\+\_\+exact}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a33d608de2cbc6328c57ba67d3ad0a253}{spearmanr}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ab33df19284919454cbde0baf361d2287}{pointbiserialr}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a484892cdf73483268a7f152eef1ae783}{kendalltau}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a1dc45b95d34e45687312f7cf93b8f7ee}{linregress}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_aaec760400f4bdc5e967fe375757db5ad}{ttest\+\_\+1samp}
\begin{DoxyCompactList}\small\item\em I\+N\+F\+E\+R\+E\+N\+T\+I\+A\+L S\+T\+A\+T\+I\+S\+T\+I\+C\+S \#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a84703cd17b880e6be5071f665c0ebcc0}{ttest\+\_\+ind}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_aed469b7890b916252322b8536991f72f}{ttest\+\_\+rel}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a20ee3cba8d73095d2c9b1f2810facbfd}{kstest}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a14512b7b896743b932c0b31425740432}{power\+\_\+divergence}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a53fbdf360f83246922ca24554f8baefa}{chisquare}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a43a4544480a8139b6c0ee7421210e53c}{ks\+\_\+2samp}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_ab1d6bbc85f44f5ff1083f04839e5291e}{mannwhitneyu}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a43186935210b50e761236cad7f4197ea}{ranksums}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a4e2fff18e299993bcc12e0e3c5de4f7e}{kruskal}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a1bd75857c9de144bfaddff735251937d}{friedmanchisquare}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_aae24e21814c47295188da5e409fbf5d3}{chisqprob}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a3e7685fba302d7d422c51406425ca9fa}{betai}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a44e70e3ef03804f5c935efe5dc2f319b}{f\+\_\+value\+\_\+wilks\+\_\+lambda}
\begin{DoxyCompactList}\small\item\em A\+N\+O\+V\+A C\+A\+L\+C\+U\+L\+A\+T\+I\+O\+N\+S \#\#\#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a3d5ee5a28595171b4204a98c3961f7ce}{f\+\_\+value}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a4795beed156e1591a1bffa0e013b1c11}{f\+\_\+value\+\_\+multivariate}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a73704e49e0db2b3a28f07bc36086f4dc}{ss}
\begin{DoxyCompactList}\small\item\em S\+U\+P\+P\+O\+R\+T F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#\#\#\#. \end{DoxyCompactList}\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a1680aa2ef3675bd4e3b47c7ee0ae6b6b}{square\+\_\+of\+\_\+sums}
\item 
def \hyperlink{namespacescipy_1_1stats_1_1stats_a9c9a228e8fa482503318a37074f3ee2e}{fastsort}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacescipy_1_1stats_1_1stats_ac590997675d3ecc91073b26005afd4f2}{pysum} = \hyperlink{vecsum_8cc_a208c561460f0b32ffa279a7ed7b7afa4}{sum}
\item 
list \hyperlink{namespacescipy_1_1stats_1_1stats_af64e57aacdbdd2800961c4f1ab76adb7}{\+\_\+\+\_\+all\+\_\+\+\_\+}
\item 
dictionary \hyperlink{namespacescipy_1_1stats_1_1stats_a1170151fdd7757465759450c6990a85b}{\+\_\+power\+\_\+div\+\_\+lambda\+\_\+names}
\item 
tuple \hyperlink{namespacescipy_1_1stats_1_1stats_a2d6aedf55bc357862b482d97ffe38b9e}{zprob}
\begin{DoxyCompactList}\small\item\em P\+R\+O\+B\+A\+B\+I\+L\+I\+T\+Y C\+A\+L\+C\+U\+L\+A\+T\+I\+O\+N\+S \#\#\#\#. \end{DoxyCompactList}\item 
tuple \hyperlink{namespacescipy_1_1stats_1_1stats_a282ba2c58cc27252c61a174891592b69}{ksprob}
\item 
tuple \hyperlink{namespacescipy_1_1stats_1_1stats_a8c31dc4becce007349246d08a1456604}{fprob}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespacescipy_1_1stats_1_1stats_a3e7685fba302d7d422c51406425ca9fa}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!betai@{betai}}
\index{betai@{betai}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{betai}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+betai (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b, }
\item[{}]{x}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a3e7685fba302d7d422c51406425ca9fa}
\begin{DoxyVerb}Returns the incomplete beta function.

I_x(a,b) = 1/B(a,b)*(Integral(0,x) of t^(a-1)(1-t)^(b-1) dt)

where a,b>0 and B(a,b) = G(a)*G(b)/(G(a+b)) where G(a) is the gamma
function of a.

The standard broadcasting rules apply to a, b, and x.

Parameters
----------
a : array_like or float > 0

b : array_like or float > 0

x : array_like or float
    x will be clipped to be no greater than 1.0 .

Returns
-------
betai : ndarray
    Incomplete beta function.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_aae24e21814c47295188da5e409fbf5d3}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!chisqprob@{chisqprob}}
\index{chisqprob@{chisqprob}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{chisqprob}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+chisqprob (
\begin{DoxyParamCaption}
\item[{}]{chisq, }
\item[{}]{df}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_aae24e21814c47295188da5e409fbf5d3}
\begin{DoxyVerb}Probability value (1-tail) for the Chi^2 probability distribution.

Broadcasting rules apply.

Parameters
----------
chisq : array_like or float > 0

df : array_like or float, probably int >= 1

Returns
-------
chisqprob : ndarray
    The area from `chisq` to infinity under the Chi^2 probability
    distribution with degrees of freedom `df`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a53fbdf360f83246922ca24554f8baefa}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!chisquare@{chisquare}}
\index{chisquare@{chisquare}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{chisquare}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+chisquare (
\begin{DoxyParamCaption}
\item[{}]{f\+\_\+obs, }
\item[{}]{f\+\_\+exp = {\ttfamily None}, }
\item[{}]{ddof = {\ttfamily 0}, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a53fbdf360f83246922ca24554f8baefa}
\begin{DoxyVerb}Calculates a one-way chi square test.

The chi square test tests the null hypothesis that the categorical data
has the given frequencies.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.

Returns
-------
chisq : float or ndarray
    The chi-squared test statistic.  The value is a float if `axis` is
    None or `f_obs` and `f_exp` are 1-D.
p : float or ndarray
    The p-value of the test.  The value is a float if `ddof` and the
    return value `chisq` are scalars.

See Also
--------
power_divergence
mstats.chisquare

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8. http://faculty.vassar.edu/lowry/ch8pt1.html
.. [2] "Chi-squared test", http://en.wikipedia.org/wiki/Chi-squared_test

Examples
--------
When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.

>>> chisquare([16, 18, 16, 14, 12, 12])
(2.0, 0.84914503608460956)

With `f_exp` the expected frequencies can be given.

>>> chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8])
(3.5, 0.62338762774958223)

When `f_obs` is 2-D, by default the test is applied to each column.

>>> obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
>>> obs.shape
(6, 2)
>>> chisquare(obs)
(array([ 2.        ,  6.66666667]), array([ 0.84914504,  0.24663415]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

>>> chisquare(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
>>> chisquare(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

>>> chisquare([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
chi-squared statistic with `ddof`.

>>> chisquare([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we use ``axis=1``:

>>> chisquare([16, 18, 16, 14, 12, 12],
...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]],
...           axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a4fa11e21b0bc19cae7fc92d8a4960462}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!cumfreq@{cumfreq}}
\index{cumfreq@{cumfreq}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{cumfreq}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+cumfreq (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{numbins = {\ttfamily 10}, }
\item[{}]{defaultreallimits = {\ttfamily None}, }
\item[{}]{weights = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a4fa11e21b0bc19cae7fc92d8a4960462}
\begin{DoxyVerb}Returns a cumulative frequency histogram, using the histogram function.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultlimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger than the range of the
    values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``,
    where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
cumfreq : ndarray
    Binned values of cumulative frequency.
lowerreallimit : float
    Lower real limit
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
>>> x = [1, 4, 2, 1, 3, 1]
>>> cumfreqs, lowlim, binsize, extrapoints = sp.stats.cumfreq(x, numbins=4)
>>> cumfreqs
array([ 3.,  4.,  5.,  6.])
>>> cumfreqs, lowlim, binsize, extrapoints = \
...     sp.stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5))
>>> cumfreqs
array([ 1.,  2.,  3.,  3.])
>>> extrapoints
3\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_af65c740b3d78e11bf6f87843a126d837}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!describe@{describe}}
\index{describe@{describe}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{describe}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+describe (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_af65c740b3d78e11bf6f87843a126d837}
\begin{DoxyVerb}Computes several descriptive statistics of the passed array.

Parameters
----------
a : array_like
   data
axis : int or None
   axis along which statistics are calculated. If axis is None, then data
   array is raveled. The default axis is zero.

Returns
-------
size of the data : int
   length of data along axis
(min, max): tuple of ndarrays or floats
   minimum and maximum value of data array
arithmetic mean : ndarray or float
   mean of data along axis
unbiased variance : ndarray or float
   variance of the data along axis, denominator is number of observations
   minus one.
biased skewness : ndarray or float
   skewness, based on moment calculations with denominator equal to the
   number of observations, i.e. no degrees of freedom correction
biased kurtosis : ndarray or float
   kurtosis (Fisher), the kurtosis is normalized so that it is zero for the
   normal distribution. No degrees of freedom or bias correction is used.

See Also
--------
skew
kurtosis\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a9346383e181e93b1660d793d6081bd1a}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!f\+\_\+oneway@{f\+\_\+oneway}}
\index{f\+\_\+oneway@{f\+\_\+oneway}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{f\+\_\+oneway}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+f\+\_\+oneway (
\begin{DoxyParamCaption}
\item[{}]{args}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a9346383e181e93b1660d793d6081bd1a}
\begin{DoxyVerb}Performs a 1-way ANOVA.

The one-way ANOVA tests the null hypothesis that two or more groups have
the same population mean.  The test is applied to samples from two or
more groups, possibly with differing sizes.

Parameters
----------
sample1, sample2, ... : array_like
    The sample measurements for each group.

Returns
-------
F-value : float
    The computed F-value of the test.
p-value : float
    The associated p-value from the F-distribution.

Notes
-----
The ANOVA test has important assumptions that must be satisfied in order
for the associated p-value to be valid.

1. The samples are independent.
2. Each sample is from a normally distributed population.
3. The population standard deviations of the groups are all equal.  This
   property is known as homoscedasticity.

If these assumptions are not true for a given set of data, it may still be
possible to use the Kruskal-Wallis H-test (`scipy.stats.kruskal`) although
with some loss of power.

The algorithm is from Heiman[2], pp.394-7.


References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 14.
       http://faculty.vassar.edu/lowry/ch14pt1.html

.. [2] Heiman, G.W.  Research Methods in Statistics. 2002.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a3d5ee5a28595171b4204a98c3961f7ce}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!f\+\_\+value@{f\+\_\+value}}
\index{f\+\_\+value@{f\+\_\+value}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{f\+\_\+value}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+f\+\_\+value (
\begin{DoxyParamCaption}
\item[{}]{E\+R, }
\item[{}]{E\+F, }
\item[{}]{df\+R, }
\item[{}]{df\+F}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a3d5ee5a28595171b4204a98c3961f7ce}
\begin{DoxyVerb}Returns an F-statistic for a restricted vs. unrestricted model.

Parameters
----------
ER : float
     `ER` is the sum of squared residuals for the restricted model
      or null hypothesis

EF : float
     `EF` is the sum of squared residuals for the unrestricted model
      or alternate hypothesis

dfR : int
      `dfR` is the degrees of freedom in the restricted model

dfF : int
      `dfF` is the degrees of freedom in the unrestricted model

Returns
-------
F-statistic : float\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a4795beed156e1591a1bffa0e013b1c11}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!f\+\_\+value\+\_\+multivariate@{f\+\_\+value\+\_\+multivariate}}
\index{f\+\_\+value\+\_\+multivariate@{f\+\_\+value\+\_\+multivariate}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{f\+\_\+value\+\_\+multivariate}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+f\+\_\+value\+\_\+multivariate (
\begin{DoxyParamCaption}
\item[{}]{E\+R, }
\item[{}]{E\+F, }
\item[{}]{dfnum, }
\item[{}]{dfden}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a4795beed156e1591a1bffa0e013b1c11}
\begin{DoxyVerb}Returns a multivariate F-statistic.

Parameters
----------
ER : ndarray
    Error associated with the null hypothesis (the Restricted model).
    From a multivariate F calculation.
EF : ndarray
    Error associated with the alternate hypothesis (the Full model)
    From a multivariate F calculation.
dfnum : int
    Degrees of freedom the Restricted model.
dfden : int
    Degrees of freedom associated with the Restricted model.

Returns
-------
fstat : float
    The computed F-statistic.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a44e70e3ef03804f5c935efe5dc2f319b}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!f\+\_\+value\+\_\+wilks\+\_\+lambda@{f\+\_\+value\+\_\+wilks\+\_\+lambda}}
\index{f\+\_\+value\+\_\+wilks\+\_\+lambda@{f\+\_\+value\+\_\+wilks\+\_\+lambda}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{f\+\_\+value\+\_\+wilks\+\_\+lambda}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+f\+\_\+value\+\_\+wilks\+\_\+lambda (
\begin{DoxyParamCaption}
\item[{}]{E\+R, }
\item[{}]{E\+F, }
\item[{}]{dfnum, }
\item[{}]{dfden, }
\item[{}]{a, }
\item[{}]{b}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a44e70e3ef03804f5c935efe5dc2f319b}


A\+N\+O\+V\+A C\+A\+L\+C\+U\+L\+A\+T\+I\+O\+N\+S \#\#\#\#\#\#\#. 

\begin{DoxyVerb}Calculation of Wilks lambda F-statistic for multivarite data, per
Maxwell & Delaney p.657.
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a9c9a228e8fa482503318a37074f3ee2e}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!fastsort@{fastsort}}
\index{fastsort@{fastsort}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{fastsort}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+fastsort (
\begin{DoxyParamCaption}
\item[{}]{a}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a9c9a228e8fa482503318a37074f3ee2e}
\begin{DoxyVerb}Sort an array and provide the argsort.

Parameters
----------
a : array_like
    Input array.

Returns
-------
fastsort : ndarray of type int
    sorted indices into the original array\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a69c44b392136bf66869061d07d655f3e}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!find\+\_\+repeats@{find\+\_\+repeats}}
\index{find\+\_\+repeats@{find\+\_\+repeats}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{find\+\_\+repeats}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+find\+\_\+repeats (
\begin{DoxyParamCaption}
\item[{}]{arr}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a69c44b392136bf66869061d07d655f3e}
\begin{DoxyVerb}Find repeats and repeat counts.

Parameters
----------
arr : array_like
    Input array

Returns
-------
find_repeats : tuple
    Returns a tuple of two 1-D ndarrays.  The first ndarray are the repeats
    as sorted, unique values that are repeated in `arr`.  The second
    ndarray are the counts mapped one-to-one of the repeated values
    in the first ndarray.

Examples
--------
    >>> sp.stats.find_repeats([2, 1, 2, 3, 2, 2, 5])
    (array([ 2. ]), array([ 4 ], dtype=int32)

    >>> sp.stats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]])
    (array([ 4., 5.]), array([2, 2], dtype=int32))\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_aff7e685424bb5315cb65e12ddb5260f4}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!fisher\+\_\+exact@{fisher\+\_\+exact}}
\index{fisher\+\_\+exact@{fisher\+\_\+exact}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{fisher\+\_\+exact}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+fisher\+\_\+exact (
\begin{DoxyParamCaption}
\item[{}]{table, }
\item[{}]{alternative = {\ttfamily '{\bf two}-\/sided'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_aff7e685424bb5315cb65e12ddb5260f4}
\begin{DoxyVerb}Performs a Fisher exact test on a 2x2 contingency table.

Parameters
----------
table : array_like of ints
    A 2x2 contingency table.  Elements should be non-negative integers.
alternative : {'two-sided', 'less', 'greater'}, optional
    Which alternative hypothesis to the null hypothesis the test uses.
    Default is 'two-sided'.

Returns
-------
oddsratio : float
    This is prior odds ratio and not a posterior estimate.
p_value : float
    P-value, the probability of obtaining a distribution at least as
    extreme as the one that was actually observed, assuming that the
    null hypothesis is true.

See Also
--------
chi2_contingency : Chi-square test of independence of variables in a
    contingency table.

Notes
-----
The calculated odds ratio is different from the one R uses. In R language,
this implementation returns the (more common) "unconditional Maximum
Likelihood Estimate", while R uses the "conditional Maximum Likelihood
Estimate".

For tables with large numbers the (inexact) chi-square test implemented
in the function `chi2_contingency` can also be used.

Examples
--------
Say we spend a few days counting whales and sharks in the Atlantic and
Indian oceans. In the Atlantic ocean we find 8 whales and 1 shark, in the
Indian ocean 2 whales and 5 sharks. Then our contingency table is::

            Atlantic  Indian
    whales     8        2
    sharks     1        5

We use this table to find the p-value:

>>> oddsratio, pvalue = stats.fisher_exact([[8, 2], [1, 5]])
>>> pvalue
0.0349...

The probability that we would observe this or an even more imbalanced ratio
by chance is about 3.5%.  A commonly used significance level is 5%, if we
adopt that we can therefore conclude that our observed imbalance is
statistically significant; whales prefer the Atlantic while sharks prefer
the Indian ocean.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a1bd75857c9de144bfaddff735251937d}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!friedmanchisquare@{friedmanchisquare}}
\index{friedmanchisquare@{friedmanchisquare}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{friedmanchisquare}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+friedmanchisquare (
\begin{DoxyParamCaption}
\item[{}]{args}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a1bd75857c9de144bfaddff735251937d}
\begin{DoxyVerb}Computes the Friedman test for repeated measurements

The Friedman test tests the null hypothesis that repeated measurements of
the same individuals have the same distribution.  It is often used
to test for consistency among measurements obtained in different ways.
For example, if two measurement techniques are used on the same set of
individuals, the Friedman test can be used to determine if the two
measurement techniques are consistent.

Parameters
----------
measurements1, measurements2, measurements3... : array_like
    Arrays of measurements.  All of the arrays must have the same number
    of elements.  At least 3 sets of measurements must be given.

Returns
-------
friedman chi-square statistic : float
    the test statistic, correcting for ties
p-value : float
    the associated p-value assuming that the test statistic has a chi
    squared distribution

Notes
-----
Due to the assumption that the test statistic has a chi squared
distribution, the p-value is only reliable for n > 10 and more than
6 repeated measurements.

References
----------
.. [1] http://en.wikipedia.org/wiki/Friedman_test\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a48fb267e94c5eb1b26a5c10776f3e2b4}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!gmean@{gmean}}
\index{gmean@{gmean}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{gmean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+gmean (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{dtype = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a48fb267e94c5eb1b26a5c10776f3e2b4}


C\+E\+N\+T\+R\+A\+L T\+E\+N\+D\+E\+N\+C\+Y \#\#\#\#\#\#\#\#. 

\begin{DoxyVerb}Compute the geometric mean along the specified axis.

Returns the geometric average of the array elements.
That is:  n-th root of (x1 * x2 * ... * xn)

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int, optional, default axis=0
    Axis along which the geometric mean is computed.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If dtype is not specified, it defaults to the
    dtype of a, unless a has an integer dtype with a precision less than
    that of the default platform integer. In that case, the default
    platform integer is used.

Returns
-------
gmean : ndarray
    see dtype parameter above

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
hmean : Harmonic mean

Notes
-----
The geometric average is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

Use masked arrays to ignore any non-finite values in the input or that
arise in the calculations such as Not a Number and infinity because masked
arrays automatically mask any non-finite values.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ad7bf370c4741b90596c8cecb021f2700}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!histogram@{histogram}}
\index{histogram@{histogram}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{histogram}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+histogram (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{numbins = {\ttfamily 10}, }
\item[{}]{defaultlimits = {\ttfamily None}, }
\item[{}]{weights = {\ttfamily None}, }
\item[{}]{printextras = {\ttfamily {\bf False}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ad7bf370c4741b90596c8cecb021f2700}
\begin{DoxyVerb}Separates the range into several bins and returns the number of instances
in each bin.

Parameters
----------
a : array_like
    Array of scores which will be put into bins.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultlimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger then the range of the
    values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0
printextras : bool, optional
    If True, if there are extra points (i.e. the points that fall outside
    the bin limits) a warning is raised saying how many of those points
    there are.  Default is False.

Returns
-------
histogram : ndarray
    Number of points (or sum of weights) in each bin.
low_range : float
    Lowest value of histogram, the lower limit of the first bin.
binsize : float
    The size of the bins (all bins have the same size).
extrapoints : int
    The number of points outside the range of the histogram.

See Also
--------
numpy.histogram

Notes
-----
This histogram is based on numpy's histogram but has a larger range by
default if default limits is not set.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a8a1c376b310589575a9ff49c01dd573e}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!histogram2@{histogram2}}
\index{histogram2@{histogram2}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{histogram2}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+histogram2 (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{bins}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a8a1c376b310589575a9ff49c01dd573e}
\begin{DoxyVerb}Compute histogram using divisions in bins.

Count the number of times values from array `a` fall into
numerical ranges defined by `bins`.  Range x is given by
bins[x] <= range_x < bins[x+1] where x =0,N and N is the
length of the `bins` array.  The last range is given by
bins[N] <= range_N < infinity.  Values less than bins[0] are
not included in the histogram.

Parameters
----------
a : array_like of rank 1
    The array of values to be assigned into bins
bins : array_like of rank 1
    Defines the ranges of values to use during histogramming.

Returns
-------
histogram2 : ndarray of rank 1
    Each value represents the occurrences for a given bin (range) of
    values.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_aac6c16e0d657f32648fc7c0e8a367336}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!hmean@{hmean}}
\index{hmean@{hmean}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{hmean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+hmean (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{dtype = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_aac6c16e0d657f32648fc7c0e8a367336}
\begin{DoxyVerb}Calculates the harmonic mean along the specified axis.

That is:  n / (1/x1 + 1/x2 + ... + 1/xn)

Parameters
----------
a : array_like
    Input array, masked array or object that can be converted to an array.
axis : int, optional, default axis=0
    Axis along which the harmonic mean is computed.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed. If `dtype` is not specified, it defaults to the
    dtype of `a`, unless `a` has an integer `dtype` with a precision less
    than that of the default platform integer. In that case, the default
    platform integer is used.

Returns
-------
hmean : ndarray
    see `dtype` parameter above

See Also
--------
numpy.mean : Arithmetic average
numpy.average : Weighted average
gmean : Geometric mean

Notes
-----
The harmonic mean is computed over a single dimension of the input
array, axis=0 by default, or all values in the array if axis=None.
float64 intermediate and return values are used for integer inputs.

Use masked arrays to ignore any non-finite values in the input or that
arise in the calculations such as Not a Number and infinity.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a973cd5f47a121bcabbc0c181a5c50fb9}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!itemfreq@{itemfreq}}
\index{itemfreq@{itemfreq}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{itemfreq}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+itemfreq (
\begin{DoxyParamCaption}
\item[{}]{a}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a973cd5f47a121bcabbc0c181a5c50fb9}


F\+R\+E\+Q\+U\+E\+N\+C\+Y F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#\#\#. 

\begin{DoxyVerb}Returns a 2-D array of item frequencies.

Parameters
----------
a : (N,) array_like
    Input array.

Returns
-------
itemfreq : (K, 2) ndarray
    A 2-D frequency table.  Column 1 contains sorted, unique values from
    `a`, column 2 contains their respective counts.

Examples
--------
>>> a = np.array([1, 1, 5, 0, 1, 2, 2, 0, 1, 4])
>>> stats.itemfreq(a)
array([[ 0.,  2.],
       [ 1.,  4.],
       [ 2.,  2.],
       [ 4.,  1.],
       [ 5.,  1.]])
>>> np.bincount(a)
array([2, 4, 2, 0, 1, 1])

>>> stats.itemfreq(a/10.)
array([[ 0. ,  2. ],
       [ 0.1,  4. ],
       [ 0.2,  2. ],
       [ 0.4,  1. ],
       [ 0.5,  1. ]])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a4431b91647766f533c7003141ad52efd}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!jarque\+\_\+bera@{jarque\+\_\+bera}}
\index{jarque\+\_\+bera@{jarque\+\_\+bera}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{jarque\+\_\+bera}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+jarque\+\_\+bera (
\begin{DoxyParamCaption}
\item[{}]{x}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a4431b91647766f533c7003141ad52efd}
\begin{DoxyVerb}Perform the Jarque-Bera goodness of fit test on sample data.

The Jarque-Bera test tests whether the sample data has the skewness and
kurtosis matching a normal distribution.

Note that this test only works for a large enough number of data samples
(>2000) as the test statistic asymptotically has a Chi-squared distribution
with 2 degrees of freedom.

Parameters
----------
x : array_like
    Observations of a random variable.

Returns
-------
jb_value : float
    The test statistic.
p : float
    The p-value for the hypothesis test.

References
----------
.. [1] Jarque, C. and Bera, A. (1980) "Efficient tests for normality,
       homoscedasticity and serial independence of regression residuals",
       6 Econometric Letters 255-259.

Examples
--------
>>> from scipy import stats
>>> np.random.seed(987654321)
>>> x = np.random.normal(0, 1, 100000)
>>> y = np.random.rayleigh(1, 100000)
>>> stats.jarque_bera(x)
(4.7165707989581342, 0.09458225503041906)
>>> stats.jarque_bera(y)
(6713.7098548143422, 0.0)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a484892cdf73483268a7f152eef1ae783}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!kendalltau@{kendalltau}}
\index{kendalltau@{kendalltau}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{kendalltau}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+kendalltau (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{y, }
\item[{}]{initial\+\_\+lexsort = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a484892cdf73483268a7f152eef1ae783}
\begin{DoxyVerb}Calculates Kendall's tau, a correlation measure for ordinal data.

Kendall's tau is a measure of the correspondence between two rankings.
Values close to 1 indicate strong agreement, values close to -1 indicate
strong disagreement.  This is the tau-b version of Kendall's tau which
accounts for ties.

Parameters
----------
x, y : array_like
    Arrays of rankings, of the same shape. If arrays are not 1-D, they will
    be flattened to 1-D.
initial_lexsort : bool, optional
    Whether to use lexsort or quicksort as the sorting method for the
    initial sort of the inputs. Default is lexsort (True), for which
    `kendalltau` is of complexity O(n log(n)). If False, the complexity is
    O(n^2), but with a smaller pre-factor (so quicksort may be faster for
    small arrays).

Returns
-------
Kendall's tau : float
   The tau statistic.
p-value : float
   The two-sided p-value for a hypothesis test whose null hypothesis is
   an absence of association, tau = 0.

Notes
-----
The definition of Kendall's tau that is used is::

  tau = (P - Q) / sqrt((P + Q + T) * (P + Q + U))

where P is the number of concordant pairs, Q the number of discordant
pairs, T the number of ties only in `x`, and U the number of ties only in
`y`.  If a tie occurs for the same pair in both `x` and `y`, it is not
added to either T or U.

References
----------
W.R. Knight, "A Computer Method for Calculating Kendall's Tau with
Ungrouped Data", Journal of the American Statistical Association, Vol. 61,
No. 314, Part 1, pp. 436-439, 1966.

Examples
--------
>>> x1 = [12, 2, 1, 12, 2]
>>> x2 = [1, 4, 7, 1, 0]
>>> tau, p_value = sp.stats.kendalltau(x1, x2)
>>> tau
-0.47140452079103173
>>> p_value
0.24821309157521476\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a4e2fff18e299993bcc12e0e3c5de4f7e}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!kruskal@{kruskal}}
\index{kruskal@{kruskal}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{kruskal}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+kruskal (
\begin{DoxyParamCaption}
\item[{}]{args}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a4e2fff18e299993bcc12e0e3c5de4f7e}
\begin{DoxyVerb}Compute the Kruskal-Wallis H-test for independent samples

The Kruskal-Wallis H-test tests the null hypothesis that the population
median of all of the groups are equal.  It is a non-parametric version of
ANOVA.  The test works on 2 or more independent samples, which may have
different sizes.  Note that rejecting the null hypothesis does not
indicate which of the groups differs.  Post-hoc comparisons between
groups are required to determine which groups are different.

Parameters
----------
sample1, sample2, ... : array_like
   Two or more arrays with the sample measurements can be given as
   arguments.

Returns
-------
H-statistic : float
   The Kruskal-Wallis H statistic, corrected for ties
p-value : float
   The p-value for the test using the assumption that H has a chi
   square distribution

Notes
-----
Due to the assumption that H has a chi square distribution, the number
of samples in each group must not be too small.  A typical rule is
that each sample must have at least 5 measurements.

References
----------
.. [1] http://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a43a4544480a8139b6c0ee7421210e53c}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!ks\+\_\+2samp@{ks\+\_\+2samp}}
\index{ks\+\_\+2samp@{ks\+\_\+2samp}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{ks\+\_\+2samp}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+ks\+\_\+2samp (
\begin{DoxyParamCaption}
\item[{}]{data1, }
\item[{}]{data2}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a43a4544480a8139b6c0ee7421210e53c}
\begin{DoxyVerb}Computes the Kolmogorov-Smirnov statistic on 2 samples.

This is a two-sided test for the null hypothesis that 2 independent samples
are drawn from the same continuous distribution.

Parameters
----------
a, b : sequence of 1-D ndarrays
    two arrays of sample observations assumed to be drawn from a continuous
    distribution, sample sizes can be different

Returns
-------
D : float
    KS statistic
p-value : float
    two-tailed p-value

Notes
-----
This tests whether 2 samples are drawn from the same distribution. Note
that, like in the case of the one-sample K-S test, the distribution is
assumed to be continuous.

This is the two-sided test, one-sided tests are not implemented.
The test uses the two-sided asymptotic Kolmogorov-Smirnov distribution.

If the K-S statistic is small or the p-value is high, then we cannot
reject the hypothesis that the distributions of the two samples
are the same.

Examples
--------
>>> from scipy import stats
>>> np.random.seed(12345678)  #fix random seed to get the same result
>>> n1 = 200  # size of first sample
>>> n2 = 300  # size of second sample

For a different distribution, we can reject the null hypothesis since the
pvalue is below 1%:

>>> rvs1 = stats.norm.rvs(size=n1, loc=0., scale=1)
>>> rvs2 = stats.norm.rvs(size=n2, loc=0.5, scale=1.5)
>>> stats.ks_2samp(rvs1, rvs2)
(0.20833333333333337, 4.6674975515806989e-005)

For a slightly different distribution, we cannot reject the null hypothesis
at a 10% or lower alpha since the p-value at 0.144 is higher than 10%

>>> rvs3 = stats.norm.rvs(size=n2, loc=0.01, scale=1.0)
>>> stats.ks_2samp(rvs1, rvs3)
(0.10333333333333333, 0.14498781825751686)

For an identical distribution, we cannot reject the null hypothesis since
the p-value is high, 41%:

>>> rvs4 = stats.norm.rvs(size=n2, loc=0.0, scale=1.0)
>>> stats.ks_2samp(rvs1, rvs4)
(0.07999999999999996, 0.41126949729859719)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a20ee3cba8d73095d2c9b1f2810facbfd}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!kstest@{kstest}}
\index{kstest@{kstest}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{kstest}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+kstest (
\begin{DoxyParamCaption}
\item[{}]{rvs, }
\item[{}]{cdf, }
\item[{}]{args = {\ttfamily ()}, }
\item[{}]{N = {\ttfamily 20}, }
\item[{}]{alternative = {\ttfamily '{\bf two}-\/sided'}, }
\item[{}]{mode = {\ttfamily 'approx'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a20ee3cba8d73095d2c9b1f2810facbfd}
\begin{DoxyVerb}Perform the Kolmogorov-Smirnov test for goodness of fit.

This performs a test of the distribution G(x) of an observed
random variable against a given distribution F(x). Under the null
hypothesis the two distributions are identical, G(x)=F(x). The
alternative hypothesis can be either 'two-sided' (default), 'less'
or 'greater'. The KS test is only valid for continuous distributions.

Parameters
----------
rvs : str, array or callable
    If a string, it should be the name of a distribution in `scipy.stats`.
    If an array, it should be a 1-D array of observations of random
    variables.
    If a callable, it should be a function to generate random variables;
    it is required to have a keyword argument `size`.
cdf : str or callable
    If a string, it should be the name of a distribution in `scipy.stats`.
    If `rvs` is a string then `cdf` can be False or the same as `rvs`.
    If a callable, that callable is used to calculate the cdf.
args : tuple, sequence, optional
    Distribution parameters, used if `rvs` or `cdf` are strings.
N : int, optional
    Sample size if `rvs` is string or callable.  Default is 20.
alternative : {'two-sided', 'less','greater'}, optional
    Defines the alternative hypothesis (see explanation above).
    Default is 'two-sided'.
mode : 'approx' (default) or 'asymp', optional
    Defines the distribution used for calculating the p-value.

      - 'approx' : use approximation to exact distribution of test statistic
      - 'asymp' : use asymptotic distribution of test statistic

Returns
-------
D : float
    KS test statistic, either D, D+ or D-.
p-value :  float
    One-tailed or two-tailed p-value.

Notes
-----
In the one-sided test, the alternative is that the empirical
cumulative distribution function of the random variable is "less"
or "greater" than the cumulative distribution function F(x) of the
hypothesis, ``G(x)<=F(x)``, resp. ``G(x)>=F(x)``.

Examples
--------
>>> from scipy import stats

>>> x = np.linspace(-15, 15, 9)
>>> stats.kstest(x, 'norm')
(0.44435602715924361, 0.038850142705171065)

>>> np.random.seed(987654321) # set random seed to get the same result
>>> stats.kstest('norm', False, N=100)
(0.058352892479417884, 0.88531190944151261)

The above lines are equivalent to:

>>> np.random.seed(987654321)
>>> stats.kstest(stats.norm.rvs(size=100), 'norm')
(0.058352892479417884, 0.88531190944151261)

*Test against one-sided alternative hypothesis*

Shift distribution to larger values, so that ``cdf_dgp(x) < norm.cdf(x)``:

>>> np.random.seed(987654321)
>>> x = stats.norm.rvs(loc=0.2, size=100)
>>> stats.kstest(x,'norm', alternative = 'less')
(0.12464329735846891, 0.040989164077641749)

Reject equal distribution against alternative hypothesis: less

>>> stats.kstest(x,'norm', alternative = 'greater')
(0.0072115233216311081, 0.98531158590396395)

Don't reject equal distribution against alternative hypothesis: greater

>>> stats.kstest(x,'norm', mode='asymp')
(0.12464329735846891, 0.08944488871182088)

*Testing t distributed random variables against normal distribution*

With 100 degrees of freedom the t distribution looks close to the normal
distribution, and the K-S test does not reject the hypothesis that the
sample came from the normal distribution:

>>> np.random.seed(987654321)
>>> stats.kstest(stats.t.rvs(100,size=100),'norm')
(0.072018929165471257, 0.67630062862479168)

With 3 degrees of freedom the t distribution looks sufficiently different
from the normal distribution, that we can reject the hypothesis that the
sample came from the normal distribution at the 10% level:

>>> np.random.seed(987654321)
>>> stats.kstest(stats.t.rvs(3,size=100),'norm')
(0.131016895759829, 0.058826222555312224)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a9d516fe8283e7c7a3bee49903bbf4c64}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!kurtosis@{kurtosis}}
\index{kurtosis@{kurtosis}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{kurtosis}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+kurtosis (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{fisher = {\ttfamily {\bf True}}, }
\item[{}]{bias = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a9d516fe8283e7c7a3bee49903bbf4c64}
\begin{DoxyVerb}Computes the kurtosis (Fisher or Pearson) of a dataset.

Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.

If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators

Use `kurtosistest` to see if result is close enough to normal.

Parameters
----------
a : array
    data for which the kurtosis is calculated
axis : int or None
    Axis along which the kurtosis is calculated
fisher : bool
    If True, Fisher's definition is used (normal ==> 0.0). If False,
    Pearson's definition is used (normal ==> 3.0).
bias : bool
    If False, then the calculations are corrected for statistical bias.

Returns
-------
kurtosis : array
    The kurtosis of values along an axis. If all values are equal,
    return -3 for Fisher's definition and 0 for Pearson's definition.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a8a22cd6b7bca6bb0a1497c02cf69e981}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!kurtosistest@{kurtosistest}}
\index{kurtosistest@{kurtosistest}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{kurtosistest}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+kurtosistest (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a8a22cd6b7bca6bb0a1497c02cf69e981}
\begin{DoxyVerb}Tests whether a dataset has normal kurtosis

This function tests the null hypothesis that the kurtosis
of the population from which the sample was drawn is that
of the normal distribution: ``kurtosis = 3(n-1)/(n+1)``.

Parameters
----------
a : array
    array of the sample data
axis : int or None
    the axis to operate along, or None to work on the whole array.
    The default is the first axis.

Returns
-------
z-score : float
    The computed z-score for this test.
p-value : float
    The 2-sided p-value for the hypothesis test

Notes
-----
Valid only for n>20.  The Z-score is set to 0 for bad entries.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a1dc45b95d34e45687312f7cf93b8f7ee}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!linregress@{linregress}}
\index{linregress@{linregress}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{linregress}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+linregress (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{y = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a1dc45b95d34e45687312f7cf93b8f7ee}
\begin{DoxyVerb}Calculate a regression line

This computes a least-squares regression for two sets of measurements.

Parameters
----------
x, y : array_like
    two sets of measurements.  Both arrays should have the same length.
    If only x is given (and y=None), then it must be a two-dimensional
    array where one dimension has length 2.  The two sets of measurements
    are then found by splitting the array along the length-2 dimension.

Returns
-------
slope : float
    slope of the regression line
intercept : float
    intercept of the regression line
r-value : float
    correlation coefficient
p-value : float
    two-sided p-value for a hypothesis test whose null hypothesis is
    that the slope is zero.
stderr : float
    Standard error of the estimate


Examples
--------
>>> from scipy import stats
>>> import numpy as np
>>> x = np.random.random(10)
>>> y = np.random.random(10)
>>> slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)

# To get coefficient of determination (r_squared)

>>> print "r-squared:", r_value**2
r-squared: 0.15286643777\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ab1d6bbc85f44f5ff1083f04839e5291e}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!mannwhitneyu@{mannwhitneyu}}
\index{mannwhitneyu@{mannwhitneyu}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{mannwhitneyu}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+mannwhitneyu (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{y, }
\item[{}]{use\+\_\+continuity = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ab1d6bbc85f44f5ff1083f04839e5291e}
\begin{DoxyVerb}Computes the Mann-Whitney rank test on samples x and y.

Parameters
----------
x, y : array_like
    Array of samples, should be one-dimensional.
use_continuity : bool, optional
        Whether a continuity correction (1/2.) should be taken into
        account. Default is True.

Returns
-------
u : float
    The Mann-Whitney statistics.
prob : float
    One-sided p-value assuming a asymptotic normal distribution.

Notes
-----
Use only when the number of observation in each sample is > 20 and
you have 2 independent samples of ranks. Mann-Whitney U is
significant if the u-obtained is LESS THAN or equal to the critical
value of U.

This test corrects for ties and by default uses a continuity correction.
The reported p-value is for a one-sided hypothesis, to get the two-sided
p-value multiply the returned p-value by 2.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ab8a3087296c7f76c65fc2fa68a55e523}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!mask\+\_\+to\+\_\+limits@{mask\+\_\+to\+\_\+limits}}
\index{mask\+\_\+to\+\_\+limits@{mask\+\_\+to\+\_\+limits}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{mask\+\_\+to\+\_\+limits}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+mask\+\_\+to\+\_\+limits (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{limits, }
\item[{}]{inclusive}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ab8a3087296c7f76c65fc2fa68a55e523}
\begin{DoxyVerb}Mask an array for values outside of given limits.

This is primarily a utility function.

Parameters
----------
a : array
limits : (float or None, float or None)
    A tuple consisting of the (lower limit, upper limit).  Values in the
    input array less than the lower limit or greater than the upper limit
    will be masked out. None implies no limit.
inclusive : (bool, bool)
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to lower or upper are allowed.

Returns
-------
A MaskedArray.

Raises
------
A ValueError if there are no values within the given limits.
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a3bc0c6247ce0aa3bdbe9bf5310d336c8}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!masked\+\_\+var@{masked\+\_\+var}}
\index{masked\+\_\+var@{masked\+\_\+var}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{masked\+\_\+var}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+masked\+\_\+var (
\begin{DoxyParamCaption}
\item[{}]{am}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a3bc0c6247ce0aa3bdbe9bf5310d336c8}
\hypertarget{namespacescipy_1_1stats_1_1stats_a82088ab884e71ebc98dc6b05d1c0a6a0}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!mode@{mode}}
\index{mode@{mode}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{mode}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+mode (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a82088ab884e71ebc98dc6b05d1c0a6a0}
\begin{DoxyVerb}Returns an array of the modal (most common) value in the passed array.

If there is more than one such value, only the first is returned.
The bin-count for the modal bins is also returned.

Parameters
----------
a : array_like
    n-dimensional array of which to find mode(s).
axis : int, optional
    Axis along which to operate. Default is 0, i.e. the first axis.

Returns
-------
vals : ndarray
    Array of modal values.
counts : ndarray
    Array of counts for each mode.

Examples
--------
>>> a = np.array([[6, 8, 3, 0],
                  [3, 2, 1, 7],
                  [8, 1, 8, 4],
                  [5, 3, 0, 5],
                  [4, 7, 5, 9]])
>>> from scipy import stats
>>> stats.mode(a)
(array([[ 3.,  1.,  0.,  0.]]), array([[ 1.,  1.,  1.,  1.]]))

To get mode of whole array, specify axis=None:

>>> stats.mode(a, axis=None)
(array([ 3.]), array([ 3.]))\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a254bd9c2c209d8ffc73376ebd700edfc}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!moment@{moment}}
\index{moment@{moment}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{moment}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+moment (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{moment = {\ttfamily 1}, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a254bd9c2c209d8ffc73376ebd700edfc}


M\+O\+M\+E\+N\+T\+S \#\#\#\#\#\#\#\#\#\#\#\#\#. 

\begin{DoxyVerb}Calculates the nth moment about the mean for a sample.

Generally used to calculate coefficients of skewness and
kurtosis.

Parameters
----------
a : array_like
   data
moment : int
   order of central moment that is returned
axis : int or None
   Axis along which the central moment is computed. If None, then the data
   array is raveled. The default axis is zero.

Returns
-------
n-th central moment : ndarray or float
   The appropriate moment along the given axis or over all values if axis
   is None. The denominator for the moment calculation is the number of
   observations, no degrees of freedom correction is done.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ab1638103f489bcc1a2fe06c806413da8}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!nanmean@{nanmean}}
\index{nanmean@{nanmean}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{nanmean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+nanmean (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ab1638103f489bcc1a2fe06c806413da8}


N\+A\+N friendly functions. 

\begin{DoxyVerb}Compute the mean over the given axis ignoring nans.

Parameters
----------
x : ndarray
    Input array.
axis : int, optional
    Axis along which the mean is computed. Default is 0, i.e. the
    first axis.

Returns
-------
m : float
    The mean of `x`, ignoring nans.

See Also
--------
nanstd, nanmedian

Examples
--------
>>> from scipy import stats
>>> a = np.linspace(0, 4, 3)
>>> a
array([ 0.,  2.,  4.])
>>> a[-1] = np.nan
>>> stats.nanmean(a)
1.0\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a9ea387540ef1b6b56a62088d3b38b3cb}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!nanmedian@{nanmedian}}
\index{nanmedian@{nanmedian}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{nanmedian}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+nanmedian (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a9ea387540ef1b6b56a62088d3b38b3cb}
\begin{DoxyVerb}Compute the median along the given axis ignoring nan values.

Parameters
----------
x : array_like
    Input array.
axis : int, optional
    Axis along which the median is computed. Default is 0, i.e. the
    first axis.

Returns
-------
m : float
    The median of `x` along `axis`.

See Also
--------
nanstd, nanmean

Examples
--------
>>> from scipy import stats
>>> a = np.array([0, 3, 1, 5, 5, np.nan])
>>> stats.nanmedian(a)
array(3.0)

>>> b = np.array([0, 3, 1, 5, 5, np.nan, 5])
>>> stats.nanmedian(b)
array(4.0)

Example with axis:

>>> c = np.arange(30.).reshape(5,6)
>>> idx = np.array([False, False, False, True, False] * 6).reshape(5,6)
>>> c[idx] = np.nan
>>> c
array([[  0.,   1.,   2.,  nan,   4.,   5.],
       [  6.,   7.,  nan,   9.,  10.,  11.],
       [ 12.,  nan,  14.,  15.,  16.,  17.],
       [ nan,  19.,  20.,  21.,  22.,  nan],
       [ 24.,  25.,  26.,  27.,  nan,  29.]])
>>> stats.nanmedian(c, axis=1)
array([  2. ,   9. ,  15. ,  20.5,  26. ])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a4c3bc74fa7ca3f5f0d0cfbb5f97b79c3}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!nanstd@{nanstd}}
\index{nanstd@{nanstd}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{nanstd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+nanstd (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{bias = {\ttfamily {\bf False}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a4c3bc74fa7ca3f5f0d0cfbb5f97b79c3}
\begin{DoxyVerb}Compute the standard deviation over the given axis, ignoring nans.

Parameters
----------
x : array_like
    Input array.
axis : int or None, optional
    Axis along which the standard deviation is computed. Default is 0.
    If None, compute over the whole array `x`.
bias : bool, optional
    If True, the biased (normalized by N) definition is used. If False
    (default), the unbiased definition is used.

Returns
-------
s : float
    The standard deviation.

See Also
--------
nanmean, nanmedian

Examples
--------
>>> from scipy import stats
>>> a = np.arange(10, dtype=float)
>>> a[1:3] = np.nan
>>> np.std(a)
nan
>>> stats.nanstd(a)
2.9154759474226504
>>> stats.nanstd(a.reshape(2, 5), axis=1)
array([ 2.0817,  1.5811])
>>> stats.nanstd(a.reshape(2, 5), axis=None)
2.9154759474226504\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ab1d985f5480e2bb7b15612b8fcbcd08a}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!normaltest@{normaltest}}
\index{normaltest@{normaltest}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{normaltest}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+normaltest (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ab1d985f5480e2bb7b15612b8fcbcd08a}
\begin{DoxyVerb}Tests whether a sample differs from a normal distribution.

This function tests the null hypothesis that a sample comes
from a normal distribution.  It is based on D'Agostino and
Pearson's [1]_, [2]_ test that combines skew and kurtosis to
produce an omnibus test of normality.


Parameters
----------
a : array_like
    The array containing the data to be tested.
axis : int or None
    If None, the array is treated as a single data set, regardless of
    its shape.  Otherwise, each 1-d array along axis `axis` is tested.

Returns
-------
k2 : float or array
    `s^2 + k^2`, where `s` is the z-score returned by `skewtest` and
    `k` is the z-score returned by `kurtosistest`.
p-value : float or array
   A 2-sided chi squared probability for the hypothesis test.

References
----------
.. [1] D'Agostino, R. B. (1971), "An omnibus test of normality for
       moderate and large sample size," Biometrika, 58, 341-348

.. [2] D'Agostino, R. and Pearson, E. S. (1973), "Testing for
       departures from normality," Biometrika, 60, 613-622\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a1bd45b2af0f91d4eb96626caf14d2ea3}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!obrientransform@{obrientransform}}
\index{obrientransform@{obrientransform}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{obrientransform}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+obrientransform (
\begin{DoxyParamCaption}
\item[{}]{args}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a1bd45b2af0f91d4eb96626caf14d2ea3}


V\+A\+R\+I\+A\+B\+I\+L\+I\+T\+Y F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#. 

\begin{DoxyVerb}Computes the O'Brien transform on input data (any number of arrays).

Used to test for homogeneity of variance prior to running one-way stats.
Each array in ``*args`` is one level of a factor.
If `f_oneway` is run on the transformed data and found significant,
the variances are unequal.  From Maxwell and Delaney [1]_, p.112.

Parameters
----------
args : tuple of array_like
    Any number of arrays.

Returns
-------
obrientransform : ndarray
    Transformed data for use in an ANOVA.  The first dimension
    of the result corresponds to the sequence of transformed
    arrays.  If the arrays given are all 1-D of the same length,
    the return value is a 2-D array; otherwise it is a 1-D array
    of type object, with each element being an ndarray.

References
----------
.. [1] S. E. Maxwell and H. D. Delaney, "Designing Experiments and
       Analyzing Data: A Model Comparison Perspective", Wadsworth, 1990.

Examples
--------
We'll test the following data sets for differences in their variance.

>>> x = [10, 11, 13, 9, 7, 12, 12, 9, 10]
>>> y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15]

Apply the O'Brien transform to the data.

>>> tx, ty = obrientransform(x, y)

Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the
transformed data.

>>> from scipy.stats import f_oneway
>>> F, p = f_oneway(tx, ty)
>>> p
0.1314139477040335

If we require that ``p < 0.05`` for significance, we cannot conclude
that the variances are different.
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a807da91092280c6c409ba4dd7aecf0ae}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!pearsonr@{pearsonr}}
\index{pearsonr@{pearsonr}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{pearsonr}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+pearsonr (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{y}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a807da91092280c6c409ba4dd7aecf0ae}
\begin{DoxyVerb}Calculates a Pearson correlation coefficient and the p-value for testing
non-correlation.

The Pearson correlation coefficient measures the linear relationship
between two datasets. Strictly speaking, Pearson's correlation requires
that each dataset be normally distributed. Like other correlation
coefficients, this one varies between -1 and +1 with 0 implying no
correlation. Correlations of -1 or +1 imply an exact linear
relationship. Positive correlations imply that as x increases, so does
y. Negative correlations imply that as x increases, y decreases.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Pearson correlation at least as extreme
as the one computed from these datasets. The p-values are not entirely
reliable but are probably reasonable for datasets larger than 500 or so.

Parameters
----------
x : (N,) array_like
    Input
y : (N,) array_like
    Input

Returns
-------
(Pearson's correlation coefficient,
 2-tailed p-value)

References
----------
http://www.statsoft.com/textbook/glosp.html#Pearson%20Correlation\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a5bfdda61db9243c3bbfea7bead760155}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!percentileofscore@{percentileofscore}}
\index{percentileofscore@{percentileofscore}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{percentileofscore}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+percentileofscore (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{score, }
\item[{}]{kind = {\ttfamily '{\bf rank}'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a5bfdda61db9243c3bbfea7bead760155}
\begin{DoxyVerb}The percentile rank of a score relative to a list of scores.

A `percentileofscore` of, for example, 80% means that 80% of the
scores in `a` are below the given score. In the case of gaps or
ties, the exact definition depends on the optional keyword, `kind`.

Parameters
----------
a : array_like
    Array of scores to which `score` is compared.
score : int or float
    Score that is compared to the elements in `a`.
kind : {'rank', 'weak', 'strict', 'mean'}, optional
    This optional parameter specifies the interpretation of the
    resulting score:

    - "rank": Average percentage ranking of score.  In case of
              multiple matches, average the percentage rankings of
              all matching scores.
    - "weak": This kind corresponds to the definition of a cumulative
              distribution function.  A percentileofscore of 80%
              means that 80% of values are less than or equal
              to the provided score.
    - "strict": Similar to "weak", except that only values that are
                strictly less than the given score are counted.
    - "mean": The average of the "weak" and "strict" scores, often used in
              testing.  See

              http://en.wikipedia.org/wiki/Percentile_rank

Returns
-------
pcos : float
    Percentile-position of score (0-100) relative to `a`.

Examples
--------
Three-quarters of the given values lie below a given score:

>>> percentileofscore([1, 2, 3, 4], 3)
75.0

With multiple matches, note how the scores of the two matches, 0.6
and 0.8 respectively, are averaged:

>>> percentileofscore([1, 2, 3, 3, 4], 3)
70.0

Only 2/5 values are strictly less than 3:

>>> percentileofscore([1, 2, 3, 3, 4], 3, kind='strict')
40.0

But 4/5 values are less than or equal to 3:

>>> percentileofscore([1, 2, 3, 3, 4], 3, kind='weak')
80.0

The average between the weak and the strict scores is

>>> percentileofscore([1, 2, 3, 3, 4], 3, kind='mean')
60.0\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ab33df19284919454cbde0baf361d2287}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!pointbiserialr@{pointbiserialr}}
\index{pointbiserialr@{pointbiserialr}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{pointbiserialr}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+pointbiserialr (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{y}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ab33df19284919454cbde0baf361d2287}
\begin{DoxyVerb}Calculates a point biserial correlation coefficient and the associated
p-value.

The point biserial correlation is used to measure the relationship
between a binary variable, x, and a continuous variable, y. Like other
correlation coefficients, this one varies between -1 and +1 with 0
implying no correlation. Correlations of -1 or +1 imply a determinative
relationship.

This function uses a shortcut formula but produces the same result as
`pearsonr`.

Parameters
----------
x : array_like of bools
    Input array.
y : array_like
    Input array.

Returns
-------
r : float
    R value
p-value : float
    2-tailed p-value

References
----------
http://en.wikipedia.org/wiki/Point-biserial_correlation_coefficient

Examples
--------
>>> from scipy import stats
>>> a = np.array([0, 0, 0, 1, 1, 1, 1])
>>> b = np.arange(7)
>>> stats.pointbiserialr(a, b)
(0.8660254037844386, 0.011724811003954652)
>>> stats.pearsonr(a, b)
(0.86602540378443871, 0.011724811003954626)
>>> np.corrcoef(a, b)
array([[ 1.       ,  0.8660254],
       [ 0.8660254,  1.       ]])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a14512b7b896743b932c0b31425740432}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!power\+\_\+divergence@{power\+\_\+divergence}}
\index{power\+\_\+divergence@{power\+\_\+divergence}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{power\+\_\+divergence}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+power\+\_\+divergence (
\begin{DoxyParamCaption}
\item[{}]{f\+\_\+obs, }
\item[{}]{f\+\_\+exp = {\ttfamily None}, }
\item[{}]{ddof = {\ttfamily 0}, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{lambda\+\_\+ = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a14512b7b896743b932c0b31425740432}
\begin{DoxyVerb}Cressie-Read power divergence statistic and goodness of fit test.

This function tests the null hypothesis that the categorical data
has the given frequencies, using the Cressie-Read power divergence
statistic.

Parameters
----------
f_obs : array_like
    Observed frequencies in each category.
f_exp : array_like, optional
    Expected frequencies in each category.  By default the categories are
    assumed to be equally likely.
ddof : int, optional
    "Delta degrees of freedom": adjustment to the degrees of freedom
    for the p-value.  The p-value is computed using a chi-squared
    distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
    is the number of observed frequencies.  The default value of `ddof`
    is 0.
axis : int or None, optional
    The axis of the broadcast result of `f_obs` and `f_exp` along which to
    apply the test.  If axis is None, all values in `f_obs` are treated
    as a single data set.  Default is 0.
lambda_ : float or str, optional
    `lambda_` gives the power in the Cressie-Read power divergence
    statistic.  The default is 1.  For convenience, `lambda_` may be
    assigned one of the following strings, in which case the
    corresponding numerical value is used::

        String              Value   Description
        "pearson"             1     Pearson's chi-squared statistic.
                                    In this case, the function is
                                    equivalent to `stats.chisquare`.
        "log-likelihood"      0     Log-likelihood ratio. Also known as
                                    the G-test [3]_.
        "freeman-tukey"      -1/2   Freeman-Tukey statistic.
        "mod-log-likelihood" -1     Modified log-likelihood ratio.
        "neyman"             -2     Neyman's statistic.
        "cressie-read"        2/3   The power recommended in [5]_.

Returns
-------
stat : float or ndarray
    The Cressie-Read power divergence test statistic.  The value is
    a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D.
p : float or ndarray
    The p-value of the test.  The value is a float if `ddof` and the
    return value `stat` are scalars.

See Also
--------
chisquare

Notes
-----
This test is invalid when the observed or expected frequencies in each
category are too small.  A typical rule is that all of the observed
and expected frequencies should be at least 5.

When `lambda_` is less than zero, the formula for the statistic involves
dividing by `f_obs`, so a warning or error may be generated if any value
in `f_obs` is 0.

Similarly, a warning or error may be generated if any value in `f_exp` is
zero when `lambda_` >= 0.

The default degrees of freedom, k-1, are for the case when no parameters
of the distribution are estimated. If p parameters are estimated by
efficient maximum likelihood then the correct degrees of freedom are
k-1-p. If the parameters are estimated in a different way, then the
dof can be between k-1-p and k-1. However, it is also possible that
the asymptotic distribution is not a chisquare, in which case this
test is not appropriate.

This function handles masked arrays.  If an element of `f_obs` or `f_exp`
is masked, then data at that position is ignored, and does not count
towards the size of the data set.

.. versionadded:: 0.13.0

References
----------
.. [1] Lowry, Richard.  "Concepts and Applications of Inferential
       Statistics". Chapter 8. http://faculty.vassar.edu/lowry/ch8pt1.html
.. [2] "Chi-squared test", http://en.wikipedia.org/wiki/Chi-squared_test
.. [3] "G-test", http://en.wikipedia.org/wiki/G-test
.. [4] Sokal, R. R. and Rohlf, F. J. "Biometry: the principles and
       practice of statistics in biological research", New York: Freeman
       (1981)
.. [5] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
       Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
       pp. 440-464.

Examples
--------

(See `chisquare` for more examples.)

When just `f_obs` is given, it is assumed that the expected frequencies
are uniform and given by the mean of the observed frequencies.  Here we
perform a G-test (i.e. use the log-likelihood ratio statistic):

>>> power_divergence([16, 18, 16, 14, 12, 12], method='log-likelihood')
(2.006573162632538, 0.84823476779463769)

The expected frequencies can be given with the `f_exp` argument:

>>> power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[16, 16, 16, 16, 16, 8],
...                  lambda_='log-likelihood')
(3.5, 0.62338762774958223)

When `f_obs` is 2-D, by default the test is applied to each column.

>>> obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
>>> obs.shape
(6, 2)
>>> power_divergence(obs, lambda_="log-likelihood")
(array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225]))

By setting ``axis=None``, the test is applied to all data in the array,
which is equivalent to applying the test to the flattened array.

>>> power_divergence(obs, axis=None)
(23.31034482758621, 0.015975692534127565)
>>> power_divergence(obs.ravel())
(23.31034482758621, 0.015975692534127565)

`ddof` is the change to make to the default degrees of freedom.

>>> power_divergence([16, 18, 16, 14, 12, 12], ddof=1)
(2.0, 0.73575888234288467)

The calculation of the p-values is done by broadcasting the
test statistic with `ddof`.

>>> power_divergence([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
(2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))

`f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
`f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
statistics, we must use ``axis=1``:

>>> power_divergence([16, 18, 16, 14, 12, 12],
...                  f_exp=[[16, 16, 16, 16, 16, 8],
...                         [8, 20, 20, 16, 12, 12]],
...                  axis=1)
(array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a43186935210b50e761236cad7f4197ea}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!ranksums@{ranksums}}
\index{ranksums@{ranksums}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{ranksums}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+ranksums (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{y}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a43186935210b50e761236cad7f4197ea}
\begin{DoxyVerb}Compute the Wilcoxon rank-sum statistic for two samples.

The Wilcoxon rank-sum test tests the null hypothesis that two sets
of measurements are drawn from the same distribution.  The alternative
hypothesis is that values in one sample are more likely to be
larger than the values in the other sample.

This test should be used to compare two samples from continuous
distributions.  It does not handle ties between measurements
in x and y.  For tie-handling and an optional continuity correction
see `scipy.stats.mannwhitneyu`.

Parameters
----------
x,y : array_like
    The data from the two samples

Returns
-------
z-statistic : float
    The test statistic under the large-sample approximation that the
    rank sum statistic is normally distributed
p-value : float
    The two-sided p-value of the test

References
----------
.. [1] http://en.wikipedia.org/wiki/Wilcoxon_rank-sum_test\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a651c9a0a2dd7ea81ee73daf3bda40fde}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!relfreq@{relfreq}}
\index{relfreq@{relfreq}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{relfreq}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+relfreq (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{numbins = {\ttfamily 10}, }
\item[{}]{defaultreallimits = {\ttfamily None}, }
\item[{}]{weights = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a651c9a0a2dd7ea81ee73daf3bda40fde}
\begin{DoxyVerb}Returns a relative frequency histogram, using the histogram function.

Parameters
----------
a : array_like
    Input array.
numbins : int, optional
    The number of bins to use for the histogram. Default is 10.
defaultreallimits : tuple (lower, upper), optional
    The lower and upper values for the range of the histogram.
    If no value is given, a range slightly larger then the range of the
    values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
        where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
weights : array_like, optional
    The weights for each value in `a`. Default is None, which gives each
    value a weight of 1.0

Returns
-------
relfreq : ndarray
    Binned values of relative frequency.
lowerreallimit : float
    Lower real limit
binsize : float
    Width of each bin.
extrapoints : int
    Extra points.

Examples
--------
>>> a = np.array([1, 4, 2, 1, 3, 1])
>>> relfreqs, lowlim, binsize, extrapoints = sp.stats.relfreq(a, numbins=4)
>>> relfreqs
array([ 0.5       ,  0.16666667,  0.16666667,  0.16666667])
>>> np.sum(relfreqs)  # relative frequencies should add up to 1
0.99999999999999989\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a72a6f95981ff8c462388584ecbf1fdb3}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!scoreatpercentile@{scoreatpercentile}}
\index{scoreatpercentile@{scoreatpercentile}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{scoreatpercentile}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+scoreatpercentile (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{per, }
\item[{}]{limit = {\ttfamily ()}, }
\item[{}]{interpolation\+\_\+method = {\ttfamily 'fraction'}, }
\item[{}]{axis = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a72a6f95981ff8c462388584ecbf1fdb3}
\begin{DoxyVerb}Calculate the score at a given percentile of the input sequence.

For example, the score at `per=50` is the median. If the desired quantile
lies between two data points, we interpolate between them, according to
the value of `interpolation`. If the parameter `limit` is provided, it
should be a tuple (lower, upper) of two values.

Parameters
----------
a : array_like
    A 1-D array of values from which to extract score.
per : array_like
    Percentile(s) at which to extract score.  Values should be in range
    [0,100].
limit : tuple, optional
    Tuple of two scalars, the lower and upper limits within which to
    compute the percentile. Values of `a` outside
    this (closed) interval will be ignored.
interpolation : {'fraction', 'lower', 'higher'}, optional
    This optional parameter specifies the interpolation method to use,
    when the desired quantile lies between two data points `i` and `j`

      - fraction: ``i + (j - i) * fraction`` where ``fraction`` is the
        fractional part of the index surrounded by ``i`` and ``j``.
      - lower: ``i``.
      - higher: ``j``.

axis : int, optional
    Axis along which the percentiles are computed. The default (None)
    is to compute the median along a flattened version of the array.

Returns
-------
score : float or ndarray
    Score at percentile(s).

See Also
--------
percentileofscore, numpy.percentile

Notes
-----
This function will become obsolete in the future.
For Numpy 1.9 and higher, `numpy.percentile` provides all the functionality
that `scoreatpercentile` provides.  And it's significantly faster.
Therefore it's recommended to use `numpy.percentile` for users that have
numpy >= 1.9.

Examples
--------
>>> from scipy import stats
>>> a = np.arange(100)
>>> stats.scoreatpercentile(a, 50)
49.5\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a60937a31f8ba30ec6197e9a24c124089}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!sem@{sem}}
\index{sem@{sem}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{sem}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+sem (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{ddof = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a60937a31f8ba30ec6197e9a24c124089}
\begin{DoxyVerb}Calculates the standard error of the mean (or standard error of
measurement) of the values in the input array.

Parameters
----------
a : array_like
    An array containing the values for which the standard error is
    returned.
axis : int or None, optional.
    If axis is None, ravel `a` first. If axis is an integer, this will be
    the axis over which to operate. Defaults to 0.
ddof : int, optional
    Delta degrees-of-freedom. How many degrees of freedom to adjust
    for bias in limited samples relative to the population estimate
    of variance. Defaults to 1.

Returns
-------
s : ndarray or float
    The standard error of the mean in the sample(s), along the input axis.

Notes
-----
The default value for `ddof` is different to the default (0) used by other
ddof containing routines, such as np.std nd stats.nanstd.

Examples
--------
Find standard error along the first axis:

>>> from scipy import stats
>>> a = np.arange(20).reshape(5,4)
>>> stats.sem(a)
array([ 2.8284,  2.8284,  2.8284,  2.8284])

Find standard error across the whole array, using n degrees of freedom:

>>> stats.sem(a, axis=None, ddof=0)
1.2893796958227628\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a8bc5d99927c5e160441e11270a1be982}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!sigmaclip@{sigmaclip}}
\index{sigmaclip@{sigmaclip}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{sigmaclip}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+sigmaclip (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{low = {\ttfamily 4.}, }
\item[{}]{high = {\ttfamily 4.}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a8bc5d99927c5e160441e11270a1be982}
\begin{DoxyVerb}Iterative sigma-clipping of array elements.

The output array contains only those elements of the input array `c`
that satisfy the conditions ::

    mean(c) - std(c)*low < c < mean(c) + std(c)*high

Starting from the full sample, all elements outside the critical range are
removed. The iteration continues with a new critical range until no
elements are outside the range.

Parameters
----------
a : array_like
    Data array, will be raveled if not 1-D.
low : float, optional
    Lower bound factor of sigma clipping. Default is 4.
high : float, optional
    Upper bound factor of sigma clipping. Default is 4.

Returns
-------
c : ndarray
    Input array with clipped elements removed.
critlower : float
    Lower threshold value use for clipping.
critlupper : float
    Upper threshold value use for clipping.

Examples
--------
>>> a = np.concatenate((np.linspace(9.5,10.5,31), np.linspace(0,20,5)))
>>> fact = 1.5
>>> c, low, upp = sigmaclip(a, fact, fact)
>>> c
array([  9.96666667,  10.        ,  10.03333333,  10.        ])
>>> c.var(), c.std()
(0.00055555555555555165, 0.023570226039551501)
>>> low, c.mean() - fact*c.std(), c.min()
(9.9646446609406727, 9.9646446609406727, 9.9666666666666668)
>>> upp, c.mean() + fact*c.std(), c.max()
(10.035355339059327, 10.035355339059327, 10.033333333333333)

>>> a = np.concatenate((np.linspace(9.5,10.5,11),
    np.linspace(-100,-50,3)))
>>> c, low, upp = sigmaclip(a, 1.8, 1.8)
>>> (c == np.linspace(9.5,10.5,11)).all()
True\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a7bb1bd5893a4e236fe9c3da20acd31fe}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!signaltonoise@{signaltonoise}}
\index{signaltonoise@{signaltonoise}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{signaltonoise}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+signaltonoise (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{ddof = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a7bb1bd5893a4e236fe9c3da20acd31fe}
\begin{DoxyVerb}The signal-to-noise ratio of the input data.

Returns the signal-to-noise ratio of `a`, here defined as the mean
divided by the standard deviation.

Parameters
----------
a : array_like
    An array_like object containing the sample data.
axis : int or None, optional
    If axis is equal to None, the array is first ravel'd. If axis is an
    integer, this is the axis over which to operate. Default is 0.
ddof : int, optional
    Degrees of freedom correction for standard deviation. Default is 0.

Returns
-------
s2n : ndarray
    The mean to standard deviation ratio(s) along `axis`, or 0 where the
    standard deviation is 0.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a744ba715bda869ac6edbadbb3223c5d5}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!skew@{skew}}
\index{skew@{skew}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{skew}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+skew (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{bias = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a744ba715bda869ac6edbadbb3223c5d5}
\begin{DoxyVerb}Computes the skewness of a data set.

For normally distributed data, the skewness should be about 0. A skewness
value > 0 means that there is more weight in the left tail of the
distribution. The function `skewtest` can be used to determine if the
skewness value is close enough to 0, statistically speaking.

Parameters
----------
a : ndarray
    data
axis : int or None
    axis along which skewness is calculated
bias : bool
    If False, then the calculations are corrected for statistical bias.

Returns
-------
skewness : ndarray
    The skewness of values along an axis, returning 0 where all values are
    equal.

References
----------
[CRCProbStat2000]_ Section 2.2.24.1

.. [CRCProbStat2000] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_af83023d02b569b719ce5ae04cdb5caa0}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!skewtest@{skewtest}}
\index{skewtest@{skewtest}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{skewtest}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+skewtest (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_af83023d02b569b719ce5ae04cdb5caa0}


N\+O\+R\+M\+A\+L\+I\+T\+Y T\+E\+S\+T\+S \#\#\#\#\#\#\#\#\#\#. 

\begin{DoxyVerb}Tests whether the skew is different from the normal distribution.

This function tests the null hypothesis that the skewness of
the population that the sample was drawn from is the same
as that of a corresponding normal distribution.

Parameters
----------
a : array
axis : int or None

Returns
-------
z-score : float
    The computed z-score for this test.
p-value : float
    a 2-sided p-value for the hypothesis test

Notes
-----
The sample size must be at least 8.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a33d608de2cbc6328c57ba67d3ad0a253}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!spearmanr@{spearmanr}}
\index{spearmanr@{spearmanr}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{spearmanr}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+spearmanr (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b = {\ttfamily None}, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a33d608de2cbc6328c57ba67d3ad0a253}
\begin{DoxyVerb}Calculates a Spearman rank-order correlation coefficient and the p-value
to test for non-correlation.

The Spearman correlation is a nonparametric measure of the monotonicity
of the relationship between two datasets. Unlike the Pearson correlation,
the Spearman correlation does not assume that both datasets are normally
distributed. Like other correlation coefficients, this one varies
between -1 and +1 with 0 implying no correlation. Correlations of -1 or
+1 imply an exact monotonic relationship. Positive correlations imply that
as x increases, so does y. Negative correlations imply that as x
increases, y decreases.

The p-value roughly indicates the probability of an uncorrelated system
producing datasets that have a Spearman correlation at least as extreme
as the one computed from these datasets. The p-values are not entirely
reliable but are probably reasonable for datasets larger than 500 or so.

Parameters
----------
a, b : 1D or 2D array_like, b is optional
    One or two 1-D or 2-D arrays containing multiple variables and
    observations. Each column of `a` and `b` represents a variable, and
    each row entry a single observation of those variables. See also
    `axis`. Both arrays need to have the same length in the `axis`
    dimension.
axis : int or None, optional
    If axis=0 (default), then each column represents a variable, with
    observations in the rows. If axis=0, the relationship is transposed:
    each row represents a variable, while the columns contain observations.
    If axis=None, then both arrays will be raveled.

Returns
-------
rho : float or ndarray (2-D square)
    Spearman correlation matrix or correlation coefficient (if only 2
    variables are given as parameters. Correlation matrix is square with
    length equal to total number of variables (columns or rows) in a and b
    combined.
p-value : float
    The two-sided p-value for a hypothesis test whose null hypothesis is
    that two sets of data are uncorrelated, has same dimension as rho.

Notes
-----
Changes in scipy 0.8.0: rewrite to add tie-handling, and axis.

References
----------
[CRCProbStat2000]_ Section  14.7

.. [CRCProbStat2000] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.

Examples
--------
>>> spearmanr([1,2,3,4,5],[5,6,7,8,7])
(0.82078268166812329, 0.088587005313543798)
>>> np.random.seed(1234321)
>>> x2n=np.random.randn(100,2)
>>> y2n=np.random.randn(100,2)
>>> spearmanr(x2n)
(0.059969996999699973, 0.55338590803773591)
>>> spearmanr(x2n[:,0], x2n[:,1])
(0.059969996999699973, 0.55338590803773591)
>>> rho, pval = spearmanr(x2n,y2n)
>>> rho
array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],
       [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],
       [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],
       [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])
>>> pval
array([[ 0.        ,  0.55338591,  0.06435364,  0.53617935],
       [ 0.55338591,  0.        ,  0.27592895,  0.80234077],
       [ 0.06435364,  0.27592895,  0.        ,  0.73039992],
       [ 0.53617935,  0.80234077,  0.73039992,  0.        ]])
>>> rho, pval = spearmanr(x2n.T, y2n.T, axis=1)
>>> rho
array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],
       [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],
       [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],
       [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])
>>> spearmanr(x2n, y2n, axis=None)
(0.10816770419260482, 0.1273562188027364)
>>> spearmanr(x2n.ravel(), y2n.ravel())
(0.10816770419260482, 0.1273562188027364)

>>> xint = np.random.randint(10,size=(100,2))
>>> spearmanr(xint)
(0.052760927029710199, 0.60213045837062351)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a1680aa2ef3675bd4e3b47c7ee0ae6b6b}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!square\+\_\+of\+\_\+sums@{square\+\_\+of\+\_\+sums}}
\index{square\+\_\+of\+\_\+sums@{square\+\_\+of\+\_\+sums}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{square\+\_\+of\+\_\+sums}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+square\+\_\+of\+\_\+sums (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a1680aa2ef3675bd4e3b47c7ee0ae6b6b}
\begin{DoxyVerb}Sums elements of the input array, and returns the square(s) of that sum.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    If axis is None, ravel `a` first. If `axis` is an integer, this will
    be the axis over which to operate. Defaults to 0.

Returns
-------
square_of_sums : float or ndarray
    The square of the sum over `axis`.

See also
--------
ss : The sum of squares (the opposite of `square_of_sums`).

Examples
--------
>>> from scipy import stats
>>> a = np.arange(20).reshape(5,4)
>>> stats.square_of_sums(a)
array([ 1600.,  2025.,  2500.,  3025.])
>>> stats.square_of_sums(a, axis=None)
36100.0\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a73704e49e0db2b3a28f07bc36086f4dc}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!ss@{ss}}
\index{ss@{ss}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{ss}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+ss (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a73704e49e0db2b3a28f07bc36086f4dc}


S\+U\+P\+P\+O\+R\+T F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#\#\#\#. 

\begin{DoxyVerb}Squares each element of the input array, and returns the sum(s) of that.

Parameters
----------
a : array_like
    Input array.
axis : int or None, optional
    The axis along which to calculate. If None, use whole array.
    Default is 0, i.e. along the first axis.

Returns
-------
ss : ndarray
    The sum along the given axis for (a**2).

See also
--------
square_of_sums : The square(s) of the sum(s) (the opposite of `ss`).

Examples
--------
>>> from scipy import stats
>>> a = np.array([1., 2., 5.])
>>> stats.ss(a)
30.0

And calculating along an axis:

>>> b = np.array([[1., 2., 5.], [2., 5., 6.]])
>>> stats.ss(b, axis=1)
array([ 30., 65.])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ab66a77dd455f02d880db0d592ff92bdd}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!threshold@{threshold}}
\index{threshold@{threshold}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{threshold}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+threshold (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{threshmin = {\ttfamily None}, }
\item[{}]{threshmax = {\ttfamily None}, }
\item[{}]{newval = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ab66a77dd455f02d880db0d592ff92bdd}


T\+R\+I\+M\+M\+I\+N\+G F\+U\+N\+C\+T\+I\+O\+N\+S \#\#\#\#\#\#\#. 

\begin{DoxyVerb}Clip array to a given value.

Similar to numpy.clip(), except that values less than `threshmin` or
greater than `threshmax` are replaced by `newval`, instead of by
`threshmin` and `threshmax` respectively.

Parameters
----------
a : array_like
    Data to threshold.
threshmin : float, int or None, optional
    Minimum threshold, defaults to None.
threshmax : float, int or None, optional
    Maximum threshold, defaults to None.
newval : float or int, optional
    Value to put in place of values in `a` outside of bounds.
    Defaults to 0.

Returns
-------
out : ndarray
    The clipped input array, with values less than `threshmin` or
    greater than `threshmax` replaced with `newval`.

Examples
--------
>>> a = np.array([9, 9, 6, 3, 1, 6, 1, 0, 0, 8])
>>> from scipy import stats
>>> stats.threshold(a, threshmin=2, threshmax=8, newval=-1)
array([-1, -1,  6,  3, -1,  6, -1, -1, -1,  8])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_ab5ff5057b7e0f015c7a82a3fd300fb34}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!tmax@{tmax}}
\index{tmax@{tmax}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{tmax}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+tmax (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{upperlimit = {\ttfamily None}, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{inclusive = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_ab5ff5057b7e0f015c7a82a3fd300fb34}
\begin{DoxyVerb}Compute the trimmed maximum

This function computes the maximum value of an array along a given axis,
while ignoring values larger than a specified upper limit.

Parameters
----------
a : array_like
    array of values
upperlimit : None or float, optional
    Values in the input array greater than the given limit will be ignored.
    When upperlimit is None, then all values are used. The default value
    is None.
axis : None or int, optional
    Operate along this axis.  None means to use the flattened array and
    the default is zero.
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the upper limit
    are included.  The default value is True.

Returns
-------
tmax : float\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a3826e86ff6b9eb4b4596335bd2a0f47d}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!tmean@{tmean}}
\index{tmean@{tmean}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{tmean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+tmean (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{limits = {\ttfamily None}, }
\item[{}]{inclusive = {\ttfamily ({\bf True},~{\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a3826e86ff6b9eb4b4596335bd2a0f47d}
\begin{DoxyVerb}Compute the trimmed mean.

This function finds the arithmetic mean of given values, ignoring values
outside the given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored.  When limits is None (default), then all
    values are used.  Either of the limit values in the tuple can also be
    None representing a half-open interval.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tmean : float\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_aa0738b7e12963beee896c5f47db4fd4b}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!tmin@{tmin}}
\index{tmin@{tmin}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{tmin}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+tmin (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{lowerlimit = {\ttfamily None}, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{inclusive = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_aa0738b7e12963beee896c5f47db4fd4b}
\begin{DoxyVerb}Compute the trimmed minimum

This function finds the miminum value of an array `a` along the
specified axis, but only considering values greater than a specified
lower limit.

Parameters
----------
a : array_like
    array of values
lowerlimit : None or float, optional
    Values in the input array less than the given limit will be ignored.
    When lowerlimit is None, then all values are used. The default value
    is None.
axis : None or int, optional
    Operate along this axis.  None means to use the flattened array and
    the default is zero
inclusive : {True, False}, optional
    This flag determines whether values exactly equal to the lower limit
    are included.  The default value is True.

Returns
-------
tmin : float\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a3bb9cd623c8771cf86301cbbe54dbbab}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!trim1@{trim1}}
\index{trim1@{trim1}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{trim1}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+trim1 (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{proportiontocut, }
\item[{}]{tail = {\ttfamily 'right'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a3bb9cd623c8771cf86301cbbe54dbbab}
\begin{DoxyVerb}Slices off a proportion of items from ONE end of the passed array
distribution.

If `proportiontocut` = 0.1, slices off 'leftmost' or 'rightmost'
10% of scores.  Slices off LESS if proportion results in a non-integer
slice index (i.e., conservatively slices off `proportiontocut` ).

Parameters
----------
a : array_like
    Input array
proportiontocut : float
    Fraction to cut off of 'left' or 'right' of distribution
tail : {'left', 'right'}, optional
    Defaults to 'right'.

Returns
-------
trim1 : ndarray
    Trimmed version of array `a`\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a89437599855e82f8fb127a272820db0e}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!trim\+\_\+mean@{trim\+\_\+mean}}
\index{trim\+\_\+mean@{trim\+\_\+mean}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{trim\+\_\+mean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+trim\+\_\+mean (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{proportiontocut, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a89437599855e82f8fb127a272820db0e}
\begin{DoxyVerb}Return mean of array after trimming distribution from both lower and upper
tails.

If `proportiontocut` = 0.1, slices off 'leftmost' and 'rightmost' 10% of
scores. Slices off LESS if proportion results in a non-integer slice
index (i.e., conservatively slices off `proportiontocut` ).

Parameters
----------
a : array_like
    Input array
proportiontocut : float
    Fraction to cut off of both tails of the distribution
axis : int or None, optional
    Axis along which the trimmed means are computed. The default is axis=0.
    If axis is None then the trimmed mean will be computed for the
    flattened array.

Returns
-------
trim_mean : ndarray
    Mean of trimmed array.

See Also
--------
trimboth

Examples
--------
>>> from scipy import stats
>>> x = np.arange(20)
>>> stats.trim_mean(x, 0.1)
9.5
>>> x2 = x.reshape(5, 4)
>>> x2
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19]])
>>> stats.trim_mean(x2, 0.25)
array([  8.,   9.,  10.,  11.])
>>> stats.trim_mean(x2, 0.25, axis=1)
array([  1.5,   5.5,   9.5,  13.5,  17.5])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a1354a0d681b70e167d85e50408f58bb7}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!trimboth@{trimboth}}
\index{trimboth@{trimboth}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{trimboth}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+trimboth (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{proportiontocut, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a1354a0d681b70e167d85e50408f58bb7}
\begin{DoxyVerb}Slices off a proportion of items from both ends of an array.

Slices off the passed proportion of items from both ends of the passed
array (i.e., with `proportiontocut` = 0.1, slices leftmost 10% **and**
rightmost 10% of scores).  You must pre-sort the array if you want
'proper' trimming.  Slices off less if proportion results in a
non-integer slice index (i.e., conservatively slices off
`proportiontocut`).

Parameters
----------
a : array_like
    Data to trim.
proportiontocut : float
    Proportion (in range 0-1) of total data set to trim of each end.
axis : int or None, optional
    Axis along which the observations are trimmed. The default is to trim
    along axis=0. If axis is None then the array will be flattened before
    trimming.

Returns
-------
out : ndarray
    Trimmed version of array `a`.

See Also
--------
trim_mean

Examples
--------
>>> from scipy import stats
>>> a = np.arange(20)
>>> b = stats.trimboth(a, 0.1)
>>> b.shape
(16,)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a76bb263845b2f0def598dd16a59e5bd3}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!tsem@{tsem}}
\index{tsem@{tsem}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{tsem}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+tsem (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{limits = {\ttfamily None}, }
\item[{}]{inclusive = {\ttfamily ({\bf True},~{\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a76bb263845b2f0def598dd16a59e5bd3}
\begin{DoxyVerb}Compute the trimmed standard error of the mean.

This function finds the standard error of the mean for given
values, ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    array of values
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tsem : float

Notes
-----
`tsem` uses unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_aab06e06d1821e3622968f6c370eb7af2}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!tstd@{tstd}}
\index{tstd@{tstd}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{tstd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+tstd (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{limits = {\ttfamily None}, }
\item[{}]{inclusive = {\ttfamily ({\bf True},~{\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_aab06e06d1821e3622968f6c370eb7af2}
\begin{DoxyVerb}Compute the trimmed sample standard deviation

This function finds the sample standard deviation of given values,
ignoring values outside the given `limits`.

Parameters
----------
a : array_like
    array of values
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tstd : float

Notes
-----
`tstd` computes the unbiased sample standard deviation, i.e. it uses a
correction factor ``n / (n - 1)``.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_aaec760400f4bdc5e967fe375757db5ad}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!ttest\+\_\+1samp@{ttest\+\_\+1samp}}
\index{ttest\+\_\+1samp@{ttest\+\_\+1samp}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{ttest\+\_\+1samp}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+ttest\+\_\+1samp (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{popmean, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_aaec760400f4bdc5e967fe375757db5ad}


I\+N\+F\+E\+R\+E\+N\+T\+I\+A\+L S\+T\+A\+T\+I\+S\+T\+I\+C\+S \#\#\#\#\#. 

\begin{DoxyVerb}Calculates the T-test for the mean of ONE group of scores.

This is a two-sided test for the null hypothesis that the expected value
(mean) of a sample of independent observations `a` is equal to the given
population mean, `popmean`.

Parameters
----------
a : array_like
    sample observation
popmean : float or array_like
    expected value in null hypothesis, if array_like than it must have the
    same shape as `a` excluding the axis dimension
axis : int, optional, (default axis=0)
    Axis can equal None (ravel array first), or an integer (the axis
    over which to operate on a).

Returns
-------
t : float or array
    t-statistic
prob : float or array
    two-tailed p-value

Examples
--------
>>> from scipy import stats

>>> np.random.seed(7654567)  # fix seed to get the same result
>>> rvs = stats.norm.rvs(loc=5, scale=10, size=(50,2))

Test if mean of random sample is equal to true mean, and different mean.
We reject the null hypothesis in the second case and don't reject it in
the first case.

>>> stats.ttest_1samp(rvs,5.0)
(array([-0.68014479, -0.04323899]), array([ 0.49961383,  0.96568674]))
>>> stats.ttest_1samp(rvs,0.0)
(array([ 2.77025808,  4.11038784]), array([ 0.00789095,  0.00014999]))

Examples using axis and non-scalar dimension for population mean.

>>> stats.ttest_1samp(rvs,[5.0,0.0])
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
>>> stats.ttest_1samp(rvs.T,[5.0,0.0],axis=1)
(array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
>>> stats.ttest_1samp(rvs,[[5.0],[0.0]])
(array([[-0.68014479, -0.04323899],
       [ 2.77025808,  4.11038784]]), array([[  4.99613833e-01,   9.65686743e-01],
       [  7.89094663e-03,   1.49986458e-04]]))\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a84703cd17b880e6be5071f665c0ebcc0}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!ttest\+\_\+ind@{ttest\+\_\+ind}}
\index{ttest\+\_\+ind@{ttest\+\_\+ind}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{ttest\+\_\+ind}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+ttest\+\_\+ind (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{equal\+\_\+var = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a84703cd17b880e6be5071f665c0ebcc0}
\begin{DoxyVerb}Calculates the T-test for the means of TWO INDEPENDENT samples of scores.

This is a two-sided test for the null hypothesis that 2 independent samples
have identical average (expected) values. This test assumes that the
populations have identical variances.

Parameters
----------
a, b : array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    Axis can equal None (ravel array first), or an integer (the axis
    over which to operate on a and b).
equal_var : bool, optional
    If True (default), perform a standard independent 2 sample test
    that assumes equal population variances [1]_.
    If False, perform Welch's t-test, which does not assume equal
    population variance [2]_.

    .. versionadded:: 0.11.0

Returns
-------
t : float or array
    The calculated t-statistic.
prob : float or array
    The two-tailed p-value.

Notes
-----
We can use this test, if we observe two independent samples from
the same or different population, e.g. exam scores of boys and
girls or of two ethnic groups. The test measures whether the
average (expected) value differs significantly across samples. If
we observe a large p-value, for example larger than 0.05 or 0.1,
then we cannot reject the null hypothesis of identical average scores.
If the p-value is smaller than the threshold, e.g. 1%, 5% or 10%,
then we reject the null hypothesis of equal averages.

References
----------
.. [1] http://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test

.. [2] http://en.wikipedia.org/wiki/Welch%27s_t_test

Examples
--------
>>> from scipy import stats
>>> np.random.seed(12345678)

Test with sample with identical means:

>>> rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
>>> rvs2 = stats.norm.rvs(loc=5,scale=10,size=500)
>>> stats.ttest_ind(rvs1,rvs2)
(0.26833823296239279, 0.78849443369564776)
>>> stats.ttest_ind(rvs1,rvs2, equal_var = False)
(0.26833823296239279, 0.78849452749500748)

`ttest_ind` underestimates p for unequal variances:

>>> rvs3 = stats.norm.rvs(loc=5, scale=20, size=500)
>>> stats.ttest_ind(rvs1, rvs3)
(-0.46580283298287162, 0.64145827413436174)
>>> stats.ttest_ind(rvs1, rvs3, equal_var = False)
(-0.46580283298287162, 0.64149646246569292)

When n1 != n2, the equal variance t-statistic is no longer equal to the
unequal variance t-statistic:

>>> rvs4 = stats.norm.rvs(loc=5, scale=20, size=100)
>>> stats.ttest_ind(rvs1, rvs4)
(-0.99882539442782481, 0.3182832709103896)
>>> stats.ttest_ind(rvs1, rvs4, equal_var = False)
(-0.69712570584654099, 0.48716927725402048)

T-test with different means, variance, and n:

>>> rvs5 = stats.norm.rvs(loc=8, scale=20, size=100)
>>> stats.ttest_ind(rvs1, rvs5)
(-1.4679669854490653, 0.14263895620529152)
>>> stats.ttest_ind(rvs1, rvs5, equal_var = False)
(-0.94365973617132992, 0.34744170334794122)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_aed469b7890b916252322b8536991f72f}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!ttest\+\_\+rel@{ttest\+\_\+rel}}
\index{ttest\+\_\+rel@{ttest\+\_\+rel}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{ttest\+\_\+rel}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+ttest\+\_\+rel (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{b, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_aed469b7890b916252322b8536991f72f}
\begin{DoxyVerb}Calculates the T-test on TWO RELATED samples of scores, a and b.

This is a two-sided test for the null hypothesis that 2 related or
repeated samples have identical average (expected) values.

Parameters
----------
a, b : array_like
    The arrays must have the same shape.
axis : int, optional, (default axis=0)
    Axis can equal None (ravel array first), or an integer (the axis
    over which to operate on a and b).

Returns
-------
t : float or array
    t-statistic
prob : float or array
    two-tailed p-value

Notes
-----
Examples for the use are scores of the same set of student in
different exams, or repeated sampling from the same units. The
test measures whether the average score differs significantly
across samples (e.g. exams). If we observe a large p-value, for
example greater than 0.05 or 0.1 then we cannot reject the null
hypothesis of identical average scores. If the p-value is smaller
than the threshold, e.g. 1%, 5% or 10%, then we reject the null
hypothesis of equal averages. Small p-values are associated with
large t-statistics.

References
----------
http://en.wikipedia.org/wiki/T-test#Dependent_t-test

Examples
--------
>>> from scipy import stats
>>> np.random.seed(12345678) # fix random seed to get same numbers

>>> rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
>>> rvs2 = (stats.norm.rvs(loc=5,scale=10,size=500) +
...         stats.norm.rvs(scale=0.2,size=500))
>>> stats.ttest_rel(rvs1,rvs2)
(0.24101764965300962, 0.80964043445811562)
>>> rvs3 = (stats.norm.rvs(loc=8,scale=10,size=500) +
...         stats.norm.rvs(scale=0.2,size=500))
>>> stats.ttest_rel(rvs1,rvs3)
(-3.9995108708727933, 7.3082402191726459e-005)\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a83ca47e55ba2a93bb820b00ccb237d67}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!tvar@{tvar}}
\index{tvar@{tvar}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{tvar}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+tvar (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{limits = {\ttfamily None}, }
\item[{}]{inclusive = {\ttfamily ({\bf True},~{\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a83ca47e55ba2a93bb820b00ccb237d67}
\begin{DoxyVerb}Compute the trimmed variance

This function computes the sample variance of an array of values,
while ignoring values which are outside of given `limits`.

Parameters
----------
a : array_like
    Array of values.
limits : None or (lower limit, upper limit), optional
    Values in the input array less than the lower limit or greater than the
    upper limit will be ignored. When limits is None, then all values are
    used. Either of the limit values in the tuple can also be None
    representing a half-open interval.  The default value is None.
inclusive : (bool, bool), optional
    A tuple consisting of the (lower flag, upper flag).  These flags
    determine whether values exactly equal to the lower or upper limits
    are included.  The default value is (True, True).

Returns
-------
tvar : float
    Trimmed variance.

Notes
-----
`tvar` computes the unbiased sample variance, i.e. it uses a correction
factor ``n / (n - 1)``.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a90ddfd8c7688498b52f36a7e56f7c996}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!variation@{variation}}
\index{variation@{variation}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{variation}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+variation (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a90ddfd8c7688498b52f36a7e56f7c996}
\begin{DoxyVerb}Computes the coefficient of variation, the ratio of the biased standard
deviation to the mean.

Parameters
----------
a : array_like
    Input array.
axis : int or None
    Axis along which to calculate the coefficient of variation.

References
----------
.. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
   Probability and Statistics Tables and Formulae. Chapman & Hall: New
   York. 2000.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_a90bce292719490568f8782fd2e5f4aa8}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!zmap@{zmap}}
\index{zmap@{zmap}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{zmap}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+zmap (
\begin{DoxyParamCaption}
\item[{}]{scores, }
\item[{}]{compare, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{ddof = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_a90bce292719490568f8782fd2e5f4aa8}
\begin{DoxyVerb}Calculates the relative z-scores.

Returns an array of z-scores, i.e., scores that are standardized to zero
mean and unit variance, where mean and variance are calculated from the
comparison array.

Parameters
----------
scores : array_like
    The input for which z-scores are calculated.
compare : array_like
    The input from which the mean and standard deviation of the
    normalization are taken; assumed to have the same dimension as
    `scores`.
axis : int or None, optional
    Axis over which mean and variance of `compare` are calculated.
    Default is 0.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.

Returns
-------
zscore : array_like
    Z-scores, in the same shape as `scores`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of `asarray`
for parameters).

Examples
--------
>>> a = [0.5, 2.0, 2.5, 3]
>>> b = [0, 1, 2, 3, 4]
>>> zmap(a, b)
array([-1.06066017,  0.        ,  0.35355339,  0.70710678])
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1stats_1_1stats_afb06bf21578e516d2bc0d9f09e9ce872}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!zscore@{zscore}}
\index{zscore@{zscore}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{zscore}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+stats.\+stats.\+zscore (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{ddof = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1stats_1_1stats_afb06bf21578e516d2bc0d9f09e9ce872}
\begin{DoxyVerb}Calculates the z score of each value in the sample, relative to the sample
mean and standard deviation.

Parameters
----------
a : array_like
    An array like object containing the sample data.
axis : int or None, optional
    If `axis` is equal to None, the array is first raveled. If `axis` is
    an integer, this is the axis over which to operate. Default is 0.
ddof : int, optional
    Degrees of freedom correction in the calculation of the
    standard deviation. Default is 0.

Returns
-------
zscore : array_like
    The z-scores, standardized by mean and standard deviation of input
    array `a`.

Notes
-----
This function preserves ndarray subclasses, and works also with
matrices and masked arrays (it uses `asanyarray` instead of `asarray`
for parameters).

Examples
--------
>>> a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,  0.1954,
                   0.6307, 0.6599,  0.1065,  0.0508])
>>> from scipy import stats
>>> stats.zscore(a)
array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,
        0.6748, -1.1488, -1.3324])

Computing along a specified axis, using n-1 degrees of freedom (``ddof=1``)
to calculate the standard deviation:

>>> b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],
                  [ 0.7149,  0.0775,  0.6072,  0.9656],
                  [ 0.6341,  0.1403,  0.9759,  0.4064],
                  [ 0.5918,  0.6948,  0.904 ,  0.3721],
                  [ 0.0921,  0.2481,  0.1188,  0.1366]])
>>> stats.zscore(b, axis=1, ddof=1)
array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358],
       [ 0.33048416, -1.37380874,  0.04251374,  1.00081084],
       [ 0.26796377, -1.12598418,  1.23283094, -0.37481053],
       [-0.22095197,  0.24468594,  1.19042819, -1.21416216],
       [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]])
\end{DoxyVerb}
 

\subsection{Variable Documentation}
\hypertarget{namespacescipy_1_1stats_1_1stats_af64e57aacdbdd2800961c4f1ab76adb7}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{\+\_\+\+\_\+all\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}list scipy.\+stats.\+stats.\+\_\+\+\_\+all\+\_\+\+\_\+}\label{namespacescipy_1_1stats_1_1stats_af64e57aacdbdd2800961c4f1ab76adb7}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = [\textcolor{stringliteral}{'find\_repeats'}, \textcolor{stringliteral}{'gmean'}, \textcolor{stringliteral}{'hmean'}, \textcolor{stringliteral}{'mode'},
2            \textcolor{stringliteral}{'tmean'}, \textcolor{stringliteral}{'tvar'}, \textcolor{stringliteral}{'tmin'}, \textcolor{stringliteral}{'tmax'}, \textcolor{stringliteral}{'tstd'}, \textcolor{stringliteral}{'tsem'},
3            \textcolor{stringliteral}{'moment'}, \textcolor{stringliteral}{'variation'}, \textcolor{stringliteral}{'skew'}, \textcolor{stringliteral}{'kurtosis'}, \textcolor{stringliteral}{'describe'},
4            \textcolor{stringliteral}{'skewtest'}, \textcolor{stringliteral}{'kurtosistest'}, \textcolor{stringliteral}{'normaltest'}, \textcolor{stringliteral}{'jarque\_bera'},
5            \textcolor{stringliteral}{'itemfreq'}, \textcolor{stringliteral}{'scoreatpercentile'}, \textcolor{stringliteral}{'percentileofscore'},
6            \textcolor{stringliteral}{'histogram'}, \textcolor{stringliteral}{'histogram2'}, \textcolor{stringliteral}{'cumfreq'}, \textcolor{stringliteral}{'relfreq'},
7            \textcolor{stringliteral}{'obrientransform'}, \textcolor{stringliteral}{'signaltonoise'}, \textcolor{stringliteral}{'sem'}, \textcolor{stringliteral}{'zmap'}, \textcolor{stringliteral}{'zscore'},
8            \textcolor{stringliteral}{'threshold'}, \textcolor{stringliteral}{'sigmaclip'}, \textcolor{stringliteral}{'trimboth'}, \textcolor{stringliteral}{'trim1'}, \textcolor{stringliteral}{'trim\_mean'},
9            \textcolor{stringliteral}{'f\_oneway'}, \textcolor{stringliteral}{'pearsonr'}, \textcolor{stringliteral}{'fisher\_exact'},
10            \textcolor{stringliteral}{'spearmanr'}, \textcolor{stringliteral}{'pointbiserialr'}, \textcolor{stringliteral}{'kendalltau'}, \textcolor{stringliteral}{'linregress'},
11            \textcolor{stringliteral}{'ttest\_1samp'}, \textcolor{stringliteral}{'ttest\_ind'}, \textcolor{stringliteral}{'ttest\_rel'}, \textcolor{stringliteral}{'kstest'},
12            \textcolor{stringliteral}{'chisquare'}, \textcolor{stringliteral}{'power\_divergence'}, \textcolor{stringliteral}{'ks\_2samp'}, \textcolor{stringliteral}{'mannwhitneyu'},
13            \textcolor{stringliteral}{'tiecorrect'}, \textcolor{stringliteral}{'ranksums'}, \textcolor{stringliteral}{'kruskal'}, \textcolor{stringliteral}{'friedmanchisquare'},
14            \textcolor{stringliteral}{'zprob'}, \textcolor{stringliteral}{'chisqprob'}, \textcolor{stringliteral}{'ksprob'}, \textcolor{stringliteral}{'fprob'}, \textcolor{stringliteral}{'betai'},
15            \textcolor{stringliteral}{'f\_value\_wilks\_lambda'}, \textcolor{stringliteral}{'f\_value'}, \textcolor{stringliteral}{'f\_value\_multivariate'},
16            \textcolor{stringliteral}{'ss'}, \textcolor{stringliteral}{'square\_of\_sums'},
17            \textcolor{stringliteral}{'fastsort'}, \textcolor{stringliteral}{'rankdata'},
18            \textcolor{stringliteral}{'nanmean'}, \textcolor{stringliteral}{'nanstd'}, \textcolor{stringliteral}{'nanmedian'},
19            ]
\end{DoxyCode}
\hypertarget{namespacescipy_1_1stats_1_1stats_a1170151fdd7757465759450c6990a85b}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!\+\_\+power\+\_\+div\+\_\+lambda\+\_\+names@{\+\_\+power\+\_\+div\+\_\+lambda\+\_\+names}}
\index{\+\_\+power\+\_\+div\+\_\+lambda\+\_\+names@{\+\_\+power\+\_\+div\+\_\+lambda\+\_\+names}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{\+\_\+power\+\_\+div\+\_\+lambda\+\_\+names}]{\setlength{\rightskip}{0pt plus 5cm}dictionary scipy.\+stats.\+stats.\+\_\+power\+\_\+div\+\_\+lambda\+\_\+names}\label{namespacescipy_1_1stats_1_1stats_a1170151fdd7757465759450c6990a85b}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = \{
2     \textcolor{stringliteral}{"pearson"}: 1,
3     \textcolor{stringliteral}{"log-likelihood"}: 0,
4     \textcolor{stringliteral}{"freeman-tukey"}: -0.5,
5     \textcolor{stringliteral}{"mod-log-likelihood"}: -1,
6     \textcolor{stringliteral}{"neyman"}: -2,
7     \textcolor{stringliteral}{"cressie-read"}: 2/3,
8 \}
\end{DoxyCode}
\hypertarget{namespacescipy_1_1stats_1_1stats_a8c31dc4becce007349246d08a1456604}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!fprob@{fprob}}
\index{fprob@{fprob}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{fprob}]{\setlength{\rightskip}{0pt plus 5cm}tuple scipy.\+stats.\+stats.\+fprob}\label{namespacescipy_1_1stats_1_1stats_a8c31dc4becce007349246d08a1456604}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = np.deprecate(message=\textcolor{stringliteral}{'fprob is deprecated in scipy 0.14, '}
2         \textcolor{stringliteral}{'use stats.f.sf or special.fdtrc instead\(\backslash\)n'},
3         old\_name=\textcolor{stringliteral}{'fprob'})
\end{DoxyCode}
\hypertarget{namespacescipy_1_1stats_1_1stats_a282ba2c58cc27252c61a174891592b69}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!ksprob@{ksprob}}
\index{ksprob@{ksprob}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{ksprob}]{\setlength{\rightskip}{0pt plus 5cm}tuple scipy.\+stats.\+stats.\+ksprob}\label{namespacescipy_1_1stats_1_1stats_a282ba2c58cc27252c61a174891592b69}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = np.deprecate(message=\textcolor{stringliteral}{'ksprob is deprecated in scipy 0.14, '}
2         \textcolor{stringliteral}{'use stats.kstwobign.sf or special.kolmogorov instead\(\backslash\)n'},
3         old\_name=\textcolor{stringliteral}{'ksprob'})
\end{DoxyCode}
\hypertarget{namespacescipy_1_1stats_1_1stats_ac590997675d3ecc91073b26005afd4f2}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!pysum@{pysum}}
\index{pysum@{pysum}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{pysum}]{\setlength{\rightskip}{0pt plus 5cm}scipy.\+stats.\+stats.\+pysum = {\bf sum}}\label{namespacescipy_1_1stats_1_1stats_ac590997675d3ecc91073b26005afd4f2}
\hypertarget{namespacescipy_1_1stats_1_1stats_a2d6aedf55bc357862b482d97ffe38b9e}{}\index{scipy\+::stats\+::stats@{scipy\+::stats\+::stats}!zprob@{zprob}}
\index{zprob@{zprob}!scipy\+::stats\+::stats@{scipy\+::stats\+::stats}}
\subsubsection[{zprob}]{\setlength{\rightskip}{0pt plus 5cm}tuple scipy.\+stats.\+stats.\+zprob}\label{namespacescipy_1_1stats_1_1stats_a2d6aedf55bc357862b482d97ffe38b9e}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = np.deprecate(message=\textcolor{stringliteral}{'zprob is deprecated in scipy 0.14, '}
2         \textcolor{stringliteral}{'use norm.cdf or special.ndtr instead\(\backslash\)n'},
3         old\_name=\textcolor{stringliteral}{'zprob'})
\end{DoxyCode}


P\+R\+O\+B\+A\+B\+I\+L\+I\+T\+Y C\+A\+L\+C\+U\+L\+A\+T\+I\+O\+N\+S \#\#\#\#. 

