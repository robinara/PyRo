\hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend}{}\section{scipy.\+linalg.\+\_\+interpolative\+\_\+backend Namespace Reference}
\label{namespacescipy_1_1linalg_1_1__interpolative__backend}\index{scipy.\+linalg.\+\_\+interpolative\+\_\+backend@{scipy.\+linalg.\+\_\+interpolative\+\_\+backend}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_abdf4970dd776dde170dd23634a8a3bc1}{id\+\_\+srand}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a48392c83034ae715a0a682d66e1dac73}{id\+\_\+srandi}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ac99d114e4189b5aa3c8f5414792268b8}{id\+\_\+srando}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ae08e4887437e875c6428867e7f4de414}{idd\+\_\+frm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a7d0a382694d49adf39338c9e630651f0}{idd\+\_\+sfrm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_abca49ffbbae1baa2b1b850dd22ae47eb}{idd\+\_\+frmi}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a43d894046b8bbc02fb010721a5219eeb}{idd\+\_\+sfrmi}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a6955ec84fb3b1e6ff9a49df50c9c7d98}{iddp\+\_\+id}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a60dfbe8ca92a351adf393f357310f791}{iddr\+\_\+id}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a41f507e3e97bed7552bb6dea4a15506d}{idd\+\_\+reconid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ae6c304ab5823c072e2db53e951755e2e}{idd\+\_\+reconint}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a61213c255e403a143fe331d7e9eed166}{idd\+\_\+copycols}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a1fb21f295e4ce26f23461ae2a72a17f7}{idd\+\_\+id2svd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a8fac5ea301701c676ba57d400e5c7cd1}{idd\+\_\+snorm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a3ea828f8de938c5d69ad3b20b1a6bd3c}{idd\+\_\+diffsnorm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a67611059c81c4c2ab70bce88653938ef}{iddr\+\_\+svd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a40b0517a2bf9ed90d91d2f458f2de0a2}{iddp\+\_\+svd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a3b47b577719e12bd2509d2668d2462d7}{iddp\+\_\+aid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a893bbbf179dd8274882b13a86d2a7699}{idd\+\_\+estrank}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a7c5147f1d2945ff0ee9bfec51346f1e6}{iddp\+\_\+asvd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a77423f7f0f45af44bab1904faf34dd3b}{iddp\+\_\+rid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ab58dcc26fae67723492e64bcf1b31b8f}{idd\+\_\+findrank}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a1a06f15e3ec853078a5f3327bed48736}{iddp\+\_\+rsvd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a552191ae5b3129dd0fc14fe580557c7d}{iddr\+\_\+aid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a19019a7a844846dcf9ee63fcb9ecc947}{iddr\+\_\+aidi}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a0bd076c3ef03cc0c28c6b3426508e009}{iddr\+\_\+asvd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a4b5bab5444a55d571766e87a932323bc}{iddr\+\_\+rid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_aba830a96a00470b98f8bcf38be8ce245}{iddr\+\_\+rsvd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a56fc07a1f2a9cae415de27f553d820c5}{idz\+\_\+frm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_adf1cd826e8803684c11faf76e3cc7e9b}{idz\+\_\+sfrm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a058b3beb0f177777c522459f2e381212}{idz\+\_\+frmi}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a00e8e14641d8b0227709ad4d53baaf57}{idz\+\_\+sfrmi}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a372f28d27c3b6eaa5d3b83ab767f9fee}{idzp\+\_\+id}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ace5fa9e95f506cbabfa4b9d37a1459d1}{idzr\+\_\+id}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_add479a081a218c034929d886229a5210}{idz\+\_\+reconid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a1c9a9761e7f021cd5999a7d7722ca73e}{idz\+\_\+reconint}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ae1a6635270fe518308f9017f33a42da7}{idz\+\_\+copycols}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a975748e797644f8ecc7633f4b0284c58}{idz\+\_\+id2svd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a5df03a3e76b4a6324868c960069db548}{idz\+\_\+snorm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a332dc0bdafc459264d890b9921c1ece9}{idz\+\_\+diffsnorm}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_aacad763182b50bafccd8b19813af99b5}{idzr\+\_\+svd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ada491d9225bf786bf8d157dd511b60bf}{idzp\+\_\+svd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ab0438e58b9a19d09fea6ed427eda3178}{idzp\+\_\+aid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a954d53e7a2c8883f6ea52b55cda97caa}{idz\+\_\+estrank}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a7d26bb7f6e677ccae6e2dc4fc7669ce9}{idzp\+\_\+asvd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a385fe6daf2aa6476835d3f5c5cc5242a}{idzp\+\_\+rid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a15d42c836f4469489c49354b81f3caf8}{idz\+\_\+findrank}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a064d49757c29991183b84f9cfab9482b}{idzp\+\_\+rsvd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ab1edc81e778e224983a017a8df5c0847}{idzr\+\_\+aid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_ae13d358a6118326d06b4007d1ace71eb}{idzr\+\_\+aidi}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a74c3f66c2f52e00d9fdf07f62c77f994}{idzr\+\_\+asvd}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a389c640a37e9ea4fc8588bcf2b040acb}{idzr\+\_\+rid}
\item 
def \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a84dffe1a101e7683cc0f7f341b72d00c}{idzr\+\_\+rsvd}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
tuple \hyperlink{namespacescipy_1_1linalg_1_1__interpolative__backend_a6cc03696964433e44dc6bc073d197cff}{\+\_\+\+R\+E\+T\+C\+O\+D\+E\+\_\+\+E\+R\+R\+O\+R} = Runtime\+Error(\char`\"{}nonzero \hyperlink{stencilops_8h_afee67e5c8680c1bb9a8cb7bef7bfcc55}{return} code\char`\"{})
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_abdf4970dd776dde170dd23634a8a3bc1}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!id\+\_\+srand@{id\+\_\+srand}}
\index{id\+\_\+srand@{id\+\_\+srand}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{id\+\_\+srand}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+id\+\_\+srand (
\begin{DoxyParamCaption}
\item[{}]{n}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_abdf4970dd776dde170dd23634a8a3bc1}
\begin{DoxyVerb}Generate standard uniform pseudorandom numbers via a very efficient lagged
Fibonacci method.

:param n:
    Number of pseudorandom numbers to generate.
:type n: int

:return:
    Pseudorandom numbers.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a48392c83034ae715a0a682d66e1dac73}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!id\+\_\+srandi@{id\+\_\+srandi}}
\index{id\+\_\+srandi@{id\+\_\+srandi}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{id\+\_\+srandi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+id\+\_\+srandi (
\begin{DoxyParamCaption}
\item[{}]{t}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a48392c83034ae715a0a682d66e1dac73}
\begin{DoxyVerb}Initialize seed values for :func:`id_srand` (any appropriately random
numbers will do).

:param t:
    Array of 55 seed values.
:type t: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ac99d114e4189b5aa3c8f5414792268b8}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!id\+\_\+srando@{id\+\_\+srando}}
\index{id\+\_\+srando@{id\+\_\+srando}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{id\+\_\+srando}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+id\+\_\+srando (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ac99d114e4189b5aa3c8f5414792268b8}
\begin{DoxyVerb}Reset seed values to their original values.
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a61213c255e403a143fe331d7e9eed166}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+copycols@{idd\+\_\+copycols}}
\index{idd\+\_\+copycols@{idd\+\_\+copycols}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+copycols}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+copycols (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k, }
\item[{}]{idx}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a61213c255e403a143fe331d7e9eed166}
\begin{DoxyVerb}Reconstruct skeleton matrix from real ID.

:param A:
    Original matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`

:return:
    Skeleton matrix.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a3ea828f8de938c5d69ad3b20b1a6bd3c}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+diffsnorm@{idd\+\_\+diffsnorm}}
\index{idd\+\_\+diffsnorm@{idd\+\_\+diffsnorm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+diffsnorm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+diffsnorm (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matvect, }
\item[{}]{matvect2, }
\item[{}]{matvec, }
\item[{}]{matvec2, }
\item[{}]{its = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a3ea828f8de938c5d69ad3b20b1a6bd3c}
\begin{DoxyVerb}Estimate spectral norm of the difference of two real matrices by the
randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the transpose of the first matrix to a vector, with
    call signature `y = matvect(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matvect: function
:param matvect2:
    Function to apply the transpose of the second matrix to a vector, with
    call signature `y = matvect2(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matvect2: function
:param matvec:
    Function to apply the first matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param matvec2:
    Function to apply the second matrix to a vector, with call signature
    `y = matvec2(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec2: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate of matrix difference.
:rtype: float
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a893bbbf179dd8274882b13a86d2a7699}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+estrank@{idd\+\_\+estrank}}
\index{idd\+\_\+estrank@{idd\+\_\+estrank}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+estrank}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+estrank (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a893bbbf179dd8274882b13a86d2a7699}
\begin{DoxyVerb}Estimate rank of a real matrix to a specified relative precision using
random sampling.

The output rank is typically about 8 higher than the actual rank.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank estimate.
:rtype: int
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ab58dcc26fae67723492e64bcf1b31b8f}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+findrank@{idd\+\_\+findrank}}
\index{idd\+\_\+findrank@{idd\+\_\+findrank}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+findrank}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+findrank (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matvect}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ab58dcc26fae67723492e64bcf1b31b8f}
\begin{DoxyVerb}Estimate rank of a real matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function

:return:
    Rank estimate.
:rtype: int
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ae08e4887437e875c6428867e7f4de414}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+frm@{idd\+\_\+frm}}
\index{idd\+\_\+frm@{idd\+\_\+frm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+frm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+frm (
\begin{DoxyParamCaption}
\item[{}]{n, }
\item[{}]{w, }
\item[{}]{x}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ae08e4887437e875c6428867e7f4de414}
\begin{DoxyVerb}Transform real vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idd_sfrm`, this routine works best when the length of
the transformed vector is the power-of-two integer output by
:func:`idd_frmi`, or when the length is not specified but instead
determined a posteriori from the output. The returned transformed vector is
randomly permuted.

:param n:
    Greatest power-of-two integer satisfying `n <= x.size` as obtained from
    :func:`idd_frmi`; `n` is also the length of the output vector.
:type n: int
:param w:
    Initialization array constructed by :func:`idd_frmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_abca49ffbbae1baa2b1b850dd22ae47eb}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+frmi@{idd\+\_\+frmi}}
\index{idd\+\_\+frmi@{idd\+\_\+frmi}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+frmi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+frmi (
\begin{DoxyParamCaption}
\item[{}]{m}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_abca49ffbbae1baa2b1b850dd22ae47eb}
\begin{DoxyVerb}Initialize data for :func:`idd_frm`.

:param m:
    Length of vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n <= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idd_frm`.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a1fb21f295e4ce26f23461ae2a72a17f7}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+id2svd@{idd\+\_\+id2svd}}
\index{idd\+\_\+id2svd@{idd\+\_\+id2svd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+id2svd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+id2svd (
\begin{DoxyParamCaption}
\item[{}]{B, }
\item[{}]{idx, }
\item[{}]{proj}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a1fb21f295e4ce26f23461ae2a72a17f7}
\begin{DoxyVerb}Convert real ID to SVD.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a41f507e3e97bed7552bb6dea4a15506d}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+reconid@{idd\+\_\+reconid}}
\index{idd\+\_\+reconid@{idd\+\_\+reconid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+reconid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+reconid (
\begin{DoxyParamCaption}
\item[{}]{B, }
\item[{}]{idx, }
\item[{}]{proj}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a41f507e3e97bed7552bb6dea4a15506d}
\begin{DoxyVerb}Reconstruct matrix from real ID.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Reconstructed matrix.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ae6c304ab5823c072e2db53e951755e2e}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+reconint@{idd\+\_\+reconint}}
\index{idd\+\_\+reconint@{idd\+\_\+reconint}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+reconint}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+reconint (
\begin{DoxyParamCaption}
\item[{}]{idx, }
\item[{}]{proj}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ae6c304ab5823c072e2db53e951755e2e}
\begin{DoxyVerb}Reconstruct interpolation matrix from real ID.

:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Interpolation matrix.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a7d0a382694d49adf39338c9e630651f0}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+sfrm@{idd\+\_\+sfrm}}
\index{idd\+\_\+sfrm@{idd\+\_\+sfrm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+sfrm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+sfrm (
\begin{DoxyParamCaption}
\item[{}]{l, }
\item[{}]{n, }
\item[{}]{w, }
\item[{}]{x}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a7d0a382694d49adf39338c9e630651f0}
\begin{DoxyVerb}Transform real vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idd_frm`, this routine works best when the length of
the transformed vector is known a priori.

:param l:
    Length of transformed vector, satisfying `l <= n`.
:type l: int
:param n:
    Greatest power-of-two integer satisfying `n <= x.size` as obtained from
    :func:`idd_sfrmi`.
:type n: int
:param w:
    Initialization array constructed by :func:`idd_sfrmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a43d894046b8bbc02fb010721a5219eeb}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+sfrmi@{idd\+\_\+sfrmi}}
\index{idd\+\_\+sfrmi@{idd\+\_\+sfrmi}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+sfrmi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+sfrmi (
\begin{DoxyParamCaption}
\item[{}]{l, }
\item[{}]{m}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a43d894046b8bbc02fb010721a5219eeb}
\begin{DoxyVerb}Initialize data for :func:`idd_sfrm`.

:param l:
    Length of output transformed vector.
:type l: int
:param m:
    Length of the vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n <= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idd_sfrm`.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a8fac5ea301701c676ba57d400e5c7cd1}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idd\+\_\+snorm@{idd\+\_\+snorm}}
\index{idd\+\_\+snorm@{idd\+\_\+snorm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idd\+\_\+snorm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idd\+\_\+snorm (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matvect, }
\item[{}]{matvec, }
\item[{}]{its = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a8fac5ea301701c676ba57d400e5c7cd1}
\begin{DoxyVerb}Estimate spectral norm of a real matrix by the randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate.
:rtype: float
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a3b47b577719e12bd2509d2668d2462d7}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddp\+\_\+aid@{iddp\+\_\+aid}}
\index{iddp\+\_\+aid@{iddp\+\_\+aid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddp\+\_\+aid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddp\+\_\+aid (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a3b47b577719e12bd2509d2668d2462d7}
\begin{DoxyVerb}Compute ID of a real matrix to a specified relative precision using random
sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a7c5147f1d2945ff0ee9bfec51346f1e6}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddp\+\_\+asvd@{iddp\+\_\+asvd}}
\index{iddp\+\_\+asvd@{iddp\+\_\+asvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddp\+\_\+asvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddp\+\_\+asvd (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a7c5147f1d2945ff0ee9bfec51346f1e6}
\begin{DoxyVerb}Compute SVD of a real matrix to a specified relative precision using random
sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a6955ec84fb3b1e6ff9a49df50c9c7d98}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddp\+\_\+id@{iddp\+\_\+id}}
\index{iddp\+\_\+id@{iddp\+\_\+id}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddp\+\_\+id}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddp\+\_\+id (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a6955ec84fb3b1e6ff9a49df50c9c7d98}
\begin{DoxyVerb}Compute ID of a real matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a77423f7f0f45af44bab1904faf34dd3b}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddp\+\_\+rid@{iddp\+\_\+rid}}
\index{iddp\+\_\+rid@{iddp\+\_\+rid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddp\+\_\+rid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddp\+\_\+rid (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matvect}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a77423f7f0f45af44bab1904faf34dd3b}
\begin{DoxyVerb}Compute ID of a real matrix to a specified relative precision using random
matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a1a06f15e3ec853078a5f3327bed48736}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddp\+\_\+rsvd@{iddp\+\_\+rsvd}}
\index{iddp\+\_\+rsvd@{iddp\+\_\+rsvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddp\+\_\+rsvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddp\+\_\+rsvd (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matvect, }
\item[{}]{matvec}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a1a06f15e3ec853078a5f3327bed48736}
\begin{DoxyVerb}Compute SVD of a real matrix to a specified relative precision using random
matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a40b0517a2bf9ed90d91d2f458f2de0a2}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddp\+\_\+svd@{iddp\+\_\+svd}}
\index{iddp\+\_\+svd@{iddp\+\_\+svd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddp\+\_\+svd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddp\+\_\+svd (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a40b0517a2bf9ed90d91d2f458f2de0a2}
\begin{DoxyVerb}Compute SVD of a real matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a552191ae5b3129dd0fc14fe580557c7d}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddr\+\_\+aid@{iddr\+\_\+aid}}
\index{iddr\+\_\+aid@{iddr\+\_\+aid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddr\+\_\+aid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddr\+\_\+aid (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a552191ae5b3129dd0fc14fe580557c7d}
\begin{DoxyVerb}Compute ID of a real matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a19019a7a844846dcf9ee63fcb9ecc947}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddr\+\_\+aidi@{iddr\+\_\+aidi}}
\index{iddr\+\_\+aidi@{iddr\+\_\+aidi}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddr\+\_\+aidi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddr\+\_\+aidi (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a19019a7a844846dcf9ee63fcb9ecc947}
\begin{DoxyVerb}Initialize array for :func:`iddr_aid`.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param k:
    Rank of ID.
:type k: int

:return:
    Initialization array to be used by :func:`iddr_aid`.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a0bd076c3ef03cc0c28c6b3426508e009}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddr\+\_\+asvd@{iddr\+\_\+asvd}}
\index{iddr\+\_\+asvd@{iddr\+\_\+asvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddr\+\_\+asvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddr\+\_\+asvd (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a0bd076c3ef03cc0c28c6b3426508e009}
\begin{DoxyVerb}Compute SVD of a real matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a60dfbe8ca92a351adf393f357310f791}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddr\+\_\+id@{iddr\+\_\+id}}
\index{iddr\+\_\+id@{iddr\+\_\+id}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddr\+\_\+id}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddr\+\_\+id (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a60dfbe8ca92a351adf393f357310f791}
\begin{DoxyVerb}Compute ID of a real matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a4b5bab5444a55d571766e87a932323bc}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddr\+\_\+rid@{iddr\+\_\+rid}}
\index{iddr\+\_\+rid@{iddr\+\_\+rid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddr\+\_\+rid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddr\+\_\+rid (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matvect, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a4b5bab5444a55d571766e87a932323bc}
\begin{DoxyVerb}Compute ID of a real matrix to a specified rank using random matrix-vector
multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_aba830a96a00470b98f8bcf38be8ce245}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddr\+\_\+rsvd@{iddr\+\_\+rsvd}}
\index{iddr\+\_\+rsvd@{iddr\+\_\+rsvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddr\+\_\+rsvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddr\+\_\+rsvd (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matvect, }
\item[{}]{matvec, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_aba830a96a00470b98f8bcf38be8ce245}
\begin{DoxyVerb}Compute SVD of a real matrix to a specified rank using random matrix-vector
multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a67611059c81c4c2ab70bce88653938ef}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!iddr\+\_\+svd@{iddr\+\_\+svd}}
\index{iddr\+\_\+svd@{iddr\+\_\+svd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{iddr\+\_\+svd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+iddr\+\_\+svd (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a67611059c81c4c2ab70bce88653938ef}
\begin{DoxyVerb}Compute SVD of a real matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ae1a6635270fe518308f9017f33a42da7}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+copycols@{idz\+\_\+copycols}}
\index{idz\+\_\+copycols@{idz\+\_\+copycols}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+copycols}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+copycols (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k, }
\item[{}]{idx}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ae1a6635270fe518308f9017f33a42da7}
\begin{DoxyVerb}Reconstruct skeleton matrix from complex ID.

:param A:
    Original matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`

:return:
    Skeleton matrix.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a332dc0bdafc459264d890b9921c1ece9}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+diffsnorm@{idz\+\_\+diffsnorm}}
\index{idz\+\_\+diffsnorm@{idz\+\_\+diffsnorm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+diffsnorm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+diffsnorm (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matveca, }
\item[{}]{matveca2, }
\item[{}]{matvec, }
\item[{}]{matvec2, }
\item[{}]{its = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a332dc0bdafc459264d890b9921c1ece9}
\begin{DoxyVerb}Estimate spectral norm of the difference of two complex matrices by the
randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the adjoint of the first matrix to a vector, with
    call signature `y = matveca(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matveca: function
:param matveca2:
    Function to apply the adjoint of the second matrix to a vector, with
    call signature `y = matveca2(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matveca2: function
:param matvec:
    Function to apply the first matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param matvec2:
    Function to apply the second matrix to a vector, with call signature
    `y = matvec2(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec2: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate of matrix difference.
:rtype: float
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a954d53e7a2c8883f6ea52b55cda97caa}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+estrank@{idz\+\_\+estrank}}
\index{idz\+\_\+estrank@{idz\+\_\+estrank}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+estrank}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+estrank (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a954d53e7a2c8883f6ea52b55cda97caa}
\begin{DoxyVerb}Estimate rank of a complex matrix to a specified relative precision using
random sampling.

The output rank is typically about 8 higher than the actual rank.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank estimate.
:rtype: int
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a15d42c836f4469489c49354b81f3caf8}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+findrank@{idz\+\_\+findrank}}
\index{idz\+\_\+findrank@{idz\+\_\+findrank}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+findrank}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+findrank (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matveca}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a15d42c836f4469489c49354b81f3caf8}
\begin{DoxyVerb}Estimate rank of a complex matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function

:return:
    Rank estimate.
:rtype: int
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a56fc07a1f2a9cae415de27f553d820c5}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+frm@{idz\+\_\+frm}}
\index{idz\+\_\+frm@{idz\+\_\+frm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+frm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+frm (
\begin{DoxyParamCaption}
\item[{}]{n, }
\item[{}]{w, }
\item[{}]{x}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a56fc07a1f2a9cae415de27f553d820c5}
\begin{DoxyVerb}Transform complex vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idz_sfrm`, this routine works best when the length of
the transformed vector is the power-of-two integer output by
:func:`idz_frmi`, or when the length is not specified but instead
determined a posteriori from the output. The returned transformed vector is
randomly permuted.

:param n:
    Greatest power-of-two integer satisfying `n <= x.size` as obtained from
    :func:`idz_frmi`; `n` is also the length of the output vector.
:type n: int
:param w:
    Initialization array constructed by :func:`idz_frmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a058b3beb0f177777c522459f2e381212}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+frmi@{idz\+\_\+frmi}}
\index{idz\+\_\+frmi@{idz\+\_\+frmi}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+frmi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+frmi (
\begin{DoxyParamCaption}
\item[{}]{m}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a058b3beb0f177777c522459f2e381212}
\begin{DoxyVerb}Initialize data for :func:`idz_frm`.

:param m:
    Length of vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n <= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idz_frm`.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a975748e797644f8ecc7633f4b0284c58}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+id2svd@{idz\+\_\+id2svd}}
\index{idz\+\_\+id2svd@{idz\+\_\+id2svd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+id2svd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+id2svd (
\begin{DoxyParamCaption}
\item[{}]{B, }
\item[{}]{idx, }
\item[{}]{proj}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a975748e797644f8ecc7633f4b0284c58}
\begin{DoxyVerb}Convert complex ID to SVD.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_add479a081a218c034929d886229a5210}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+reconid@{idz\+\_\+reconid}}
\index{idz\+\_\+reconid@{idz\+\_\+reconid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+reconid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+reconid (
\begin{DoxyParamCaption}
\item[{}]{B, }
\item[{}]{idx, }
\item[{}]{proj}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_add479a081a218c034929d886229a5210}
\begin{DoxyVerb}Reconstruct matrix from complex ID.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Reconstructed matrix.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a1c9a9761e7f021cd5999a7d7722ca73e}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+reconint@{idz\+\_\+reconint}}
\index{idz\+\_\+reconint@{idz\+\_\+reconint}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+reconint}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+reconint (
\begin{DoxyParamCaption}
\item[{}]{idx, }
\item[{}]{proj}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a1c9a9761e7f021cd5999a7d7722ca73e}
\begin{DoxyVerb}Reconstruct interpolation matrix from complex ID.

:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Interpolation matrix.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_adf1cd826e8803684c11faf76e3cc7e9b}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+sfrm@{idz\+\_\+sfrm}}
\index{idz\+\_\+sfrm@{idz\+\_\+sfrm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+sfrm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+sfrm (
\begin{DoxyParamCaption}
\item[{}]{l, }
\item[{}]{n, }
\item[{}]{w, }
\item[{}]{x}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_adf1cd826e8803684c11faf76e3cc7e9b}
\begin{DoxyVerb}Transform complex vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idz_frm`, this routine works best when the length of
the transformed vector is known a priori.

:param l:
    Length of transformed vector, satisfying `l <= n`.
:type l: int
:param n:
    Greatest power-of-two integer satisfying `n <= x.size` as obtained from
    :func:`idz_sfrmi`.
:type n: int
:param w:
    Initialization array constructed by :func:`idd_sfrmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a00e8e14641d8b0227709ad4d53baaf57}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+sfrmi@{idz\+\_\+sfrmi}}
\index{idz\+\_\+sfrmi@{idz\+\_\+sfrmi}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+sfrmi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+sfrmi (
\begin{DoxyParamCaption}
\item[{}]{l, }
\item[{}]{m}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a00e8e14641d8b0227709ad4d53baaf57}
\begin{DoxyVerb}Initialize data for :func:`idz_sfrm`.

:param l:
    Length of output transformed vector.
:type l: int
:param m:
    Length of the vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n <= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idz_sfrm`.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a5df03a3e76b4a6324868c960069db548}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idz\+\_\+snorm@{idz\+\_\+snorm}}
\index{idz\+\_\+snorm@{idz\+\_\+snorm}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idz\+\_\+snorm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idz\+\_\+snorm (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matveca, }
\item[{}]{matvec, }
\item[{}]{its = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a5df03a3e76b4a6324868c960069db548}
\begin{DoxyVerb}Estimate spectral norm of a complex matrix by the randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate.
:rtype: float
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ab0438e58b9a19d09fea6ed427eda3178}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzp\+\_\+aid@{idzp\+\_\+aid}}
\index{idzp\+\_\+aid@{idzp\+\_\+aid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzp\+\_\+aid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzp\+\_\+aid (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ab0438e58b9a19d09fea6ed427eda3178}
\begin{DoxyVerb}Compute ID of a complex matrix to a specified relative precision using
random sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a7d26bb7f6e677ccae6e2dc4fc7669ce9}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzp\+\_\+asvd@{idzp\+\_\+asvd}}
\index{idzp\+\_\+asvd@{idzp\+\_\+asvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzp\+\_\+asvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzp\+\_\+asvd (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a7d26bb7f6e677ccae6e2dc4fc7669ce9}
\begin{DoxyVerb}Compute SVD of a complex matrix to a specified relative precision using
random sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a372f28d27c3b6eaa5d3b83ab767f9fee}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzp\+\_\+id@{idzp\+\_\+id}}
\index{idzp\+\_\+id@{idzp\+\_\+id}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzp\+\_\+id}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzp\+\_\+id (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a372f28d27c3b6eaa5d3b83ab767f9fee}
\begin{DoxyVerb}Compute ID of a complex matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a385fe6daf2aa6476835d3f5c5cc5242a}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzp\+\_\+rid@{idzp\+\_\+rid}}
\index{idzp\+\_\+rid@{idzp\+\_\+rid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzp\+\_\+rid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzp\+\_\+rid (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matveca}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a385fe6daf2aa6476835d3f5c5cc5242a}
\begin{DoxyVerb}Compute ID of a complex matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a064d49757c29991183b84f9cfab9482b}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzp\+\_\+rsvd@{idzp\+\_\+rsvd}}
\index{idzp\+\_\+rsvd@{idzp\+\_\+rsvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzp\+\_\+rsvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzp\+\_\+rsvd (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matveca, }
\item[{}]{matvec}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a064d49757c29991183b84f9cfab9482b}
\begin{DoxyVerb}Compute SVD of a complex matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ada491d9225bf786bf8d157dd511b60bf}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzp\+\_\+svd@{idzp\+\_\+svd}}
\index{idzp\+\_\+svd@{idzp\+\_\+svd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzp\+\_\+svd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzp\+\_\+svd (
\begin{DoxyParamCaption}
\item[{}]{eps, }
\item[{}]{A}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ada491d9225bf786bf8d157dd511b60bf}
\begin{DoxyVerb}Compute SVD of a complex matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ab1edc81e778e224983a017a8df5c0847}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzr\+\_\+aid@{idzr\+\_\+aid}}
\index{idzr\+\_\+aid@{idzr\+\_\+aid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzr\+\_\+aid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzr\+\_\+aid (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ab1edc81e778e224983a017a8df5c0847}
\begin{DoxyVerb}Compute ID of a complex matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ae13d358a6118326d06b4007d1ace71eb}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzr\+\_\+aidi@{idzr\+\_\+aidi}}
\index{idzr\+\_\+aidi@{idzr\+\_\+aidi}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzr\+\_\+aidi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzr\+\_\+aidi (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ae13d358a6118326d06b4007d1ace71eb}
\begin{DoxyVerb}Initialize array for :func:`idzr_aid`.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param k:
    Rank of ID.
:type k: int

:return:
    Initialization array to be used by :func:`idzr_aid`.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a74c3f66c2f52e00d9fdf07f62c77f994}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzr\+\_\+asvd@{idzr\+\_\+asvd}}
\index{idzr\+\_\+asvd@{idzr\+\_\+asvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzr\+\_\+asvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzr\+\_\+asvd (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a74c3f66c2f52e00d9fdf07f62c77f994}
\begin{DoxyVerb}Compute SVD of a complex matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_ace5fa9e95f506cbabfa4b9d37a1459d1}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzr\+\_\+id@{idzr\+\_\+id}}
\index{idzr\+\_\+id@{idzr\+\_\+id}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzr\+\_\+id}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzr\+\_\+id (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_ace5fa9e95f506cbabfa4b9d37a1459d1}
\begin{DoxyVerb}Compute ID of a complex matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a389c640a37e9ea4fc8588bcf2b040acb}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzr\+\_\+rid@{idzr\+\_\+rid}}
\index{idzr\+\_\+rid@{idzr\+\_\+rid}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzr\+\_\+rid}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzr\+\_\+rid (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matveca, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a389c640a37e9ea4fc8588bcf2b040acb}
\begin{DoxyVerb}Compute ID of a complex matrix to a specified rank using random
matrix-vector multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a84dffe1a101e7683cc0f7f341b72d00c}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzr\+\_\+rsvd@{idzr\+\_\+rsvd}}
\index{idzr\+\_\+rsvd@{idzr\+\_\+rsvd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzr\+\_\+rsvd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzr\+\_\+rsvd (
\begin{DoxyParamCaption}
\item[{}]{m, }
\item[{}]{n, }
\item[{}]{matveca, }
\item[{}]{matvec, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a84dffe1a101e7683cc0f7f341b72d00c}
\begin{DoxyVerb}Compute SVD of a complex matrix to a specified rank using random
matrix-vector multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_aacad763182b50bafccd8b19813af99b5}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!idzr\+\_\+svd@{idzr\+\_\+svd}}
\index{idzr\+\_\+svd@{idzr\+\_\+svd}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{idzr\+\_\+svd}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+idzr\+\_\+svd (
\begin{DoxyParamCaption}
\item[{}]{A, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_aacad763182b50bafccd8b19813af99b5}
\begin{DoxyVerb}Compute SVD of a complex matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
\end{DoxyVerb}
 

\subsection{Variable Documentation}
\hypertarget{namespacescipy_1_1linalg_1_1__interpolative__backend_a6cc03696964433e44dc6bc073d197cff}{}\index{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}!\+\_\+\+R\+E\+T\+C\+O\+D\+E\+\_\+\+E\+R\+R\+O\+R@{\+\_\+\+R\+E\+T\+C\+O\+D\+E\+\_\+\+E\+R\+R\+O\+R}}
\index{\+\_\+\+R\+E\+T\+C\+O\+D\+E\+\_\+\+E\+R\+R\+O\+R@{\+\_\+\+R\+E\+T\+C\+O\+D\+E\+\_\+\+E\+R\+R\+O\+R}!scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend@{scipy\+::linalg\+::\+\_\+interpolative\+\_\+backend}}
\subsubsection[{\+\_\+\+R\+E\+T\+C\+O\+D\+E\+\_\+\+E\+R\+R\+O\+R}]{\setlength{\rightskip}{0pt plus 5cm}tuple scipy.\+linalg.\+\_\+interpolative\+\_\+backend.\+\_\+\+R\+E\+T\+C\+O\+D\+E\+\_\+\+E\+R\+R\+O\+R = Runtime\+Error(\char`\"{}nonzero {\bf return} code\char`\"{})}\label{namespacescipy_1_1linalg_1_1__interpolative__backend_a6cc03696964433e44dc6bc073d197cff}
