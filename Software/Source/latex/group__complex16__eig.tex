\hypertarget{group__complex16__eig}{}\section{complex16}
\label{group__complex16__eig}\index{complex16@{complex16}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
subroutine \hyperlink{group__complex16__eig_ga4447fac086ee96b40677482c9e273ac8}{zbdt01} (M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, Q, L\+D\+Q, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, P\+T, L\+D\+P\+T, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+B\+D\+T01} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gae2e86e0081ec0a0bd76bad8463394dc5}{zbdt02} (M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, C, L\+D\+C, U, L\+D\+U, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+B\+D\+T02} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga9fb67a93383bedd0a2573cc1e4e38008}{zbdt03} (U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+D, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, S, V\+T, L\+D\+V\+T, W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+B\+D\+T03} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gae5f31f8b72cd1f618622fe93c6b9eac1}{zchkbb} (N\+S\+I\+Z\+E\+S, M\+V\+A\+L, N\+V\+A\+L, N\+W\+D\+T\+H\+S, K\+K, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, A\+B, L\+D\+A\+B, B\+D, B\+E, Q, L\+D\+Q, P, L\+D\+P, C, L\+D\+C, C\+C, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+B\+B} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gae8a8aba29ee582b9b36f60338693a761}{zchkbd} (N\+S\+I\+Z\+E\+S, M\+V\+A\+L, N\+V\+A\+L, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B\+D, B\+E, S1, S2, X, L\+D\+X, Y, Z, Q, L\+D\+Q, P\+T, L\+D\+P\+T, U, V\+T, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+B\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga2497b5e3c907b7b142fdc6a9f1fb6e84}{zchkbk} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+B\+K} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga7573daf15e153234596fdfebe48c9ca9}{zchkbl} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+B\+L} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gab88590f7d1eca9dc769c0be30a6d16c3}{zchkec} (\hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, T\+S\+T\+E\+R\+R, N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+E\+C} \end{DoxyCompactList}\item 
program \hyperlink{group__complex16__eig_gae499dac46ffdbb5251d1221610866e68}{zchkee}
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+E\+E} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga0b24cd17637a0c7c2689c338e3beb720}{zchkgg} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, T\+S\+T\+D\+I\+F, T\+H\+R\+S\+H\+N, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, H, T, S1, S2, P1, P2, U, L\+D\+U, V, Q, Z, A\+L\+P\+H\+A1, B\+E\+T\+A1, A\+L\+P\+H\+A3, B\+E\+T\+A3, E\+V\+E\+C\+T\+L, E\+V\+E\+C\+T\+R, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, L\+L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+G\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga0aa6f942e1e31569fa01d6b77572c3f6}{zchkgk} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+G\+K} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga2452dadb41e2405e8c575902c4b7a2a2}{zchkgl} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+G\+L} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gac3ea5af78cd94f1a41d4a27e56481087}{zchkhb} (N\+S\+I\+Z\+E\+S, N\+N, N\+W\+D\+T\+H\+S, K\+K, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, S\+D, S\+E, U, L\+D\+U, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+H\+B} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga427e9c206762384bc4e7b5bc787e6073}{zchkhs} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, T1, T2, U, L\+D\+U, Z, U\+Z, W1, W3, E\+V\+E\+C\+T\+L, E\+V\+E\+C\+T\+R, E\+V\+E\+C\+T\+Y, E\+V\+E\+C\+T\+X, U\+U, T\+A\+U, W\+O\+R\+K, N\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+W\+O\+R\+K, S\+E\+L\+E\+C\+T, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+H\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga23b67e5ea0fd86a8df3a60703acabef0}{zchkst} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, A\+P, S\+D, S\+E, D1, D2, D3, D4, D5, W\+A1, W\+A2, W\+A3, W\+R, U, L\+D\+U, V, V\+P, T\+A\+U, Z, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, L\+R\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+H\+K\+S\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga0e8297dde284d708a45b7934df36470e}{zckcsd} (N\+M, M\+V\+A\+L, P\+V\+A\+L, Q\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, M\+M\+A\+X, X, X\+F, U1, U2, V1\+T, V2\+T, T\+H\+E\+T\+A, I\+W\+O\+R\+K, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+K\+C\+S\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga93ce24d5c1333291a37deb1d10bae67b}{zckglm} (N\+N, N\+V\+A\+L, M\+V\+A\+L, P\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, B, B\+F, X, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+K\+G\+L\+M} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gac50da824da9466bc66bfe055ebd480ae}{zckgqr} (N\+M, M\+V\+A\+L, N\+P, P\+V\+A\+L, N\+N, N\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, A\+Q, A\+R, T\+A\+U\+A, B, B\+F, B\+Z, B\+T, B\+W\+K, T\+A\+U\+B, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+K\+G\+Q\+R} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga3a1762cecf9f9df47372de50edff2380}{zckgsv} (N\+M, M\+V\+A\+L, P\+V\+A\+L, N\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, B, B\+F, U, V, Q, A\+L\+P\+H\+A, B\+E\+T\+A, R, I\+W\+O\+R\+K, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+K\+G\+S\+V} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga5a3131eede15fe6df2ab00e42c3f2ff6}{zcklse} (N\+N, M\+V\+A\+L, P\+V\+A\+L, N\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, B, B\+F, X, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+K\+L\+S\+E} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaf744ea7ce60893481da2287736a5e860}{zcsdts} (M, P, Q, X, X\+F, L\+D\+X, U1, L\+D\+U1, U2, L\+D\+U2, V1\+T, L\+D\+V1\+T, V2\+T, L\+D\+V2\+T, T\+H\+E\+T\+A, I\+W\+O\+R\+K, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+C\+S\+D\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga81ce6378154b5d55bedfa1241bb928d1}{zdrges} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, S, T, Q, L\+D\+Q, Z, A\+L\+P\+H\+A, B\+E\+T\+A, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+G\+E\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gac25982b5c0c58a1f9f8025ab4ab33287}{zdrgev} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, S, T, Q, L\+D\+Q, Z, Q\+E, L\+D\+Q\+E, A\+L\+P\+H\+A, B\+E\+T\+A, A\+L\+P\+H\+A1, B\+E\+T\+A1, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+G\+E\+V} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaf81dc11e477868381fba4cb8f61904ab}{zdrgsx} (N\+S\+I\+Z\+E, N\+C\+M\+A\+X, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+N, N\+O\+U\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, A\+I, B\+I, Z, Q, A\+L\+P\+H\+A, B\+E\+T\+A, C, L\+D\+C, S, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+G\+S\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga15555ac728d52bb12042d5b57152ecff}{zdrgvx} (N\+S\+I\+Z\+E, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+N, N\+O\+U\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, A\+I, B\+I, A\+L\+P\+H\+A, B\+E\+T\+A, V\+L, V\+R, I\+L\+O, I\+H\+I, L\+S\+C\+A\+L\+E, R\+S\+C\+A\+L\+E, S, D\+T\+R\+U, D\+I\+F, D\+I\+F\+T\+R\+U, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+G\+V\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga2948dcf75ffb37ad4c8893b027ee4de1}{zdrvbd} (N\+S\+I\+Z\+E\+S, M\+M, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, U, L\+D\+U, V\+T, L\+D\+V\+T, A\+S\+A\+V, U\+S\+A\+V, V\+T\+S\+A\+V, S, S\+S\+A\+V, E, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+W\+O\+R\+K, N\+O\+U\+N\+I\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+B\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga46e5b4f2d2d900a8be48339a8fcbff42}{zdrves} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, H\+T, W, W\+T, V\+S, L\+D\+V\+S, R\+E\+S\+U\+L\+T, W\+O\+R\+K, N\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+E\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga09d05af8ce92a19304b6700e26d1548e}{zdrvev} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, W, W1, V\+L, L\+D\+V\+L, V\+R, L\+D\+V\+R, L\+R\+E, L\+D\+L\+R\+E, R\+E\+S\+U\+L\+T, W\+O\+R\+K, N\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+E\+V} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga8f328a5e733c25b59a64e5aceec5bf7f}{zdrvgg} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, T\+H\+R\+S\+H\+N, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, S, T, S2, T2, Q, L\+D\+Q, Z, A\+L\+P\+H\+A1, B\+E\+T\+A1, A\+L\+P\+H\+A2, B\+E\+T\+A2, V\+L, V\+R, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+G\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gadac8ad25581dfea4f0a2b147a7ce7da9}{zdrvsg} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, Z, L\+D\+Z, A\+B, B\+B, A\+P, B\+P, W\+O\+R\+K, N\+W\+O\+R\+K, R\+W\+O\+R\+K, L\+R\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+S\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaeb52cb23aa5a5fe5a884ba5413ea8d02}{zdrvst} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, D1, D2, D3, W\+A1, W\+A2, W\+A3, U, L\+D\+U, V, T\+A\+U, Z, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, L\+R\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+S\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaf5eb53e84bb7255969d88aba73a1dd82}{zdrvsx} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+U\+N\+I\+T, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, H\+T, W, W\+T, W\+T\+M\+P, V\+S, L\+D\+V\+S, V\+S1, R\+E\+S\+U\+L\+T, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+S\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gad219aa578f2f410c3431c8d3642c28cb}{zdrvvx} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+U\+N\+I\+T, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, W, W1, V\+L, L\+D\+V\+L, V\+R, L\+D\+V\+R, L\+R\+E, L\+D\+L\+R\+E, R\+C\+O\+N\+D\+V, R\+C\+N\+D\+V1, R\+C\+D\+V\+I\+N, R\+C\+O\+N\+D\+E, R\+C\+N\+D\+E1, R\+C\+D\+E\+I\+N, S\+C\+A\+L\+E, S\+C\+A\+L\+E1, R\+E\+S\+U\+L\+T, W\+O\+R\+K, N\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+D\+R\+V\+V\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga5d4eaa3add8cbf75ae58c21d83fa54a9}{zerrbd} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+E\+R\+R\+B\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga2ded12fae46c5460170f505ca65744a2}{zerrec} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+E\+R\+R\+E\+C} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga5e12931d109ad06c796b415722e71e52}{zerred} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+E\+R\+R\+E\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gabef96c9e9ff97dba730385e3b59a9b0f}{zerrgg} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+E\+R\+R\+G\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gac8d8895448cbc459ded47dd743f46699}{zerrhs} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+E\+R\+R\+H\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaa43562d1ca14d490f6fb6ee555df7438}{zerrst} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+E\+R\+R\+S\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga66d124fa093cbd4a9c70d869fae241fd}{zget02} (\hyperlink{superlu__enum__consts_8h_a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58}{T\+R\+A\+N\+S}, M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, X, L\+D\+X, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, R\+W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T02} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gac9dffccc2faf3942bfc7d9ae4c92be0e}{zget10} (M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T10} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga2613f5765953757de881b744e9b72725}{zget22} (T\+R\+A\+N\+S\+A, T\+R\+A\+N\+S\+E, T\+R\+A\+N\+S\+W, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, E, L\+D\+E, W, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T22} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gafff141ca176900b033d426a3442a5971}{zget23} (C\+O\+M\+P, I\+S\+R\+T, B\+A\+L\+A\+N\+C, J\+T\+Y\+P\+E, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, I\+S\+E\+E\+D, N\+O\+U\+N\+I\+T, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, W, W1, V\+L, L\+D\+V\+L, V\+R, L\+D\+V\+R, L\+R\+E, L\+D\+L\+R\+E, R\+C\+O\+N\+D\+V, R\+C\+N\+D\+V1, R\+C\+D\+V\+I\+N, R\+C\+O\+N\+D\+E, R\+C\+N\+D\+E1, R\+C\+D\+E\+I\+N, S\+C\+A\+L\+E, S\+C\+A\+L\+E1, R\+E\+S\+U\+L\+T, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T23} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga856fb6d577946eb001db09bd7a0bb2d3}{zget24} (C\+O\+M\+P, J\+T\+Y\+P\+E, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, I\+S\+E\+E\+D, N\+O\+U\+N\+I\+T, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, H\+T, W, W\+T, W\+T\+M\+P, V\+S, L\+D\+V\+S, V\+S1, R\+C\+D\+E\+I\+N, R\+C\+D\+V\+I\+N, N\+S\+L\+C\+T, I\+S\+L\+C\+T, I\+S\+R\+T, R\+E\+S\+U\+L\+T, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T24} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga06b79b13bd73f94f9dd9091c656edf38}{zget35} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T, N\+I\+N)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T35} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga278000fdcd9e195f025572375e81eb60}{zget36} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T, N\+I\+N)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T36} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaae18ead2df57b6911e5acdc209a39a76}{zget37} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T, N\+I\+N)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T37} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga7e72d2c592f4188ce6e1f4c065edd682}{zget38} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T, N\+I\+N)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T38} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga607a14c898294891e1205e5b20b011c8}{zget51} (I\+T\+Y\+P\+E, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, U, L\+D\+U, V, L\+D\+V, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T51} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga0e033c8f1d94f2f9dcf5742d6c93d85b}{zget52} (L\+E\+F\+T, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, E, L\+D\+E, A\+L\+P\+H\+A, B\+E\+T\+A, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T52} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga8cfa5d9479fe4546ef7d28e400003358}{zget54} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, S, L\+D\+S, T, L\+D\+T, U, L\+D\+U, V, L\+D\+V, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+E\+T54} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gab64718de54eca7f9e28308a0cdce411f}{zglmts} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, P, \hyperlink{classA}{A}, A\+F, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, B\+F, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, D\+F, X, U, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+L\+M\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga66843d0b4fb7bdf9641534ed86711b55}{zgqrts} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, P, \hyperlink{classA}{A}, A\+F, Q, R, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, T\+A\+U\+A, B, B\+F, Z, T, B\+W\+K, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, T\+A\+U\+B, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+Q\+R\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga52fe5c26c3ab6431adb83d9bba8b4eeb}{zgrqts} (M, P, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, A\+F, Q, R, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, T\+A\+U\+A, B, B\+F, Z, T, B\+W\+K, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, T\+A\+U\+B, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+R\+Q\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga13b64eda7bfa37b59a8daa81990c42c8}{zgsvts} (M, P, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, A\+F, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, B\+F, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, U, L\+D\+U, V, L\+D\+V, Q, L\+D\+Q, A\+L\+P\+H\+A, B\+E\+T\+A, R, L\+D\+R, I\+W\+O\+R\+K, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+G\+S\+V\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaa47ecbf426a7802083f1a164e1525005}{zhbt21} (U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+A, K\+S, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+H\+B\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gab79dcd8016959527ea3d7137912e932d}{zhet21} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+B\+A\+N\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, V, L\+D\+V, T\+A\+U, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+H\+E\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gaf5ac8f81c63bc01215d2523af67f0a9f}{zhet22} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, K\+B\+A\+N\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, V, L\+D\+V, T\+A\+U, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+H\+E\+T22} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gacb29438aa9a7dd450f3db905ef4a8daa}{zhpt21} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+B\+A\+N\+D, A\+P, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, V\+P, T\+A\+U, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+H\+P\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga0fb275b7e7ca95861483e96a8865baeb}{zhst01} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, I\+L\+O, I\+H\+I, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, L\+D\+H, Q, L\+D\+Q, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+H\+S\+T01} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga817c8e2419ed8d953bad714eb82d4c54}{zlarfy} (U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, V, I\+N\+C\+V, T\+A\+U, C, L\+D\+C, W\+O\+R\+K)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+L\+A\+R\+F\+Y} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gadf62e94d7d1eba45c66a510ca52f9802}{zlarhs} (P\+A\+T\+H, X\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{superlu__enum__consts_8h_a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58}{T\+R\+A\+N\+S}, M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+L, K\+U, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, X, L\+D\+X, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, I\+S\+E\+E\+D, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+L\+A\+R\+H\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga4f20b187dff04372757a4008eecbc21f}{zlatm4} (I\+T\+Y\+P\+E, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, N\+Z1, N\+Z2, R\+S\+I\+G\+N, A\+M\+A\+G\+N, \hyperlink{superlu__enum__consts_8h_af00a42ecad444bbda75cde1b64bd7e72a9b5c151728d8512307565994c89919d5}{R\+C\+O\+N\+D}, T\+R\+I\+A\+N\+G, I\+D\+I\+S\+T, I\+S\+E\+E\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A})
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+L\+A\+T\+M4} \end{DoxyCompactList}\item 
\hyperlink{tnc_8c_aa7b64cdf39500931f7b333343791a104}{logical} \hyperlink{afunc_8m_a7b5e596df91eadea6c537c0825e894a7}{function} \hyperlink{group__complex16__eig_ga070d0aa3531da9c4cf1187ddacfadc04}{zlctes} (Z, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D})
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+L\+C\+T\+E\+S} \end{DoxyCompactList}\item 
\hyperlink{tnc_8c_aa7b64cdf39500931f7b333343791a104}{logical} \hyperlink{afunc_8m_a7b5e596df91eadea6c537c0825e894a7}{function} \hyperlink{group__complex16__eig_gafb3b6ea91b75f8ed29914e8e7169adb3}{zlctsx} (A\+L\+P\+H\+A, B\+E\+T\+A)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+L\+C\+T\+S\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga67fc2605422315893d6fec201c155a59}{zlsets} (M, P, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, A\+F, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, B\+F, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, C, C\+F, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, D\+F, X, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+L\+S\+E\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga63eabd833fa379aa63dafb0a57392fe4}{zsbmv} (U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K, A\+L\+P\+H\+A, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, X, I\+N\+C\+X, B\+E\+T\+A, Y, I\+N\+C\+Y)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+S\+B\+M\+V} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga96a59c0d9bd47e0ed39035f813b7b684}{zsgt01} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, Z, L\+D\+Z, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+S\+G\+T01} \end{DoxyCompactList}\item 
\hyperlink{tnc_8c_aa7b64cdf39500931f7b333343791a104}{logical} \hyperlink{afunc_8m_a7b5e596df91eadea6c537c0825e894a7}{function} \hyperlink{group__complex16__eig_ga5f37daf9fec134eae34b3575fff5e7c6}{zslect} (Z)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+S\+L\+E\+C\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga648d5fcaa302d5769d588aaa6f736fe8}{zstt21} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+B\+A\+N\+D, A\+D, A\+E, S\+D, S\+E, U, L\+D\+U, W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+S\+T\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_ga06f5cd0527f88e4aed3bdbf084d050a9}{zstt22} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, K\+B\+A\+N\+D, A\+D, A\+E, S\+D, S\+E, U, L\+D\+U, W\+O\+R\+K, L\+D\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+S\+T\+T22} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gac8d92ee1ea8c00830b42ebf4017a2ae3}{zunt01} (R\+O\+W\+C\+O\+L, M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, U, L\+D\+U, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+U\+N\+T01} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__complex16__eig_gae5e4eed24a4a8519245d586b181df38f}{zunt03} (R\+C, M\+U, M\+V, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K, U, L\+D\+U, V, L\+D\+V, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries Z\+U\+N\+T03} \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This is the group of complex16 L\+A\+P\+A\+C\+K T\+E\+S\+T\+I\+N\+G E\+I\+G routines. 

\subsection{Function Documentation}
\hypertarget{group__complex16__eig_ga4447fac086ee96b40677482c9e273ac8}{}\index{complex16@{complex16}!zbdt01@{zbdt01}}
\index{zbdt01@{zbdt01}!complex16@{complex16}}
\subsubsection[{zbdt01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zbdt01 (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{integer}]{K\+D, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{E, }
\item[{{\bf complex}$\ast$16, dimension( ldpt, $\ast$ )}]{P\+T, }
\item[{integer}]{L\+D\+P\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga4447fac086ee96b40677482c9e273ac8}


{\bfseries Z\+B\+D\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZBDT01 reconstructs a general matrix A from its bidiagonal form
    A = Q * B * P'
 where Q (m by min(m,n)) and P' (min(m,n) by n) are unitary
 matrices and B is bidiagonal.

 The test ratio to test the reduction is
    RESID = norm( A - Q * B * PT ) / ( n * norm(A) * EPS )
 where PT = P' and EPS is the machine precision.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrices A and Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and P'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+D} & \begin{DoxyVerb}          KD is INTEGER
          If KD = 0, B is diagonal and the array E is not referenced.
          If KD = 1, the reduction was performed by xGEBRD; B is upper
          bidiagonal if M >= N, and lower bidiagonal if M < N.
          If KD = -1, the reduction was performed by xGBBRD; B is
          always upper bidiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The m by n matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDQ,N)
          The m by min(m,n) unitary matrix Q in the reduction
          A = Q * B * P'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is DOUBLE PRECISION array, dimension (min(M,N))
          The diagonal elements of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is DOUBLE PRECISION array, dimension (min(M,N)-1)
          The superdiagonal elements of the bidiagonal matrix B if
          m >= n, or the subdiagonal elements of B if m < n.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+T} & \begin{DoxyVerb}          PT is COMPLEX*16 array, dimension (LDPT,N)
          The min(m,n) by n unitary matrix P' in the reduction
          A = Q * B * P'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+P\+T} & \begin{DoxyVerb}          LDPT is INTEGER
          The leading dimension of the array PT.
          LDPT >= max(1,min(M,N)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (M+N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is DOUBLE PRECISION
          The test ratio:  norm(A - Q * B * P') / ( n * norm(A) * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gae2e86e0081ec0a0bd76bad8463394dc5}{}\index{complex16@{complex16}!zbdt02@{zbdt02}}
\index{zbdt02@{zbdt02}!complex16@{complex16}}
\subsubsection[{zbdt02}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zbdt02 (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gae2e86e0081ec0a0bd76bad8463394dc5}


{\bfseries Z\+B\+D\+T02} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZBDT02 tests the change of basis C = U' * B by computing the residual

    RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),

 where B and C are M by N matrices, U is an M by M orthogonal matrix,
 and EPS is the machine precision.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrices B and C and the order of
          the matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices B and C.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,N)
          The m by n matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em C} & \begin{DoxyVerb}          C is COMPLEX*16 array, dimension (LDC,N)
          The m by n matrix C, assumed to contain U' * B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of the array C.  LDC >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU,M)
          The m by m orthogonal matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U.  LDU >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is DOUBLE PRECISION
          RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga9fb67a93383bedd0a2573cc1e4e38008}{}\index{complex16@{complex16}!zbdt03@{zbdt03}}
\index{zbdt03@{zbdt03}!complex16@{complex16}}
\subsubsection[{zbdt03}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zbdt03 (
\begin{DoxyParamCaption}
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S, }
\item[{{\bf complex}$\ast$16, dimension( ldvt, $\ast$ )}]{V\+T, }
\item[{integer}]{L\+D\+V\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga9fb67a93383bedd0a2573cc1e4e38008}


{\bfseries Z\+B\+D\+T03} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZBDT03 reconstructs a bidiagonal matrix B from its SVD:
    S = U' * B * V
 where U and V are orthogonal matrices and S is diagonal.

 The test ratio to test the singular value decomposition is
    RESID = norm( B - U * S * VT ) / ( n * norm(B) * EPS )
 where VT = V' and EPS is the machine precision.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Specifies whether the matrix B is upper or lower bidiagonal.
          = 'U':  Upper bidiagonal
          = 'L':  Lower bidiagonal\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+D} & \begin{DoxyVerb}          KD is INTEGER
          The bandwidth of the bidiagonal matrix B.  If KD = 1, the
          matrix B is bidiagonal, and if KD = 0, B is diagonal and E is
          not referenced.  If KD is greater than 1, it is assumed to be
          1, and if KD is less than 0, it is assumed to be 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is DOUBLE PRECISION array, dimension (N)
          The n diagonal elements of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is DOUBLE PRECISION array, dimension (N-1)
          The (n-1) superdiagonal elements of the bidiagonal matrix B
          if UPLO = 'U', or the (n-1) subdiagonal elements of B if
          UPLO = 'L'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU,N)
          The n by n orthogonal matrix U in the reduction B = U'*A*P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U.  LDU >= max(1,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S} & \begin{DoxyVerb}          S is DOUBLE PRECISION array, dimension (N)
          The singular values from the SVD of B, sorted in decreasing
          order.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V\+T} & \begin{DoxyVerb}          VT is COMPLEX*16 array, dimension (LDVT,N)
          The n by n orthogonal matrix V' in the reduction
          B = U * S * V'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+T} & \begin{DoxyVerb}          LDVT is INTEGER
          The leading dimension of the array VT.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (2*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is DOUBLE PRECISION
          The test ratio:  norm(B - U * S * V') / ( n * norm(A) * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gae5f31f8b72cd1f618622fe93c6b9eac1}{}\index{complex16@{complex16}!zchkbb@{zchkbb}}
\index{zchkbb@{zchkbb}!complex16@{complex16}}
\subsubsection[{zchkbb}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkbb (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+W\+D\+T\+H\+S, }
\item[{integer, dimension( $\ast$ )}]{K\+K, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer}]{N\+R\+H\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldab, $\ast$ )}]{A\+B, }
\item[{integer}]{L\+D\+A\+B, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{B\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{B\+E, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{{\bf complex}$\ast$16, dimension( {\bf ldp}, $\ast$ )}]{P, }
\item[{integer}]{L\+D\+P, }
\item[{{\bf complex}$\ast$16, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{{\bf complex}$\ast$16, dimension( ldc, $\ast$ )}]{C\+C, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gae5f31f8b72cd1f618622fe93c6b9eac1}


{\bfseries Z\+C\+H\+K\+B\+B} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKBB tests the reduction of a general complex rectangular band
 matrix to real bidiagonal form.

 ZGBBRD factors a general band matrix A as  Q B P* , where * means
 conjugate transpose, B is upper bidiagonal, and Q and P are unitary;
 ZGBBRD can also overwrite a given matrix C with Q* C .

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix C are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x M
    P:          N x N
    B:          min(M,N) x min(M,N)
    C:          M x NRHS

 For each generated matrix, 4 tests are performed:

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 (4)   | Y - Q' C | / ( |Y| max(M,NRHS) ulp ), where Y = Q' C.

 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).
          If NSIZES is zero, ZCHKBB does nothing.  NSIZES must be at
          least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix column dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+D\+T\+H\+S} & \begin{DoxyVerb}          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          ZCHKBB does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+K} & \begin{DoxyVerb}          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZCHKBB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of columns in the "right-hand side" matrix C.
          If NRHS = 0, then the operations on the right-hand side will
          not be tested. NRHS must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZCHKBB to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is DOUBLE PRECISION array, dimension
                            (LDA, max(NN))
          Used to hold the matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+B} & \begin{DoxyVerb}          AB is DOUBLE PRECISION array, dimension (LDAB, max(NN))
          Used to hold A in band storage format.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A\+B} & \begin{DoxyVerb}          LDAB is INTEGER
          The leading dimension of AB.  It must be at least 2 (not 1!)
          and at least max( KK )+1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+D} & \begin{DoxyVerb}          BD is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the diagonal of the bidiagonal matrix computed
          by ZGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E} & \begin{DoxyVerb}          BE is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the off-diagonal of the bidiagonal matrix
          computed by ZGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDQ, max(NN))
          Used to hold the unitary matrix Q computed by ZGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P} & \begin{DoxyVerb}          P is COMPLEX*16 array, dimension (LDP, max(NN))
          Used to hold the unitary matrix P computed by ZGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+P} & \begin{DoxyVerb}          LDP is INTEGER
          The leading dimension of P.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C} & \begin{DoxyVerb}          C is COMPLEX*16 array, dimension (LDC, max(NN))
          Used to hold the matrix C updated by ZGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C\+C} & \begin{DoxyVerb}          CC is COMPLEX*16 array, dimension (LDC, max(NN))
          Used to hold a copy of the matrix C.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gae8a8aba29ee582b9b36f60338693a761}{}\index{complex16@{complex16}!zchkbd@{zchkbd}}
\index{zchkbd@{zchkbd}!complex16@{complex16}}
\subsubsection[{zchkbd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkbd (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer}]{N\+R\+H\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{B\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{B\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S2, }
\item[{{\bf complex}$\ast$16, dimension( ldx, $\ast$ )}]{X, }
\item[{integer}]{L\+D\+X, }
\item[{{\bf complex}$\ast$16, dimension( ldx, $\ast$ )}]{Y, }
\item[{{\bf complex}$\ast$16, dimension( ldx, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{{\bf complex}$\ast$16, dimension( ldpt, $\ast$ )}]{P\+T, }
\item[{integer}]{L\+D\+P\+T, }
\item[{{\bf complex}$\ast$16, dimension( ldpt, $\ast$ )}]{U, }
\item[{{\bf complex}$\ast$16, dimension( ldpt, $\ast$ )}]{V\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gae8a8aba29ee582b9b36f60338693a761}


{\bfseries Z\+C\+H\+K\+B\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKBD checks the singular value decomposition (SVD) routines.

 ZGEBRD reduces a complex general m by n matrix A to real upper or
 lower bidiagonal form by an orthogonal transformation: Q' * A * P = B
 (or A = Q * B * P').  The matrix B is upper bidiagonal if m >= n
 and lower bidiagonal if m < n.

 ZUNGBR generates the orthogonal matrices Q and P' from ZGEBRD.
 Note that Q and P are not necessarily square.

 ZBDSQR computes the singular value decomposition of the bidiagonal
 matrix B as B = U S V'.  It is called three times to compute
    1)  B = U S1 V', where S1 is the diagonal matrix of singular
        values and the columns of the matrices U and V are the left
        and right singular vectors, respectively, of B.
    2)  Same as 1), but the singular values are stored in S2 and the
        singular vectors are not computed.
    3)  A = (UQ) S (P'V'), the SVD of the original matrix A.
 In addition, ZBDSQR has an option to apply the left orthogonal matrix
 U to a matrix X, useful in least squares applications.

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix X are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x min(M,N) (but M x M if NRHS > 0)
    P:          min(M,N) x N
    B:          min(M,N) x min(M,N)
    U, V:       min(M,N) x min(M,N)
    S1, S2      diagonal, order min(M,N)
    X:          M x NRHS

 For each generated matrix, 14 tests are performed:

 Test ZGEBRD and ZUNGBR

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 Test ZBDSQR on bidiagonal matrix B

 (4)   | B - U S1 VT | / ( |B| min(M,N) ulp ), VT = V'

 (5)   | Y - U Z | / ( |Y| max(min(M,N),k) ulp ), where Y = Q' X
                                                  and   Z = U' Y.
 (6)   | I - U' U | / ( min(M,N) ulp )

 (7)   | I - VT VT' | / ( min(M,N) ulp )

 (8)   S1 contains min(M,N) nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (9)   0 if the true singular values of B are within THRESH of
       those in S1.  2*THRESH if they are not.  (Tested using
       DSVDCH)

 (10)  | S1 - S2 | / ( |S1| ulp ), where S2 is computed without
                                   computing U and V.

 Test ZBDSQR on matrix A

 (11)  | A - (QU) S (VT PT) | / ( |A| max(M,N) ulp )

 (12)  | X - (QU) Z | / ( |X| max(M,k) ulp )

 (13)  | I - (QU)'(QU) | / ( M ulp )

 (14)  | I - (VT PT) (PT'VT') | / ( N ulp )

 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )

 Special case:
 (16) A bidiagonal matrix with random entries chosen from a
      logarithmic distribution on [ulp^2,ulp^(-2)]  (I.e., each
      entry is  e^x, where x is chosen uniformly on
      [ 2 log(ulp), -2 log(ulp) ] .)  For *this* type:
      (a) ZGEBRD is not called to reduce it to bidiagonal form.
      (b) the bidiagonal is  min(M,N) x min(M,N); if M<N, the
          matrix will be lower bidiagonal, otherwise upper.
      (c) only tests 5--8 and 14 are performed.

 A subset of the full set of matrix types may be selected through
 the logical array DOTYPE.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZCHKBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of columns in the "right-hand side" matrices X, Y,
          and Z, used in testing ZBDSQR.  If NRHS = 0, then the
          operations on the right-hand side will not be tested.
          NRHS must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The values of ISEED are changed on exit, and can be
          used in the next call to ZCHKBD to continue the same random
          number sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.  Note that the
          expected value of the test ratios is O(1), so THRESH should
          be a reasonably small multiple of 1, e.g., 10 or 100.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,NMAX)
          where NMAX is the maximum value of N in NVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,MMAX),
          where MMAX is the maximum value of M in MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+D} & \begin{DoxyVerb}          BD is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E} & \begin{DoxyVerb}          BE is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S1} & \begin{DoxyVerb}          S1 is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S2} & \begin{DoxyVerb}          S2 is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension (LDX,NRHS)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the arrays X, Y, and Z.
          LDX >= max(1,MMAX).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Y} & \begin{DoxyVerb}          Y is COMPLEX*16 array, dimension (LDX,NRHS)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension (LDX,NRHS)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDQ,MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ >= max(1,MMAX).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P\+T} & \begin{DoxyVerb}          PT is COMPLEX*16 array, dimension (LDPT,NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+P\+T} & \begin{DoxyVerb}          LDPT is INTEGER
          The leading dimension of the arrays PT, U, and V.
          LDPT >= max(1, max(min(MVAL(j),NVAL(j)))).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+T} & \begin{DoxyVerb}          VT is COMPLEX*16 array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          3(M+N) and  M(M + max(M,N,k) + 1) + N*min(M,N)  for all
          pairs  (M,N)=(MM(j),NN(j))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension
                      (5*max(min(M,N)))\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some MM(j) < 0
           -3: Some NN(j) < 0
           -4: NTYPES < 0
           -6: NRHS  < 0
           -8: THRESH < 0
          -11: LDA < 1 or LDA < MMAX, where MMAX is max( MM(j) ).
          -17: LDB < 1 or LDB < MMAX.
          -21: LDQ < 1 or LDQ < MMAX.
          -23: LDP < 1 or LDP < MNMAX.
          -27: LWORK too small.
          If  ZLATMR, CLATMS, ZGEBRD, ZUNGBR, or ZBDSQR,
              returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NTEST           The number of tests performed, or which can
                     be performed so far, for the current matrix.
     MMAX            Largest value in NN.
     NMAX            Largest value in NN.
     MNMIN           min(MM(j), NN(j)) (the dimension of the bidiagonal
                     matrix.)
     MNMAX           The maximum value of MNMIN for j=1,...,NSIZES.
     NFAIL           The number of tests which have exceeded THRESH
     COND, IMODE     Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     RTOVFL, RTUNFL  Square roots of the previous 2 values.
     ULP, ULPINV     Finest relative precision and its inverse.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga2497b5e3c907b7b142fdc6a9f1fb6e84}{}\index{complex16@{complex16}!zchkbk@{zchkbk}}
\index{zchkbk@{zchkbk}!complex16@{complex16}}
\subsubsection[{zchkbk}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkbk (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga2497b5e3c907b7b142fdc6a9f1fb6e84}


{\bfseries Z\+C\+H\+K\+B\+K} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKBK tests ZGEBAK, a routine for backward transformation of
 the computed right or left eigenvectors if the orginal matrix
 was preprocessed by balance subroutine ZGEBAL.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga7573daf15e153234596fdfebe48c9ca9}{}\index{complex16@{complex16}!zchkbl@{zchkbl}}
\index{zchkbl@{zchkbl}!complex16@{complex16}}
\subsubsection[{zchkbl}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkbl (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga7573daf15e153234596fdfebe48c9ca9}


{\bfseries Z\+C\+H\+K\+B\+L} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKBL tests ZGEBAL, a routine for balancing a general complex
 matrix and isolating some of its eigenvalues.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gab88590f7d1eca9dc769c0be30a6d16c3}{}\index{complex16@{complex16}!zchkec@{zchkec}}
\index{zchkec@{zchkec}!complex16@{complex16}}
\subsubsection[{zchkec}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkec (
\begin{DoxyParamCaption}
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{{\bf logical}}]{T\+S\+T\+E\+R\+R, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gab88590f7d1eca9dc769c0be30a6d16c3}


{\bfseries Z\+C\+H\+K\+E\+C} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKEC tests eigen- condition estimation routines
        ZTRSYL, CTREXC, CTRSNA, CTRSEN

 In all cases, the routine runs through a fixed set of numerical
 examples, subjects them to various tests, and compares the test
 results to a threshold THRESH. In addition, ZTRSNA and CTRSEN are
 tested by reading in precomputed examples from a file (on input unit
 NIN).  Output is written to output unit NOUT.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          Threshold for residual tests.  A computed test ratio passes
          the threshold if it is less than THRESH.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+S\+T\+E\+R\+R} & \begin{DoxyVerb}          TSTERR is LOGICAL
          Flag that indicates whether error exits are to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
September 2012 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gae499dac46ffdbb5251d1221610866e68}{}\index{complex16@{complex16}!zchkee@{zchkee}}
\index{zchkee@{zchkee}!complex16@{complex16}}
\subsubsection[{zchkee}]{\setlength{\rightskip}{0pt plus 5cm}program zchkee (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gae499dac46ffdbb5251d1221610866e68}


{\bfseries Z\+C\+H\+K\+E\+E} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKEE tests the COMPLEX*16 LAPACK subroutines for the matrix
 eigenvalue problem.  The test paths in this version are

 NEP (Nonsymmetric Eigenvalue Problem):
     Test ZGEHRD, ZUNGHR, ZHSEQR, ZTREVC, ZHSEIN, and ZUNMHR

 SEP (Hermitian Eigenvalue Problem):
     Test ZHETRD, ZUNGTR, ZSTEQR, ZSTERF, ZSTEIN, ZSTEDC,
     and drivers ZHEEV(X), ZHBEV(X), ZHPEV(X),
                 ZHEEVD,   ZHBEVD,   ZHPEVD

 SVD (Singular Value Decomposition):
     Test ZGEBRD, ZUNGBR, and ZBDSQR
     and the drivers ZGESVD, ZGESDD

 ZEV (Nonsymmetric Eigenvalue/eigenvector Driver):
     Test ZGEEV

 ZES (Nonsymmetric Schur form Driver):
     Test ZGEES

 ZVX (Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test ZGEEVX

 ZSX (Nonsymmetric Schur form Expert Driver):
     Test ZGEESX

 ZGG (Generalized Nonsymmetric Eigenvalue Problem):
     Test ZGGHRD, ZGGBAL, ZGGBAK, ZHGEQZ, and ZTGEVC
     and the driver routines ZGEGS and ZGEGV

 ZGS (Generalized Nonsymmetric Schur form Driver):
     Test ZGGES

 ZGV (Generalized Nonsymmetric Eigenvalue/eigenvector Driver):
     Test ZGGEV

 ZGX (Generalized Nonsymmetric Schur form Expert Driver):
     Test ZGGESX

 ZXV (Generalized Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test ZGGEVX

 ZSG (Hermitian Generalized Eigenvalue Problem):
     Test ZHEGST, ZHEGV, ZHEGVD, ZHEGVX, ZHPGST, ZHPGV, ZHPGVD,
     ZHPGVX, ZHBGST, ZHBGV, ZHBGVD, and ZHBGVX

 ZHB (Hermitian Band Eigenvalue Problem):
     Test ZHBTRD

 ZBB (Band Singular Value Decomposition):
     Test ZGBBRD

 ZEC (Eigencondition estimation):
     Test ZTRSYL, ZTREXC, ZTRSNA, and ZTRSEN

 ZBL (Balancing a general matrix)
     Test ZGEBAL

 ZBK (Back transformation on a balanced matrix)
     Test ZGEBAK

 ZGL (Balancing a matrix pair)
     Test ZGGBAL

 ZGK (Back transformation on a matrix pair)
     Test ZGGBAK

 GLM (Generalized Linear Regression Model):
     Tests ZGGGLM

 GQR (Generalized QR and RQ factorizations):
     Tests ZGGQRF and ZGGRQF

 GSV (Generalized Singular Value Decomposition):
     Tests ZGGSVD, ZGGSVP, ZTGSJA, ZLAGS2, ZLAPLL, and ZLAPMT

 CSD (CS decomposition):
     Tests ZUNCSD

 LSE (Constrained Linear Least Squares):
     Tests ZGGLSE

 Each test path has a different set of inputs, but the data sets for
 the driver routines xEV, xES, xVX, and xSX can be concatenated in a
 single input file.  The first line of input should contain one of the
 3-character path names in columns 1-3.  The number of remaining lines
 depends on what is found on the first line.

 The number of matrix types used in testing is often controllable from
 the input file.  The number of matrix types for each path, and the
 test routine that describes them, is as follows:

 Path name(s)  Types    Test routine

 ZHS or NEP      21     ZCHKHS
 ZST or SEP      21     ZCHKST (routines)
                 18     ZDRVST (drivers)
 ZBD or SVD      16     ZCHKBD (routines)
                  5     ZDRVBD (drivers)
 ZEV             21     ZDRVEV
 ZES             21     ZDRVES
 ZVX             21     ZDRVVX
 ZSX             21     ZDRVSX
 ZGG             26     ZCHKGG (routines)
                 26     ZDRVGG (drivers)
 ZGS             26     ZDRGES
 ZGX              5     ZDRGSX
 ZGV             26     ZDRGEV
 ZXV              2     ZDRGVX
 ZSG             21     ZDRVSG
 ZHB             15     ZCHKHB
 ZBB             15     ZCHKBB
 ZEC              -     ZCHKEC
 ZBL              -     ZCHKBL
 ZBK              -     ZCHKBK
 ZGL              -     ZCHKGL
 ZGK              -     ZCHKGK
 GLM              8     ZCKGLM
 GQR              8     ZCKGQR
 GSV              8     ZCKGSV
 CSD              3     ZCKCSD
 LSE              8     ZCKLSE

-----------------------------------------------------------------------

 NEP input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NX, NS, and
          MAXB.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  INMIN, INTEGER array, dimension (NPARMS)
          LAHQR vs TTQRE crossover point, >= 11

 line 9:  INWIN, INTEGER array, dimension (NPARMS)
          recommended deflation window size

 line 10: INIBL, INTEGER array, dimension (NPARMS)
          nibble crossover point

 line 11:  ISHFTS, INTEGER array, dimension (NPARMS)
          number of simultaneous shifts)

 line 12:  IACC22, INTEGER array, dimension (NPARMS)
          select structured matrix multiply: 0, 1 or 2)

 line 13: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.  To have all of the test
          ratios printed, use THRESH = 0.0 .

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  The remaining lines occur in sets of 1 or 2 and allow
          the user to specify the matrix types.  Each line contains
          a 3-character path name in columns 1-3, and the number
          of matrix types must be the first nonblank item in columns
          4-80.  If the number of matrix types is at least 1 but is
          less than the maximum number of possible types, a second
          line will be read to get the numbers of the matrix types to
          be used.  For example,
 NEP 21
          requests all of the matrix types for the nonsymmetric
          eigenvalue problem, while
 NEP  4
 9 10 11 12
          requests only matrices of type 9, 10, 11, and 12.

          The valid 3-character path names are 'NEP' or 'ZHS' for the
          nonsymmetric eigenvalue routines.

-----------------------------------------------------------------------

 SEP or ZSG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, and NX.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 10: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 11: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 12: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 12 was 2:

 line 13: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 13-EOF:  Lines specifying matrix types, as for NEP.
          The valid 3-character path names are 'SEP' or 'ZST' for the
          Hermitian eigenvalue routines and driver routines, and
          'ZSG' for the routines for the Hermitian generalized
          eigenvalue problem.

-----------------------------------------------------------------------

 SVD input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 5:  NPARMS, INTEGER
          Number of values of the parameter NB, NBMIN, NX, and NRHS.

 line 6:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 7:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 8:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 9:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path names are 'SVD' or 'ZBD' for both the
          SVD routines and the SVD driver routines.

-----------------------------------------------------------------------

 ZEV and ZES data files:

 line 1:  'ZEV' or 'ZES' in columns 1 to 3.

 line 2:  NSIZES, INTEGER
          Number of sizes of matrices to use. Should be at least 0
          and at most 20. If NSIZES = 0, no testing is done
          (although the remaining  3 lines are still read).

 line 3:  NN, INTEGER array, dimension(NSIZES)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHSEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 8 and following:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'ZEV' to test CGEEV, or
          'ZES' to test CGEES.

-----------------------------------------------------------------------

 The ZVX data has two parts. The first part is identical to ZEV,
 and the second part consists of test matrices with precomputed
 solutions.

 line 1:  'ZVX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  NEWSD, INTEGER

 If line 6 was 2:

 line 7:  INTEGER array, dimension (4)

 lines 8 and following: The first line contains 'ZVX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 1+N+N**2 lines, where N is
          its dimension. The first line contains the dimension N and
          ISRT (two integers). ISRT indicates whether the last N lines
          are sorted by increasing real part of the eigenvalue
          (ISRT=0) or by increasing imaginary part (ISRT=1). The next
          N**2 lines contain the matrix rowwise, one entry per line.
          The last N lines correspond to each eigenvalue. Each of
          these last N lines contains 4 real values: the real part of
          the eigenvalues, the imaginary part of the eigenvalue, the
          reciprocal condition number of the eigenvalues, and the
          reciprocal condition number of the vector eigenvector. The
          end of data is indicated by dimension N=0. Even if no data
          is to be tested, there must be at least one line containing
          N=0.

-----------------------------------------------------------------------

 The ZSX data is like ZVX. The first part is identical to ZEV, and the
 second part consists of test matrices with precomputed solutions.

 line 1:  'ZSX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  NEWSD, INTEGER

 If line 6 was 2:

 line 7:  INTEGER array, dimension (4)

 lines 8 and following: The first line contains 'ZSX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 3+N**2 lines, where N is
          its dimension. The first line contains the dimension N, the
          dimension M of an invariant subspace, and ISRT. The second
          line contains M integers, identifying the eigenvalues in the
          invariant subspace (by their position in a list of
          eigenvalues ordered by increasing real part (if ISRT=0) or
          by increasing imaginary part (if ISRT=1)). The next N**2
          lines contain the matrix rowwise. The last line contains the
          reciprocal condition number for the average of the selected
          eigenvalues, and the reciprocal condition number for the
          corresponding right invariant subspace. The end of data in
          indicated by a line containing N=0, M=0, and ISRT = 0.  Even
          if no data is to be tested, there must be at least one line
          containing N=0, M=0 and ISRT=0.

-----------------------------------------------------------------------

 ZGG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NBCOL, NS, and
          MAXB.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for NBMIN, the minimum row dimension for blocks.

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of shifts.

 line 8:  MXBVAL, INTEGER array, dimension (NPARMS)
          The values for MAXB, used in determining minimum blocksize.

 line 9:  NBCOL, INTEGER array, dimension (NPARMS)
          The values for NBCOL, the minimum column dimension for
          blocks.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 16-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'ZGG' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 ZGS and ZGV input files:

 line 1:  'ZGS' or 'ZGV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension(NN)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 17 was 2:

 line 7:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 7-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'ZGS' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 ZGX input file:
 line 1:  'ZGX' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer).  The next line contains an integer k such
          that only the last k eigenvalues will be selected and appear
          in the leading diagonal blocks of $A$ and $B$. The next N*N
          lines contain the matrix A, one element per line. The next N*N
          lines contain the matrix B. The last line contains the
          reciprocal of the eigenvalue cluster condition number and the
          reciprocal of the deflating subspace (associated with the
          selected eigencluster) condition number.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 ZXV input files:
 line 1:  'ZXV' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer). The next N*N lines contain the matrix A, one
          element per line. The next N*N lines contain the matrix B.
          The next line contains the reciprocals of the eigenvalue
          condition numbers.  The last line contains the reciprocals of
          the eigenvector condition numbers.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 ZHB input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix dimension K.

 line 6:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 8-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'ZHB'.

-----------------------------------------------------------------------

 ZBB input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix bandwidth K.

 line 6:  NPARMS, INTEGER
          Number of values of the parameter NRHS

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 9 was 2:

 line 10: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 10-EOF:  Lines specifying matrix types, as for SVD.
          The 3-character path name is 'ZBB'.

-----------------------------------------------------------------------

 ZEC input file:

 line  2: THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 lines  3-EOF:

 Input for testing the eigencondition routines consists of a set of
 specially constructed test cases and their solutions.  The data
 format is not intended to be modified by the user.

-----------------------------------------------------------------------

 ZBL and ZBK input files:

 line 1:  'ZBL' in columns 1-3 to test CGEBAL, or 'ZBK' in
          columns 1-3 to test CGEBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 ZGL and ZGK input files:

 line 1:  'ZGL' in columns 1-3 to test ZGGBAL, or 'ZGK' in
          columns 1-3 to test ZGGBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 GLM data file:

 line 1:  'GLM' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension), note M <= N <= M+P.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GLM' for the generalized
          linear regression model routines.

-----------------------------------------------------------------------

 GQR data file:

 line 1:  'GQR' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GQR' for the generalized
          QR and RQ routines.

-----------------------------------------------------------------------

 GSV data file:

 line 1:  'GSV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 CSD data file:

 line 1:  'CSD' in columns 1 to 3.

 line 2:  NM, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NM)
          Values of M (row and column dimension of orthogonal matrix).

 line 4:  PVAL, INTEGER array, dimension(NM)
          Values of P (row dimension of top-left block).

 line 5:  NVAL, INTEGER array, dimension(NM)
          Values of N (column dimension of top-left block).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CSD' for the CSD routine.

-----------------------------------------------------------------------

 LSE data file:

 line 1:  'LSE' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N, note P <= N <= P+M.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 NMAX is currently set to 132 and must be at least 12 for some of the
 precomputed examples, and LWORK = NMAX*(5*NMAX+20) in the parameter
 statements below.  For SVD, we assume NRHS may be as big as N.  The
 parameter NEED is set to 14 to allow for 14 N-by-N matrices for ZGG.\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2013 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga0b24cd17637a0c7c2689c338e3beb720}{}\index{complex16@{complex16}!zchkgg@{zchkgg}}
\index{zchkgg@{zchkgg}!complex16@{complex16}}
\subsubsection[{zchkgg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkgg (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{{\bf logical}}]{T\+S\+T\+D\+I\+F, }
\item[{double {\bf precision}}]{T\+H\+R\+S\+H\+N, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{S1, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{S2, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{P1, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{P2, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{V, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{Q, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A3, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A3, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+L, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+R, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{L\+L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 15 )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga0b24cd17637a0c7c2689c338e3beb720}


{\bfseries Z\+C\+H\+K\+G\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKGG  checks the nonsymmetric generalized eigenvalue problem
 routines.
                                H          H        H
 ZGGHRD factors A and B as U H V  and U T V , where   means conjugate
 transpose, H is hessenberg, T is triangular and U and V are unitary.

                                 H          H
 ZHGEQZ factors H and T as  Q S Z  and Q P Z , where P and S are upper
 triangular and Q and Z are unitary.  It also computes the generalized
 eigenvalues (alpha(1),beta(1)),...,(alpha(n),beta(n)), where
 alpha(j)=S(j,j) and beta(j)=P(j,j) -- thus, w(j) = alpha(j)/beta(j)
 is a root of the generalized eigenvalue problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 ZTGEVC computes the matrix L of left eigenvectors and the matrix R
 of right eigenvectors for the matrix pair ( S, P ).  In the
 description below,  l and r are left and right eigenvectors
 corresponding to the generalized eigenvalues (alpha,beta).

 When ZCHKGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 13
 tests will be performed.  The first twelve "test ratios" should be
 small -- O(1).  They will be compared with the threshhold THRESH:

                  H
 (1)   | A - U H V  | / ( |A| n ulp )

                  H
 (2)   | B - U T V  | / ( |B| n ulp )

               H
 (3)   | I - UU  | / ( n ulp )

               H
 (4)   | I - VV  | / ( n ulp )

                  H
 (5)   | H - Q S Z  | / ( |H| n ulp )

                  H
 (6)   | T - Q P Z  | / ( |T| n ulp )

               H
 (7)   | I - QQ  | / ( n ulp )

               H
 (8)   | I - ZZ  | / ( n ulp )

 (9)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of
                           H
       | (beta A - alpha B) l | / ( ulp max( |beta A|, |alpha B| ) )

 (10)  max over all left eigenvalue/-vector pairs (beta/alpha,l') of
                           H
       | (beta H - alpha T) l' | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors l' are the result of passing Q to
       DTGEVC and back transforming (JOB='B').

 (11)  max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 (12)  max over all right eigenvalue/-vector pairs (beta/alpha,r') of

       | (beta H - alpha T) r' | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors r' are the result of passing Z to
       DTGEVC and back transforming (JOB='B').

 The last three test ratios will usually be small, but there is no
 mathematical requirement that they be so.  They are therefore
 compared with THRESH only if TSTDIF is .TRUE.

 (13)  | S(Q,Z computed) - S(Q,Z not computed) | / ( |S| ulp )

 (14)  | P(Q,Z computed) - P(Q,Z not computed) | / ( |P| ulp )

 (15)  max( |alpha(Q,Z computed) - alpha(Q,Z not computed)|/|S| ,
            |beta(Q,Z computed) - beta(Q,Z not computed)|/|P| ) / ulp

 In addition, the normalization of L and R are checked, and compared
 with the threshhold THRSHN.

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is P*D1, P is a random unitary diagonal
                       matrix (i.e., with random magnitude 1 entries
                       on the diagonal), and D1=diag( 0, 1,..., N-1 )
                       (i.e., a diagonal matrix with D1(1,1)=0,
                       D1(2,2)=1, ..., D1(N,N)=N-1.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1=P*diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2=Q*diag( 0, N-3, N-4,..., 1, 0, 0 ), and
                        P and Q are random unitary diagonal matrices.
           t   t
 (16) U ( J , J ) V     where U and V are random unitary matrices.

 (17) U ( T1, T2 ) V    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        P*( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        Q*( 0, N-3, N-4,..., 1, 0, 0 )

 (18) U ( T1, T2 ) V    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) U ( T1, T2 ) V    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) U ( big*T1, small*T2 ) V   diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) U ( small*T1, big*T2 ) V   diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) U ( small*T1, small*T2 ) V diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) U ( big*T1, big*T2 ) V     diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) U ( T1, T2 ) V     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZCHKGG does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZCHKGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZCHKGG to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+S\+T\+D\+I\+F} & \begin{DoxyVerb}          TSTDIF is LOGICAL
          Specifies whether test ratios 13-15 will be computed and
          compared with THRESH.
          = .FALSE.: Only test ratios 1-12 will be computed and tested.
                     Ratios 13-15 will be set to zero.
          = .TRUE.:  All the test ratios 1-15 will be computed and
                     tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+S\+H\+N} & \begin{DoxyVerb}          THRSHN is DOUBLE PRECISION
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, H, T, S1, P1, S2, and P2.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper Hessenberg matrix computed from A by ZGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by ZGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S1} & \begin{DoxyVerb}          S1 is COMPLEX*16 array, dimension (LDA, max(NN))
          The Schur (upper triangular) matrix computed from H by ZHGEQZ
          when Q and Z are also computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S2} & \begin{DoxyVerb}          S2 is COMPLEX*16 array, dimension (LDA, max(NN))
          The Schur (upper triangular) matrix computed from H by ZHGEQZ
          when Q and Z are not computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P1} & \begin{DoxyVerb}          P1 is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by ZHGEQZ
          when Q and Z are also computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P2} & \begin{DoxyVerb}          P2 is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by ZHGEQZ
          when Q and Z are not computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, max(NN))
          The (left) unitary matrix computed by ZGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U, V, Q, Z, EVECTL, and EVEZTR.  It
          must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension (LDU, max(NN))
          The (right) unitary matrix computed by ZGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDU, max(NN))
          The (left) unitary matrix computed by ZHGEQZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension (LDU, max(NN))
          The (left) unitary matrix computed by ZHGEQZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A1} & \begin{DoxyVerb}          ALPHA1 is COMPLEX*16 array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A1} & \begin{DoxyVerb}          BETA1 is COMPLEX*16 array, dimension (max(NN))
          The generalized eigenvalues of (A,B) computed by ZHGEQZ
          when Q, Z, and the full Schur matrices are computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A3} & \begin{DoxyVerb}          ALPHA3 is COMPLEX*16 array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A3} & \begin{DoxyVerb}          BETA3 is COMPLEX*16 array, dimension (max(NN))
          The generalized eigenvalues of (A,B) computed by ZHGEQZ
          when neither Q, Z, nor the Schur matrices are computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em E\+V\+E\+C\+T\+L} & \begin{DoxyVerb}          EVECTL is COMPLEX*16 array, dimension (LDU, max(NN))
          The (lower triangular) left eigenvector matrix for the
          matrices in S1 and P1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em E\+V\+E\+C\+T\+R} & \begin{DoxyVerb}          EVECTR is COMPLEX*16 array, dimension (LDU, max(NN))
          The (upper triangular) right eigenvector matrix for the
          matrices in S1 and P1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( 4*N, 2 * N**2, 1 ), for all N=NN(j).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (2*max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+L\+W\+O\+R\+K} & \begin{DoxyVerb}          LLWORK is LOGICAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit.
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga0aa6f942e1e31569fa01d6b77572c3f6}{}\index{complex16@{complex16}!zchkgk@{zchkgk}}
\index{zchkgk@{zchkgk}!complex16@{complex16}}
\subsubsection[{zchkgk}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkgk (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga0aa6f942e1e31569fa01d6b77572c3f6}


{\bfseries Z\+C\+H\+K\+G\+K} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKGK tests ZGGBAK, a routine for backward balancing  of
 a matrix pair (A, B).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga2452dadb41e2405e8c575902c4b7a2a2}{}\index{complex16@{complex16}!zchkgl@{zchkgl}}
\index{zchkgl@{zchkgl}!complex16@{complex16}}
\subsubsection[{zchkgl}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkgl (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga2452dadb41e2405e8c575902c4b7a2a2}


{\bfseries Z\+C\+H\+K\+G\+L} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKGL tests ZGGBAL, a routine for balancing a matrix pair (A, B).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gac3ea5af78cd94f1a41d4a27e56481087}{}\index{complex16@{complex16}!zchkhb@{zchkhb}}
\index{zchkhb@{zchkhb}!complex16@{complex16}}
\subsubsection[{zchkhb}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkhb (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+W\+D\+T\+H\+S, }
\item[{integer, dimension( $\ast$ )}]{K\+K, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gac3ea5af78cd94f1a41d4a27e56481087}


{\bfseries Z\+C\+H\+K\+H\+B} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKHB tests the reduction of a Hermitian band matrix to tridiagonal
 from, used with the Hermitian eigenvalue problem.

 ZHBTRD factors a Hermitian band matrix A as  U S U* , where * means
 conjugate transpose, S is symmetric tridiagonal, and U is unitary.
 ZHBTRD can use either just the lower or just the upper triangle
 of A; ZCHKHB checks both cases.

 When ZCHKHB is called, a number of matrix "sizes" ("n's"), a number
 of bandwidths ("k's"), and a number of matrix "types" are
 specified.  For each size ("n"), each bandwidth ("k") less than or
 equal to "n", and each type of matrix, one matrix will be generated
 and used to test the hermitian banded reduction routine.  For each
 matrix, a number of tests will be performed:

 (1)     | A - V S V* | / ( |A| n ulp )  computed by ZHBTRD with
                                         UPLO='U'

 (2)     | I - UU* | / ( n ulp )

 (3)     | A - V S V* | / ( |A| n ulp )  computed by ZHBTRD with
                                         UPLO='L'

 (4)     | I - UU* | / ( n ulp )

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U* D U, where U is unitary and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U* D U, where U is unitary and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U* D U, where U is unitary and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Hermitian matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZCHKHB does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+D\+T\+H\+S} & \begin{DoxyVerb}          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          ZCHKHB does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+K} & \begin{DoxyVerb}          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZCHKHB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZCHKHB to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension
                            (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 2 (not 1!)
          and at least max( KK )+1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+D} & \begin{DoxyVerb}          SD is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the diagonal of the tridiagonal matrix computed
          by ZHBTRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+E} & \begin{DoxyVerb}          SE is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the off-diagonal of the tridiagonal matrix
          computed by ZHBTRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, max(NN))
          Used to hold the unitary matrix computed by ZHBTRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga427e9c206762384bc4e7b5bc787e6073}{}\index{complex16@{complex16}!zchkhs@{zchkhs}}
\index{zchkhs@{zchkhs}!complex16@{complex16}}
\subsubsection[{zchkhs}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkhs (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{T1, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{T2, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U\+Z, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W3, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+L, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+R, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+Y, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+X, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{S\+E\+L\+E\+C\+T, }
\item[{double {\bf precision}, dimension( 14 )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga427e9c206762384bc4e7b5bc787e6073}


{\bfseries Z\+C\+H\+K\+H\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    ZCHKHS  checks the nonsymmetric eigenvalue problem routines.

            ZGEHRD factors A as  U H U' , where ' means conjugate
            transpose, H is hessenberg, and U is unitary.

            ZUNGHR generates the unitary matrix U.

            ZUNMHR multiplies a matrix by the unitary matrix U.

            ZHSEQR factors H as  Z T Z' , where Z is unitary and T
            is upper triangular.  It also computes the eigenvalues,
            w(1), ..., w(n); we define a diagonal matrix W whose
            (diagonal) entries are the eigenvalues.

            ZTREVC computes the left eigenvector matrix L and the
            right eigenvector matrix R for the matrix T.  The
            columns of L are the complex conjugates of the left
            eigenvectors of T.  The columns of R are the right
            eigenvectors of T.  L is lower triangular, and R is
            upper triangular.

            ZHSEIN computes the left eigenvector matrix Y and the
            right eigenvector matrix X for the matrix H.  The
            columns of Y are the complex conjugates of the left
            eigenvectors of H.  The columns of X are the right
            eigenvectors of H.  Y is lower triangular, and X is
            upper triangular.

    When ZCHKHS is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 14
    tests will be performed:

    (1)     | A - U H U**H | / ( |A| n ulp )

    (2)     | I - UU**H | / ( n ulp )

    (3)     | H - Z T Z**H | / ( |H| n ulp )

    (4)     | I - ZZ**H | / ( n ulp )

    (5)     | A - UZ H (UZ)**H | / ( |A| n ulp )

    (6)     | I - UZ (UZ)**H | / ( n ulp )

    (7)     | T(Z computed) - T(Z not computed) | / ( |T| ulp )

    (8)     | W(Z computed) - W(Z not computed) | / ( |W| ulp )

    (9)     | TR - RW | / ( |T| |R| ulp )

    (10)    | L**H T - W**H L | / ( |T| |L| ulp )

    (11)    | HX - XW | / ( |H| |X| ulp )

    (12)    | Y**H H - W**H Y | / ( |H| |Y| ulp )

    (13)    | AX - XW | / ( |A| |X| ulp )

    (14)    | Y**H A - W**H Y | / ( |A| |Y| ulp )

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by SQRT( overflow threshold )
    (8)  Same as (4), but multiplied by SQRT( underflow threshold )

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random complex
         angles on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is unitary and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP < |z| < 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from   ULP < |z| < 1   and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by SQRT( overflow threshold )
    (18) Same as (16), but multiplied by SQRT( underflow threshold )

    (19) Nonsymmetric matrix with random entries chosen from |z| < 1
    (20) Same as (19), but multiplied by SQRT( overflow threshold )
    (21) Same as (19), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 \begin{DoxyVerb}  NSIZES - INTEGER
           The number of sizes of matrices to use.  If it is zero,
           ZCHKHS does nothing.  It must be at least zero.
           Not modified.

  NN     - INTEGER array, dimension (NSIZES)
           An array containing the sizes to be used for the matrices.
           Zero values will be skipped.  The values must be at least
           zero.
           Not modified.

  NTYPES - INTEGER
           The number of elements in DOTYPE.   If it is zero, ZCHKHS
           does nothing.  It must be at least zero.  If it is MAXTYP+1
           and NSIZES is 1, then an additional type, MAXTYP+1 is
           defined, which is to use whatever matrix is in A.  This
           is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
           DOTYPE(MAXTYP+1) is .TRUE. .
           Not modified.

  DOTYPE - LOGICAL array, dimension (NTYPES)
           If DOTYPE(j) is .TRUE., then for each size in NN a
           matrix of that size and of type j will be generated.
           If NTYPES is smaller than the maximum number of types
           defined (PARAMETER MAXTYP), then types NTYPES+1 through
           MAXTYP will not be generated.  If NTYPES is larger
           than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
           will be ignored.
           Not modified.

  ISEED  - INTEGER array, dimension (4)
           On entry ISEED specifies the seed of the random number
           generator. The array elements should be between 0 and 4095;
           if not they will be reduced mod 4096.  Also, ISEED(4) must
           be odd.  The random number generator uses a linear
           congruential sequence limited to small integers, and so
           should produce machine independent random numbers. The
           values of ISEED are changed on exit, and can be used in the
           next call to ZCHKHS to continue the same random number
           sequence.
           Modified.

  THRESH - DOUBLE PRECISION
           A test will count as "failed" if the "error", computed as
           described above, exceeds THRESH.  Note that the error
           is scaled to be O(1), so THRESH should be a reasonably
           small multiple of 1, e.g., 10 or 100.  In particular,
           it should not depend on the precision (single vs. double)
           or the size of the matrix.  It must be at least zero.
           Not modified.

  NOUNIT - INTEGER
           The FORTRAN unit number for printing out error messages
           (e.g., if a routine returns IINFO not equal to 0.)
           Not modified.

  A      - COMPLEX*16 array, dimension (LDA,max(NN))
           Used to hold the matrix whose eigenvalues are to be
           computed.  On exit, A contains the last matrix actually
           used.
           Modified.

  LDA    - INTEGER
           The leading dimension of A, H, T1 and T2.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  H      - COMPLEX*16 array, dimension (LDA,max(NN))
           The upper hessenberg matrix computed by ZGEHRD.  On exit,
           H contains the Hessenberg form of the matrix in A.
           Modified.

  T1     - COMPLEX*16 array, dimension (LDA,max(NN))
           The Schur (="quasi-triangular") matrix computed by ZHSEQR
           if Z is computed.  On exit, T1 contains the Schur form of
           the matrix in A.
           Modified.

  T2     - COMPLEX*16 array, dimension (LDA,max(NN))
           The Schur matrix computed by ZHSEQR when Z is not computed.
           This should be identical to T1.
           Modified.

  LDU    - INTEGER
           The leading dimension of U, Z, UZ and UU.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  U      - COMPLEX*16 array, dimension (LDU,max(NN))
           The unitary matrix computed by ZGEHRD.
           Modified.

  Z      - COMPLEX*16 array, dimension (LDU,max(NN))
           The unitary matrix computed by ZHSEQR.
           Modified.

  UZ     - COMPLEX*16 array, dimension (LDU,max(NN))
           The product of U times Z.
           Modified.

  W1     - COMPLEX*16 array, dimension (max(NN))
           The eigenvalues of A, as computed by a full Schur
           decomposition H = Z T Z'.  On exit, W1 contains the
           eigenvalues of the matrix in A.
           Modified.

  W3     - COMPLEX*16 array, dimension (max(NN))
           The eigenvalues of A, as computed by a partial Schur
           decomposition (Z not computed, T only computed as much
           as is necessary for determining eigenvalues).  On exit,
           W3 contains the eigenvalues of the matrix in A, possibly
           perturbed by ZHSEIN.
           Modified.

  EVECTL - COMPLEX*16 array, dimension (LDU,max(NN))
           The conjugate transpose of the (upper triangular) left
           eigenvector matrix for the matrix in T1.
           Modified.

  EVEZTR - COMPLEX*16 array, dimension (LDU,max(NN))
           The (upper triangular) right eigenvector matrix for the
           matrix in T1.
           Modified.

  EVECTY - COMPLEX*16 array, dimension (LDU,max(NN))
           The conjugate transpose of the left eigenvector matrix
           for the matrix in H.
           Modified.

  EVECTX - COMPLEX*16 array, dimension (LDU,max(NN))
           The right eigenvector matrix for the matrix in H.
           Modified.

  UU     - COMPLEX*16 array, dimension (LDU,max(NN))
           Details of the unitary matrix computed by ZGEHRD.
           Modified.

  TAU    - COMPLEX*16 array, dimension (max(NN))
           Further details of the unitary matrix computed by ZGEHRD.
           Modified.

  WORK   - COMPLEX*16 array, dimension (NWORK)
           Workspace.
           Modified.

  NWORK  - INTEGER
           The number of entries in WORK.  NWORK >= 4*NN(j)*NN(j) + 2.

  RWORK  - DOUBLE PRECISION array, dimension (max(NN))
           Workspace.  Could be equivalenced to IWORK, but not SELECT.
           Modified.

  IWORK  - INTEGER array, dimension (max(NN))
           Workspace.
           Modified.

  SELECT - LOGICAL array, dimension (max(NN))
           Workspace.  Could be equivalenced to IWORK, but not RWORK.
           Modified.

  RESULT - DOUBLE PRECISION array, dimension (14)
           The values computed by the fourteen tests described above.
           The values are currently limited to 1/ulp, to avoid
           overflow.
           Modified.

  INFO   - INTEGER
           If 0, then everything ran OK.
            -1: NSIZES < 0
            -2: Some NN(j) < 0
            -3: NTYPES < 0
            -6: THRESH < 0
            -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
           -14: LDU < 1 or LDU < NMAX.
           -26: NWORK too small.
           If  ZLATMR, CLATMS, or CLATME returns an error code, the
               absolute value of it is returned.
           If 1, then ZHSEQR could not find all the shifts.
           If 2, then the EISPACK code (for small blocks) failed.
           If >2, then 30*N iterations were not enough to find an
               eigenvalue or to decompose the problem.
           Modified.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     MTEST           The number of tests defined: care must be taken
                     that (1) the size of RESULT, (2) the number of
                     tests actually performed, and (3) MTEST agree.
     NTEST           The number of tests performed on this matrix
                     so far.  This should be less than MTEST, and
                     equal to it by the last test.  It will be less
                     if any of the routines being tested indicates
                     that it could not compute the matrices that
                     would be tested.
     NMAX            Largest value in NN.
     NMATS           The number of matrices generated so far.
     NERRS           The number of tests which have exceeded THRESH
                     so far (computed by DLAFTS).
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTOVFL, RTUNFL,
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selects whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga23b67e5ea0fd86a8df3a60703acabef0}{}\index{complex16@{complex16}!zchkst@{zchkst}}
\index{zchkst@{zchkst}!complex16@{complex16}}
\subsubsection[{zchkst}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zchkst (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+P, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D2, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D3, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D4, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D5, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{W\+A1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{W\+A2, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{W\+A3, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{W\+R, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{V\+P, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{L\+R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga23b67e5ea0fd86a8df3a60703acabef0}


{\bfseries Z\+C\+H\+K\+S\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCHKST  checks the Hermitian eigenvalue problem routines.

    ZHETRD factors A as  U S U* , where * means conjugate transpose,
    S is real symmetric tridiagonal, and U is unitary.
    ZHETRD can use either just the lower or just the upper triangle
    of A; ZCHKST checks both cases.
    U is represented as a product of Householder
    transformations, whose vectors are stored in the first
    n-1 columns of V, and whose scale factors are in TAU.

    ZHPTRD does the same as ZHETRD, except that A and V are stored
    in "packed" format.

    ZUNGTR constructs the matrix U from the contents of V and TAU.

    ZUPGTR constructs the matrix U from the contents of VP and TAU.

    ZSTEQR factors S as  Z D1 Z* , where Z is the unitary
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal.  D2 is the matrix of
    eigenvalues computed when Z is not computed.

    DSTERF computes D3, the matrix of eigenvalues, by the
    PWK method, which does not yield eigenvectors.

    ZPTEQR factors S as  Z4 D4 Z4* , for a
    Hermitian positive definite tridiagonal matrix.
    D5 is the matrix of eigenvalues computed when Z is not
    computed.

    DSTEBZ computes selected eigenvalues.  WA1, WA2, and
    WA3 will denote eigenvalues computed to high
    absolute accuracy, with different range options.
    WR will denote eigenvalues computed to high relative
    accuracy.

    ZSTEIN computes Y, the eigenvectors of S, given the
    eigenvalues.

    ZSTEDC factors S as Z D1 Z* , where Z is the unitary
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option). It may also
    update an input unitary matrix, usually the output
    from ZHETRD/ZUNGTR or ZHPTRD/ZUPGTR ('V' option). It may
    also just compute eigenvalues ('N' option).

    ZSTEMR factors S as Z D1 Z* , where Z is the unitary
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option).  ZSTEMR
    uses the Relatively Robust Representation whenever possible.

 When ZCHKST is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the Hermitian eigenroutines.  For each matrix, a number
 of tests will be performed:

 (1)     | A - V S V* | / ( |A| n ulp ) ZHETRD( UPLO='U', ... )

 (2)     | I - UV* | / ( n ulp )        ZUNGTR( UPLO='U', ... )

 (3)     | A - V S V* | / ( |A| n ulp ) ZHETRD( UPLO='L', ... )

 (4)     | I - UV* | / ( n ulp )        ZUNGTR( UPLO='L', ... )

 (5-8)   Same as 1-4, but for ZHPTRD and ZUPGTR.

 (9)     | S - Z D Z* | / ( |S| n ulp ) ZSTEQR('V',...)

 (10)    | I - ZZ* | / ( n ulp )        ZSTEQR('V',...)

 (11)    | D1 - D2 | / ( |D1| ulp )        ZSTEQR('N',...)

 (12)    | D1 - D3 | / ( |D1| ulp )        DSTERF

 (13)    0 if the true eigenvalues (computed by sturm count)
         of S are within THRESH of
         those in D1.  2*THRESH if they are not.  (Tested using
         DSTECH)

 For S positive definite,

 (14)    | S - Z4 D4 Z4* | / ( |S| n ulp ) ZPTEQR('V',...)

 (15)    | I - Z4 Z4* | / ( n ulp )        ZPTEQR('V',...)

 (16)    | D4 - D5 | / ( 100 |D4| ulp )       ZPTEQR('N',...)

 When S is also diagonally dominant by the factor gamma < 1,

 (17)    max | D4(i) - WR(i) | / ( |D4(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              DSTEBZ( 'A', 'E', ...)

 (18)    | WA1 - D3 | / ( |D3| ulp )          DSTEBZ( 'A', 'E', ...)

 (19)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
                                              DSTEBZ( 'I', 'E', ...)

 (20)    | S - Y WA1 Y* | / ( |S| n ulp )  DSTEBZ, ZSTEIN

 (21)    | I - Y Y* | / ( n ulp )          DSTEBZ, ZSTEIN

 (22)    | S - Z D Z* | / ( |S| n ulp )    ZSTEDC('I')

 (23)    | I - ZZ* | / ( n ulp )           ZSTEDC('I')

 (24)    | S - Z D Z* | / ( |S| n ulp )    ZSTEDC('V')

 (25)    | I - ZZ* | / ( n ulp )           ZSTEDC('V')

 (26)    | D1 - D2 | / ( |D1| ulp )           ZSTEDC('V') and
                                              ZSTEDC('N')

 Test 27 is disabled at the moment because ZSTEMR does not
 guarantee high relatvie accuracy.

 (27)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              ZSTEMR('V', 'A')

 (28)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              ZSTEMR('V', 'I')

 Tests 29 through 34 are disable at present because ZSTEMR
 does not handle partial specturm requests.

 (29)    | S - Z D Z* | / ( |S| n ulp )    ZSTEMR('V', 'I')

 (30)    | I - ZZ* | / ( n ulp )           ZSTEMR('V', 'I')

 (31)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         ZSTEMR('N', 'I') vs. CSTEMR('V', 'I')

 (32)    | S - Z D Z* | / ( |S| n ulp )    ZSTEMR('V', 'V')

 (33)    | I - ZZ* | / ( n ulp )           ZSTEMR('V', 'V')

 (34)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         ZSTEMR('N', 'V') vs. CSTEMR('V', 'V')

 (35)    | S - Z D Z* | / ( |S| n ulp )    ZSTEMR('V', 'A')

 (36)    | I - ZZ* | / ( n ulp )           ZSTEMR('V', 'A')

 (37)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         ZSTEMR('N', 'A') vs. CSTEMR('V', 'A')

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U* D U, where U is unitary and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U* D U, where U is unitary and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U* D U, where U is unitary and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Hermitian matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )
 (16) Same as (8), but diagonal elements are all positive.
 (17) Same as (9), but diagonal elements are all positive.
 (18) Same as (10), but diagonal elements are all positive.
 (19) Same as (16), but multiplied by SQRT( overflow threshold )
 (20) Same as (16), but multiplied by SQRT( underflow threshold )
 (21) A diagonally dominant tridiagonal matrix with geometrically
      spaced diagonal entries 1, ..., ULP.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZCHKST does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZCHKST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZCHKST to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array of
                                  dimension ( LDA , max(NN) )
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+P} & \begin{DoxyVerb}          AP is COMPLEX*16 array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix A stored in packed format.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+D} & \begin{DoxyVerb}          SD is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The diagonal of the tridiagonal matrix computed by ZHETRD.
          On exit, SD and SE contain the tridiagonal form of the
          matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+E} & \begin{DoxyVerb}          SE is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The off-diagonal of the tridiagonal matrix computed by
          ZHETRD.  On exit, SD and SE contain the tridiagonal form of
          the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D1} & \begin{DoxyVerb}          D1 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by ZSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D2} & \begin{DoxyVerb}          D2 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by ZSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D3} & \begin{DoxyVerb}          D3 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by DSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D4} & \begin{DoxyVerb}          D4 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by ZPTEQR(V).
          ZPTEQR factors S as  Z4 D4 Z4*
          On exit, the eigenvalues in D4 correspond with the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D5} & \begin{DoxyVerb}          D5 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by ZPTEQR(N)
          when Z is not computed. On exit, the
          eigenvalues in D4 correspond with the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+A1} & \begin{DoxyVerb}          WA1 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by DSTEBZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+A2} & \begin{DoxyVerb}          WA2 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by DSTEBZ.
          Choose random values for IL and IU, and ask for the
          IL-th through IU-th eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+A3} & \begin{DoxyVerb}          WA3 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by DSTEBZ.
          Determine the values VL and VU of the IL-th and IU-th
          eigenvalues and ask for all eigenvalues in this range.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is DOUBLE PRECISION array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different options.
          as computed by DSTEBZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array of
                             dimension( LDU, max(NN) ).
          The unitary matrix computed by ZHETRD + ZUNGTR.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U, Z, and V.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array of
                             dimension( LDU, max(NN) ).
          The Housholder vectors computed by ZHETRD in reducing A to
          tridiagonal form.  The vectors computed with UPLO='U' are
          in the upper triangle, and the vectors computed with UPLO='L'
          are in the lower triangle.  (As described in ZHETRD, the
          sub- and superdiagonal are not set to 1, although the
          true Householder vector has a 1 in that position.  The
          routines that use V, such as ZUNGTR, set those entries to
          1 before using them, and then restore them later.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+P} & \begin{DoxyVerb}          VP is COMPLEX*16 array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix V stored in packed format.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is COMPLEX*16 array of
                             dimension( max(NN) )
          The Householder factors computed by ZHETRD in reducing A
          to tridiagonal form.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array of
                             dimension( LDU, max(NN) ).
          The unitary matrix of eigenvectors computed by ZSTEQR,
          ZPTEQR, and ZSTEIN.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array of
                      dimension( LWORK )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          1 + 4 * Nmax + 2 * Nmax * lg Nmax + 3 * Nmax**2
          where Nmax = max( NN(j), 2 ) and lg = log base 2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array,
          Workspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+I\+W\+O\+R\+K} & \begin{DoxyVerb}          LIWORK is INTEGER
          The number of entries in IWORK.  This must be at least
                  6 + 6*Nmax + 5 * Nmax * lg Nmax 
          where Nmax = max( NN(j), 2 ) and lg = log base 2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+R\+W\+O\+R\+K} & \begin{DoxyVerb}          LRWORK is INTEGER
          The number of entries in LRWORK (dimension( ??? )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (26)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -5: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -23: LDU < 1 or LDU < NMAX.
          -29: LWORK too small.
          If  ZLATMR, CLATMS, ZHETRD, ZUNGTR, ZSTEQR, DSTERF,
              or ZUNMC2 returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NBLOCK          Blocksize as returned by ENVIR.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga0e8297dde284d708a45b7934df36470e}{}\index{complex16@{complex16}!zckcsd@{zckcsd}}
\index{zckcsd@{zckcsd}!complex16@{complex16}}
\subsubsection[{zckcsd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zckcsd (
\begin{DoxyParamCaption}
\item[{integer}]{N\+M, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{Q\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{M\+M\+A\+X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{X\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{U1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{U2, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{V1\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{V2\+T, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{T\+H\+E\+T\+A, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga0e8297dde284d708a45b7934df36470e}


{\bfseries Z\+C\+K\+C\+S\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCKCSD tests ZUNCSD:
        the CSD for an M-by-M unitary matrix X partitioned as
        [ X11 X12; X21 X22 ]. X11 is P-by-Q.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+M} & \begin{DoxyVerb}          NM is INTEGER
          The number of values of M contained in the vector MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q\+V\+A\+L} & \begin{DoxyVerb}          QVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+M\+A\+X} & \begin{DoxyVerb}          MMAX is INTEGER
          The maximum value permitted for M, used in dimensioning the
          work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X\+F} & \begin{DoxyVerb}          XF is COMPLEX*16 array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U1} & \begin{DoxyVerb}          U1 is COMPLEX*16 array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U2} & \begin{DoxyVerb}          U2 is COMPLEX*16 array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V1\+T} & \begin{DoxyVerb}          V1T is COMPLEX*16 array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V2\+T} & \begin{DoxyVerb}          V2T is COMPLEX*16 array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+H\+E\+T\+A} & \begin{DoxyVerb}          THETA is DOUBLE PRECISION array, dimension (MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If ZLAROR returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga93ce24d5c1333291a37deb1d10bae67b}{}\index{complex16@{complex16}!zckglm@{zckglm}}
\index{zckglm@{zckglm}!complex16@{complex16}}
\subsubsection[{zckglm}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zckglm (
\begin{DoxyParamCaption}
\item[{integer}]{N\+N, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga93ce24d5c1333291a37deb1d10bae67b}


{\bfseries Z\+C\+K\+G\+L\+M} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCKGLM tests ZGGGLM - subroutine for solving generalized linear
                       model problem.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER
          The number of values of N, M and P contained in the vectors
          NVAL, MVAL and PVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix row dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESID >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension (4*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If ZLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gac50da824da9466bc66bfe055ebd480ae}{}\index{complex16@{complex16}!zckgqr@{zckgqr}}
\index{zckgqr@{zckgqr}!complex16@{complex16}}
\subsubsection[{zckgqr}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zckgqr (
\begin{DoxyParamCaption}
\item[{integer}]{N\+M, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer}]{N\+P, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer}]{N\+N, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+Q, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+R, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+Z, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+W\+K, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U\+B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gac50da824da9466bc66bfe055ebd480ae}


{\bfseries Z\+C\+K\+G\+Q\+R} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCKGQR tests
 ZGGQRF: GQR factorization for N-by-M matrix A and N-by-P matrix B,
 ZGGRQF: GRQ factorization for M-by-N matrix A and P-by-N matrix B.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+M} & \begin{DoxyVerb}          NM is INTEGER
          The number of values of M contained in the vector MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row(column) dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+P} & \begin{DoxyVerb}          NP is INTEGER
          The number of values of P contained in the vector PVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row(column) dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER
          The number of values of N contained in the vector NVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+Q} & \begin{DoxyVerb}          AQ is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+R} & \begin{DoxyVerb}          AR is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+A} & \begin{DoxyVerb}          TAUA is COMPLEX*16 array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+Z} & \begin{DoxyVerb}          BZ is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+T} & \begin{DoxyVerb}          BT is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+K} & \begin{DoxyVerb}          BWK is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+B} & \begin{DoxyVerb}          TAUB is COMPLEX*16 array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If ZLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga3a1762cecf9f9df47372de50edff2380}{}\index{complex16@{complex16}!zckgsv@{zckgsv}}
\index{zckgsv@{zckgsv}!complex16@{complex16}}
\subsubsection[{zckgsv}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zckgsv (
\begin{DoxyParamCaption}
\item[{integer}]{N\+M, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{Q, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{R, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga3a1762cecf9f9df47372de50edff2380}


{\bfseries Z\+C\+K\+G\+S\+V} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCKGSV tests ZGGSVD:
        the GSVD for M-by-N matrix A and P-by-N matrix B.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+M} & \begin{DoxyVerb}          NM is INTEGER
          The number of values of M contained in the vector MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is DOUBLE PRECISION array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is DOUBLE PRECISION array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If ZLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga5a3131eede15fe6df2ab00e42c3f2ff6}{}\index{complex16@{complex16}!zcklse@{zcklse}}
\index{zcklse@{zcklse}!complex16@{complex16}}
\subsubsection[{zcklse}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zcklse (
\begin{DoxyParamCaption}
\item[{integer}]{N\+N, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga5a3131eede15fe6df2ab00e42c3f2ff6}


{\bfseries Z\+C\+K\+L\+S\+E} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCKLSE tests ZGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER
          The number of values of (M,P,N) contained in the vectors
          (MVAL, PVAL, NVAL).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension (5*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If ZLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaf744ea7ce60893481da2287736a5e860}{}\index{complex16@{complex16}!zcsdts@{zcsdts}}
\index{zcsdts@{zcsdts}!complex16@{complex16}}
\subsubsection[{zcsdts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zcsdts (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{Q, }
\item[{{\bf complex}$\ast$16, dimension( ldx, $\ast$ )}]{X, }
\item[{{\bf complex}$\ast$16, dimension( ldx, $\ast$ )}]{X\+F, }
\item[{integer}]{L\+D\+X, }
\item[{{\bf complex}$\ast$16, dimension( ldu1, $\ast$ )}]{U1, }
\item[{integer}]{L\+D\+U1, }
\item[{{\bf complex}$\ast$16, dimension( ldu2, $\ast$ )}]{U2, }
\item[{integer}]{L\+D\+U2, }
\item[{{\bf complex}$\ast$16, dimension( ldv1t, $\ast$ )}]{V1\+T, }
\item[{integer}]{L\+D\+V1\+T, }
\item[{{\bf complex}$\ast$16, dimension( ldv2t, $\ast$ )}]{V2\+T, }
\item[{integer}]{L\+D\+V2\+T, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{T\+H\+E\+T\+A, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf complex}$\ast$16, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 15 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaf744ea7ce60893481da2287736a5e860}


{\bfseries Z\+C\+S\+D\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZCSDTS tests ZUNCSD, which, given an M-by-M partitioned unitary
 matrix X,
              Q  M-Q
       X = [ X11 X12 ] P   ,
           [ X21 X22 ] M-P

 computes the CSD

       [ U1    ]**T * [ X11 X12 ] * [ V1    ]
       [    U2 ]      [ X21 X22 ]   [    V2 ]

                             [  I  0  0 |  0  0  0 ]
                             [  0  C  0 |  0 -S  0 ]
                             [  0  0  0 |  0  0 -I ]
                           = [---------------------] = [ D11 D12 ] .
                             [  0  0  0 |  I  0  0 ]   [ D21 D22 ]
                             [  0  S  0 |  0  C  0 ]
                             [  0  0  I |  0  0  0 ]

 and also SORCSD2BY1, which, given
          Q
       [ X11 ] P   ,
       [ X21 ] M-P

 computes the 2-by-1 CSD

                                     [  I  0  0 ]
                                     [  0  C  0 ]
                                     [  0  0  0 ]
       [ U1    ]**T * [ X11 ] * V1 = [----------] = [ D11 ] ,
       [    U2 ]      [ X21 ]        [  0  0  0 ]   [ D21 ]
                                     [  0  S  0 ]
                                     [  0  0  I ]\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix X.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix X11.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q} & \begin{DoxyVerb}          Q is INTEGER
          The number of columns of the matrix X11.  Q >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension (LDX,M)
          The M-by-M matrix X.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X\+F} & \begin{DoxyVerb}          XF is COMPLEX*16 array, dimension (LDX,M)
          Details of the CSD of X, as returned by ZUNCSD;
          see ZUNCSD for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the arrays X and XF.
          LDX >= max( 1,M ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U1} & \begin{DoxyVerb}          U1 is COMPLEX*16 array, dimension(LDU1,P)
          The P-by-P unitary matrix U1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U1} & \begin{DoxyVerb}          LDU1 is INTEGER
          The leading dimension of the array U1. LDU >= max(1,P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U2} & \begin{DoxyVerb}          U2 is COMPLEX*16 array, dimension(LDU2,M-P)
          The (M-P)-by-(M-P) unitary matrix U2.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U2} & \begin{DoxyVerb}          LDU2 is INTEGER
          The leading dimension of the array U2. LDU >= max(1,M-P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V1\+T} & \begin{DoxyVerb}          V1T is COMPLEX*16 array, dimension(LDV1T,Q)
          The Q-by-Q unitary matrix V1T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V1\+T} & \begin{DoxyVerb}          LDV1T is INTEGER
          The leading dimension of the array V1T. LDV1T >=
          max(1,Q).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V2\+T} & \begin{DoxyVerb}          V2T is COMPLEX*16 array, dimension(LDV2T,M-Q)
          The (M-Q)-by-(M-Q) unitary matrix V2T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V2\+T} & \begin{DoxyVerb}          LDV2T is INTEGER
          The leading dimension of the array V2T. LDV2T >=
          max(1,M-Q).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+H\+E\+T\+A} & \begin{DoxyVerb}          THETA is DOUBLE PRECISION array, dimension MIN(P,M-P,Q,M-Q)
          The CS values of X; the essentially diagonal matrices C and
          S are constructed from THETA; see subroutine ZUNCSD for
          details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (15)
          The test ratios:
          First, the 2-by-2 CSD:
          RESULT(1) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(2) = norm( U1'*X12*V2 - D12 ) / ( MAX(1,P,M-Q)*EPS2 )
          RESULT(3) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(4) = norm( U2'*X22*V2 - D22 ) / ( MAX(1,M-P,M-Q)*EPS2 )
          RESULT(5) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(6) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(7) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(8) = norm( I - V2T'*V2T ) / ( MAX(1,M-Q)*ULP )
          RESULT(9) = 0        if THETA is in increasing order and
                               all angles are in [0,pi/2];
                    = ULPINV   otherwise.
          Then, the 2-by-1 CSD:
          RESULT(10) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(11) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(12) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(13) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(14) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(15) = 0        if THETA is in increasing order and
                                all angles are in [0,pi/2];
                     = ULPINV   otherwise.
          ( EPS2 = MAX( norm( I - X'*X ) / M, ULP ). )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga81ce6378154b5d55bedfa1241bb928d1}{}\index{complex16@{complex16}!zdrges@{zdrges}}
\index{zdrges@{zdrges}!complex16@{complex16}}
\subsubsection[{zdrges}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrges (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{S, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{T, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 13 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga81ce6378154b5d55bedfa1241bb928d1}


{\bfseries Z\+D\+R\+G\+E\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZDRGES checks the nonsymmetric generalized eigenvalue (Schur form)
 problem driver ZGGES.

 ZGGES factors A and B as Q*S*Z'  and Q*T*Z' , where ' means conjugate
 transpose, S and T are  upper triangular (i.e., in generalized Schur
 form), and Q and Z are unitary. It also computes the generalized
 eigenvalues (alpha(j),beta(j)), j=1,...,n.  Thus,
 w(j) = alpha(j)/beta(j) is a root of the characteristic equation

                 det( A - w(j) B ) = 0

 Optionally it also reorder the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms.

 When ZDRGES is called, a number of matrix "sizes" ("N's") and a
 number of matrix "TYPES" are specified.  For each size ("N")
 and each TYPE of matrix, a pair of matrices (A, B) will be generated
 and used for testing. For each matrix pair, the following 13 tests
 will be performed and compared with the threshhold THRESH except
 the tests (5), (11) and (13).


 (1)   | A - Q S Z' | / ( |A| n ulp ) (no sorting of eigenvalues)


 (2)   | B - Q T Z' | / ( |B| n ulp ) (no sorting of eigenvalues)


 (3)   | I - QQ' | / ( n ulp ) (no sorting of eigenvalues)


 (4)   | I - ZZ' | / ( n ulp ) (no sorting of eigenvalues)

 (5)   if A is in Schur form (i.e. triangular form) (no sorting of
       eigenvalues)

 (6)   if eigenvalues = diagonal elements of the Schur form (S, T),
       i.e., test the maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       (no sorting of eigenvalues)

 (7)   | (A,B) - Q (S,T) Z' | / ( |(A,B)| n ulp )
       (with sorting of eigenvalues).

 (8)   | I - QQ' | / ( n ulp ) (with sorting of eigenvalues).

 (9)   | I - ZZ' | / ( n ulp ) (with sorting of eigenvalues).

 (10)  if A is in Schur form (i.e. quasi-triangular form)
       (with sorting of eigenvalues).

 (11)  if eigenvalues = diagonal elements of the Schur form (S, T),
       i.e. test the maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       (with sorting of eigenvalues).

 (12)  if sorting worked and SDIM is the number of eigenvalues
       which were CELECTed.

 Test Matrices
 =============

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRGES does nothing.  NSIZES >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRGES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A on input.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRGES to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  THRESH >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is COMPLEX*16 array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by ZGGES.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by ZGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDQ, max(NN))
          The (left) orthogonal matrix computed by ZGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by ZGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is COMPLEX*16 array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is COMPLEX*16 array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by ZGGES.
          ALPHA(k) / BETA(k) is the k-th generalized eigenvalue of A
          and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.  LWORK >= 3*N*N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension ( 8*N )
          Real workspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gac25982b5c0c58a1f9f8025ab4ab33287}{}\index{complex16@{complex16}!zdrgev@{zdrgev}}
\index{zdrgev@{zdrgev}!complex16@{complex16}}
\subsubsection[{zdrgev}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrgev (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{S, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{T, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( ldqe, $\ast$ )}]{Q\+E, }
\item[{integer}]{L\+D\+Q\+E, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gac25982b5c0c58a1f9f8025ab4ab33287}


{\bfseries Z\+D\+R\+G\+E\+V} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZDRGEV checks the nonsymmetric generalized eigenvalue problem driver
 routine ZGGEV.

 ZGGEV computes for a pair of n-by-n nonsymmetric matrices (A,B) the
 generalized eigenvalues and, optionally, the left and right
 eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio  alpha/beta = w, such that A - w*B is singular.  It is
 usually represented as the pair (alpha,beta), as there is reasonalbe
 interpretation for beta=0, and even for both being zero.

 A right generalized eigenvector corresponding to a generalized
 eigenvalue  w  for a pair of matrices (A,B) is a vector r  such that
 (A - wB) * r = 0.  A left generalized eigenvector is a vector l such
 that l**H * (A - wB) = 0, where l**H is the conjugate-transpose of l.

 When ZDRGEV is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, a pair of matrices (A, B) will be generated
 and used for testing.  For each matrix pair, the following tests
 will be performed and compared with the threshhold THRESH.

 Results from ZGGEV:

 (1)  max over all left eigenvalue/-vector pairs (alpha/beta,l) of

      | VL**H * (beta A - alpha B) |/( ulp max(|beta A|, |alpha B|) )

      where VL**H is the conjugate-transpose of VL.

 (2)  | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

 (3)  max over all left eigenvalue/-vector pairs (alpha/beta,r) of

      | (beta A - alpha B) * VR | / ( ulp max(|beta A|, |alpha B|) )

 (4)  | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

 (5)  W(full) = W(partial)
      W(full) denotes the eigenvalues computed when both l and r
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and r, or only W and l are
      computed.

 (6)  VL(full) = VL(partial)
      VL(full) denotes the left eigenvectors computed when both l
      and r are computed, and VL(partial) denotes the result
      when only l is computed.

 (7)  VR(full) = VR(partial)
      VR(full) denotes the right eigenvectors computed when both l
      and r are also computed, and VR(partial) denotes the result
      when only l is computed.


 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZDRGES does nothing.  NSIZES >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZDRGEV
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRGES to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IERR not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is COMPLEX*16 array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by ZGGEV.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by ZGGEV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDQ, max(NN))
          The (left) eigenvectors matrix computed by ZGGEV.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by ZGGEV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q\+E} & \begin{DoxyVerb}          QE is COMPLEX*16 array, dimension( LDQ, max(NN) )
          QE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q\+E} & \begin{DoxyVerb}          LDQE is INTEGER
          The leading dimension of QE. LDQE >= max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is COMPLEX*16 array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is COMPLEX*16 array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by ZGGEV.
          ( ALPHAR(k)+ALPHAI(k)*i ) / BETA(k) is the k-th
          generalized eigenvalue of A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A1} & \begin{DoxyVerb}          ALPHA1 is COMPLEX*16 array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A1} & \begin{DoxyVerb}          BETA1 is COMPLEX*16 array, dimension (max(NN))

          Like ALPHAR, ALPHAI, BETA, these arrays contain the
          eigenvalues of A and B, but those computed when ZGGEV only
          computes a partial eigendecomposition, i.e. not the
          eigenvalues and left and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  LWORK >= N*(N+1)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (8*N)
          Real workspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaf81dc11e477868381fba4cb8f61904ab}{}\index{complex16@{complex16}!zdrgsx@{zdrgsx}}
\index{zdrgsx@{zdrgsx}!complex16@{complex16}}
\subsubsection[{zdrgsx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrgsx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E, }
\item[{integer}]{N\+C\+M\+A\+X, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+I, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B\+I, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{Q, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaf81dc11e477868381fba4cb8f61904ab}


{\bfseries Z\+D\+R\+G\+S\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZDRGSX checks the nonsymmetric generalized eigenvalue (Schur form)
 problem expert driver ZGGESX.

 ZGGES factors A and B as Q*S*Z'  and Q*T*Z' , where ' means conjugate
 transpose, S and T are  upper triangular (i.e., in generalized Schur
 form), and Q and Z are unitary. It also computes the generalized
 eigenvalues (alpha(j),beta(j)), j=1,...,n.  Thus,
 w(j) = alpha(j)/beta(j) is a root of the characteristic equation

                 det( A - w(j) B ) = 0

 Optionally it also reorders the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms; computes a reciprocal condition number for the average
 of the selected eigenvalues; and computes a reciprocal condition
 number for the right and left deflating subspaces corresponding to
 the selected eigenvalues.

 When ZDRGSX is called with NSIZE > 0, five (5) types of built-in
 matrix pairs are used to test the routine ZGGESX.

 When ZDRGSX is called with NSIZE = 0, it reads in test matrix data
 to test ZGGESX.
 (need more details on what kind of read-in data are needed).

 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH except for the tests (7) and (9):

 (1)   | A - Q S Z' | / ( |A| n ulp )

 (2)   | B - Q T Z' | / ( |B| n ulp )

 (3)   | I - QQ' | / ( n ulp )

 (4)   | I - ZZ' | / ( n ulp )

 (5)   if A is in Schur form (i.e. triangular form)

 (6)   maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

 (7)   if sorting worked and SDIM is the number of eigenvalues
       which were selected.

 (8)   the estimated value DIF does not differ from the true values of
       Difu and Difl more than a factor 10*THRESH. If the estimate DIF
       equals zero the corresponding true values of Difu and Difl
       should be less than EPS*norm(A, B). If the true value of Difu
       and Difl equal zero, the estimate DIF should be less than
       EPS*norm(A, B).

 (9)   If INFO = N+3 is returned by ZGGESX, the reordering "failed"
       and we check that DIF = PL = PR = 0 and that the true value of
       Difu and Difl is < EPS*norm(A, B). We count the events when
       INFO=N+3.

 For read-in test matrices, the same tests are run except that the
 exact value for DIF (and PL) is input data.  Additionally, there is
 one more test run for read-in test matrices:

 (10)  the estimated value PL does not differ from the true value of
       PLTRU more than a factor THRESH. If the estimate PL equals
       zero the corresponding true value of PLTRU should be less than
       EPS*norm(A, B). If the true value of PLTRU equal zero, the
       estimate PL should be less than EPS*norm(A, B).

 Note that for the built-in tests, a total of 10*NSIZE*(NSIZE-1)
 matrix pairs are generated and tested. NSIZE should be kept small.

 SVD (routine ZGESVD) is used for computing the true value of DIF_u
 and DIF_l when testing the built-in test problems.

 Built-in Test Matrices
 ======================

 All built-in test matrices are the 2 by 2 block of triangular
 matrices

          A = [ A11 A12 ]    and      B = [ B11 B12 ]
              [     A22 ]                 [     B22 ]

 where for different type of A11 and A22 are given as the following.
 A12 and B12 are chosen so that the generalized Sylvester equation

          A11*R - L*A22 = -A12
          B11*R - L*B22 = -B12

 have prescribed solution R and L.

 Type 1:  A11 = J_m(1,-1) and A_22 = J_k(1-a,1).
          B11 = I_m, B22 = I_k
          where J_k(a,b) is the k-by-k Jordan block with ``a'' on
          diagonal and ``b'' on superdiagonal.

 Type 2:  A11 = (a_ij) = ( 2(.5-sin(i)) ) and
          B11 = (b_ij) = ( 2(.5-sin(ij)) ) for i=1,...,m, j=i,...,m
          A22 = (a_ij) = ( 2(.5-sin(i+j)) ) and
          B22 = (b_ij) = ( 2(.5-sin(ij)) ) for i=m+1,...,k, j=i,...,k

 Type 3:  A11, A22 and B11, B22 are chosen as for Type 2, but each
          second diagonal block in A_11 and each third diagonal block
          in A_22 are made as 2 by 2 blocks.

 Type 4:  A11 = ( 20(.5 - sin(ij)) ) and B22 = ( 2(.5 - sin(i+j)) )
             for i=1,...,m,  j=1,...,m and
          A22 = ( 20(.5 - sin(i+j)) ) and B22 = ( 2(.5 - sin(ij)) )
             for i=m+1,...,k,  j=m+1,...,k

 Type 5:  (A,B) and have potentially close or common eigenvalues and
          very large departure from block diagonality A_11 is chosen
          as the m x m leading submatrix of A_1:
                  |  1  b                            |
                  | -b  1                            |
                  |        1+d  b                    |
                  |         -b 1+d                   |
           A_1 =  |                  d  1            |
                  |                 -1  d            |
                  |                        -d  1     |
                  |                        -1 -d     |
                  |                               1  |
          and A_22 is chosen as the k x k leading submatrix of A_2:
                  | -1  b                            |
                  | -b -1                            |
                  |       1-d  b                     |
                  |       -b  1-d                    |
           A_2 =  |                 d 1+b            |
                  |               -1-b d             |
                  |                       -d  1+b    |
                  |                      -1+b  -d    |
                  |                              1-d |
          and matrix B are chosen as identity matrices (see DLATM5).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E} & \begin{DoxyVerb}          NSIZE is INTEGER
          The maximum size of the matrices to use. NSIZE >= 0.
          If NSIZE = 0, no built-in tests matrices are used, but
          read-in test matrices are used to test DGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+C\+M\+A\+X} & \begin{DoxyVerb}          NCMAX is INTEGER
          Maximum allowable NMAX for generating Kroneker matrix
          in call to ZLAKF2\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  THRESH >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Z and Q,
          LDA >= max( 1, NSIZE ). For the read-in test,
          LDA >= max( 1, N ), N is the size of the test matrices.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+I} & \begin{DoxyVerb}          AI is COMPLEX*16 array, dimension (LDA, NSIZE)
          Copy of A, modified by ZGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+I} & \begin{DoxyVerb}          BI is COMPLEX*16 array, dimension (LDA, NSIZE)
          Copy of B, modified by ZGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension (LDA, NSIZE)
          Z holds the left Schur vectors computed by ZGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDA, NSIZE)
          Q holds the right Schur vectors computed by ZGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is COMPLEX*16 array, dimension (NSIZE)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is COMPLEX*16 array, dimension (NSIZE)

          On exit, ALPHA/BETA are the eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C} & \begin{DoxyVerb}          C is COMPLEX*16 array, dimension (LDC, LDC)
          Store the matrix generated by subroutine ZLAKF2, this is the
          matrix formed by Kronecker products used for estimating
          DIF.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of C. LDC >= max(1, LDA*LDA/2 ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is DOUBLE PRECISION array, dimension (LDC)
          Singular values of C\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.  LWORK >= 3*NSIZE*NSIZE/2\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array,
                                 dimension (5*NSIZE*NSIZE/2 - 4)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (LIWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+I\+W\+O\+R\+K} & \begin{DoxyVerb}          LIWORK is INTEGER
          The dimension of the array IWORK. LIWORK >= NSIZE + 2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (NSIZE)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga15555ac728d52bb12042d5b57152ecff}{}\index{complex16@{complex16}!zdrgvx@{zdrgvx}}
\index{zdrgvx@{zdrgvx}!complex16@{complex16}}
\subsubsection[{zdrgvx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrgvx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+I, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B\+I, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{V\+L, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{V\+R, }
\item[{integer}]{I\+L\+O, }
\item[{integer}]{I\+H\+I, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{L\+S\+C\+A\+L\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+S\+C\+A\+L\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D\+T\+R\+U, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D\+I\+F, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D\+I\+F\+T\+R\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 4 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga15555ac728d52bb12042d5b57152ecff}


{\bfseries Z\+D\+R\+G\+V\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZDRGVX checks the nonsymmetric generalized eigenvalue problem
 expert driver ZGGEVX.

 ZGGEVX computes the generalized eigenvalues, (optionally) the left
 and/or right eigenvectors, (optionally) computes a balancing
 transformation to improve the conditioning, and (optionally)
 reciprocal condition numbers for the eigenvalues and eigenvectors.

 When ZDRGVX is called with NSIZE > 0, two types of test matrix pairs
 are generated by the subroutine DLATM6 and test the driver ZGGEVX.
 The test matrices have the known exact condition numbers for
 eigenvalues. For the condition numbers of the eigenvectors
 corresponding the first and last eigenvalues are also know
 ``exactly'' (see ZLATM6).
 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH.

 (1) max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

     where l**H is the conjugate tranpose of l.

 (2) max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 (3) The condition number S(i) of eigenvalues computed by ZGGEVX
     differs less than a factor THRESH from the exact S(i) (see
     ZLATM6).

 (4) DIF(i) computed by ZTGSNA differs less than a factor 10*THRESH
     from the exact value (for the 1st and 5th vectors only).

 Test Matrices
 =============

 Two kinds of test matrix pairs
          (A, B) = inverse(YH) * (Da, Db) * inverse(X)
 are used in the tests:

 1: Da = 1+a   0    0    0    0    Db = 1   0   0   0   0
          0   2+a   0    0    0         0   1   0   0   0
          0    0   3+a   0    0         0   0   1   0   0
          0    0    0   4+a   0         0   0   0   1   0
          0    0    0    0   5+a ,      0   0   0   0   1 , and

 2: Da =  1   -1    0    0    0    Db = 1   0   0   0   0
          1    1    0    0    0         0   1   0   0   0
          0    0    1    0    0         0   0   1   0   0
          0    0    0   1+a  1+b        0   0   0   1   0
          0    0    0  -1-b  1+a ,      0   0   0   0   1 .

 In both cases the same inverse(YH) and inverse(X) are used to compute
 (A, B), giving the exact eigenvectors to (A,B) as (YH, X):

 YH:  =  1    0   -y    y   -y    X =  1   0  -x  -x   x
         0    1   -y    y   -y         0   1   x  -x  -x
         0    0    1    0    0         0   0   1   0   0
         0    0    0    1    0         0   0   0   1   0
         0    0    0    0    1,        0   0   0   0   1 , where

 a, b, x and y will have all values independently of each other from
 { sqrt(sqrt(ULP)),  0.1,  1,  10,  1/sqrt(sqrt(ULP)) }.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E} & \begin{DoxyVerb}          NSIZE is INTEGER
          The number of sizes of matrices to use.  NSIZE must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIN will be
          tested.  If it is not zero, then N = 5.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Ao, and Bo.
          It must be at least 1 and at least NSIZE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+I} & \begin{DoxyVerb}          AI is COMPLEX*16 array, dimension (LDA, NSIZE)
          Copy of A, modified by ZGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+I} & \begin{DoxyVerb}          BI is COMPLEX*16 array, dimension (LDA, NSIZE)
          Copy of B, modified by ZGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is COMPLEX*16 array, dimension (NSIZE)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is COMPLEX*16 array, dimension (NSIZE)

          On exit, ALPHA/BETA are the eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is COMPLEX*16 array, dimension (LDA, NSIZE)
          VL holds the left eigenvectors computed by ZGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is COMPLEX*16 array, dimension (LDA, NSIZE)
          VR holds the right eigenvectors computed by ZGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+L\+O} & \begin{DoxyVerb}        ILO is INTEGER\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+H\+I} & \begin{DoxyVerb}        IHI is INTEGER\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+S\+C\+A\+L\+E} & \begin{DoxyVerb}        LSCALE is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+S\+C\+A\+L\+E} & \begin{DoxyVerb}        RSCALE is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}        S is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+T\+R\+U} & \begin{DoxyVerb}        DTRU is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+I\+F} & \begin{DoxyVerb}        DIF is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+I\+F\+T\+R\+U} & \begin{DoxyVerb}        DIFTRU is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          Leading dimension of WORK.  LWORK >= 2*N*N + 2*N\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (6*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (LIWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+I\+W\+O\+R\+K} & \begin{DoxyVerb}          LIWORK is INTEGER
          Leading dimension of IWORK.  LIWORK >= N+2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}        RESULT is DOUBLE PRECISION array, dimension (4)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga2948dcf75ffb37ad4c8893b027ee4de1}{}\index{complex16@{complex16}!zdrvbd@{zdrvbd}}
\index{zdrvbd@{zdrvbd}!complex16@{complex16}}
\subsubsection[{zdrvbd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrvbd (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{M\+M, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldvt, $\ast$ )}]{V\+T, }
\item[{integer}]{L\+D\+V\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+S\+A\+V, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U\+S\+A\+V, }
\item[{{\bf complex}$\ast$16, dimension( ldvt, $\ast$ )}]{V\+T\+S\+A\+V, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+S\+A\+V, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{E, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga2948dcf75ffb37ad4c8893b027ee4de1}


{\bfseries Z\+D\+R\+V\+B\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZDRVBD checks the singular value decomposition (SVD) driver ZGESVD
 and ZGESDD.
 ZGESVD and CGESDD factors A = U diag(S) VT, where U and VT are
 unitary and diag(S) is diagonal with the entries of the array S on
 its diagonal. The entries of S are the singular values, nonnegative
 and stored in decreasing order.  U and VT can be optionally not
 computed, overwritten on A, or computed partially.

 A is M by N. Let MNMIN = min( M, N ). S has dimension MNMIN.
 U can be M by M or M by MNMIN. VT can be N by N or MNMIN by N.

 When ZDRVBD is called, a number of matrix "sizes" (M's and N's)
 and a number of matrix "types" are specified.  For each size (M,N)
 and each type of matrix, and for the minimal workspace as well as
 workspace adequate to permit blocking, an  M x N  matrix "A" will be
 generated and used to test the SVD routines.  For each matrix, A will
 be factored as A = U diag(S) VT and the following 12 tests computed:

 Test for ZGESVD:

 (1)   | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (2)   | I - U'U | / ( M ulp )

 (3)   | I - VT VT' | / ( N ulp )

 (4)   S contains MNMIN nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (5)   | U - Upartial | / ( M ulp ) where Upartial is a partially
       computed U.

 (6)   | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
       computed VT.

 (7)   | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
       vector of singular values from the partial SVD

 Test for ZGESDD:

 (1)   | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (2)   | I - U'U | / ( M ulp )

 (3)   | I - VT VT' | / ( N ulp )

 (4)   S contains MNMIN nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (5)   | U - Upartial | / ( M ulp ) where Upartial is a partially
       computed U.

 (6)   | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
       computed VT.

 (7)   | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
       vector of singular values from the partial SVD

 The "sizes" are specified by the arrays MM(1:NSIZES) and
 NN(1:NSIZES); the value of each element pair (MM(j),NN(j))
 specifies one size.  The "types" are specified by a logical array
 DOTYPE( 1:NTYPES ); if DOTYPE(j) is .TRUE., then matrix type "j"
 will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.
 (3)  A matrix of the form  U D V, where U and V are unitary and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.
 (4)  Same as (3), but multiplied by the underflow-threshold / ULP.
 (5)  Same as (3), but multiplied by the overflow-threshold * ULP.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZDRVBD does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+M} & \begin{DoxyVerb}          MM is INTEGER array, dimension (NSIZES)
          An array containing the matrix "heights" to be used.  For
          each j=1,...,NSIZES, if MM(j) is zero, then MM(j) and NN(j)
          will be ignored.  The MM(j) values must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the matrix "widths" to be used.  For
          each j=1,...,NSIZES, if NN(j) is zero, then MM(j) and NN(j)
          will be ignored.  The NN(j) values must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZDRVBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVBD to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,max(NN))
          Used to hold the matrix whose singular values are to be
          computed.  On exit, A contains the last matrix actually
          used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( MM ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU,max(MM))
          Used to hold the computed matrix of right singular vectors.
          On exit, U contains the last such vectors actually computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  It must be at
          least 1 and at least max( MM ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+T} & \begin{DoxyVerb}          VT is COMPLEX*16 array, dimension (LDVT,max(NN))
          Used to hold the computed matrix of left singular vectors.
          On exit, VT contains the last such vectors actually computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+T} & \begin{DoxyVerb}          LDVT is INTEGER
          The leading dimension of VT.  It must be at
          least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+S\+A\+V} & \begin{DoxyVerb}          ASAV is COMPLEX*16 array, dimension (LDA,max(NN))
          Used to hold a different copy of the matrix whose singular
          values are to be computed.  On exit, A contains the last
          matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U\+S\+A\+V} & \begin{DoxyVerb}          USAV is COMPLEX*16 array, dimension (LDU,max(MM))
          Used to hold a different copy of the computed matrix of
          right singular vectors. On exit, USAV contains the last such
          vectors actually computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+T\+S\+A\+V} & \begin{DoxyVerb}          VTSAV is COMPLEX*16 array, dimension (LDVT,max(NN))
          Used to hold a different copy of the computed matrix of
          left singular vectors. On exit, VTSAV contains the last such
          vectors actually computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is DOUBLE PRECISION array, dimension (max(min(MM,NN)))
          Contains the computed singular values.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+S\+A\+V} & \begin{DoxyVerb}          SSAV is DOUBLE PRECISION array, dimension (max(min(MM,NN)))
          Contains another copy of the computed singular values.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em E} & \begin{DoxyVerb}          E is DOUBLE PRECISION array, dimension (max(min(MM,NN)))
          Workspace for ZGESVD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          MAX(3*MIN(M,N)+MAX(M,N)**2,5*MIN(M,N),3*MAX(M,N)) for all
          pairs  (M,N)=(MM(j),NN(j))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array,
                      dimension ( 5*max(max(MM,NN)) )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension at least 8*min(M,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some MM(j) < 0
           -3: Some NN(j) < 0
           -4: NTYPES < 0
           -7: THRESH < 0
          -10: LDA < 1 or LDA < MMAX, where MMAX is max( MM(j) ).
          -12: LDU < 1 or LDU < MMAX.
          -14: LDVT < 1 or LDVT < NMAX, where NMAX is max( NN(j) ).
          -21: LWORK too small.
          If  ZLATMS, or ZGESVD returns an error code, the
              absolute value of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga46e5b4f2d2d900a8be48339a8fcbff42}{}\index{complex16@{complex16}!zdrves@{zdrves}}
\index{zdrves@{zdrves}!complex16@{complex16}}
\subsubsection[{zdrves}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrves (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+T, }
\item[{{\bf complex}$\ast$16, dimension( ldvs, $\ast$ )}]{V\+S, }
\item[{integer}]{L\+D\+V\+S, }
\item[{double {\bf precision}, dimension( 13 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga46e5b4f2d2d900a8be48339a8fcbff42}


{\bfseries Z\+D\+R\+V\+E\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    ZDRVES checks the nonsymmetric eigenvalue (Schur form) problem
    driver ZGEES.

    When ZDRVES is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 13
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if W are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if W are eigenvalues of T
            1/ulp otherwise
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP < |z| < 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP < |z| < 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZDRVES does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZDRVES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVES to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by ZGEES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H\+T} & \begin{DoxyVerb}          HT is COMPLEX*16 array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by ZGEES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W} & \begin{DoxyVerb}          W is COMPLEX*16 array, dimension (max(NN))
          The computed eigenvalues of A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+T} & \begin{DoxyVerb}          WT is COMPLEX*16 array, dimension (max(NN))
          Like W, this array contains the eigenvalues of A,
          but those computed when ZGEES only computes a partial
          eigendecomposition, i.e. not Schur vectors\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S} & \begin{DoxyVerb}          VS is COMPLEX*16 array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+S} & \begin{DoxyVerb}          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (13)
          The values computed by the 13 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (NWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+O\+R\+K} & \begin{DoxyVerb}          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -6: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -15: LDVS < 1 or LDVS < NMAX, where NMAX is max( NN(j) ).
          -18: NWORK too small.
          If  ZLATMR, CLATMS, CLATME or ZGEES returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------
     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.
             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Select whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga09d05af8ce92a19304b6700e26d1548e}{}\index{complex16@{complex16}!zdrvev@{zdrvev}}
\index{zdrvev@{zdrvev}!complex16@{complex16}}
\subsubsection[{zdrvev}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrvev (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W1, }
\item[{{\bf complex}$\ast$16, dimension( ldvl, $\ast$ )}]{V\+L, }
\item[{integer}]{L\+D\+V\+L, }
\item[{{\bf complex}$\ast$16, dimension( ldvr, $\ast$ )}]{V\+R, }
\item[{integer}]{L\+D\+V\+R, }
\item[{{\bf complex}$\ast$16, dimension( ldlre, $\ast$ )}]{L\+R\+E, }
\item[{integer}]{L\+D\+L\+R\+E, }
\item[{double {\bf precision}, dimension( 7 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga09d05af8ce92a19304b6700e26d1548e}


{\bfseries Z\+D\+R\+V\+E\+V} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    ZDRVEV  checks the nonsymmetric eigenvalue problem driver ZGEEV.

    When ZDRVEV is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 7
    tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a diagonal matrix with diagonal entries W(j).

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate-transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when both VR and VL
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and VR, or only W and VL are
      computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when both VR
      and VL are computed, and VR(partial) denotes the result
      when only VR is computed.

     (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when both VR
      and VL are also computed, and VL(partial) denotes the result
      when only VL is computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random complex
         angles on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is unitary and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP < |z| < 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP < |z| < 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from |z| < 1
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZDRVEV does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZDRVEV
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVEV to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max(NN).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by ZGEEV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W} & \begin{DoxyVerb}          W is COMPLEX*16 array, dimension (max(NN))
          The eigenvalues of A. On exit, W are the eigenvalues of
          the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W1} & \begin{DoxyVerb}          W1 is COMPLEX*16 array, dimension (max(NN))
          Like W, this array contains the eigenvalues of A,
          but those computed when ZGEEV only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is COMPLEX*16 array, dimension (LDVL, max(NN))
          VL holds the computed left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+L} & \begin{DoxyVerb}          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is COMPLEX*16 array, dimension (LDVR, max(NN))
          VR holds the computed right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+R} & \begin{DoxyVerb}          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+R\+E} & \begin{DoxyVerb}          LRE is COMPLEX*16 array, dimension (LDLRE, max(NN))
          LRE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+L\+R\+E} & \begin{DoxyVerb}          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (7)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (NWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+O\+R\+K} & \begin{DoxyVerb}          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (2*max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -6: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -14: LDVL < 1 or LDVL < NMAX, where NMAX is max( NN(j) ).
          -16: LDVR < 1 or LDVR < NMAX, where NMAX is max( NN(j) ).
          -18: LDLRE < 1 or LDLRE < NMAX, where NMAX is max( NN(j) ).
          -21: NWORK too small.
          If  ZLATMR, CLATMS, CLATME or ZGEEV returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga8f328a5e733c25b59a64e5aceec5bf7f}{}\index{complex16@{complex16}!zdrvgg@{zdrvgg}}
\index{zdrvgg@{zdrvgg}!complex16@{complex16}}
\subsubsection[{zdrvgg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrvgg (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{double {\bf precision}}]{T\+H\+R\+S\+H\+N, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{S, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{S2, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{T2, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A1, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A2, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A2, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{V\+L, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{V\+R, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga8f328a5e733c25b59a64e5aceec5bf7f}


{\bfseries Z\+D\+R\+V\+G\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZDRVGG  checks the nonsymmetric generalized eigenvalue driver
 routines.
                               T          T        T
 ZGEGS factors A and B as Q S Z  and Q T Z , where   means
 transpose, T is upper triangular, S is in generalized Schur form
 (upper triangular), and Q and Z are unitary.  It also
 computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), where alpha(j)=S(j,j) and beta(j)=T(j,j) --
 thus, w(j) = alpha(j)/beta(j) is a root of the generalized
 eigenvalue problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 ZGEGV computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), the matrix L whose columns contain the
 generalized left eigenvectors l, and the matrix R whose columns
 contain the generalized right eigenvectors r for the pair (A,B).

 When ZDRVGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 7
 tests will be performed and compared with the threshhold THRESH:

 Results from ZGEGS:

                  H
 (1)   | A - Q S Z  | / ( |A| n ulp )

                  H
 (2)   | B - Q T Z  | / ( |B| n ulp )

               H
 (3)   | I - QQ  | / ( n ulp )

               H
 (4)   | I - ZZ  | / ( n ulp )

 (5)   maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

 Results from ZGEGV:

 (6)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

       where l**H is the conjugate tranpose of l.

 (7)   max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random unitary matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZDRVGG does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, ZDRVGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVGG to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+S\+H\+N} & \begin{DoxyVerb}          THRSHN is DOUBLE PRECISION
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, S, T, S2, and T2.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper triangular matrix computed from A by ZGEGS.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is COMPLEX*16 array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by ZGEGS.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S2} & \begin{DoxyVerb}          S2 is COMPLEX*16 array, dimension (LDA, max(NN))
          The matrix computed from A by ZGEGV.  This will be the
          Schur (upper triangular) form of some matrix related to A,
          but will not, in general, be the same as S.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T2} & \begin{DoxyVerb}          T2 is COMPLEX*16 array, dimension (LDA, max(NN))
          The matrix computed from B by ZGEGV.  This will be the
          Schur form of some matrix related to B, but will not, in
          general, be the same as T.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDQ, max(NN))
          The (left) unitary matrix computed by ZGEGS.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q, Z, VL, and VR.  It must
          be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension (LDQ, max(NN))
          The (right) unitary matrix computed by ZGEGS.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A1} & \begin{DoxyVerb}          ALPHA1 is COMPLEX*16 array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A1} & \begin{DoxyVerb}          BETA1 is COMPLEX*16 array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by ZGEGS.
          ALPHA1(k) / BETA1(k)  is the k-th generalized eigenvalue of
          the matrices in A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A2} & \begin{DoxyVerb}          ALPHA2 is COMPLEX*16 array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A2} & \begin{DoxyVerb}          BETA2 is COMPLEX*16 array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by ZGEGV.
          ALPHA2(k) / BETA2(k)  is the k-th generalized eigenvalue of
          the matrices in A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is COMPLEX*16 array, dimension (LDQ, max(NN))
          The (lower triangular) left eigenvector matrix for the
          matrices in A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is COMPLEX*16 array, dimension (LDQ, max(NN))
          The (upper triangular) right eigenvector matrix for the
          matrices in A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          MAX( 2*N, N*(NB+1), (k+1)*(2*k+N+1) ), where "k" is the
          sum of the blocksize and number-of-shifts for ZHGEQZ, and
          NB is the greatest of the blocksizes for ZGEQRF, ZUNMQR,
          and ZUNGQR.  (The blocksizes and the number-of-shifts are
          retrieved through calls to ILAENV.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (8*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (7)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gadac8ad25581dfea4f0a2b147a7ce7da9}{}\index{complex16@{complex16}!zdrvsg@{zdrvsg}}
\index{zdrvsg@{zdrvsg}!complex16@{complex16}}
\subsubsection[{zdrvsg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrvsg (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{{\bf complex}$\ast$16, dimension( ldz, $\ast$ )}]{Z, }
\item[{integer}]{L\+D\+Z, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+B, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+P, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+P, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{L\+R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gadac8ad25581dfea4f0a2b147a7ce7da9}


{\bfseries Z\+D\+R\+V\+S\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      ZDRVSG checks the complex Hermitian generalized eigenproblem
      drivers.

              ZHEGV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem.

              ZHEGVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem using a divide and conquer algorithm.

              ZHEGVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem.

              ZHPGV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem in packed storage.

              ZHPGVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem in packed storage using a divide and
              conquer algorithm.

              ZHPGVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem in packed storage.

              ZHBGV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite banded
              generalized eigenproblem.

              ZHBGVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite banded
              generalized eigenproblem using a divide and conquer
              algorithm.

              ZHBGVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite banded
              generalized eigenproblem.

      When ZDRVSG is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix A of the given type will be
      generated; a random well-conditioned matrix B is also generated
      and the pair (A,B) is used to test the drivers.

      For each pair (A,B), the following tests are performed:

      (1) ZHEGV with ITYPE = 1 and UPLO ='U':

              | A Z - B Z D | / ( |A| |Z| n ulp )

      (2) as (1) but calling ZHPGV
      (3) as (1) but calling ZHBGV
      (4) as (1) but with UPLO = 'L'
      (5) as (4) but calling ZHPGV
      (6) as (4) but calling ZHBGV

      (7) ZHEGV with ITYPE = 2 and UPLO ='U':

              | A B Z - Z D | / ( |A| |Z| n ulp )

      (8) as (7) but calling ZHPGV
      (9) as (7) but with UPLO = 'L'
      (10) as (9) but calling ZHPGV

      (11) ZHEGV with ITYPE = 3 and UPLO ='U':

              | B A Z - Z D | / ( |A| |Z| n ulp )

      (12) as (11) but calling ZHPGV
      (13) as (11) but with UPLO = 'L'
      (14) as (13) but calling ZHPGV

      ZHEGVD, ZHPGVD and ZHBGVD performed the same 14 tests.

      ZHEGVX, ZHPGVX and ZHBGVX performed the above 14 tests with
      the parameter RANGE = 'A', 'N' and 'I', respectively.

      The "sizes" are specified by an array NN(1:NSIZES); the value of
      each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      This type is used for the matrix A which has half-bandwidth KA.
      B is generated as a well-conditioned positive definite matrix
      with half-bandwidth KB (<= KA).
      Currently, the list of possible types for A is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced entries
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced entries
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
           and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U* D U, where U is unitary and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U* D U, where U is unitary and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U* D U, where U is unitary and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) Hermitian matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold )

      (16) Same as (8), but with KA = 1 and KB = 1
      (17) Same as (8), but with KA = 2 and KB = 1
      (18) Same as (8), but with KA = 2 and KB = 2
      (19) Same as (8), but with KA = 3 and KB = 1
      (20) Same as (8), but with KA = 3 and KB = 2
      (21) Same as (8), but with KA = 3 and KB = 3\end{DoxyVerb}
 \begin{DoxyVerb}  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZDRVSG does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, ZDRVSG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVSG to continue the same random number
          sequence.
          Modified.

  THRESH  DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       COMPLEX*16 array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  B       COMPLEX*16 array, dimension (LDB , max(NN))
          Used to hold the Hermitian positive definite matrix for
          the generailzed problem.
          On exit, B contains the last matrix actually
          used.
          Modified.

  LDB     INTEGER
          The leading dimension of B.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D       DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A. On exit, the eigenvalues in D
          correspond with the matrix in A.
          Modified.

  Z       COMPLEX*16 array, dimension (LDZ, max(NN))
          The matrix of eigenvectors.
          Modified.

  LDZ     INTEGER
          The leading dimension of ZZ.  It must be at least 1 and
          at least max( NN ).
          Not modified.

  AB      COMPLEX*16 array, dimension (LDA, max(NN))
          Workspace.
          Modified.

  BB      COMPLEX*16 array, dimension (LDB, max(NN))
          Workspace.
          Modified.

  AP      COMPLEX*16 array, dimension (max(NN)**2)
          Workspace.
          Modified.

  BP      COMPLEX*16 array, dimension (max(NN)**2)
          Workspace.
          Modified.

  WORK    COMPLEX*16 array, dimension (NWORK)
          Workspace.
          Modified.

  NWORK   INTEGER
          The number of entries in WORK.  This must be at least
          2*N + N**2  where  N = max( NN(j), 2 ).
          Not modified.

  RWORK   DOUBLE PRECISION array, dimension (LRWORK)
          Workspace.
          Modified.

  LRWORK  INTEGER
          The number of entries in RWORK.  This must be at least
          max( 7*N, 1 + 4*N + 2*N*lg(N) + 3*N**2 ) where
          N = max( NN(j) ) and lg( N ) = smallest integer k such
          that 2**k >= N .
          Not modified.

  IWORK   INTEGER array, dimension (LIWORK))
          Workspace.
          Modified.

  LIWORK  INTEGER
          The number of entries in IWORK.  This must be at least
          2 + 5*max( NN(j) ).
          Not modified.

  RESULT  DOUBLE PRECISION array, dimension (70)
          The values computed by the 70 tests described above.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -5: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -16: LDZ < 1 or LDZ < NMAX.
          -21: NWORK too small.
          -23: LRWORK too small.
          -25: LIWORK too small.
          If  ZLATMR, CLATMS, ZHEGV, ZHPGV, ZHBGV, CHEGVD, CHPGVD,
              ZHPGVD, ZHEGVX, CHPGVX, ZHBGVX returns an error code,
              the absolute value of it is returned.
          Modified.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests that have been run
                       on this matrix.
       NTESTT          The total number of tests for this call.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by DLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaeb52cb23aa5a5fe5a884ba5413ea8d02}{}\index{complex16@{complex16}!zdrvst@{zdrvst}}
\index{zdrvst@{zdrvst}!complex16@{complex16}}
\subsubsection[{zdrvst}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrvst (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D2, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D3, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{W\+A1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{W\+A2, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{W\+A3, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{L\+R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaeb52cb23aa5a5fe5a884ba5413ea8d02}


{\bfseries Z\+D\+R\+V\+S\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      ZDRVST  checks the Hermitian eigenvalue problem drivers.

              ZHEEVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix,
              using a divide-and-conquer algorithm.

              ZHEEVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix.

              ZHEEVR computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix
              using the Relatively Robust Representation where it can.

              ZHPEVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix in packed
              storage, using a divide-and-conquer algorithm.

              ZHPEVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix in packed
              storage.

              ZHBEVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian band matrix,
              using a divide-and-conquer algorithm.

              ZHBEVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian band matrix.

              ZHEEV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix.

              ZHPEV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix in packed
              storage.

              ZHBEV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian band matrix.

      When ZDRVST is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix will be generated and used
      to test the appropriate drivers.  For each matrix and each
      driver routine called, the following tests will be performed:

      (1)     | A - Z D Z' | / ( |A| n ulp )

      (2)     | I - Z Z' | / ( n ulp )

      (3)     | D1 - D2 | / ( |D1| ulp )

      where Z is the matrix of eigenvectors returned when the
      eigenvector option is given and D1 and D2 are the eigenvalues
      returned with and without the eigenvector option.

      The "sizes" are specified by an array NN(1:NSIZES); the value of
      each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      Currently, the list of possible types is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced entries
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced entries
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
           and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U* D U, where U is unitary and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U* D U, where U is unitary and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U* D U, where U is unitary and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) Symmetric matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold )
      (16) A band matrix with half bandwidth randomly chosen between
           0 and N-1, with evenly spaced eigenvalues 1, ..., ULP
           with random signs.
      (17) Same as (16), but multiplied by SQRT( overflow threshold )
      (18) Same as (16), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 \begin{DoxyVerb}  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          ZDRVST does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, ZDRVST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVST to continue the same random number
          sequence.
          Modified.

  THRESH  DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       COMPLEX*16 array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D1      DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A, as computed by ZSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.
          Modified.

  D2      DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A, as computed by ZSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.
          Modified.

  D3      DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A, as computed by DSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.
          Modified.

  WA1     DOUBLE PRECISION array, dimension

  WA2     DOUBLE PRECISION array, dimension

  WA3     DOUBLE PRECISION array, dimension

  U       COMPLEX*16 array, dimension (LDU, max(NN))
          The unitary matrix computed by ZHETRD + ZUNGC3.
          Modified.

  LDU     INTEGER
          The leading dimension of U, Z, and V.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  V       COMPLEX*16 array, dimension (LDU, max(NN))
          The Housholder vectors computed by ZHETRD in reducing A to
          tridiagonal form.
          Modified.

  TAU     COMPLEX*16 array, dimension (max(NN))
          The Householder factors computed by ZHETRD in reducing A
          to tridiagonal form.
          Modified.

  Z       COMPLEX*16 array, dimension (LDU, max(NN))
          The unitary matrix of eigenvectors computed by ZHEEVD,
          ZHEEVX, ZHPEVD, CHPEVX, ZHBEVD, and CHBEVX.
          Modified.

  WORK  - COMPLEX*16 array of dimension ( LWORK )
           Workspace.
           Modified.

  LWORK - INTEGER
           The number of entries in WORK.  This must be at least
           2*max( NN(j), 2 )**2.
           Not modified.

  RWORK   DOUBLE PRECISION array, dimension (3*max(NN))
           Workspace.
           Modified.

  LRWORK - INTEGER
           The number of entries in RWORK.

  IWORK   INTEGER array, dimension (6*max(NN))
          Workspace.
          Modified.

  LIWORK - INTEGER
           The number of entries in IWORK.

  RESULT  DOUBLE PRECISION array, dimension (??)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -5: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -16: LDU < 1 or LDU < NMAX.
          -21: LWORK too small.
          If  DLATMR, SLATMS, ZHETRD, DORGC3, ZSTEQR, DSTERF,
              or DORMC2 returns an error code, the
              absolute value of it is returned.
          Modified.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by DLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaf5eb53e84bb7255969d88aba73a1dd82}{}\index{complex16@{complex16}!zdrvsx@{zdrvsx}}
\index{zdrvsx@{zdrvsx}!complex16@{complex16}}
\subsubsection[{zdrvsx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrvsx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+U\+N\+I\+T, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+T\+M\+P, }
\item[{{\bf complex}$\ast$16, dimension( ldvs, $\ast$ )}]{V\+S, }
\item[{integer}]{L\+D\+V\+S, }
\item[{{\bf complex}$\ast$16, dimension( ldvs, $\ast$ )}]{V\+S1, }
\item[{double {\bf precision}, dimension( 17 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaf5eb53e84bb7255969d88aba73a1dd82}


{\bfseries Z\+D\+R\+V\+S\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    ZDRVSX checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver ZGEESX.

    ZDRVSX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When ZDRVSX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 15
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if W are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if W are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare W with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP < |z| < 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP < |z| < 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalue
    average and right invariant subspace. For these matrices, in
    addition to tests (1) to (15) we will compute the following two
    tests:

   (16)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal average eigenvalue condition number
      computed by ZGEESX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.

   (17)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right invariant subspace condition
      number computed by ZGEESX and RCDVIN (the precomputed true
      value) is supplied as input. cond(RCONDV) is the condition
      number of RCONDV, and takes errors in computing RCONDV into
      account, so that the resulting quantity should be O(ULP).
      cond(RCONDV) is essentially given by norm(A)/RCONDE.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVSX to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+U\+N\+I\+T} & \begin{DoxyVerb}          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by ZGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H\+T} & \begin{DoxyVerb}          HT is COMPLEX*16 array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by ZGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W} & \begin{DoxyVerb}          W is COMPLEX*16 array, dimension (max(NN))
          The computed eigenvalues of A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+T} & \begin{DoxyVerb}          WT is COMPLEX*16 array, dimension (max(NN))
          Like W, this array contains the eigenvalues of A,
          but those computed when ZGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+T\+M\+P} & \begin{DoxyVerb}          WTMP is COMPLEX*16 array, dimension (max(NN))
          More temporary storage for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S} & \begin{DoxyVerb}          VS is COMPLEX*16 array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+S} & \begin{DoxyVerb}          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S1} & \begin{DoxyVerb}          VS1 is COMPLEX*16 array, dimension (LDVS, max(NN))
          VS1 holds another copy of the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(1,2*NN(j)**2) for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  successful exit.
            <0,  input parameter -INFO is incorrect
            >0,  ZLATMR, CLATMS, CLATME or ZGET24 returned an error
                 code and INFO is its absolute value

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------
     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.
             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gad219aa578f2f410c3431c8d3642c28cb}{}\index{complex16@{complex16}!zdrvvx@{zdrvvx}}
\index{zdrvvx@{zdrvvx}!complex16@{complex16}}
\subsubsection[{zdrvvx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zdrvvx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+U\+N\+I\+T, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W1, }
\item[{{\bf complex}$\ast$16, dimension( ldvl, $\ast$ )}]{V\+L, }
\item[{integer}]{L\+D\+V\+L, }
\item[{{\bf complex}$\ast$16, dimension( ldvr, $\ast$ )}]{V\+R, }
\item[{integer}]{L\+D\+V\+R, }
\item[{{\bf complex}$\ast$16, dimension( ldlre, $\ast$ )}]{L\+R\+E, }
\item[{integer}]{L\+D\+L\+R\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+V, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+N\+D\+V1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+D\+V\+I\+N, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+N\+D\+E1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+D\+E\+I\+N, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+C\+A\+L\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+C\+A\+L\+E1, }
\item[{double {\bf precision}, dimension( 11 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gad219aa578f2f410c3431c8d3642c28cb}


{\bfseries Z\+D\+R\+V\+V\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    ZDRVVX  checks the nonsymmetric eigenvalue problem expert driver
    ZGEEVX.

    ZDRVVX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When ZDRVVX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified in the calling sequence.
    For each size ("n") and each type of matrix, one matrix will be
    generated and used to test the nonsymmetric eigenroutines.  For
    each matrix, 9 tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a diagonal matrix with diagonal entries W(j).

    (2)     | A**H  * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     RCONDV(full) = RCONDV(partial)

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random complex
         angles on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is unitary and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP < |z| < 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP < |z| < 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from |z| < 1
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalues
    and right eigenvectors. For these matrices, in addition to tests
    (1) to (9) we will compute the following two tests:

   (10)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by ZGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by ZGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to ZDRVVX to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+U\+N\+I\+T} & \begin{DoxyVerb}          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, max(NN,12))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN, 12 ). (12 is the
          dimension of the largest matrix on the precomputed
          input file.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDA, max(NN,12))
          Another copy of the test matrix A, modified by ZGEEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W} & \begin{DoxyVerb}          W is COMPLEX*16 array, dimension (max(NN,12))
          Contains the eigenvalues of A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W1} & \begin{DoxyVerb}          W1 is COMPLEX*16 array, dimension (max(NN,12))
          Like W, this array contains the eigenvalues of A,
          but those computed when ZGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is COMPLEX*16 array, dimension (LDVL, max(NN,12))
          VL holds the computed left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+L} & \begin{DoxyVerb}          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN,12)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is COMPLEX*16 array, dimension (LDVR, max(NN,12))
          VR holds the computed right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+R} & \begin{DoxyVerb}          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN,12)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+R\+E} & \begin{DoxyVerb}          LRE is COMPLEX*16 array, dimension (LDLRE, max(NN,12))
          LRE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+L\+R\+E} & \begin{DoxyVerb}          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN,12))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+V} & \begin{DoxyVerb}          RCONDV is DOUBLE PRECISION array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+V1} & \begin{DoxyVerb}          RCNDV1 is DOUBLE PRECISION array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+V\+I\+N} & \begin{DoxyVerb}          RCDVIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+E} & \begin{DoxyVerb}          RCONDE is DOUBLE PRECISION array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+E1} & \begin{DoxyVerb}          RCNDE1 is DOUBLE PRECISION array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+E\+I\+N} & \begin{DoxyVerb}          RCDEIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E} & \begin{DoxyVerb}          SCALE is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E1} & \begin{DoxyVerb}          SCALE1 is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (NWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (11)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+O\+R\+K} & \begin{DoxyVerb}          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(6*12+2*12**2,6*NN(j)+2*NN(j)**2) =
          max(    360     ,6*NN(j)+2*NN(j)**2)    for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (2*max(NN,12))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  then successful exit.
          If <0, then input paramter -INFO is incorrect.
          If >0, ZLATMR, CLATMS, CLATME or ZGET23 returned an error
                 code, and INFO is its absolute value.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN or 12.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga5d4eaa3add8cbf75ae58c21d83fa54a9}{}\index{complex16@{complex16}!zerrbd@{zerrbd}}
\index{zerrbd@{zerrbd}!complex16@{complex16}}
\subsubsection[{zerrbd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zerrbd (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga5d4eaa3add8cbf75ae58c21d83fa54a9}


{\bfseries Z\+E\+R\+R\+B\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZERRBD tests the error exits for ZGEBRD, ZUNGBR, ZUNMBR, and ZBDSQR.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga2ded12fae46c5460170f505ca65744a2}{}\index{complex16@{complex16}!zerrec@{zerrec}}
\index{zerrec@{zerrec}!complex16@{complex16}}
\subsubsection[{zerrec}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zerrec (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga2ded12fae46c5460170f505ca65744a2}


{\bfseries Z\+E\+R\+R\+E\+C} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZERREC tests the error exits for the routines for eigen- condition
 estimation for DOUBLE PRECISION matrices:
    ZTRSYL, CTREXC, CTRSNA and CTRSEN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga5e12931d109ad06c796b415722e71e52}{}\index{complex16@{complex16}!zerred@{zerred}}
\index{zerred@{zerred}!complex16@{complex16}}
\subsubsection[{zerred}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zerred (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga5e12931d109ad06c796b415722e71e52}


{\bfseries Z\+E\+R\+R\+E\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZERRED tests the error exits for the eigenvalue driver routines for
 DOUBLE PRECISION matrices:

 PATH  driver   description
 ----  ------   -----------
 ZEV   ZGEEV    find eigenvalues/eigenvectors for nonsymmetric A
 ZES   ZGEES    find eigenvalues/Schur form for nonsymmetric A
 ZVX   ZGEEVX   ZGEEV + balancing and condition estimation
 ZSX   ZGEESX   ZGEES + balancing and condition estimation
 ZBD   ZGESVD   compute SVD of an M-by-N matrix A
       ZGESDD   compute SVD of an M-by-N matrix A(by divide and
                conquer)\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gabef96c9e9ff97dba730385e3b59a9b0f}{}\index{complex16@{complex16}!zerrgg@{zerrgg}}
\index{zerrgg@{zerrgg}!complex16@{complex16}}
\subsubsection[{zerrgg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zerrgg (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gabef96c9e9ff97dba730385e3b59a9b0f}


{\bfseries Z\+E\+R\+R\+G\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZERRGG tests the error exits for ZGGES, ZGGESX, ZGGEV, ZGGEVX,
 ZGGGLM, ZGGHRD, ZGGLSE, ZGGQRF, ZGGRQF, ZGGSVD, ZGGSVP, ZHGEQZ,
 ZTGEVC, ZTGEXC, ZTGSEN, ZTGSJA, ZTGSNA, ZTGSYL, and ZUNCSD.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gac8d8895448cbc459ded47dd743f46699}{}\index{complex16@{complex16}!zerrhs@{zerrhs}}
\index{zerrhs@{zerrhs}!complex16@{complex16}}
\subsubsection[{zerrhs}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zerrhs (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gac8d8895448cbc459ded47dd743f46699}


{\bfseries Z\+E\+R\+R\+H\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZERRHS tests the error exits for ZGEBAK, CGEBAL, CGEHRD, ZUNGHR,
 ZUNMHR, ZHSEQR, CHSEIN, and ZTREVC.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaa43562d1ca14d490f6fb6ee555df7438}{}\index{complex16@{complex16}!zerrst@{zerrst}}
\index{zerrst@{zerrst}!complex16@{complex16}}
\subsubsection[{zerrst}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zerrst (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaa43562d1ca14d490f6fb6ee555df7438}


{\bfseries Z\+E\+R\+R\+S\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZERRST tests the error exits for ZHETRD, ZUNGTR, CUNMTR, ZHPTRD,
 ZUNGTR, ZUPMTR, ZSTEQR, CSTEIN, ZPTEQR, ZHBTRD,
 ZHEEV, CHEEVX, CHEEVD, ZHBEV, CHBEVX, CHBEVD,
 ZHPEV, CHPEVX, CHPEVD, and ZSTEDC.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga66d124fa093cbd4a9c70d869fae241fd}{}\index{complex16@{complex16}!zget02@{zget02}}
\index{zget02@{zget02}!complex16@{complex16}}
\subsubsection[{zget02}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget02 (
\begin{DoxyParamCaption}
\item[{character}]{T\+R\+A\+N\+S, }
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{integer}]{N\+R\+H\+S, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldx, $\ast$ )}]{X, }
\item[{integer}]{L\+D\+X, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga66d124fa093cbd4a9c70d869fae241fd}


{\bfseries Z\+G\+E\+T02} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET02 computes the residual for a solution of a system of linear
 equations  A*x = b  or  A'*x = b:
    RESID = norm(B - A*X) / ( norm(A) * norm(X) * EPS ),
 where EPS is the machine epsilon.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em T\+R\+A\+N\+S} & \begin{DoxyVerb}          TRANS is CHARACTER*1
          Specifies the form of the system of equations:
          = 'N':  A *x = b
          = 'T':  A^T*x = b, where A^T is the transpose of A
          = 'C':  A^H*x = b, where A^H is the conjugate transpose of A\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of columns of B, the matrix of right hand sides.
          NRHS >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The original M x N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension (LDX,NRHS)
          The computed solution vectors for the system of linear
          equations.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX >= max(1,N); if TRANS = 'T' or 'C', LDX >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,NRHS)
          On entry, the right hand side vectors for the system of
          linear equations.
          On exit, B is overwritten with the difference B - A*X.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  IF TRANS = 'N',
          LDB >= max(1,M); if TRANS = 'T' or 'C', LDB >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is DOUBLE PRECISION
          The maximum over the number of right hand sides of
          norm(B - A*X) / ( norm(A) * norm(X) * EPS ).\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gac9dffccc2faf3942bfc7d9ae4c92be0e}{}\index{complex16@{complex16}!zget10@{zget10}}
\index{zget10@{zget10}!complex16@{complex16}}
\subsubsection[{zget10}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget10 (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gac9dffccc2faf3942bfc7d9ae4c92be0e}


{\bfseries Z\+G\+E\+T10} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET10 compares two matrices A and B and computes the ratio
 RESULT = norm( A - B ) / ( norm(A) * M * EPS )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrices A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The m by n matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,N)
          The m by n matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is COMPLEX*16 array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION
          RESULT = norm( A - B ) / ( norm(A) * M * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga2613f5765953757de881b744e9b72725}{}\index{complex16@{complex16}!zget22@{zget22}}
\index{zget22@{zget22}!complex16@{complex16}}
\subsubsection[{zget22}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget22 (
\begin{DoxyParamCaption}
\item[{character}]{T\+R\+A\+N\+S\+A, }
\item[{character}]{T\+R\+A\+N\+S\+E, }
\item[{character}]{T\+R\+A\+N\+S\+W, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( {\bf lde}, $\ast$ )}]{E, }
\item[{integer}]{L\+D\+E, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga2613f5765953757de881b744e9b72725}


{\bfseries Z\+G\+E\+T22} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET22 does an eigenvector check.

 The basic test is:

    RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )

 using the 1-norm.  It also tests the normalization of E:

    RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )
                 j

 where E(j) is the j-th eigenvector, and m-norm is the max-norm of a
 vector.  The max-norm of a complex n-vector x in this case is the
 maximum of |re(x(i)| + |im(x(i)| over i = 1, ..., n.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em T\+R\+A\+N\+S\+A} & \begin{DoxyVerb}          TRANSA is CHARACTER*1
          Specifies whether or not A is transposed.
          = 'N':  No transpose
          = 'T':  Transpose
          = 'C':  Conjugate transpose\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+A\+N\+S\+E} & \begin{DoxyVerb}          TRANSE is CHARACTER*1
          Specifies whether or not E is transposed.
          = 'N':  No transpose, eigenvectors are in columns of E
          = 'T':  Transpose, eigenvectors are in rows of E
          = 'C':  Conjugate transpose, eigenvectors are in rows of E\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+A\+N\+S\+W} & \begin{DoxyVerb}          TRANSW is CHARACTER*1
          Specifies whether or not W is transposed.
          = 'N':  No transpose
          = 'T':  Transpose, same as TRANSW = 'N'
          = 'C':  Conjugate transpose, use -WI(j) instead of WI(j)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The matrix whose eigenvectors are in E.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is COMPLEX*16 array, dimension (LDE,N)
          The matrix of eigenvectors. If TRANSE = 'N', the eigenvectors
          are stored in the columns of E, if TRANSE = 'T' or 'C', the
          eigenvectors are stored in the rows of E.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+E} & \begin{DoxyVerb}          LDE is INTEGER
          The leading dimension of the array E.  LDE >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em W} & \begin{DoxyVerb}          W is COMPLEX*16 array, dimension (N)
          The eigenvalues of A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (N*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )
          RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gafff141ca176900b033d426a3442a5971}{}\index{complex16@{complex16}!zget23@{zget23}}
\index{zget23@{zget23}!complex16@{complex16}}
\subsubsection[{zget23}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget23 (
\begin{DoxyParamCaption}
\item[{{\bf logical}}]{C\+O\+M\+P, }
\item[{integer}]{I\+S\+R\+T, }
\item[{character}]{B\+A\+L\+A\+N\+C, }
\item[{integer}]{J\+T\+Y\+P\+E, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W1, }
\item[{{\bf complex}$\ast$16, dimension( ldvl, $\ast$ )}]{V\+L, }
\item[{integer}]{L\+D\+V\+L, }
\item[{{\bf complex}$\ast$16, dimension( ldvr, $\ast$ )}]{V\+R, }
\item[{integer}]{L\+D\+V\+R, }
\item[{{\bf complex}$\ast$16, dimension( ldlre, $\ast$ )}]{L\+R\+E, }
\item[{integer}]{L\+D\+L\+R\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+V, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+N\+D\+V1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+D\+V\+I\+N, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+N\+D\+E1, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+C\+D\+E\+I\+N, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+C\+A\+L\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+C\+A\+L\+E1, }
\item[{double {\bf precision}, dimension( 11 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gafff141ca176900b033d426a3442a5971}


{\bfseries Z\+G\+E\+T23} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    ZGET23  checks the nonsymmetric eigenvalue problem driver CGEEVX.
    If COMP = .FALSE., the first 8 of the following tests will be
    performed on the input matrix A, and also test 9 if LWORK is
    sufficiently large.
    if COMP is .TRUE. all 11 tests will be performed.

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a diagonal matrix with diagonal entries W(j).

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     0 if W(full) = W(partial), 1/ulp otherwise

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     0 if VR(full) = VR(partial), 1/ulp otherwise

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     0 if VL(full) = VL(partial), 1/ulp otherwise

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     0 if RCONDV(full) = RCONDV(partial), 1/ulp otherwise

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

   (10)     |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by ZGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)     |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by ZGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em C\+O\+M\+P} & \begin{DoxyVerb}          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+R\+T} & \begin{DoxyVerb}          ISRT is INTEGER
          If COMP = .TRUE., ISRT indicates in how the eigenvalues
          corresponding to values in RCDVIN and RCDEIN are ordered:
            = 0 means the eigenvalues are sorted by
                increasing real part
            = 1 means the eigenvalues are sorted by
                increasing imaginary part
          If COMP = .FALSE., ISRT is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B\+A\+L\+A\+N\+C} & \begin{DoxyVerb}          BALANC is CHARACTER
          Describes the balancing option to be tested.
            = 'N' for no permuting or diagonal scaling
            = 'P' for permuting but no diagonal scaling
            = 'S' for no permuting but diagonal scaling
            = 'B' for permuting and diagonal scaling\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em J\+T\+Y\+P\+E} & \begin{DoxyVerb}          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of A. N must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          Used to hold the matrix whose eigenvalues are to be
          computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDA,N)
          Another copy of the test matrix A, modified by ZGEEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W} & \begin{DoxyVerb}          W is COMPLEX*16 array, dimension (N)
          Contains the eigenvalues of A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W1} & \begin{DoxyVerb}          W1 is COMPLEX*16 array, dimension (N)
          Like W, this array contains the eigenvalues of A,
          but those computed when ZGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is COMPLEX*16 array, dimension (LDVL,N)
          VL holds the computed left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+L} & \begin{DoxyVerb}          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is COMPLEX*16 array, dimension (LDVR,N)
          VR holds the computed right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+R} & \begin{DoxyVerb}          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+R\+E} & \begin{DoxyVerb}          LRE is COMPLEX*16 array, dimension (LDLRE,N)
          LRE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+L\+R\+E} & \begin{DoxyVerb}          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+V} & \begin{DoxyVerb}          RCONDV is DOUBLE PRECISION array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+V1} & \begin{DoxyVerb}          RCNDV1 is DOUBLE PRECISION array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+V\+I\+N} & \begin{DoxyVerb}          RCDVIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+E} & \begin{DoxyVerb}          RCONDE is DOUBLE PRECISION array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+E1} & \begin{DoxyVerb}          RCNDE1 is DOUBLE PRECISION array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+E\+I\+N} & \begin{DoxyVerb}          RCDEIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E} & \begin{DoxyVerb}          SCALE is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E1} & \begin{DoxyVerb}          SCALE1 is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (11)
          The values computed by the 11 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          2*N, and 2*N+N**2 if tests 9, 10 or 11 are to be performed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (2*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  successful exit.
          If <0, input parameter -INFO had an incorrect value.
          If >0, ZGEEVX returned an error code, the absolute
                 value of which is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga856fb6d577946eb001db09bd7a0bb2d3}{}\index{complex16@{complex16}!zget24@{zget24}}
\index{zget24@{zget24}!complex16@{complex16}}
\subsubsection[{zget24}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget24 (
\begin{DoxyParamCaption}
\item[{{\bf logical}}]{C\+O\+M\+P, }
\item[{integer}]{J\+T\+Y\+P\+E, }
\item[{double {\bf precision}}]{T\+H\+R\+E\+S\+H, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{H\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+T\+M\+P, }
\item[{{\bf complex}$\ast$16, dimension( ldvs, $\ast$ )}]{V\+S, }
\item[{integer}]{L\+D\+V\+S, }
\item[{{\bf complex}$\ast$16, dimension( ldvs, $\ast$ )}]{V\+S1, }
\item[{double {\bf precision}}]{R\+C\+D\+E\+I\+N, }
\item[{double {\bf precision}}]{R\+C\+D\+V\+I\+N, }
\item[{integer}]{N\+S\+L\+C\+T, }
\item[{integer, dimension( $\ast$ )}]{I\+S\+L\+C\+T, }
\item[{integer}]{I\+S\+R\+T, }
\item[{double {\bf precision}, dimension( 17 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga856fb6d577946eb001db09bd7a0bb2d3}


{\bfseries Z\+G\+E\+T24} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    ZGET24 checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver ZGEESX.

    If COMP = .FALSE., the first 13 of the following tests will be
    be performed on the input matrix A, and also tests 14 and 15
    if LWORK is sufficiently large.
    If COMP = .TRUE., all 17 test will be performed.

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if W are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if W are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare W with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    (16)  |RCONDE - RCDEIN| / cond(RCONDE)

       RCONDE is the reciprocal average eigenvalue condition number
       computed by ZGEESX and RCDEIN (the precomputed true value)
       is supplied as input.  cond(RCONDE) is the condition number
       of RCONDE, and takes errors in computing RCONDE into account,
       so that the resulting quantity should be O(ULP). cond(RCONDE)
       is essentially given by norm(A)/RCONDV.

    (17)  |RCONDV - RCDVIN| / cond(RCONDV)

       RCONDV is the reciprocal right invariant subspace condition
       number computed by ZGEESX and RCDVIN (the precomputed true
       value) is supplied as input. cond(RCONDV) is the condition
       number of RCONDV, and takes errors in computing RCONDV into
       account, so that the resulting quantity should be O(ULP).
       cond(RCONDV) is essentially given by norm(A)/RCONDE.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em C\+O\+M\+P} & \begin{DoxyVerb}          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em J\+T\+Y\+P\+E} & \begin{DoxyVerb}          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of A. N must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          Used to hold the matrix whose eigenvalues are to be
          computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDA, N)
          Another copy of the test matrix A, modified by ZGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H\+T} & \begin{DoxyVerb}          HT is COMPLEX*16 array, dimension (LDA, N)
          Yet another copy of the test matrix A, modified by ZGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W} & \begin{DoxyVerb}          W is COMPLEX*16 array, dimension (N)
          The computed eigenvalues of A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+T} & \begin{DoxyVerb}          WT is COMPLEX*16 array, dimension (N)
          Like W, this array contains the eigenvalues of A,
          but those computed when ZGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+T\+M\+P} & \begin{DoxyVerb}          WTMP is COMPLEX*16 array, dimension (N)
          Like W, this array contains the eigenvalues of A,
          but sorted by increasing real or imaginary part.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S} & \begin{DoxyVerb}          VS is COMPLEX*16 array, dimension (LDVS, N)
          VS holds the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+S} & \begin{DoxyVerb}          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1, N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S1} & \begin{DoxyVerb}          VS1 is COMPLEX*16 array, dimension (LDVS, N)
          VS1 holds another copy of the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+E\+I\+N} & \begin{DoxyVerb}          RCDEIN is DOUBLE PRECISION
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition number for the average of selected eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+V\+I\+N} & \begin{DoxyVerb}          RCDVIN is DOUBLE PRECISION
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition number for the selected right invariant subspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+S\+L\+C\+T} & \begin{DoxyVerb}          NSLCT is INTEGER
          When COMP = .TRUE. the number of selected eigenvalues
          corresponding to the precomputed values RCDEIN and RCDVIN.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+L\+C\+T} & \begin{DoxyVerb}          ISLCT is INTEGER array, dimension (NSLCT)
          When COMP = .TRUE. ISLCT selects the eigenvalues of the
          input matrix corresponding to the precomputed values RCDEIN
          and RCDVIN. For I=1, ... ,NSLCT, if ISLCT(I) = J, then the
          eigenvalue with the J-th largest real or imaginary part is
          selected. The real part is used if ISRT = 0, and the
          imaginary part if ISRT = 1.
          Not referenced if COMP = .FALSE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+R\+T} & \begin{DoxyVerb}          ISRT is INTEGER
          When COMP = .TRUE., ISRT describes how ISLCT is used to
          choose a subset of the spectrum.
          Not referenced if COMP = .FALSE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (2*N*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK to be passed to ZGEESX. This
          must be at least 2*N, and N*(N+1)/2 if tests 14--16 are to
          be performed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  successful exit.
          If <0, input parameter -INFO had an incorrect value.
          If >0, ZGEESX returned an error code, the absolute
                 value of which is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga06b79b13bd73f94f9dd9091c656edf38}{}\index{complex16@{complex16}!zget35@{zget35}}
\index{zget35@{zget35}!complex16@{complex16}}
\subsubsection[{zget35}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget35 (
\begin{DoxyParamCaption}
\item[{double {\bf precision}}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T, }
\item[{integer}]{N\+I\+N}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga06b79b13bd73f94f9dd9091c656edf38}


{\bfseries Z\+G\+E\+T35} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET35 tests ZTRSYL, a routine for solving the Sylvester matrix
 equation

    op(A)*X + ISGN*X*op(B) = scale*C,

 A and B are assumed to be in Schur canonical form, op() represents an
 optional transpose, and ISGN can be -1 or +1.  Scale is an output
 less than or equal to 1, chosen to avoid overflow in X.

 The test code verifies that the following residual is order 1:

    norm(op(A)*X + ISGN*X*op(B) - scale*C) /
        (EPS*max(norm(A),norm(B))*norm(X))\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER
          Number of examples where INFO is nonzero.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          Input logical unit number.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga278000fdcd9e195f025572375e81eb60}{}\index{complex16@{complex16}!zget36@{zget36}}
\index{zget36@{zget36}!complex16@{complex16}}
\subsubsection[{zget36}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget36 (
\begin{DoxyParamCaption}
\item[{double {\bf precision}}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T, }
\item[{integer}]{N\+I\+N}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga278000fdcd9e195f025572375e81eb60}


{\bfseries Z\+G\+E\+T36} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET36 tests ZTREXC, a routine for reordering diagonal entries of a
 matrix in complex Schur form. Thus, ZLAEXC computes a unitary matrix
 Q such that

    Q' * T1 * Q  = T2

 and where one of the diagonal blocks of T1 (the one at row IFST) has
 been moved to position ILST.

 The test code verifies that the residual Q'*T1*Q-T2 is small, that T2
 is in Schur form, and that the final position of the IFST block is
 ILST.

 The test matrices are read from a file with logical unit number NIN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER
          Number of examples where INFO is nonzero.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          Input logical unit number.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaae18ead2df57b6911e5acdc209a39a76}{}\index{complex16@{complex16}!zget37@{zget37}}
\index{zget37@{zget37}!complex16@{complex16}}
\subsubsection[{zget37}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget37 (
\begin{DoxyParamCaption}
\item[{double {\bf precision}, dimension( 3 )}]{R\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{L\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T, }
\item[{integer}]{N\+I\+N}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaae18ead2df57b6911e5acdc209a39a76}


{\bfseries Z\+G\+E\+T37} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET37 tests ZTRSNA, a routine for estimating condition numbers of
 eigenvalues and/or right eigenvectors of a matrix.

 The test matrices are read from a file with logical unit number NIN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is DOUBLE PRECISION array, dimension (3)
          Value of the largest test ratio.
          RMAX(1) = largest ratio comparing different calls to ZTRSNA
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If ZGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If ZHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If ZTRSNA returns INFO nonzero on example i, LMAX(3)=i\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times ZGEHRD returned INFO nonzero
          NINFO(2) = No. of times ZHSEQR returned INFO nonzero
          NINFO(3) = No. of times ZTRSNA returned INFO nonzero\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          Input logical unit number\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga7e72d2c592f4188ce6e1f4c065edd682}{}\index{complex16@{complex16}!zget38@{zget38}}
\index{zget38@{zget38}!complex16@{complex16}}
\subsubsection[{zget38}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget38 (
\begin{DoxyParamCaption}
\item[{double {\bf precision}, dimension( 3 )}]{R\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{L\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T, }
\item[{integer}]{N\+I\+N}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga7e72d2c592f4188ce6e1f4c065edd682}


{\bfseries Z\+G\+E\+T38} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET38 tests ZTRSEN, a routine for estimating condition numbers of a
 cluster of eigenvalues and/or its associated right invariant subspace

 The test matrices are read from a file with logical unit number NIN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is DOUBLE PRECISION array, dimension (3)
          Values of the largest test ratios.
          RMAX(1) = largest residuals from ZHST01 or comparing
                    different calls to ZTRSEN
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If ZGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If ZHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If ZTRSEN returns INFO nonzero on example i, LMAX(3)=i\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times ZGEHRD returned INFO nonzero
          NINFO(2) = No. of times ZHSEQR returned INFO nonzero
          NINFO(3) = No. of times ZTRSEN returned INFO nonzero\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          Input logical unit number.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga607a14c898294891e1205e5b20b011c8}{}\index{complex16@{complex16}!zget51@{zget51}}
\index{zget51@{zget51}!complex16@{complex16}}
\subsubsection[{zget51}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget51 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga607a14c898294891e1205e5b20b011c8}


{\bfseries Z\+G\+E\+T51} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      ZGET51  generally checks a decomposition of the form

              A = U B VC>
      where * means conjugate transpose and U and V are unitary.

      Specifically, if ITYPE=1

              RESULT = | A - U B V* | / ( |A| n ulp )

      If ITYPE=2, then:

              RESULT = | A - B | / ( |A| n ulp )

      If ITYPE=3, then:

              RESULT = | I - UU* | / ( n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          =1: RESULT = | A - U B V* | / ( |A| n ulp )
          =2: RESULT = | A - B | / ( |A| n ulp )
          =3: RESULT = | I - UU* | / ( n ulp )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, ZGET51 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          The original (unfactored) matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB, N)
          The factored matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, N)
          The unitary matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension (LDV, N)
          The unitary matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (2*N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION
          The values computed by the test specified by ITYPE.  The
          value is currently limited to 1/ulp, to avoid overflow.
          Errors are flagged by RESULT=10/ulp.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga0e033c8f1d94f2f9dcf5742d6c93d85b}{}\index{complex16@{complex16}!zget52@{zget52}}
\index{zget52@{zget52}!complex16@{complex16}}
\subsubsection[{zget52}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget52 (
\begin{DoxyParamCaption}
\item[{{\bf logical}}]{L\+E\+F\+T, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( {\bf lde}, $\ast$ )}]{E, }
\item[{integer}]{L\+D\+E, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga0e033c8f1d94f2f9dcf5742d6c93d85b}


{\bfseries Z\+G\+E\+T52} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET52  does an eigenvector check for the generalized eigenvalue
 problem.

 The basic test for right eigenvectors is:

                           | b(i) A E(i) -  a(i) B E(i) |
         RESULT(1) = max   -------------------------------
                      i    n ulp max( |b(i) A|, |a(i) B| )

 using the 1-norm.  Here, a(i)/b(i) = w is the i-th generalized
 eigenvalue of A - w B, or, equivalently, b(i)/a(i) = m is the i-th
 generalized eigenvalue of m A - B.

                         H   H  _      _
 For left eigenvectors, A , B , a, and b  are used.

 ZGET52 also tests the normalization of E.  Each eigenvector is
 supposed to be normalized so that the maximum "absolute value"
 of its elements is 1, where in this case, "absolute value"
 of a complex value x is  |Re(x)| + |Im(x)| ; let us call this
 maximum "absolute value" norm of a vector v  M(v).  
 If a(i)=b(i)=0, then the eigenvector is set to be the jth coordinate
 vector. The normalization test is:

         RESULT(2) =      max       | M(v(i)) - 1 | / ( n ulp )
                    eigenvectors v(i)\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em L\+E\+F\+T} & \begin{DoxyVerb}          LEFT is LOGICAL
          =.TRUE.:  The eigenvectors in the columns of E are assumed
                    to be *left* eigenvectors.
          =.FALSE.: The eigenvectors in the columns of E are assumed
                    to be *right* eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrices.  If it is zero, ZGET52 does
          nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          The matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB, N)
          The matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is COMPLEX*16 array, dimension (LDE, N)
          The matrix of eigenvectors.  It must be O( 1 ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+E} & \begin{DoxyVerb}          LDE is INTEGER
          The leading dimension of E.  It must be at least 1 and at
          least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is COMPLEX*16 array, dimension (N)
          The values a(i) as described above, which, along with b(i),
          define the generalized eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is COMPLEX*16 array, dimension (N)
          The values b(i) as described above, which, along with a(i),
          define the generalized eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the test described above.  If A E or
          B E is likely to overflow, then RESULT(1:2) is set to
          10 / ulp.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga8cfa5d9479fe4546ef7d28e400003358}{}\index{complex16@{complex16}!zget54@{zget54}}
\index{zget54@{zget54}!complex16@{complex16}}
\subsubsection[{zget54}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zget54 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( lds, $\ast$ )}]{S, }
\item[{integer}]{L\+D\+S, }
\item[{{\bf complex}$\ast$16, dimension( ldt, $\ast$ )}]{T, }
\item[{integer}]{L\+D\+T, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga8cfa5d9479fe4546ef7d28e400003358}


{\bfseries Z\+G\+E\+T54} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGET54 checks a generalized decomposition of the form

          A = U*S*V'  and B = U*T* V'

 where ' means conjugate transpose and U and V are unitary.

 Specifically,

   RESULT = ||( A - U*S*V', B - U*T*V' )|| / (||( A, B )||*n*ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, DGET54 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          The original (unfactored) matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB, N)
          The original (unfactored) matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S} & \begin{DoxyVerb}          S is COMPLEX*16 array, dimension (LDS, N)
          The factored matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+S} & \begin{DoxyVerb}          LDS is INTEGER
          The leading dimension of S.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T} & \begin{DoxyVerb}          T is COMPLEX*16 array, dimension (LDT, N)
          The factored matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & \begin{DoxyVerb}          LDT is INTEGER
          The leading dimension of T.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension (LDV, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (3*N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION
          The value RESULT, It is currently limited to 1/ulp, to
          avoid overflow. Errors are flagged by RESULT=10/ulp.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gab64718de54eca7f9e28308a0cdce411f}{}\index{complex16@{complex16}!zglmts@{zglmts}}
\index{zglmts@{zglmts}!complex16@{complex16}}
\subsubsection[{zglmts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zglmts (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+F, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{D, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{D\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{X, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{U, }
\item[{{\bf complex}$\ast$16, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gab64718de54eca7f9e28308a0cdce411f}


{\bfseries Z\+G\+L\+M\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGLMTS tests ZGGGLM - a subroutine for solving the generalized
 linear model problem.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of rows of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of columns of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of columns of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,M)
          The N-by-M matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (LDA,M)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF. LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,P)
          The N-by-P matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (LDB,P)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF. LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is COMPLEX*16 array, dimension( N )
          On input, the left hand side of the GLM.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+F} & \begin{DoxyVerb}          DF is COMPLEX*16 array, dimension( N )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension( M )
          solution vector X in the GLM problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension( P )
          solution vector U in the GLM problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION
          The test ratio:
                           norm( d - A*x - B*u )
            RESULT = -----------------------------------------
                     (norm(A)+norm(B))*(norm(x)+norm(u))*EPS\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga66843d0b4fb7bdf9641534ed86711b55}{}\index{complex16@{complex16}!zgqrts@{zgqrts}}
\index{zgqrts@{zgqrts}!complex16@{complex16}}
\subsubsection[{zgqrts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zgqrts (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+F, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{Q, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{R, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{T, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+W\+K, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U\+B, }
\item[{{\bf complex}$\ast$16, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 4 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga66843d0b4fb7bdf9641534ed86711b55}


{\bfseries Z\+G\+Q\+R\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGQRTS tests ZGGQRF, which computes the GQR factorization of an
 N-by-M matrix A and a N-by-P matrix B: A = Q*R and B = Q*T*Z.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of rows of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of columns of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of columns of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,M)
          The N-by-M matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (LDA,N)
          Details of the GQR factorization of A and B, as returned
          by ZGGQRF, see CGGQRF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDA,N)
          The M-by-M unitary matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is COMPLEX*16 array, dimension (LDA,MAX(M,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+A} & \begin{DoxyVerb}          TAUA is COMPLEX*16 array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by ZGGQRF.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,P)
          On entry, the N-by-P matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by ZGGQRF, see CGGQRF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension (LDB,P)
          The P-by-P unitary matrix Z.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is COMPLEX*16 array, dimension (LDB,max(P,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+K} & \begin{DoxyVerb}          BWK is COMPLEX*16 array, dimension (LDB,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+B} & \begin{DoxyVerb}          TAUB is COMPLEX*16 array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by DGGRQF.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK, LWORK >= max(N,M,P)**2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (max(N,M,P))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - Q'*A ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Z - Q'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( M*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga52fe5c26c3ab6431adb83d9bba8b4eeb}{}\index{complex16@{complex16}!zgrqts@{zgrqts}}
\index{zgrqts@{zgrqts}!complex16@{complex16}}
\subsubsection[{zgrqts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zgrqts (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+F, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{Q, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{R, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{Z, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{T, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+W\+K, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U\+B, }
\item[{{\bf complex}$\ast$16, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 4 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga52fe5c26c3ab6431adb83d9bba8b4eeb}


{\bfseries Z\+G\+R\+Q\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGRQTS tests ZGGRQF, which computes the GRQ factorization of an
 M-by-N matrix A and a P-by-N matrix B: A = R*Q and B = Z*T*Q.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The M-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (LDA,N)
          Details of the GRQ factorization of A and B, as returned
          by ZGGRQF, see CGGRQF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDA,N)
          The N-by-N unitary matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is COMPLEX*16 array, dimension (LDA,MAX(M,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+A} & \begin{DoxyVerb}          TAUA is COMPLEX*16 array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by DGGQRC.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,N)
          On entry, the P-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by ZGGRQF, see CGGRQF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is DOUBLE PRECISION array, dimension (LDB,P)
          The P-by-P unitary matrix Z.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is COMPLEX*16 array, dimension (LDB,max(P,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+K} & \begin{DoxyVerb}          BWK is COMPLEX*16 array, dimension (LDB,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+B} & \begin{DoxyVerb}          TAUB is COMPLEX*16 array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by DGGRQF.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK, LWORK >= max(M,P,N)**2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - A*Q' ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Q - Z'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( N*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga13b64eda7bfa37b59a8daa81990c42c8}{}\index{complex16@{complex16}!zgsvts@{zgsvts}}
\index{zgsvts@{zgsvts}!complex16@{complex16}}
\subsubsection[{zgsvts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zgsvts (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+F, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldr, $\ast$ )}]{R, }
\item[{integer}]{L\+D\+R, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf complex}$\ast$16, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 6 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga13b64eda7bfa37b59a8daa81990c42c8}


{\bfseries Z\+G\+S\+V\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZGSVTS tests ZGGSVD, which computes the GSVD of an M-by-N matrix A
 and a P-by-N matrix B:
              U'*A*Q = D1*R and V'*B*Q = D2*R.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,M)
          The M-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (LDA,N)
          Details of the GSVD of A and B, as returned by ZGGSVD,
          see ZGGSVD for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A and AF.
          LDA >= max( 1,M ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,P)
          On entry, the P-by-N matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (LDB,N)
          Details of the GSVD of A and B, as returned by ZGGSVD,
          see ZGGSVD for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B and BF.
          LDB >= max(1,P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension(LDU,M)
          The M by M unitary matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U. LDU >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension(LDV,M)
          The P by P unitary matrix V.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of the array V. LDV >= max(1,P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension(LDQ,N)
          The N by N unitary matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q. LDQ >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is DOUBLE PRECISION array, dimension (N)

          The generalized singular value pairs of A and B, the
          ``diagonal'' matrices D1 and D2 are constructed from
          ALPHA and BETA, see subroutine ZGGSVD for details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is COMPLEX*16 array, dimension(LDQ,N)
          The upper triangular matrix R.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+R} & \begin{DoxyVerb}          LDR is INTEGER
          The leading dimension of the array R. LDR >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK,
          LWORK >= max(M,P,N)*max(M,P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (max(M,P,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (5)
          The test ratios:
          RESULT(1) = norm( U'*A*Q - D1*R ) / ( MAX(M,N)*norm(A)*ULP)
          RESULT(2) = norm( V'*B*Q - D2*R ) / ( MAX(P,N)*norm(B)*ULP)
          RESULT(3) = norm( I - U'*U ) / ( M*ULP )
          RESULT(4) = norm( I - V'*V ) / ( P*ULP )
          RESULT(5) = norm( I - Q'*Q ) / ( N*ULP )
          RESULT(6) = 0        if ALPHA is in decreasing order;
                    = ULPINV   otherwise.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaa47ecbf426a7802083f1a164e1525005}{}\index{complex16@{complex16}!zhbt21@{zhbt21}}
\index{zhbt21@{zhbt21}!complex16@{complex16}}
\subsubsection[{zhbt21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zhbt21 (
\begin{DoxyParamCaption}
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+A, }
\item[{integer}]{K\+S, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaa47ecbf426a7802083f1a164e1525005}


{\bfseries Z\+H\+B\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZHBT21  generally checks a decomposition of the form

         A = U S UC>
 where * means conjugate transpose, A is hermitian banded, U is
 unitary, and S is diagonal (if KS=0) or symmetric
 tridiagonal (if KS=1).

 Specifically:

         RESULT(1) = | A - U S U* | / ( |A| n ulp ) *andC>         RESULT(2) = | I - UU* | / ( n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, ZHBT21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+A} & \begin{DoxyVerb}          KA is INTEGER
          The bandwidth of the matrix A.  It must be at least zero.  If
          it is larger than N-1, then max( 0, N-1 ) will be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+S} & \begin{DoxyVerb}          KS is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          hermitian, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least min( KA, N-1 ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KS=0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, N)
          The unitary matrix in the decomposition, expressed as a
          dense matrix (i.e., not as a product of Householder
          transformations, Givens transformations, etc.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gab79dcd8016959527ea3d7137912e932d}{}\index{complex16@{complex16}!zhet21@{zhet21}}
\index{zhet21@{zhet21}!complex16@{complex16}}
\subsubsection[{zhet21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zhet21 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gab79dcd8016959527ea3d7137912e932d}


{\bfseries Z\+H\+E\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZHET21 generally checks a decomposition of the form

    A = U S UC>
 where * means conjugate transpose, A is hermitian, U is unitary, and
 S is diagonal (if KBAND=0) or (real) symmetric tridiagonal (if
 KBAND=1).

 If ITYPE=1, then U is represented as a dense matrix; otherwise U is
 expressed as a product of Householder transformations, whose vectors
 are stored in the array "V" and whose scaling constants are in "TAU".
 We shall use the letter "V" to refer to the product of Householder
 transformations (which should be equal to U).

 Specifically, if ITYPE=1, then:

    RESULT(1) = | A - U S U* | / ( |A| n ulp ) *andC>    RESULT(2) = | I - UU* | / ( n ulp )

 If ITYPE=2, then:

    RESULT(1) = | A - V S V* | / ( |A| n ulp )

 If ITYPE=3, then:

    RESULT(1) = | I - UV* | / ( n ulp )

 For ITYPE > 1, the transformation U is expressed as a product
 V = H(1)...H(n-2),  where H(j) = I  -  tau(j) v(j) v(j)C> and each
 vector v(j) has its first j elements 0 and the remaining n-j elements
 stored in V(j+1:n,j).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense unitary matrix:
             RESULT(1) = | A - U S U* | / ( |A| n ulp )   *andC>             RESULT(2) = | I - UU* | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V* | / ( |A| n ulp )

          3: U expressed both as a dense unitary matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - UV* | / ( n ulp )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, ZHET21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          hermitian, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the unitary matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension (LDV, N)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the unitary matrix
          in the decomposition.  If UPLO='L', then the vectors are in
          the lower triangle, if UPLO='U', then in the upper
          triangle.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is COMPLEX*16 array, dimension (N)
          If ITYPE >= 2, then TAU(j) is the scalar factor of
          v(j) v(j)* in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE < 2, then TAU is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (2*N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gaf5ac8f81c63bc01215d2523af67f0a9f}{}\index{complex16@{complex16}!zhet22@{zhet22}}
\index{zhet22@{zhet22}!complex16@{complex16}}
\subsubsection[{zhet22}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zhet22 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gaf5ac8f81c63bc01215d2523af67f0a9f}


{\bfseries Z\+H\+E\+T22} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      ZHET22  generally checks a decomposition of the form

              A U = U S

      where A is complex Hermitian, the columns of U are orthonormal,
      and S is diagonal (if KBAND=0) or symmetric tridiagonal (if
      KBAND=1).  If ITYPE=1, then U is represented as a dense matrix,
      otherwise the U is expressed as a product of Householder
      transformations, whose vectors are stored in the array "V" and
      whose scaling constants are in "TAU"; we shall use the letter
      "V" to refer to the product of Householder transformations
      (which should be equal to U).

      Specifically, if ITYPE=1, then:

              RESULT(1) = | U' A U - S | / ( |A| m ulp ) *andC>              RESULT(2) = | I - U'U | / ( m ulp )\end{DoxyVerb}
 \begin{DoxyVerb}  ITYPE   INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC>             RESULT(2) = | I - UU' | / ( n ulp )

  UPLO    CHARACTER
          If UPLO='U', the upper triangle of A will be used and the
          (strictly) lower triangle will not be referenced.  If
          UPLO='L', the lower triangle of A will be used and the
          (strictly) upper triangle will not be referenced.
          Not modified.

  N       INTEGER
          The size of the matrix.  If it is zero, ZHET22 does nothing.
          It must be at least zero.
          Not modified.

  M       INTEGER
          The number of columns of U.  If it is zero, ZHET22 does
          nothing.  It must be at least zero.
          Not modified.

  KBAND   INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.
          Not modified.

  A       COMPLEX*16 array, dimension (LDA , N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.
          Not modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.
          Not modified.

  D       DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.
          Not modified.

  E       DOUBLE PRECISION array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is ignored, E(2) is the (1,2) and (2,1) element, etc.
          Not referenced if KBAND=0.
          Not modified.

  U       COMPLEX*16 array, dimension (LDU, N)
          If ITYPE=1, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.
          Not modified.

  LDU     INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.
          Not modified.

  V       COMPLEX*16 array, dimension (LDV, N)
          If ITYPE=2 or 3, the lower triangle of this array contains
          the Householder vectors used to describe the orthogonal
          matrix in the decomposition.  If ITYPE=1, then it is not
          referenced.
          Not modified.

  LDV     INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.
          Not modified.

  TAU     COMPLEX*16 array, dimension (N)
          If ITYPE >= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE < 2, then TAU is not referenced.
          Not modified.

  WORK    COMPLEX*16 array, dimension (2*N**2)
          Workspace.
          Modified.

  RWORK   DOUBLE PRECISION array, dimension (N)
          Workspace.
          Modified.

  RESULT  DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if LDU is at least N.
          Modified.\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gacb29438aa9a7dd450f3db905ef4a8daa}{}\index{complex16@{complex16}!zhpt21@{zhpt21}}
\index{zhpt21@{zhpt21}!complex16@{complex16}}
\subsubsection[{zhpt21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zhpt21 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{A\+P, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{V\+P, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{T\+A\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gacb29438aa9a7dd450f3db905ef4a8daa}


{\bfseries Z\+H\+P\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZHPT21  generally checks a decomposition of the form

         A = U S UC>
 where * means conjugate transpose, A is hermitian, U is
 unitary, and S is diagonal (if KBAND=0) or (real) symmetric
 tridiagonal (if KBAND=1).  If ITYPE=1, then U is represented as
 a dense matrix, otherwise the U is expressed as a product of
 Householder transformations, whose vectors are stored in the
 array "V" and whose scaling constants are in "TAU"; we shall
 use the letter "V" to refer to the product of Householder
 transformations (which should be equal to U).

 Specifically, if ITYPE=1, then:

         RESULT(1) = | A - U S U* | / ( |A| n ulp ) *andC>         RESULT(2) = | I - UU* | / ( n ulp )

 If ITYPE=2, then:

         RESULT(1) = | A - V S V* | / ( |A| n ulp )

 If ITYPE=3, then:

         RESULT(1) = | I - UV* | / ( n ulp )

 Packed storage means that, for example, if UPLO='U', then the columns
 of the upper triangle of A are stored one after another, so that
 A(1,j+1) immediately follows A(j,j) in the array AP.  Similarly, if
 UPLO='L', then the columns of the lower triangle of A are stored one
 after another in AP, so that A(j+1,j+1) immediately follows A(n,j)
 in the array AP.  This means that A(i,j) is stored in:

    AP( i + j*(j-1)/2 )                 if UPLO='U'

    AP( i + (2*n-j)*(j-1)/2 )           if UPLO='L'

 The array VP bears the same relation to the matrix V that A does to
 AP.

 For ITYPE > 1, the transformation U is expressed as a product
 of Householder transformations:

    If UPLO='U', then  V = H(n-1)...H(1),  where

        H(j) = I  -  tau(j) v(j) v(j)C>
    and the first j-1 elements of v(j) are stored in V(1:j-1,j+1),
    (i.e., VP( j*(j+1)/2 + 1 : j*(j+1)/2 + j-1 ) ),
    the j-th element is 1, and the last n-j elements are 0.

    If UPLO='L', then  V = H(1)...H(n-1),  where

        H(j) = I  -  tau(j) v(j) v(j)C>
    and the first j elements of v(j) are 0, the (j+1)-st is 1, and the
    (j+2)-nd through n-th elements are stored in V(j+2:n,j) (i.e.,
    in VP( (2*n-j)*(j-1)/2 + j+2 : (2*n-j)*(j-1)/2 + n ) .)\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense unitary matrix:
             RESULT(1) = | A - U S U* | / ( |A| n ulp )   *andC>             RESULT(2) = | I - UU* | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V* | / ( |A| n ulp )

          3: U expressed both as a dense unitary matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - UV* | / ( n ulp )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, ZHPT21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+P} & \begin{DoxyVerb}          AP is COMPLEX*16 array, dimension (N*(N+1)/2)
          The original (unfactored) matrix.  It is assumed to be
          hermitian, and contains the columns of just the upper
          triangle (UPLO='U') or only the lower triangle (UPLO='L'),
          packed one after another.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is DOUBLE PRECISION array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the unitary matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V\+P} & \begin{DoxyVerb}          VP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the unitary matrix
          in the decomposition, as described in purpose.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is COMPLEX*16 array, dimension (N)
          If ITYPE >= 2, then TAU(j) is the scalar factor of
          v(j) v(j)* in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE < 2, then TAU is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (N**2)
          Workspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)
          Workspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga0fb275b7e7ca95861483e96a8865baeb}{}\index{complex16@{complex16}!zhst01@{zhst01}}
\index{zhst01@{zhst01}!complex16@{complex16}}
\subsubsection[{zhst01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zhst01 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{I\+L\+O, }
\item[{integer}]{I\+H\+I, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldh, $\ast$ )}]{H, }
\item[{integer}]{L\+D\+H, }
\item[{{\bf complex}$\ast$16, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{{\bf complex}$\ast$16, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga0fb275b7e7ca95861483e96a8865baeb}


{\bfseries Z\+H\+S\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZHST01 tests the reduction of a general matrix A to upper Hessenberg
 form:  A = Q*H*Q'.  Two test ratios are computed;

 RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
 RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )

 The matrix Q is assumed to be given explicitly as it would be
 following ZGEHRD + ZUNGHR.

 In this version, ILO and IHI are not used, but they could be used
 to save some work if this is desired.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+L\+O} & \begin{DoxyVerb}          ILO is INTEGER\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+H\+I} & \begin{DoxyVerb}          IHI is INTEGER

          A is assumed to be upper triangular in rows and columns
          1:ILO-1 and IHI+1:N, so Q differs from the identity only in
          rows and columns ILO+1:IHI.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The original n by n matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em H} & \begin{DoxyVerb}          H is COMPLEX*16 array, dimension (LDH,N)
          The upper Hessenberg matrix H from the reduction A = Q*H*Q'
          as computed by ZGEHRD.  H is assumed to be zero below the
          first subdiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+H} & \begin{DoxyVerb}          LDH is INTEGER
          The leading dimension of the array H.  LDH >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q} & \begin{DoxyVerb}          Q is COMPLEX*16 array, dimension (LDQ,N)
          The orthogonal matrix Q from the reduction A = Q*H*Q' as
          computed by ZGEHRD + ZUNGHR.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The length of the array WORK.  LWORK >= 2*N*N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
          RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga817c8e2419ed8d953bad714eb82d4c54}{}\index{complex16@{complex16}!zlarfy@{zlarfy}}
\index{zlarfy@{zlarfy}!complex16@{complex16}}
\subsubsection[{zlarfy}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zlarfy (
\begin{DoxyParamCaption}
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{V, }
\item[{integer}]{I\+N\+C\+V, }
\item[{{\bf complex}$\ast$16}]{T\+A\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga817c8e2419ed8d953bad714eb82d4c54}


{\bfseries Z\+L\+A\+R\+F\+Y} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZLARFY applies an elementary reflector, or Householder matrix, H,
 to an n x n Hermitian matrix C, from both the left and the right.

 H is represented in the form

    H = I - tau * v * v'

 where  tau  is a scalar and  v  is a vector.

 If  tau  is  zero, then  H  is taken to be the unit matrix.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix C is stored.
          = 'U':  Upper triangle
          = 'L':  Lower triangle\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of rows and columns of the matrix C.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension
                  (1 + (N-1)*abs(INCV))
          The vector v as described above.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+N\+C\+V} & \begin{DoxyVerb}          INCV is INTEGER
          The increment between successive elements of v.  INCV must
          not be zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is COMPLEX*16
          The value tau as described above.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em C} & \begin{DoxyVerb}          C is COMPLEX*16 array, dimension (LDC, N)
          On entry, the matrix C.
          On exit, C is overwritten by H * C * H'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of the array C.  LDC >= max( 1, N ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (N)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gadf62e94d7d1eba45c66a510ca52f9802}{}\index{complex16@{complex16}!zlarhs@{zlarhs}}
\index{zlarhs@{zlarhs}!complex16@{complex16}}
\subsubsection[{zlarhs}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zlarhs (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{character}]{X\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{character}]{T\+R\+A\+N\+S, }
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{integer}]{K\+L, }
\item[{integer}]{K\+U, }
\item[{integer}]{N\+R\+H\+S, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldx, $\ast$ )}]{X, }
\item[{integer}]{L\+D\+X, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gadf62e94d7d1eba45c66a510ca52f9802}


{\bfseries Z\+L\+A\+R\+H\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZLARHS chooses a set of NRHS random solution vectors and sets
 up the right hand sides for the linear system
    op( A ) * X = B,
 where op( A ) may be A, A**T (transpose of A), or A**H (conjugate
 transpose of A).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The type of the complex matrix A.  PATH may be given in any
          combination of upper and lower case.  Valid paths include
             xGE:  General m x n matrix
             xGB:  General banded matrix
             xPO:  Hermitian positive definite, 2-D storage
             xPP:  Hermitian positive definite packed
             xPB:  Hermitian positive definite banded
             xHE:  Hermitian indefinite, 2-D storage
             xHP:  Hermitian indefinite packed
             xHB:  Hermitian indefinite banded
             xSY:  Symmetric indefinite, 2-D storage
             xSP:  Symmetric indefinite packed
             xSB:  Symmetric indefinite banded
             xTR:  Triangular
             xTP:  Triangular packed
             xTB:  Triangular banded
             xQR:  General m x n matrix
             xLQ:  General m x n matrix
             xQL:  General m x n matrix
             xRQ:  General m x n matrix
          where the leading character indicates the precision.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em X\+T\+Y\+P\+E} & \begin{DoxyVerb}          XTYPE is CHARACTER*1
          Specifies how the exact solution X will be determined:
          = 'N':  New solution; generate a random X.
          = 'C':  Computed; use value of X on entry.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Used only if A is symmetric or triangular; specifies whether
          the upper or lower triangular part of the matrix A is stored.
          = 'U':  Upper triangular
          = 'L':  Lower triangular\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+A\+N\+S} & \begin{DoxyVerb}          TRANS is CHARACTER*1
          Used only if A is nonsymmetric; specifies the operation
          applied to the matrix A.
          = 'N':  B := A    * X
          = 'T':  B := A**T * X
          = 'C':  B := A**H * X\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+L} & \begin{DoxyVerb}          KL is INTEGER
          Used only if A is a band matrix; specifies the number of
          subdiagonals of A if A is a general band matrix or if A is
          symmetric or triangular and UPLO = 'L'; specifies the number
          of superdiagonals of A if A is symmetric or triangular and
          UPLO = 'U'.  0 <= KL <= M-1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+U} & \begin{DoxyVerb}          KU is INTEGER
          Used only if A is a general band matrix or if A is
          triangular.

          If PATH = xGB, specifies the number of superdiagonals of A,
          and 0 <= KU <= N-1.

          If PATH = xTR, xTP, or xTB, specifies whether or not the
          matrix has unit diagonal:
          = 1:  matrix has non-unit diagonal (default)
          = 2:  matrix has unit diagonal\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of right hand side vectors in the system A*X = B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The test matrix whose type is given by PATH.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.
          If PATH = xGB, LDA >= KL+KU+1.
          If PATH = xPB, xSB, xHB, or xTB, LDA >= KL+1.
          Otherwise, LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em X} & \begin{DoxyVerb}          X is or output) COMPLEX*16 array, dimension (LDX,NRHS)
          On entry, if XTYPE = 'C' (for 'Computed'), then X contains
          the exact solution to the system of linear equations.
          On exit, if XTYPE = 'N' (for 'New'), then X is initialized
          with random values.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX >= max(1,N); if TRANS = 'T', LDX >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,NRHS)
          The right hand side vector(s) for the system of equations,
          computed from B = op(A) * X, where op(A) is determined by
          TRANS.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  If TRANS = 'N',
          LDB >= max(1,M); if TRANS = 'T', LDB >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          The seed vector for the random number generator (used in
          ZLATMS).  Modified on exit.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga4f20b187dff04372757a4008eecbc21f}{}\index{complex16@{complex16}!zlatm4@{zlatm4}}
\index{zlatm4@{zlatm4}!complex16@{complex16}}
\subsubsection[{zlatm4}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zlatm4 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{integer}]{N, }
\item[{integer}]{N\+Z1, }
\item[{integer}]{N\+Z2, }
\item[{{\bf logical}}]{R\+S\+I\+G\+N, }
\item[{double {\bf precision}}]{A\+M\+A\+G\+N, }
\item[{double {\bf precision}}]{R\+C\+O\+N\+D, }
\item[{double {\bf precision}}]{T\+R\+I\+A\+N\+G, }
\item[{integer}]{I\+D\+I\+S\+T, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga4f20b187dff04372757a4008eecbc21f}


{\bfseries Z\+L\+A\+T\+M4} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZLATM4 generates basic square matrices, which may later be
 multiplied by others in order to produce test matrices.  It is
 intended mainly to be used to test the generalized eigenvalue
 routines.

 It first generates the diagonal and (possibly) subdiagonal,
 according to the value of ITYPE, NZ1, NZ2, RSIGN, AMAGN, and RCOND.
 It then fills in the upper triangle with random numbers, if TRIANG is
 non-zero.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          The "type" of matrix on the diagonal and sub-diagonal.
          If ITYPE < 0, then type abs(ITYPE) is generated and then
             swapped end for end (A(I,J) := A'(N-J,N-I).)  See also
             the description of AMAGN and RSIGN.

          Special types:
          = 0:  the zero matrix.
          = 1:  the identity.
          = 2:  a transposed Jordan block.
          = 3:  If N is odd, then a k+1 x k+1 transposed Jordan block
                followed by a k x k identity block, where k=(N-1)/2.
                If N is even, then k=(N-2)/2, and a zero diagonal entry
                is tacked onto the end.

          Diagonal types.  The diagonal consists of NZ1 zeros, then
             k=N-NZ1-NZ2 nonzeros.  The subdiagonal is zero.  ITYPE
             specifies the nonzero diagonal entries as follows:
          = 4:  1, ..., k
          = 5:  1, RCOND, ..., RCOND
          = 6:  1, ..., 1, RCOND
          = 7:  1, a, a^2, ..., a^(k-1)=RCOND
          = 8:  1, 1-d, 1-2*d, ..., 1-(k-1)*d=RCOND
          = 9:  random numbers chosen from (RCOND,1)
          = 10: random numbers with distribution IDIST (see ZLARND.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+Z1} & \begin{DoxyVerb}          NZ1 is INTEGER
          If abs(ITYPE) > 3, then the first NZ1 diagonal entries will
          be zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+Z2} & \begin{DoxyVerb}          NZ2 is INTEGER
          If abs(ITYPE) > 3, then the last NZ2 diagonal entries will
          be zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+S\+I\+G\+N} & \begin{DoxyVerb}          RSIGN is LOGICAL
          = .TRUE.:  The diagonal and subdiagonal entries will be
                     multiplied by random numbers of magnitude 1.
          = .FALSE.: The diagonal and subdiagonal entries will be
                     left as they are (usually non-negative real.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+M\+A\+G\+N} & \begin{DoxyVerb}          AMAGN is DOUBLE PRECISION
          The diagonal and subdiagonal entries will be multiplied by
          AMAGN.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+O\+N\+D} & \begin{DoxyVerb}          RCOND is DOUBLE PRECISION
          If abs(ITYPE) > 4, then the smallest diagonal entry will be
          RCOND.  RCOND must be between 0 and 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+I\+A\+N\+G} & \begin{DoxyVerb}          TRIANG is DOUBLE PRECISION
          The entries above the diagonal will be random numbers with
          magnitude bounded by TRIANG (i.e., random numbers multiplied
          by TRIANG.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+D\+I\+S\+T} & \begin{DoxyVerb}          IDIST is INTEGER
          On entry, DIST specifies the type of distribution to be used
          to generate a random matrix .
          = 1: real and imaginary parts each UNIFORM( 0, 1 )
          = 2: real and imaginary parts each UNIFORM( -1, 1 )
          = 3: real and imaginary parts each NORMAL( 0, 1 )
          = 4: complex number uniform in DISK( 0, 1 )\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator.  The values of ISEED are changed on exit, and can
          be used in the next call to ZLATM4 to continue the same
          random number sequence.
          Note: ISEED(4) should be odd, for the random number generator
          used at present.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          Array to be computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          Leading dimension of A.  Must be at least 1 and at least N.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga070d0aa3531da9c4cf1187ddacfadc04}{}\index{complex16@{complex16}!zlctes@{zlctes}}
\index{zlctes@{zlctes}!complex16@{complex16}}
\subsubsection[{zlctes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf logical} {\bf function} zlctes (
\begin{DoxyParamCaption}
\item[{{\bf complex}$\ast$16}]{Z, }
\item[{{\bf complex}$\ast$16}]{D}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga070d0aa3531da9c4cf1187ddacfadc04}


{\bfseries Z\+L\+C\+T\+E\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZLCTES returns .TRUE. if the eigenvalue Z/D is to be selected
 (specifically, in this subroutine, if the real part of the
 eigenvalue is negative), and otherwise it returns .FALSE..

 It is used by the test routine ZDRGES to test whether the driver
 routine ZGGES succesfully sorts eigenvalues.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16
          The numerator part of a complex eigenvalue Z/D.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is COMPLEX*16
          The denominator part of a complex eigenvalue Z/D.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gafb3b6ea91b75f8ed29914e8e7169adb3}{}\index{complex16@{complex16}!zlctsx@{zlctsx}}
\index{zlctsx@{zlctsx}!complex16@{complex16}}
\subsubsection[{zlctsx}]{\setlength{\rightskip}{0pt plus 5cm}{\bf logical} {\bf function} zlctsx (
\begin{DoxyParamCaption}
\item[{{\bf complex}$\ast$16}]{A\+L\+P\+H\+A, }
\item[{{\bf complex}$\ast$16}]{B\+E\+T\+A}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gafb3b6ea91b75f8ed29914e8e7169adb3}


{\bfseries Z\+L\+C\+T\+S\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} This function is used to determine what eigenvalues will be
 selected.  If this is part of the test driver ZDRGSX, do not
 change the code UNLESS you are testing input examples and not
 using the built-in examples.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is COMPLEX*16\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is COMPLEX*16

          parameters to decide whether the pair (ALPHA, BETA) is
          selected.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga67fc2605422315893d6fec201c155a59}{}\index{complex16@{complex16}!zlsets@{zlsets}}
\index{zlsets@{zlsets}!complex16@{complex16}}
\subsubsection[{zlsets}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zlsets (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A\+F, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{C, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{C\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{D, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{D\+F, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{X, }
\item[{{\bf complex}$\ast$16, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga67fc2605422315893d6fec201c155a59}


{\bfseries Z\+L\+S\+E\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZLSETS tests ZGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA,N)
          The M-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is COMPLEX*16 array, dimension (LDA,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF, Q and R.
          LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB,N)
          The P-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is COMPLEX*16 array, dimension (LDB,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF, V and S.
          LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em C} & \begin{DoxyVerb}          C is COMPLEX*16 array, dimension( M )
          the vector C in the LSE problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C\+F} & \begin{DoxyVerb}          CF is COMPLEX*16 array, dimension( M )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is COMPLEX*16 array, dimension( P )
          the vector D in the LSE problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+F} & \begin{DoxyVerb}          DF is COMPLEX*16 array, dimension( P )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is COMPLEX*16 array, dimension( N )
          solution vector X in the LSE problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The test ratios:
            RESULT(1) = norm( A*x - c )/ norm(A)*norm(X)*EPS
            RESULT(2) = norm( B*x - d )/ norm(B)*norm(X)*EPS\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga63eabd833fa379aa63dafb0a57392fe4}{}\index{complex16@{complex16}!zsbmv@{zsbmv}}
\index{zsbmv@{zsbmv}!complex16@{complex16}}
\subsubsection[{zsbmv}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zsbmv (
\begin{DoxyParamCaption}
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K, }
\item[{{\bf complex}$\ast$16}]{A\+L\+P\+H\+A, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{X, }
\item[{integer}]{I\+N\+C\+X, }
\item[{{\bf complex}$\ast$16}]{B\+E\+T\+A, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{Y, }
\item[{integer}]{I\+N\+C\+Y}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga63eabd833fa379aa63dafb0a57392fe4}


{\bfseries Z\+S\+B\+M\+V} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZSBMV  performs the matrix-vector  operation

    y := alpha*A*x + beta*y,

 where alpha and beta are scalars, x and y are n element vectors and
 A is an n by n symmetric band matrix, with k super-diagonals.\end{DoxyVerb}
 \begin{DoxyVerb}  UPLO   - CHARACTER*1
           On entry, UPLO specifies whether the upper or lower
           triangular part of the band matrix A is being supplied as
           follows:

              UPLO = 'U' or 'u'   The upper triangular part of A is
                                  being supplied.

              UPLO = 'L' or 'l'   The lower triangular part of A is
                                  being supplied.

           Unchanged on exit.

  N      - INTEGER
           On entry, N specifies the order of the matrix A.
           N must be at least zero.
           Unchanged on exit.

  K      - INTEGER
           On entry, K specifies the number of super-diagonals of the
           matrix A. K must satisfy  0 .le. K.
           Unchanged on exit.

  ALPHA  - COMPLEX*16
           On entry, ALPHA specifies the scalar alpha.
           Unchanged on exit.

  A      - COMPLEX*16 array, dimension( LDA, N )
           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
           by n part of the array A must contain the upper triangular
           band part of the symmetric matrix, supplied column by
           column, with the leading diagonal of the matrix in row
           ( k + 1 ) of the array, the first super-diagonal starting at
           position 2 in row k, and so on. The top left k by k triangle
           of the array A is not referenced.
           The following program segment will transfer the upper
           triangular part of a symmetric band matrix from conventional
           full matrix storage to band storage:

                 DO 20, J = 1, N
                    M = K + 1 - J
                    DO 10, I = MAX( 1, J - K ), J
                       A( M + I, J ) = matrix( I, J )
              10    CONTINUE
              20 CONTINUE

           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
           by n part of the array A must contain the lower triangular
           band part of the symmetric matrix, supplied column by
           column, with the leading diagonal of the matrix in row 1 of
           the array, the first sub-diagonal starting at position 1 in
           row 2, and so on. The bottom right k by k triangle of the
           array A is not referenced.
           The following program segment will transfer the lower
           triangular part of a symmetric band matrix from conventional
           full matrix storage to band storage:

                 DO 20, J = 1, N
                    M = 1 - J
                    DO 10, I = J, MIN( N, J + K )
                       A( M + I, J ) = matrix( I, J )
              10    CONTINUE
              20 CONTINUE

           Unchanged on exit.

  LDA    - INTEGER
           On entry, LDA specifies the first dimension of A as declared
           in the calling (sub) program. LDA must be at least
           ( k + 1 ).
           Unchanged on exit.

  X      - COMPLEX*16 array, dimension at least
           ( 1 + ( N - 1 )*abs( INCX ) ).
           Before entry, the incremented array X must contain the
           vector x.
           Unchanged on exit.

  INCX   - INTEGER
           On entry, INCX specifies the increment for the elements of
           X. INCX must not be zero.
           Unchanged on exit.

  BETA   - COMPLEX*16
           On entry, BETA specifies the scalar beta.
           Unchanged on exit.

  Y      - COMPLEX*16 array, dimension at least
           ( 1 + ( N - 1 )*abs( INCY ) ).
           Before entry, the incremented array Y must contain the
           vector y. On exit, Y is overwritten by the updated vector y.

  INCY   - INTEGER
           On entry, INCY specifies the increment for the elements of
           Y. INCY must not be zero.
           Unchanged on exit.\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga96a59c0d9bd47e0ed39035f813b7b684}{}\index{complex16@{complex16}!zsgt01@{zsgt01}}
\index{zsgt01@{zsgt01}!complex16@{complex16}}
\subsubsection[{zsgt01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zsgt01 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{{\bf complex}$\ast$16, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}$\ast$16, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{{\bf complex}$\ast$16, dimension( ldz, $\ast$ )}]{Z, }
\item[{integer}]{L\+D\+Z, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{D, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga96a59c0d9bd47e0ed39035f813b7b684}


{\bfseries Z\+S\+G\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} CDGT01 checks a decomposition of the form

    A Z   =  B Z D or
    A B Z =  Z D or
    B A Z =  Z D

 where A is a Hermitian matrix, B is Hermitian positive definite,
 Z is unitary, and D is diagonal.

 One of the following test ratios is computed:

 ITYPE = 1:  RESULT(1) = | A Z - B Z D | / ( |A| |Z| n ulp )

 ITYPE = 2:  RESULT(1) = | A B Z - Z D | / ( |A| |Z| n ulp )

 ITYPE = 3:  RESULT(1) = | B A Z - Z D | / ( |A| |Z| n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          The form of the Hermitian generalized eigenproblem.
          = 1:  A*z = (lambda)*B*z
          = 2:  A*B*z = (lambda)*z
          = 3:  B*A*z = (lambda)*z\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          Hermitian matrices A and B is stored.
          = 'U':  Upper triangular
          = 'L':  Lower triangular\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of eigenvalues found.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX*16 array, dimension (LDA, N)
          The original Hermitian matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX*16 array, dimension (LDB, N)
          The original Hermitian positive definite matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16 array, dimension (LDZ, M)
          The computed eigenvectors of the generalized eigenproblem.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Z} & \begin{DoxyVerb}          LDZ is INTEGER
          The leading dimension of the array Z.  LDZ >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is DOUBLE PRECISION array, dimension (M)
          The computed eigenvalues of the generalized eigenproblem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (N*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (1)
          The test ratio as described above.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga5f37daf9fec134eae34b3575fff5e7c6}{}\index{complex16@{complex16}!zslect@{zslect}}
\index{zslect@{zslect}!complex16@{complex16}}
\subsubsection[{zslect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf logical} {\bf function} zslect (
\begin{DoxyParamCaption}
\item[{{\bf complex}$\ast$16}]{Z}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga5f37daf9fec134eae34b3575fff5e7c6}


{\bfseries Z\+S\+L\+E\+C\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZSLECT returns .TRUE. if the eigenvalue Z is to be selected,
 otherwise it returns .FALSE.
 It is used by ZCHK41 to test if ZGEES succesfully sorts eigenvalues,
 and by ZCHK43 to test if ZGEESX succesfully sorts eigenvalues.

 The common block /SSLCT/ controls how eigenvalues are selected.
 If SELOPT = 0, then ZSLECT return .TRUE. when real(Z) is less than
 zero, and .FALSE. otherwise.
 If SELOPT is at least 1, ZSLECT returns SELVAL(SELOPT) and adds 1
 to SELOPT, cycling back to 1 at SELMAX.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Z} & \begin{DoxyVerb}          Z is COMPLEX*16
          The eigenvalue Z.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga648d5fcaa302d5769d588aaa6f736fe8}{}\index{complex16@{complex16}!zstt21@{zstt21}}
\index{zstt21@{zstt21}!complex16@{complex16}}
\subsubsection[{zstt21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zstt21 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{A\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{A\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga648d5fcaa302d5769d588aaa6f736fe8}


{\bfseries Z\+S\+T\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZSTT21  checks a decomposition of the form

    A = U S UC>
 where * means conjugate transpose, A is real symmetric tridiagonal,
 U is unitary, and S is real and diagonal (if KBAND=0) or symmetric
 tridiagonal (if KBAND=1).  Two tests are performed:

    RESULT(1) = | A - U S U* | / ( |A| n ulp )

    RESULT(2) = | I - UU* | / ( n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, ZSTT21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+D} & \begin{DoxyVerb}          AD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be real symmetric tridiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+E} & \begin{DoxyVerb}          AE is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be symmetric tridiagonal.  AE(1) is the (1,2)
          and (2,1) element, AE(2) is the (2,3) and (3,2) element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+D} & \begin{DoxyVerb}          SD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the real (symmetric tri-) diagonal matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+E} & \begin{DoxyVerb}          SE is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is the
          (1,2) and (2,1) element, SE(2) is the (2,3) and (3,2)
          element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU, N)
          The unitary matrix in the decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_ga06f5cd0527f88e4aed3bdbf084d050a9}{}\index{complex16@{complex16}!zstt22@{zstt22}}
\index{zstt22@{zstt22}!complex16@{complex16}}
\subsubsection[{zstt22}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zstt22 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{A\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{A\+E, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+D, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{S\+E, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldwork, $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+D\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_ga06f5cd0527f88e4aed3bdbf084d050a9}


{\bfseries Z\+S\+T\+T22} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZSTT22  checks a set of M eigenvalues and eigenvectors,

     A U = U S

 where A is Hermitian tridiagonal, the columns of U are unitary,
 and S is diagonal (if KBAND=0) or Hermitian tridiagonal (if KBAND=1).
 Two tests are performed:

    RESULT(1) = | U* A U - S | / ( |A| m ulp )

    RESULT(2) = | I - U*U | / ( m ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, ZSTT22 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of eigenpairs to check.  If it is zero, ZSTT22
          does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is Hermitian tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+D} & \begin{DoxyVerb}          AD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be Hermitian tridiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+E} & \begin{DoxyVerb}          AE is DOUBLE PRECISION array, dimension (N)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be Hermitian tridiagonal.  AE(1) is ignored,
          AE(2) is the (1,2) and (2,1) element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+D} & \begin{DoxyVerb}          SD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (Hermitian tri-) diagonal matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+E} & \begin{DoxyVerb}          SE is DOUBLE PRECISION array, dimension (N)
          The off-diagonal of the (Hermitian tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is
          ignored, SE(2) is the (1,2) and (2,1) element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is DOUBLE PRECISION array, dimension (LDU, N)
          The unitary matrix in the decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LDWORK, M+1)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & \begin{DoxyVerb}          LDWORK is INTEGER
          The leading dimension of WORK.  LDWORK must be at least
          max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gac8d92ee1ea8c00830b42ebf4017a2ae3}{}\index{complex16@{complex16}!zunt01@{zunt01}}
\index{zunt01@{zunt01}!complex16@{complex16}}
\subsubsection[{zunt01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zunt01 (
\begin{DoxyParamCaption}
\item[{character}]{R\+O\+W\+C\+O\+L, }
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gac8d92ee1ea8c00830b42ebf4017a2ae3}


{\bfseries Z\+U\+N\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZUNT01 checks that the matrix U is unitary by computing the ratio

    RESID = norm( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = norm( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 Alternatively, if there isn't sufficient workspace to form
 I - U*U' or I - U'*U, the ratio is computed as

    RESID = abs( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = abs( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 where EPS is the machine precision.  ROWCOL is used only if m = n;
 if m > n, ROWCOL is assumed to be 'C', and if m < n, ROWCOL is
 assumed to be 'R'.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em R\+O\+W\+C\+O\+L} & \begin{DoxyVerb}          ROWCOL is CHARACTER
          Specifies whether the rows or columns of U should be checked
          for orthogonality.  Used only if M = N.
          = 'R':  Check for orthogonal rows of U
          = 'C':  Check for orthogonal columns of U\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU,N)
          The unitary matrix U.  U is checked for orthogonal columns
          if m > n or if m = n and ROWCOL = 'C'.  U is checked for
          orthogonal rows if m < n or if m = n and ROWCOL = 'R'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U.  LDU >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*N if ROWCOL = 'C' or M*M if
          ROWCOL = 'R', but the test will be done even if LWORK is 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (min(M,N))
          Used only if LWORK is large enough to use the Level 3 BLAS
          code.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is DOUBLE PRECISION
          RESID = norm( I - U * U' ) / ( n * EPS ), if ROWCOL = 'R', or
          RESID = norm( I - U' * U ) / ( m * EPS ), if ROWCOL = 'C'.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__complex16__eig_gae5e4eed24a4a8519245d586b181df38f}{}\index{complex16@{complex16}!zunt03@{zunt03}}
\index{zunt03@{zunt03}!complex16@{complex16}}
\subsubsection[{zunt03}]{\setlength{\rightskip}{0pt plus 5cm}subroutine zunt03 (
\begin{DoxyParamCaption}
\item[{character$\ast$( $\ast$ )}]{R\+C, }
\item[{integer}]{M\+U, }
\item[{integer}]{M\+V, }
\item[{integer}]{N, }
\item[{integer}]{K, }
\item[{{\bf complex}$\ast$16, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{{\bf complex}$\ast$16, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{{\bf complex}$\ast$16, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{double {\bf precision}, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{double {\bf precision}}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__complex16__eig_gae5e4eed24a4a8519245d586b181df38f}


{\bfseries Z\+U\+N\+T03} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} ZUNT03 compares two unitary matrices U and V to see if their
 corresponding rows or columns span the same spaces.  The rows are
 checked if RC = 'R', and the columns are checked if RC = 'C'.

 RESULT is the maximum of

    | V*V' - I | / ( MV ulp ), if RC = 'R', or

    | V'*V - I | / ( MV ulp ), if RC = 'C',

 and the maximum over rows (or columns) 1 to K of

    | U(i) - S*V(i) |/ ( N ulp )

 where abs(S) = 1 (chosen to minimize the expression), U(i) is the
 i-th row (column) of U, and V(i) is the i-th row (column) of V.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em R\+C} & \begin{DoxyVerb}          RC is CHARACTER*1
          If RC = 'R' the rows of U and V are to be compared.
          If RC = 'C' the columns of U and V are to be compared.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+U} & \begin{DoxyVerb}          MU is INTEGER
          The number of rows of U if RC = 'R', and the number of
          columns if RC = 'C'.  If MU = 0 ZUNT03 does nothing.
          MU must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V} & \begin{DoxyVerb}          MV is INTEGER
          The number of rows of V if RC = 'R', and the number of
          columns if RC = 'C'.  If MV = 0 ZUNT03 does nothing.
          MV must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          If RC = 'R', the number of columns in the matrices U and V,
          and if RC = 'C', the number of rows in U and V.  If N = 0
          ZUNT03 does nothing.  N must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K} & \begin{DoxyVerb}          K is INTEGER
          The number of rows or columns of U and V to compare.
          0 <= K <= max(MU,MV).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is COMPLEX*16 array, dimension (LDU,N)
          The first matrix to compare.  If RC = 'R', U is MU by N, and
          if RC = 'C', U is N by MU.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  If RC = 'R', LDU >= max(1,MU),
          and if RC = 'C', LDU >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is COMPLEX*16 array, dimension (LDV,N)
          The second matrix to compare.  If RC = 'R', V is MV by N, and
          if RC = 'C', V is N by MV.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  If RC = 'R', LDV >= max(1,MV),
          and if RC = 'C', LDV >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX*16 array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*N if RC = 'C' or M*M if RC = 'R', but
          the tests will be done even if LWORK is 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is DOUBLE PRECISION array, dimension (max(MV,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is DOUBLE PRECISION
          The value computed by the test described above.  RESULT is
          limited to 1/ulp to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          0  indicates a successful exit
          -k indicates the k-th parameter had an illegal value\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
