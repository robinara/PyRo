\hypertarget{namespacescipy_1_1signal_1_1filter__design}{}\section{scipy.\+signal.\+filter\+\_\+design Namespace Reference}
\label{namespacescipy_1_1signal_1_1filter__design}\index{scipy.\+signal.\+filter\+\_\+design@{scipy.\+signal.\+filter\+\_\+design}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classscipy_1_1signal_1_1filter__design_1_1BadCoefficients}{Bad\+Coefficients}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_af42fb83b1787aee4fe7e1a37547ada4d}{findfreqs}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a9d0ceb14f2c2895da8f99366e6a2e058}{freqs}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_aa9786d57f917e26ea46ad1678cbb20a1}{freqz}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a08ab6b864e5f68f117e796e2633296f3}{tf2zpk}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a141991c8bde3a3e253f35585a8ebcc26}{zpk2tf}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_aaec12d9a9da7f3d679ab72c6db7e853e}{normalize}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a39ce4f870ba69ce26fc36db50a7a17a2}{lp2lp}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a9bd017734e9600e370cb73015c65290a}{lp2hp}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a7dc60fad5272f29bb8bedcec09b96810}{lp2bp}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a42c7aeabc8d55bc5c2756234a02939b2}{lp2bs}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_ac5c3fc872b114e96d494488e59ab63ae}{bilinear}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a9a14e1ac39675b0a66a7e2ef1d193b1b}{iirdesign}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a008214925846b0a984096fb298eef2df}{iirfilter}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_adcd456e985b0de2881159fc03d0583a1}{butter}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a9fa81c48e581756829873cce264fbc67}{cheby1}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_ae989c42eec42742e485e1161352a9ac5}{cheby2}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a64dd34b82b73bef6d483bf7c20e4b927}{ellip}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a98de9970676ec7dd4cc9822336a532da}{bessel}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_ab7a3353bb2dbb5c8ad21846011a3ac8a}{maxflat}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_ad41eeb98d7ac36b22b4fec9e56bbf9c4}{yulewalk}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a8c7a5519d24a9964b4a016fb17fc62ae}{band\+\_\+stop\+\_\+obj}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_ae7c487db53b0acae5c25d96f66e5e3e6}{buttord}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a1f78cafe863ed9d374e4d11e4f014cea}{cheb1ord}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a5a88a0cbf61c8f1bc5fe12552521dbd4}{cheb2ord}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a6e555afa4d43199ac268a4b183c4efc0}{ellipord}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a43823e629bd7d988a7c12725f6942857}{buttap}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a95baa47fb59022eabe5199b5c497a181}{cheb1ap}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_a8062d4b13309fcce3197bd7cc18dd890}{cheb2ap}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_aaa241b999335d9a56c8d9079abd718ae}{ellipap}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1filter__design_ad7b935998e2145ea375842f7a51e1364}{besselap}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \hyperlink{namespacescipy_1_1signal_1_1filter__design_af0972d6b8a9b21621b707b844c4f9f98}{\+\_\+\+\_\+all\+\_\+\+\_\+}
\item 
\hyperlink{namespacescipy_1_1signal_1_1filter__design_a6573ad6621291c2b1e1ba5ebe9dacc8b}{abs} = absolute
\item 
int \hyperlink{namespacescipy_1_1signal_1_1filter__design_abf768628d14ff81355c222ac07cf68a1}{E\+P\+S\+I\+L\+O\+N} = 2
\item 
dictionary \hyperlink{namespacescipy_1_1signal_1_1filter__design_a23ab4b1c5a1e9c67731e24f1cfc8123b}{filter\+\_\+dict}
\item 
dictionary \hyperlink{namespacescipy_1_1signal_1_1filter__design_a3568772c57d8bb86cfe4133f6d3c738f}{band\+\_\+dict}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Filter design.
\end{DoxyVerb}
 

\subsection{Function Documentation}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_a8c7a5519d24a9964b4a016fb17fc62ae}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!band\+\_\+stop\+\_\+obj@{band\+\_\+stop\+\_\+obj}}
\index{band\+\_\+stop\+\_\+obj@{band\+\_\+stop\+\_\+obj}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{band\+\_\+stop\+\_\+obj}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+band\+\_\+stop\+\_\+obj (
\begin{DoxyParamCaption}
\item[{}]{wp, }
\item[{}]{ind, }
\item[{}]{passb, }
\item[{}]{stopb, }
\item[{}]{gpass, }
\item[{}]{gstop, }
\item[{}]{type}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a8c7a5519d24a9964b4a016fb17fc62ae}
\begin{DoxyVerb}Band Stop Objective Function for order minimization.

Returns the non-integer order for an analog band stop filter.

Parameters
----------
wp : scalar
    Edge of passband `passb`.
ind : int, {0, 1}
    Index specifying which `passb` edge to vary (0 or 1).
passb : ndarray
    Two element sequence of fixed passband edges.
stopb : ndarray
    Two element sequence of fixed stopband edges.
gstop : float
    Amount of attenuation in stopband in dB.
gpass : float
    Amount of ripple in the passband in dB.
type : {'butter', 'cheby', 'ellip'}
    Type of filter.

Returns
-------
n : scalar
    Filter order (possibly non-integer).\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a98de9970676ec7dd4cc9822336a532da}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!bessel@{bessel}}
\index{bessel@{bessel}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{bessel}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+bessel (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{Wn, }
\item[{}]{btype = {\ttfamily '{\bf low}'}, }
\item[{}]{analog = {\ttfamily {\bf False}}, }
\item[{}]{output = {\ttfamily 'ba'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a98de9970676ec7dd4cc9822336a532da}
\begin{DoxyVerb}Bessel/Thomson digital and analog filter design.

Design an Nth order digital or analog Bessel filter and return the
filter coefficients in (B,A) or (Z,P,K) form.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For a Bessel filter, this is defined as the point at which the
    asymptotes of the response are the same as a Butterworth filter of
    the same order.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk'}, optional
    Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').
    Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.

Notes
-----
Also known as a Thomson filter, the analog Bessel filter has maximally
flat group delay and maximally linear phase response, with very little
ringing in the step response.

As order increases, the Bessel filter approaches a Gaussian filter.

The digital Bessel filter is generated using the bilinear
transform, which does not preserve the phase response of the analog
filter. As such, it is only approximately correct at frequencies
below about fs/4.  To get maximally flat group delay at higher
frequencies, the analog Bessel filter must be transformed using
phase-preserving techniques.

For a given `Wn`, the lowpass and highpass filter have the same phase vs
frequency curves; they are "phase-matched".

Examples
--------
Plot the filter's frequency response, showing the flat group delay and
the relationship to the Butterworth's cutoff frequency:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> b, a = signal.butter(4, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.plot(w, 20 * np.log10(np.abs(h)), color='silver', ls='dashed')
>>> b, a = signal.bessel(4, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.plot(w, 20 * np.log10(np.abs(h)))
>>> plt.xscale('log')
>>> plt.title('Bessel filter frequency response (with Butterworth)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.show()

>>> plt.figure()
>>> plt.plot(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w))
>>> plt.xscale('log')
>>> plt.title('Bessel filter group delay')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Group delay [seconds]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_ad7b935998e2145ea375842f7a51e1364}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!besselap@{besselap}}
\index{besselap@{besselap}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{besselap}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+besselap (
\begin{DoxyParamCaption}
\item[{}]{N}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_ad7b935998e2145ea375842f7a51e1364}
\begin{DoxyVerb}Return (z,p,k) zero, pole, gain for analog prototype of an Nth order
Bessel filter.

The filter is normalized such that the filter asymptotes are the same as
a Butterworth filter of the same order with an angular (e.g. rad/s)
cutoff frequency of 1.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_ac5c3fc872b114e96d494488e59ab63ae}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!bilinear@{bilinear}}
\index{bilinear@{bilinear}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{bilinear}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+bilinear (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{fs = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_ac5c3fc872b114e96d494488e59ab63ae}
\begin{DoxyVerb}Return a digital filter from an analog one using a bilinear transform.

The bilinear transform substitutes ``(z-1) / (z+1)`` for ``s``.
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a43823e629bd7d988a7c12725f6942857}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!buttap@{buttap}}
\index{buttap@{buttap}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{buttap}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+buttap (
\begin{DoxyParamCaption}
\item[{}]{N}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a43823e629bd7d988a7c12725f6942857}
\begin{DoxyVerb}Return (z,p,k) zero, pole, gain for analog prototype of an Nth
order Butterworth filter with an angular (e.g. rad/s) cutoff frequency
of 1.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_adcd456e985b0de2881159fc03d0583a1}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!butter@{butter}}
\index{butter@{butter}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{butter}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+butter (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{Wn, }
\item[{}]{btype = {\ttfamily '{\bf low}'}, }
\item[{}]{analog = {\ttfamily {\bf False}}, }
\item[{}]{output = {\ttfamily 'ba'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_adcd456e985b0de2881159fc03d0583a1}
\begin{DoxyVerb}Butterworth digital and analog filter design.

Design an Nth order digital or analog Butterworth filter and return
the filter coefficients in (B,A) or (Z,P,K) form.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For a Butterworth filter, this is the point at which the gain
    drops to 1/sqrt(2) that of the passband (the "-3 dB point").
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk'}, optional
    Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').
    Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.

See also
--------
buttord

Notes
-----
The Butterworth filter has maximally flat frequency response in the
passband.

Examples
--------
Plot the filter's frequency response, showing the critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> b, a = signal.butter(4, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.plot(w, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Butterworth filter frequency response')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_ae7c487db53b0acae5c25d96f66e5e3e6}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!buttord@{buttord}}
\index{buttord@{buttord}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{buttord}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+buttord (
\begin{DoxyParamCaption}
\item[{}]{wp, }
\item[{}]{ws, }
\item[{}]{gpass, }
\item[{}]{gstop, }
\item[{}]{analog = {\ttfamily {\bf False}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_ae7c487db53b0acae5c25d96f66e5e3e6}
\begin{DoxyVerb}Butterworth filter order selection.

Return the order of the lowest order digital or analog Butterworth filter
that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for a Butterworth filter which meets specs.
wn : ndarray or float
    The Butterworth natural frequency (i.e. the "3dB frequency").  Should
    be used with `butter` to give filter results.

See Also
--------
butter : Filter design using order and critical points
cheb1ord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design an analog bandpass filter with passband within 3 dB from 20 to
50 rad/s, while rejecting at least -40 dB below 14 and above 60 rad/s.
Plot its frequency response, showing the passband and stopband
constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> N, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True)
>>> b, a = signal.butter(N, Wn, 'band', True)
>>> w, h = signal.freqs(b, a, np.logspace(1, 2, 500))
>>> plt.plot(w, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Butterworth bandpass filter fit to constraints')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([1,  14,  14,   1], [-40, -40, 99, 99], '0.9', lw=0) # stop
>>> plt.fill([20, 20,  50,  50], [-99, -3, -3, -99], '0.9', lw=0) # pass
>>> plt.fill([60, 60, 1e9, 1e9], [99, -40, -40, 99], '0.9', lw=0) # stop
>>> plt.axis([10, 100, -60, 3])
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a95baa47fb59022eabe5199b5c497a181}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!cheb1ap@{cheb1ap}}
\index{cheb1ap@{cheb1ap}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{cheb1ap}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+cheb1ap (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{rp}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a95baa47fb59022eabe5199b5c497a181}
\begin{DoxyVerb}Return (z,p,k) zero, pole, gain for Nth order Chebyshev type I lowpass
analog filter prototype with `rp` decibels of ripple in the passband.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below -`rp`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a1f78cafe863ed9d374e4d11e4f014cea}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!cheb1ord@{cheb1ord}}
\index{cheb1ord@{cheb1ord}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{cheb1ord}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+cheb1ord (
\begin{DoxyParamCaption}
\item[{}]{wp, }
\item[{}]{ws, }
\item[{}]{gpass, }
\item[{}]{gstop, }
\item[{}]{analog = {\ttfamily {\bf False}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a1f78cafe863ed9d374e4d11e4f014cea}
\begin{DoxyVerb}Chebyshev type I filter order selection.

Return the order of the lowest order digital or analog Chebyshev Type I
filter that loses no more than `gpass` dB in the passband and has at
least `gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for a Chebyshev type I filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `cheby1` to give filter results.

See Also
--------
cheby1 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design a digital lowpass filter such that the passband is within 3 dB up
to 0.2*(fs/2), while rejecting at least -40 dB above 0.3*(fs/2).  Plot its
frequency response, showing the passband and stopband constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> N, Wn = signal.cheb1ord(0.2, 0.3, 3, 40)
>>> b, a = signal.cheby1(N, 3, Wn, 'low')
>>> w, h = signal.freqz(b, a)
>>> plt.plot(w / np.pi, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Chebyshev I lowpass filter fit to constraints')
>>> plt.xlabel('Normalized frequency')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([.01, 0.2, 0.2, .01], [-3, -3, -99, -99], '0.9', lw=0) # stop
>>> plt.fill([0.3, 0.3,   2,   2], [ 9, -40, -40,  9], '0.9', lw=0) # pass
>>> plt.axis([0.08, 1, -60, 3])
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a8062d4b13309fcce3197bd7cc18dd890}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!cheb2ap@{cheb2ap}}
\index{cheb2ap@{cheb2ap}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{cheb2ap}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+cheb2ap (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{rs}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a8062d4b13309fcce3197bd7cc18dd890}
\begin{DoxyVerb}Return (z,p,k) zero, pole, gain for Nth order Chebyshev type II lowpass
analog filter prototype with `rs` decibels of ripple in the stopband.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first reaches -`rs`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a5a88a0cbf61c8f1bc5fe12552521dbd4}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!cheb2ord@{cheb2ord}}
\index{cheb2ord@{cheb2ord}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{cheb2ord}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+cheb2ord (
\begin{DoxyParamCaption}
\item[{}]{wp, }
\item[{}]{ws, }
\item[{}]{gpass, }
\item[{}]{gstop, }
\item[{}]{analog = {\ttfamily {\bf False}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a5a88a0cbf61c8f1bc5fe12552521dbd4}
\begin{DoxyVerb}Chebyshev type II filter order selection.

Return the order of the lowest order digital or analog Chebyshev Type II
filter that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for a Chebyshev type II filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `cheby2` to give filter results.

See Also
--------
cheby2 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design a digital bandstop filter which rejects -60 dB from 0.2*(fs/2) to
0.5*(fs/2), while staying within 3 dB below 0.1*(fs/2) or above
0.6*(fs/2).  Plot its frequency response, showing the passband and
stopband constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> N, Wn = signal.cheb2ord([0.1, 0.6], [0.2, 0.5], 3, 60)
>>> b, a = signal.cheby2(N, 60, Wn, 'stop')
>>> w, h = signal.freqz(b, a)
>>> plt.plot(w / np.pi, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Chebyshev II bandstop filter fit to constraints')
>>> plt.xlabel('Normalized frequency')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([.01, .1, .1, .01], [-3,  -3, -99, -99], '0.9', lw=0) # stop
>>> plt.fill([.2,  .2, .5,  .5], [ 9, -60, -60,   9], '0.9', lw=0) # pass
>>> plt.fill([.6,  .6,  2,   2], [-99, -3,  -3, -99], '0.9', lw=0) # stop
>>> plt.axis([0.06, 1, -80, 3])
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a9fa81c48e581756829873cce264fbc67}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!cheby1@{cheby1}}
\index{cheby1@{cheby1}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{cheby1}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+cheby1 (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{rp, }
\item[{}]{Wn, }
\item[{}]{btype = {\ttfamily '{\bf low}'}, }
\item[{}]{analog = {\ttfamily {\bf False}}, }
\item[{}]{output = {\ttfamily 'ba'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a9fa81c48e581756829873cce264fbc67}
\begin{DoxyVerb}Chebyshev type I digital and analog filter design.

Design an Nth order digital or analog Chebyshev type I filter and
return the filter coefficients in (B,A) or (Z,P,K) form.

Parameters
----------
N : int
    The order of the filter.
rp : float
    The maximum ripple allowed below unity gain in the passband.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For Type I filters, this is the point in the transition band at which
    the gain first drops below -`rp`.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk'}, optional
    Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').
    Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.

See also
--------
cheb1ord

Notes
-----
The Chebyshev type I filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the passband and increased ringing in the step response.

Type I filters roll off faster than Type II (`cheby2`), but Type II
filters do not have any ripple in the passband.

The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.

Examples
--------
Plot the filter's frequency response, showing the critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> b, a = signal.cheby1(4, 5, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.plot(w, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Chebyshev Type I frequency response (rp=5)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.axhline(-5, color='green') # rp
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_ae989c42eec42742e485e1161352a9ac5}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!cheby2@{cheby2}}
\index{cheby2@{cheby2}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{cheby2}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+cheby2 (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{rs, }
\item[{}]{Wn, }
\item[{}]{btype = {\ttfamily '{\bf low}'}, }
\item[{}]{analog = {\ttfamily {\bf False}}, }
\item[{}]{output = {\ttfamily 'ba'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_ae989c42eec42742e485e1161352a9ac5}
\begin{DoxyVerb}Chebyshev type II digital and analog filter design.

Design an Nth order digital or analog Chebyshev type II filter and
return the filter coefficients in (B,A) or (Z,P,K) form.

Parameters
----------
N : int
    The order of the filter.
rs : float
    The minimum attenuation required in the stop band.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For Type II filters, this is the point in the transition band at which
    the gain first reaches -`rs`.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk'}, optional
    Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').
    Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.

See also
--------
cheb2ord

Notes
-----
The Chebyshev type II filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the stopband and increased ringing in the step response.

Type II filters do not roll off as fast as Type I (`cheby1`).

Examples
--------
Plot the filter's frequency response, showing the critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> b, a = signal.cheby2(4, 40, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.plot(w, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Chebyshev Type II frequency response (rs=40)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.axhline(-40, color='green') # rs
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a64dd34b82b73bef6d483bf7c20e4b927}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!ellip@{ellip}}
\index{ellip@{ellip}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{ellip}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+ellip (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{rp, }
\item[{}]{rs, }
\item[{}]{Wn, }
\item[{}]{btype = {\ttfamily '{\bf low}'}, }
\item[{}]{analog = {\ttfamily {\bf False}}, }
\item[{}]{output = {\ttfamily 'ba'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a64dd34b82b73bef6d483bf7c20e4b927}
\begin{DoxyVerb}Elliptic (Cauer) digital and analog filter design.

Design an Nth order digital or analog elliptic filter and return
the filter coefficients in (B,A) or (Z,P,K) form.

Parameters
----------
N : int
    The order of the filter.
rp : float
    The maximum ripple allowed below unity gain in the passband.
    Specified in decibels, as a positive number.
rs : float
    The minimum attenuation required in the stop band.
    Specified in decibels, as a positive number.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For elliptic filters, this is the point in the transition band at
    which the gain first drops below -`rp`.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
    The type of filter.  Default is 'lowpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
output : {'ba', 'zpk'}, optional
    Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').
    Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.

See also
--------
ellipord

Notes
-----
Also known as Cauer or Zolotarev filters, the elliptical filter maximizes
the rate of transition between the frequency response's passband and
stopband, at the expense of ripple in both, and increased ringing in the
step response.

As `rp` approaches 0, the elliptical filter becomes a Chebyshev
type II filter (`cheby2`).  As `rs` approaches 0, it becomes a Chebyshev
type I filter (`cheby1`).  As both approach 0, it becomes a Butterworth
filter (`butter`).

The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.

Examples
--------
Plot the filter's frequency response, showing the critical points:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> b, a = signal.ellip(4, 5, 40, 100, 'low', analog=True)
>>> w, h = signal.freqs(b, a)
>>> plt.plot(w, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Elliptic filter frequency response (rp=5, rs=40)')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.margins(0, 0.1)
>>> plt.grid(which='both', axis='both')
>>> plt.axvline(100, color='green') # cutoff frequency
>>> plt.axhline(-40, color='green') # rs
>>> plt.axhline(-5, color='green') # rp
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_aaa241b999335d9a56c8d9079abd718ae}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!ellipap@{ellipap}}
\index{ellipap@{ellipap}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{ellipap}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+ellipap (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{rp, }
\item[{}]{rs}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_aaa241b999335d9a56c8d9079abd718ae}
\begin{DoxyVerb}Return (z,p,k) zeros, poles, and gain of an Nth order normalized
prototype elliptic analog lowpass filter with `rp` decibels of ripple in
the passband and a stopband `rs` decibels down.

The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below -`rp`.

References
----------
Lutova, Tosic, and Evans, "Filter Design for Signal Processing", Chapters 5
and 12.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a6e555afa4d43199ac268a4b183c4efc0}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!ellipord@{ellipord}}
\index{ellipord@{ellipord}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{ellipord}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+ellipord (
\begin{DoxyParamCaption}
\item[{}]{wp, }
\item[{}]{ws, }
\item[{}]{gpass, }
\item[{}]{gstop, }
\item[{}]{analog = {\ttfamily {\bf False}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a6e555afa4d43199ac268a4b183c4efc0}
\begin{DoxyVerb}Elliptic (Cauer) filter order selection.

Return the order of the lowest order digital or analog elliptic filter
that loses no more than `gpass` dB in the passband and has at least
`gstop` dB attenuation in the stopband.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.

Returns
-------
ord : int
    The lowest order for an Elliptic (Cauer) filter that meets specs.
wn : ndarray or float
    The Chebyshev natural frequency (the "3dB frequency") for use with
    `ellip` to give filter results.

See Also
--------
ellip : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec

Examples
--------
Design an analog highpass filter such that the passband is within 3 dB
above 30 rad/s, while rejecting -60 dB at 10 rad/s.  Plot its
frequency response, showing the passband and stopband constraints in gray.

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> N, Wn = signal.ellipord(30, 10, 3, 60, True)
>>> b, a = signal.ellip(N, 3, 60, Wn, 'high', True)
>>> w, h = signal.freqs(b, a, np.logspace(0, 3, 500))
>>> plt.plot(w, 20 * np.log10(abs(h)))
>>> plt.xscale('log')
>>> plt.title('Elliptical highpass filter fit to constraints')
>>> plt.xlabel('Frequency [radians / second]')
>>> plt.ylabel('Amplitude [dB]')
>>> plt.grid(which='both', axis='both')
>>> plt.fill([.1, 10,  10,  .1], [1e4, 1e4, -60, -60], '0.9', lw=0) # stop
>>> plt.fill([30, 30, 1e9, 1e9], [-99,  -3,  -3, -99], '0.9', lw=0) # pass
>>> plt.axis([1, 300, -80, 3])
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_af42fb83b1787aee4fe7e1a37547ada4d}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!findfreqs@{findfreqs}}
\index{findfreqs@{findfreqs}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{findfreqs}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+findfreqs (
\begin{DoxyParamCaption}
\item[{}]{num, }
\item[{}]{den, }
\item[{}]{N}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_af42fb83b1787aee4fe7e1a37547ada4d}
\begin{DoxyVerb}Find an array of frequencies for computing the response of a filter.

Parameters
----------
num, den : array_like, 1-D
    The polynomial coefficients of the numerator and denominator of the
    transfer function of the filter or LTI system.  The coefficients are
    ordered from highest to lowest degree.
N : int
    The length of the array to be computed.

Returns
-------
w : (N,) ndarray
    A 1-D array of frequencies, logarithmically spaced.

Examples
--------
Find a set of nine frequencies that span the "interesting part" of the
frequency response for the filter with the transfer function
    H(s) = s / (s^2 + 8s + 25)

>>> findfreqs([1, 0], [1, 8, 25], N=9)
array([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01,
         3.16227766e-01,   1.00000000e+00,   3.16227766e+00,
         1.00000000e+01,   3.16227766e+01,   1.00000000e+02])
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a9d0ceb14f2c2895da8f99366e6a2e058}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!freqs@{freqs}}
\index{freqs@{freqs}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{freqs}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+freqs (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{wor\+N = {\ttfamily None}, }
\item[{}]{plot = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a9d0ceb14f2c2895da8f99366e6a2e058}
\begin{DoxyVerb}Compute frequency response of analog filter.

Given the numerator `b` and denominator `a` of a filter, compute its
frequency response::

         b[0]*(jw)**(nb-1) + b[1]*(jw)**(nb-2) + ... + b[nb-1]
 H(w) = -------------------------------------------------------
         a[0]*(jw)**(na-1) + a[1]*(jw)**(na-2) + ... + a[na-1]

Parameters
----------
b : ndarray
    Numerator of a linear filter.
a : ndarray
    Denominator of a linear filter.
worN : {None, int}, optional
    If None, then compute at 200 frequencies around the interesting parts
    of the response curve (determined by pole-zero locations).  If a single
    integer, then compute at that many frequencies.  Otherwise, compute the
    response at the angular frequencies (e.g. rad/s) given in `worN`.
plot : callable
    A callable that takes two arguments. If given, the return parameters
    `w` and `h` are passed to plot. Useful for plotting the frequency
    response inside `freqs`.

Returns
-------
w : ndarray
    The angular frequencies at which h was computed.
h : ndarray
    The frequency response.

See Also
--------
freqz : Compute the frequency response of a digital filter.

Notes
-----
Using Matplotlib's "plot" function as the callable for `plot` produces
unexpected results,  this plots the real part of the complex transfer
function, not the magnitude.  Try ``lambda w, h: plot(w, abs(h))``.

Examples
--------
>>> from scipy.signal import freqs, iirfilter

>>> b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1')

>>> w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000))

>>> import matplotlib.pyplot as plt
>>> plt.semilogx(w, 20 * np.log10(abs(h)))
>>> plt.xlabel('Frequency')
>>> plt.ylabel('Amplitude response [dB]')
>>> plt.grid()
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_aa9786d57f917e26ea46ad1678cbb20a1}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!freqz@{freqz}}
\index{freqz@{freqz}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{freqz}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+freqz (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a = {\ttfamily 1}, }
\item[{}]{wor\+N = {\ttfamily None}, }
\item[{}]{whole = {\ttfamily 0}, }
\item[{}]{plot = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_aa9786d57f917e26ea46ad1678cbb20a1}
\begin{DoxyVerb}Compute the frequency response of a digital filter.

Given the numerator `b` and denominator `a` of a digital filter,
compute its frequency response::

           jw               -jw            -jmw
    jw  B(e)    b[0] + b[1]e + .... + b[m]e
 H(e) = ---- = ------------------------------------
           jw               -jw            -jnw
        A(e)    a[0] + a[1]e + .... + a[n]e

Parameters
----------
b : ndarray
    numerator of a linear filter
a : ndarray
    denominator of a linear filter
worN : {None, int, array_like}, optional
    If None (default), then compute at 512 frequencies equally spaced
    around the unit circle.
    If a single integer, then compute at that many frequencies.
    If an array_like, compute the response at the frequencies given (in
    radians/sample).
whole : bool, optional
    Normally, frequencies are computed from 0 to the Nyquist frequency,
    pi radians/sample (upper-half of unit-circle).  If `whole` is True,
    compute frequencies from 0 to 2*pi radians/sample.
plot : callable
    A callable that takes two arguments. If given, the return parameters
    `w` and `h` are passed to plot. Useful for plotting the frequency
    response inside `freqz`.

Returns
-------
w : ndarray
    The normalized frequencies at which h was computed, in radians/sample.
h : ndarray
    The frequency response.

Notes
-----
Using Matplotlib's "plot" function as the callable for `plot` produces
unexpected results,  this plots the real part of the complex transfer
function, not the magnitude.  Try ``lambda w, h: plot(w, abs(h))``.

Examples
--------
>>> from scipy import signal
>>> b = signal.firwin(80, 0.5, window=('kaiser', 8))
>>> w, h = signal.freqz(b)

>>> import matplotlib.pyplot as plt
>>> fig = plt.figure()
>>> plt.title('Digital filter frequency response')
>>> ax1 = fig.add_subplot(111)

>>> plt.plot(w, 20 * np.log10(abs(h)), 'b')
>>> plt.ylabel('Amplitude [dB]', color='b')
>>> plt.xlabel('Frequency [rad/sample]')

>>> ax2 = ax1.twinx()
>>> angles = np.unwrap(np.angle(h))
>>> plt.plot(w, angles, 'g')
>>> plt.ylabel('Angle (radians)', color='g')
>>> plt.grid()
>>> plt.axis('tight')
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a9a14e1ac39675b0a66a7e2ef1d193b1b}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!iirdesign@{iirdesign}}
\index{iirdesign@{iirdesign}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{iirdesign}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+iirdesign (
\begin{DoxyParamCaption}
\item[{}]{wp, }
\item[{}]{ws, }
\item[{}]{gpass, }
\item[{}]{gstop, }
\item[{}]{analog = {\ttfamily {\bf False}}, }
\item[{}]{ftype = {\ttfamily 'ellip'}, }
\item[{}]{output = {\ttfamily 'ba'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a9a14e1ac39675b0a66a7e2ef1d193b1b}
\begin{DoxyVerb}Complete IIR digital and analog filter design.

Given passband and stopband frequencies and gains, construct an analog or
digital IIR filter of minimum order for a given basic type.  Return the
output in numerator, denominator ('ba') or pole-zero ('zpk') form.

Parameters
----------
wp, ws : float
    Passband and stopband edge frequencies.
    For digital filters, these are normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`wp` and `ws` are thus in
    half-cycles / sample.)  For example:

        - Lowpass:   wp = 0.2,          ws = 0.3
        - Highpass:  wp = 0.3,          ws = 0.2
        - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
        - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]

    For analog filters, `wp` and `ws` are angular frequencies (e.g. rad/s).

gpass : float
    The maximum loss in the passband (dB).
gstop : float
    The minimum attenuation in the stopband (dB).
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
ftype : str, optional
    The type of IIR filter to design:

        - Butterworth   : 'butter'
        - Chebyshev I   : 'cheby1'
        - Chebyshev II  : 'cheby2'
        - Cauer/elliptic: 'ellip'
        - Bessel/Thomson: 'bessel'

output : {'ba', 'zpk'}, optional
    Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').
    Default is 'ba'.

Returns
-------
b, a : ndarray, ndarray
    Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
    Only returned if ``output='ba'``.
z, p, k : ndarray, ndarray, float
    Zeros, poles, and system gain of the IIR filter transfer
    function.  Only returned if ``output='zpk'``.

See Also
--------
butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a008214925846b0a984096fb298eef2df}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!iirfilter@{iirfilter}}
\index{iirfilter@{iirfilter}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{iirfilter}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+iirfilter (
\begin{DoxyParamCaption}
\item[{}]{N, }
\item[{}]{Wn, }
\item[{}]{rp = {\ttfamily None}, }
\item[{}]{rs = {\ttfamily None}, }
\item[{}]{btype = {\ttfamily 'band'}, }
\item[{}]{analog = {\ttfamily {\bf False}}, }
\item[{}]{ftype = {\ttfamily 'butter'}, }
\item[{}]{output = {\ttfamily 'ba'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a008214925846b0a984096fb298eef2df}
\begin{DoxyVerb}IIR digital and analog filter design given order and critical points.

Design an Nth order digital or analog filter and return the filter
coefficients in (B,A) (numerator, denominator) or (Z,P,K) form.

Parameters
----------
N : int
    The order of the filter.
Wn : array_like
    A scalar or length-2 sequence giving the critical frequencies.
    For digital filters, `Wn` is normalized from 0 to 1, where 1 is the
    Nyquist frequency, pi radians/sample.  (`Wn` is thus in
    half-cycles / sample.)
    For analog filters, `Wn` is an angular frequency (e.g. rad/s).
rp : float, optional
    For Chebyshev and elliptic filters, provides the maximum ripple
    in the passband. (dB)
rs : float, optional
    For Chebyshev and elliptic filters, provides the minimum attenuation
    in the stop band. (dB)
btype : {'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
    The type of filter.  Default is 'bandpass'.
analog : bool, optional
    When True, return an analog filter, otherwise a digital filter is
    returned.
ftype : str, optional
    The type of IIR filter to design:

        - Butterworth   : 'butter'
        - Chebyshev I   : 'cheby1'
        - Chebyshev II  : 'cheby2'
        - Cauer/elliptic: 'ellip'
        - Bessel/Thomson: 'bessel'

output : {'ba', 'zpk'}, optional
    Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').
    Default is 'ba'.

See Also
--------
butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirdesign : General filter design using passband and stopband spec

Examples
--------
Generate a 17th-order Chebyshev II bandpass filter and plot the frequency
response:

>>> from scipy import signal
>>> import matplotlib.pyplot as plt

>>> b, a = signal.iirfilter(17, [50, 200], rs=60, btype='band',
...                         analog=True, ftype='cheby2')
>>> w, h = signal.freqs(b, a, 1000)
>>> fig = plt.figure()
>>> ax = fig.add_subplot(111)
>>> ax.plot(w, 20 * np.log10(abs(h)))
>>> ax.set_xscale('log')
>>> ax.set_title('Chebyshev Type II bandpass frequency response')
>>> ax.set_xlabel('Frequency [radians / second]')
>>> ax.set_ylabel('Amplitude [dB]')
>>> ax.axis((10, 1000, -100, 10))
>>> ax.grid(which='both', axis='both')
>>> plt.show()\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a7dc60fad5272f29bb8bedcec09b96810}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!lp2bp@{lp2bp}}
\index{lp2bp@{lp2bp}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{lp2bp}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+lp2bp (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{wo = {\ttfamily 1.0}, }
\item[{}]{bw = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a7dc60fad5272f29bb8bedcec09b96810}
\begin{DoxyVerb}Transform a lowpass filter prototype to a bandpass filter.

Return an analog band-pass filter with center frequency `wo` and
bandwidth `bw` from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a42c7aeabc8d55bc5c2756234a02939b2}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!lp2bs@{lp2bs}}
\index{lp2bs@{lp2bs}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{lp2bs}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+lp2bs (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{wo = {\ttfamily 1.0}, }
\item[{}]{bw = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a42c7aeabc8d55bc5c2756234a02939b2}
\begin{DoxyVerb}Transform a lowpass filter prototype to a bandstop filter.

Return an analog band-stop filter with center frequency `wo` and
bandwidth `bw` from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a9bd017734e9600e370cb73015c65290a}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!lp2hp@{lp2hp}}
\index{lp2hp@{lp2hp}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{lp2hp}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+lp2hp (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{wo = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a9bd017734e9600e370cb73015c65290a}
\begin{DoxyVerb}Transform a lowpass filter prototype to a highpass filter.

Return an analog high-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a39ce4f870ba69ce26fc36db50a7a17a2}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!lp2lp@{lp2lp}}
\index{lp2lp@{lp2lp}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{lp2lp}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+lp2lp (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{wo = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a39ce4f870ba69ce26fc36db50a7a17a2}
\begin{DoxyVerb}Transform a lowpass filter prototype to a different frequency.

Return an analog low-pass filter with cutoff frequency `wo`
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_ab7a3353bb2dbb5c8ad21846011a3ac8a}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!maxflat@{maxflat}}
\index{maxflat@{maxflat}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{maxflat}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+maxflat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_ab7a3353bb2dbb5c8ad21846011a3ac8a}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_aaec12d9a9da7f3d679ab72c6db7e853e}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!normalize@{normalize}}
\index{normalize@{normalize}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{normalize}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+normalize (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_aaec12d9a9da7f3d679ab72c6db7e853e}
\begin{DoxyVerb}Normalize polynomial representation of a transfer function.

If values of `b` are too close to 0, they are removed. In that case, a
BadCoefficients warning is emitted.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1filter__design_a08ab6b864e5f68f117e796e2633296f3}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!tf2zpk@{tf2zpk}}
\index{tf2zpk@{tf2zpk}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{tf2zpk}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+tf2zpk (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a08ab6b864e5f68f117e796e2633296f3}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_ad41eeb98d7ac36b22b4fec9e56bbf9c4}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!yulewalk@{yulewalk}}
\index{yulewalk@{yulewalk}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{yulewalk}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+yulewalk (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_ad41eeb98d7ac36b22b4fec9e56bbf9c4}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_a141991c8bde3a3e253f35585a8ebcc26}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!zpk2tf@{zpk2tf}}
\index{zpk2tf@{zpk2tf}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{zpk2tf}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+filter\+\_\+design.\+zpk2tf (
\begin{DoxyParamCaption}
\item[{}]{z, }
\item[{}]{p, }
\item[{}]{k}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1filter__design_a141991c8bde3a3e253f35585a8ebcc26}
\begin{DoxyVerb}Return polynomial transfer function representation from zeros
and poles

Parameters
----------
z : ndarray
    Zeros of the transfer function.
p : ndarray
    Poles of the transfer function.
k : float
    System gain.

Returns
-------
b : ndarray
    Numerator polynomial.
a : ndarray
    Denominator polynomial.\end{DoxyVerb}
 

\subsection{Variable Documentation}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_af0972d6b8a9b21621b707b844c4f9f98}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{\+\_\+\+\_\+all\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}list scipy.\+signal.\+filter\+\_\+design.\+\_\+\+\_\+all\+\_\+\+\_\+}\label{namespacescipy_1_1signal_1_1filter__design_af0972d6b8a9b21621b707b844c4f9f98}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = [\textcolor{stringliteral}{'findfreqs'}, \textcolor{stringliteral}{'freqs'}, \textcolor{stringliteral}{'freqz'}, \textcolor{stringliteral}{'tf2zpk'}, \textcolor{stringliteral}{'zpk2tf'}, \textcolor{stringliteral}{'normalize'},
2            \textcolor{stringliteral}{'lp2lp'}, \textcolor{stringliteral}{'lp2hp'}, \textcolor{stringliteral}{'lp2bp'}, \textcolor{stringliteral}{'lp2bs'}, \textcolor{stringliteral}{'bilinear'}, \textcolor{stringliteral}{'iirdesign'},
3            \textcolor{stringliteral}{'iirfilter'}, \textcolor{stringliteral}{'butter'}, \textcolor{stringliteral}{'cheby1'}, \textcolor{stringliteral}{'cheby2'}, \textcolor{stringliteral}{'ellip'}, \textcolor{stringliteral}{'bessel'},
4            \textcolor{stringliteral}{'band\_stop\_obj'}, \textcolor{stringliteral}{'buttord'}, \textcolor{stringliteral}{'cheb1ord'}, \textcolor{stringliteral}{'cheb2ord'}, \textcolor{stringliteral}{'ellipord'},
5            \textcolor{stringliteral}{'buttap'}, \textcolor{stringliteral}{'cheb1ap'}, \textcolor{stringliteral}{'cheb2ap'}, \textcolor{stringliteral}{'ellipap'}, \textcolor{stringliteral}{'besselap'},
6            \textcolor{stringliteral}{'filter\_dict'}, \textcolor{stringliteral}{'band\_dict'}, \textcolor{stringliteral}{'BadCoefficients'}]
\end{DoxyCode}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_a6573ad6621291c2b1e1ba5ebe9dacc8b}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!abs@{abs}}
\index{abs@{abs}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{abs}]{\setlength{\rightskip}{0pt plus 5cm}scipy.\+signal.\+filter\+\_\+design.\+abs = absolute}\label{namespacescipy_1_1signal_1_1filter__design_a6573ad6621291c2b1e1ba5ebe9dacc8b}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_a3568772c57d8bb86cfe4133f6d3c738f}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!band\+\_\+dict@{band\+\_\+dict}}
\index{band\+\_\+dict@{band\+\_\+dict}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{band\+\_\+dict}]{\setlength{\rightskip}{0pt plus 5cm}dictionary scipy.\+signal.\+filter\+\_\+design.\+band\+\_\+dict}\label{namespacescipy_1_1signal_1_1filter__design_a3568772c57d8bb86cfe4133f6d3c738f}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = \{\textcolor{stringliteral}{'band'}: \textcolor{stringliteral}{'bandpass'},
2              \textcolor{stringliteral}{'bandpass'}: \textcolor{stringliteral}{'bandpass'},
3              \textcolor{stringliteral}{'pass'}: \textcolor{stringliteral}{'bandpass'},
4              \textcolor{stringliteral}{'bp'}: \textcolor{stringliteral}{'bandpass'},
5 
6              \textcolor{stringliteral}{'bs'}: \textcolor{stringliteral}{'bandstop'},
7              \textcolor{stringliteral}{'bandstop'}: \textcolor{stringliteral}{'bandstop'},
8              \textcolor{stringliteral}{'bands'}: \textcolor{stringliteral}{'bandstop'},
9              \textcolor{stringliteral}{'stop'}: \textcolor{stringliteral}{'bandstop'},
10 
11              \textcolor{stringliteral}{'l'}: \textcolor{stringliteral}{'lowpass'},
12              \textcolor{stringliteral}{'low'}: \textcolor{stringliteral}{'lowpass'},
13              \textcolor{stringliteral}{'lowpass'}: \textcolor{stringliteral}{'lowpass'},
14              \textcolor{stringliteral}{'lp'}: \textcolor{stringliteral}{'lowpass'},
15 
16              \textcolor{stringliteral}{'high'}: \textcolor{stringliteral}{'highpass'},
17              \textcolor{stringliteral}{'highpass'}: \textcolor{stringliteral}{'highpass'},
18              \textcolor{stringliteral}{'h'}: \textcolor{stringliteral}{'highpass'},
19              \textcolor{stringliteral}{'hp'}: \textcolor{stringliteral}{'highpass'},
20              \}
\end{DoxyCode}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_abf768628d14ff81355c222ac07cf68a1}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!E\+P\+S\+I\+L\+O\+N@{E\+P\+S\+I\+L\+O\+N}}
\index{E\+P\+S\+I\+L\+O\+N@{E\+P\+S\+I\+L\+O\+N}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{E\+P\+S\+I\+L\+O\+N}]{\setlength{\rightskip}{0pt plus 5cm}int scipy.\+signal.\+filter\+\_\+design.\+E\+P\+S\+I\+L\+O\+N = 2}\label{namespacescipy_1_1signal_1_1filter__design_abf768628d14ff81355c222ac07cf68a1}
\hypertarget{namespacescipy_1_1signal_1_1filter__design_a23ab4b1c5a1e9c67731e24f1cfc8123b}{}\index{scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}!filter\+\_\+dict@{filter\+\_\+dict}}
\index{filter\+\_\+dict@{filter\+\_\+dict}!scipy\+::signal\+::filter\+\_\+design@{scipy\+::signal\+::filter\+\_\+design}}
\subsubsection[{filter\+\_\+dict}]{\setlength{\rightskip}{0pt plus 5cm}dictionary scipy.\+signal.\+filter\+\_\+design.\+filter\+\_\+dict}\label{namespacescipy_1_1signal_1_1filter__design_a23ab4b1c5a1e9c67731e24f1cfc8123b}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = \{\textcolor{stringliteral}{'butter'}: [buttap, buttord],
2                \textcolor{stringliteral}{'butterworth'}: [buttap, buttord],
3 
4                \textcolor{stringliteral}{'cauer'}: [ellipap, ellipord],
5                \textcolor{stringliteral}{'elliptic'}: [ellipap, ellipord],
6                \textcolor{stringliteral}{'ellip'}: [ellipap, ellipord],
7 
8                \textcolor{stringliteral}{'bessel'}: [besselap],
9 
10                \textcolor{stringliteral}{'cheby1'}: [cheb1ap, cheb1ord],
11                \textcolor{stringliteral}{'chebyshev1'}: [cheb1ap, cheb1ord],
12                \textcolor{stringliteral}{'chebyshevi'}: [cheb1ap, cheb1ord],
13 
14                \textcolor{stringliteral}{'cheby2'}: [cheb2ap, cheb2ord],
15                \textcolor{stringliteral}{'chebyshev2'}: [cheb2ap, cheb2ord],
16                \textcolor{stringliteral}{'chebyshevii'}: [cheb2ap, cheb2ord],
17                \}
\end{DoxyCode}
