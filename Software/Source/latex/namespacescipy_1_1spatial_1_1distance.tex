\hypertarget{namespacescipy_1_1spatial_1_1distance}{}\section{scipy.\+spatial.\+distance Namespace Reference}
\label{namespacescipy_1_1spatial_1_1distance}\index{scipy.\+spatial.\+distance@{scipy.\+spatial.\+distance}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a42f964c9b59729e10ee81440c20b682c}{minkowski}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_aad6bcf15a40337aa59d8c4b652efb7ac}{wminkowski}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a108434d094539dcfbae6bc35f488108a}{euclidean}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a58d74cd7cf9313f0bf10afc5037a9a98}{sqeuclidean}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a8b96cda5be045e1cec1c34c06c37c3c0}{cosine}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a588f9c43c1859788389c383870c337c8}{correlation}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a2c5f8a0b13edfdf2152a08694e390681}{hamming}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a68a9627afaa09b2dd14b6d938ae0dc0b}{jaccard}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_ad9fa0f1a4b1c67bf0c767594f4f0910d}{kulsinski}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a3e57a4b6dbe657d7e38f9daa6eba315a}{seuclidean}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_ac029e0f4e7b7808756169861c3b1574d}{cityblock}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a3c5d20e0351fcf7e47cbd73ac65babac}{mahalanobis}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a7de603cc98f4334e5a9cdf6dac8c2acf}{chebyshev}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a2282f96c4e20f20f04e371ff6955b500}{braycurtis}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_aff80f0a9eec5c56a46f65ded4a676c82}{canberra}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a2cd113484f0d7ca9328d0ed8b43e9a56}{yule}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a7c2d1ce4dccd5adcbc03624d61067a54}{matching}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_ad107a58a15e381f1463863e800fdf1e4}{dice}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_ace78ac9a6feba0a188ce3f99bd6062fc}{rogerstanimoto}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_afaa1633ffa1c0ee142e187c314b913f1}{russellrao}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a3a0e6b50f64498cc097d3fcb503ed8da}{sokalmichener}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a01b1431beb2b5b5a9e018b23961508db}{sokalsneath}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a5ba06c0cf7b841afd1980bbe09663744}{pdist}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a2a23c7f48657843ae5739fc231745529}{squareform}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_af4d07c12f69f8711c53e91be94792655}{is\+\_\+valid\+\_\+dm}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a06ab64b4928636ffa559626804147cea}{is\+\_\+valid\+\_\+y}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a036cab00dbf32d0c3377e2a5963a8e3e}{num\+\_\+obs\+\_\+dm}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a5ed66732e33c885673c32b2f39a703aa}{num\+\_\+obs\+\_\+y}
\item 
def \hyperlink{namespacescipy_1_1spatial_1_1distance_a7b143de4b8d8935cfe756bdd3ebb745b}{cdist}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}=====================================================
Distance computations (:mod:`scipy.spatial.distance`)
=====================================================

.. sectionauthor:: Damian Eads

Function Reference
------------------

Distance matrix computation from a collection of raw observation vectors
stored in a rectangular array.

.. autosummary::
   :toctree: generated/

   pdist   -- pairwise distances between observation vectors.
   cdist   -- distances between two collections of observation vectors
   squareform -- convert distance matrix to a condensed one and vice versa

Predicates for checking the validity of distance matrices, both
condensed and redundant. Also contained in this module are functions
for computing the number of observations in a distance matrix.

.. autosummary::
   :toctree: generated/

   is_valid_dm -- checks for a valid distance matrix
   is_valid_y  -- checks for a valid condensed distance matrix
   num_obs_dm  -- # of observations in a distance matrix
   num_obs_y   -- # of observations in a condensed distance matrix

Distance functions between two vectors ``u`` and ``v``. Computing
distances over a large collection of vectors is inefficient for these
functions. Use ``pdist`` for this purpose.

.. autosummary::
   :toctree: generated/

   braycurtis       -- the Bray-Curtis distance.
   canberra         -- the Canberra distance.
   chebyshev        -- the Chebyshev distance.
   cityblock        -- the Manhattan distance.
   correlation      -- the Correlation distance.
   cosine           -- the Cosine distance.
   dice             -- the Dice dissimilarity (boolean).
   euclidean        -- the Euclidean distance.
   hamming          -- the Hamming distance (boolean).
   jaccard          -- the Jaccard distance (boolean).
   kulsinski        -- the Kulsinski distance (boolean).
   mahalanobis      -- the Mahalanobis distance.
   matching         -- the matching dissimilarity (boolean).
   minkowski        -- the Minkowski distance.
   rogerstanimoto   -- the Rogers-Tanimoto dissimilarity (boolean).
   russellrao       -- the Russell-Rao dissimilarity (boolean).
   seuclidean       -- the normalized Euclidean distance.
   sokalmichener    -- the Sokal-Michener dissimilarity (boolean).
   sokalsneath      -- the Sokal-Sneath dissimilarity (boolean).
   sqeuclidean      -- the squared Euclidean distance.
   wminkowski       -- the weighted Minkowski distance.
   yule             -- the Yule dissimilarity (boolean).\end{DoxyVerb}
 

\subsection{Function Documentation}
\hypertarget{namespacescipy_1_1spatial_1_1distance_a2282f96c4e20f20f04e371ff6955b500}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!braycurtis@{braycurtis}}
\index{braycurtis@{braycurtis}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{braycurtis}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+braycurtis (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a2282f96c4e20f20f04e371ff6955b500}
\begin{DoxyVerb}Computes the Bray-Curtis distance between two 1-D arrays.

Bray-Curtis distance is defined as

.. math::

   \\sum{|u_i-v_i|} / \\sum{|u_i+v_i|}

The Bray-Curtis distance is in the range [0, 1] if all coordinates are
positive, and is undefined if the inputs are of length zero.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
braycurtis : double
    The Bray-Curtis distance between 1-D arrays `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_aff80f0a9eec5c56a46f65ded4a676c82}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!canberra@{canberra}}
\index{canberra@{canberra}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{canberra}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+canberra (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_aff80f0a9eec5c56a46f65ded4a676c82}
\begin{DoxyVerb}Computes the Canberra distance between two 1-D arrays.

The Canberra distance is defined as

.. math::

     d(u,v) = \\sum_i \\frac{|u_i-v_i|}
                          {|u_i|+|v_i|}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
canberra : double
    The Canberra distance between vectors `u` and `v`.

Notes
-----
When `u[i]` and `v[i]` are 0 for given i, then the fraction 0/0 = 0 is
used in the calculation.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a7b143de4b8d8935cfe756bdd3ebb745b}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!cdist@{cdist}}
\index{cdist@{cdist}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{cdist}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+cdist (
\begin{DoxyParamCaption}
\item[{}]{X\+A, }
\item[{}]{X\+B, }
\item[{}]{metric = {\ttfamily 'euclidean'}, }
\item[{}]{p = {\ttfamily 2}, }
\item[{}]{V = {\ttfamily None}, }
\item[{}]{V\+I = {\ttfamily None}, }
\item[{}]{w = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a7b143de4b8d8935cfe756bdd3ebb745b}
\begin{DoxyVerb}Computes distance between each pair of the two collections of inputs.

The following are common calling conventions:

1. ``Y = cdist(XA, XB, 'euclidean')``

   Computes the distance between :math:`m` points using
   Euclidean distance (2-norm) as the distance metric between the
   points. The points are arranged as :math:`m`
   :math:`n`-dimensional row vectors in the matrix X.

2. ``Y = cdist(XA, XB, 'minkowski', p)``

   Computes the distances using the Minkowski distance
   :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \\geq 1`.

3. ``Y = cdist(XA, XB, 'cityblock')``

   Computes the city block or Manhattan distance between the
   points.

4. ``Y = cdist(XA, XB, 'seuclidean', V=None)``

   Computes the standardized Euclidean distance. The standardized
   Euclidean distance between two n-vectors ``u`` and ``v`` is

   .. math::

      \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.

   V is the variance vector; V[i] is the variance computed over all
   the i'th components of the points. If not passed, it is
   automatically computed.

5. ``Y = cdist(XA, XB, 'sqeuclidean')``

   Computes the squared Euclidean distance :math:`||u-v||_2^2` between
   the vectors.

6. ``Y = cdist(XA, XB, 'cosine')``

   Computes the cosine distance between vectors u and v,

   .. math::

      1 - \\frac{u \\cdot v}
               {{||u||}_2 {||v||}_2}

   where :math:`||*||_2` is the 2-norm of its argument ``*``, and
   :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.

7. ``Y = cdist(XA, XB, 'correlation')``

   Computes the correlation distance between vectors u and v. This is

   .. math::

      1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}
               {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}

   where :math:`\\bar{v}` is the mean of the elements of vector v,
   and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.


8. ``Y = cdist(XA, XB, 'hamming')``

   Computes the normalized Hamming distance, or the proportion of
   those vector elements between two n-vectors ``u`` and ``v``
   which disagree. To save memory, the matrix ``X`` can be of type
   boolean.

9. ``Y = cdist(XA, XB, 'jaccard')``

   Computes the Jaccard distance between the points. Given two
   vectors, ``u`` and ``v``, the Jaccard distance is the
   proportion of those elements ``u[i]`` and ``v[i]`` that
   disagree where at least one of them is non-zero.

10. ``Y = cdist(XA, XB, 'chebyshev')``

   Computes the Chebyshev distance between the points. The
   Chebyshev distance between two n-vectors ``u`` and ``v`` is the
   maximum norm-1 distance between their respective elements. More
   precisely, the distance is given by

   .. math::

      d(u,v) = \\max_i {|u_i-v_i|}.

11. ``Y = cdist(XA, XB, 'canberra')``

   Computes the Canberra distance between the points. The
   Canberra distance between two points ``u`` and ``v`` is

   .. math::

     d(u,v) = \\sum_i \\frac{|u_i-v_i|}
                          {|u_i|+|v_i|}.

12. ``Y = cdist(XA, XB, 'braycurtis')``

   Computes the Bray-Curtis distance between the points. The
   Bray-Curtis distance between two points ``u`` and ``v`` is


   .. math::

        d(u,v) = \\frac{\\sum_i (u_i-v_i)}
                      {\\sum_i (u_i+v_i)}

13. ``Y = cdist(XA, XB, 'mahalanobis', VI=None)``

   Computes the Mahalanobis distance between the points. The
   Mahalanobis distance between two points ``u`` and ``v`` is
   :math:`(u-v)(1/V)(u-v)^T` where :math:`(1/V)` (the ``VI``
   variable) is the inverse covariance. If ``VI`` is not None,
   ``VI`` will be used as the inverse covariance matrix.

14. ``Y = cdist(XA, XB, 'yule')``

   Computes the Yule distance between the boolean
   vectors. (see yule function documentation)

15. ``Y = cdist(XA, XB, 'matching')``

   Computes the matching distance between the boolean
   vectors. (see matching function documentation)

16. ``Y = cdist(XA, XB, 'dice')``

   Computes the Dice distance between the boolean vectors. (see
   dice function documentation)

17. ``Y = cdist(XA, XB, 'kulsinski')``

   Computes the Kulsinski distance between the boolean
   vectors. (see kulsinski function documentation)

18. ``Y = cdist(XA, XB, 'rogerstanimoto')``

   Computes the Rogers-Tanimoto distance between the boolean
   vectors. (see rogerstanimoto function documentation)

19. ``Y = cdist(XA, XB, 'russellrao')``

   Computes the Russell-Rao distance between the boolean
   vectors. (see russellrao function documentation)

20. ``Y = cdist(XA, XB, 'sokalmichener')``

   Computes the Sokal-Michener distance between the boolean
   vectors. (see sokalmichener function documentation)

21. ``Y = cdist(XA, XB, 'sokalsneath')``

   Computes the Sokal-Sneath distance between the vectors. (see
   sokalsneath function documentation)


22. ``Y = cdist(XA, XB, 'wminkowski')``

   Computes the weighted Minkowski distance between the
   vectors. (see wminkowski function documentation)

23. ``Y = cdist(XA, XB, f)``

   Computes the distance between all pairs of vectors in X
   using the user supplied 2-arity function f. For example,
   Euclidean distance between the vectors could be computed
   as follows::

     dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))

   Note that you should avoid passing a reference to one of
   the distance functions defined in this library. For example,::

     dm = cdist(XA, XB, sokalsneath)

   would calculate the pair-wise distances between the vectors in
   X using the Python function sokalsneath. This would result in
   sokalsneath being called :math:`{n \\choose 2}` times, which
   is inefficient. Instead, the optimized C version is more
   efficient, and we call it using the following syntax.::

     dm = cdist(XA, XB, 'sokalsneath')

Parameters
----------
XA : ndarray
    An :math:`m_A` by :math:`n` array of :math:`m_A`
    original observations in an :math:`n`-dimensional space.
XB : ndarray
    An :math:`m_B` by :math:`n` array of :math:`m_B`
    original observations in an :math:`n`-dimensional space.
metric : string or function
    The distance metric to use. The distance function can
    be 'braycurtis', 'canberra', 'chebyshev', 'cityblock',
    'correlation', 'cosine', 'dice', 'euclidean', 'hamming',
    'jaccard', 'kulsinski', 'mahalanobis', 'matching',
    'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
    'sokalmichener', 'sokalsneath', 'sqeuclidean', 'wminkowski',
    'yule'.
w : ndarray
    The weight vector (for weighted Minkowski).
p : double
    The p-norm to apply (for Minkowski, weighted and unweighted)
V : ndarray
    The variance vector (for standardized Euclidean).
VI : ndarray
    The inverse of the covariance matrix (for Mahalanobis).

Returns
-------
Y : ndarray
    A :math:`m_A` by :math:`m_B` distance matrix is returned.
    For each :math:`i` and :math:`j`, the metric
    ``dist(u=XA[i], v=XB[j])`` is computed and stored in the
    :math:`ij` th entry.

Raises
------
An exception is thrown if ``XA`` and ``XB`` do not have
the same number of columns.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a7de603cc98f4334e5a9cdf6dac8c2acf}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!chebyshev@{chebyshev}}
\index{chebyshev@{chebyshev}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{chebyshev}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+chebyshev (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a7de603cc98f4334e5a9cdf6dac8c2acf}
\begin{DoxyVerb}Computes the Chebyshev distance.

Computes the Chebyshev distance between two 1-D arrays `u` and `v`,
which is defined as

.. math::

   \\max_i {|u_i-v_i|}.

Parameters
----------
u : (N,) array_like
    Input vector.
v : (N,) array_like
    Input vector.

Returns
-------
chebyshev : double
    The Chebyshev distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_ac029e0f4e7b7808756169861c3b1574d}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!cityblock@{cityblock}}
\index{cityblock@{cityblock}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{cityblock}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+cityblock (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_ac029e0f4e7b7808756169861c3b1574d}
\begin{DoxyVerb}Computes the City Block (Manhattan) distance.

Computes the Manhattan distance between two 1-D arrays `u` and `v`,
which is defined as

.. math::

   \\sum_i {\\left| u_i - v_i \\right|}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
cityblock : double
    The City Block (Manhattan) distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a588f9c43c1859788389c383870c337c8}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!correlation@{correlation}}
\index{correlation@{correlation}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{correlation}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+correlation (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a588f9c43c1859788389c383870c337c8}
\begin{DoxyVerb}Computes the correlation distance between two 1-D arrays.

The correlation distance between `u` and `v`, is
defined as

.. math::

   1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}
           {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}

where :math:`\\bar{u}` is the mean of the elements of `u`
and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
correlation : double
    The correlation distance between 1-D array `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a8b96cda5be045e1cec1c34c06c37c3c0}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!cosine@{cosine}}
\index{cosine@{cosine}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{cosine}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+cosine (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a8b96cda5be045e1cec1c34c06c37c3c0}
\begin{DoxyVerb}Computes the Cosine distance between 1-D arrays.

The Cosine distance between `u` and `v`, is defined as

.. math::

   1 - \\frac{u \\cdot v}
            {||u||_2 ||v||_2}.

where :math:`u \\cdot v` is the dot product of :math:`u` and
:math:`v`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
cosine : double
    The Cosine distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_ad107a58a15e381f1463863e800fdf1e4}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!dice@{dice}}
\index{dice@{dice}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{dice}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+dice (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_ad107a58a15e381f1463863e800fdf1e4}
\begin{DoxyVerb}Computes the Dice dissimilarity between two boolean 1-D arrays.

The Dice dissimilarity between `u` and `v`, is

.. math::

     \\frac{c_{TF} + c_{FT}}
          {2c_{TT} + c_{FT} + c_{TF}}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n`.

Parameters
----------
u : (N,) ndarray, bool
    Input 1-D array.
v : (N,) ndarray, bool
    Input 1-D array.

Returns
-------
dice : double
    The Dice dissimilarity between 1-D arrays `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a108434d094539dcfbae6bc35f488108a}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!euclidean@{euclidean}}
\index{euclidean@{euclidean}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{euclidean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+euclidean (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a108434d094539dcfbae6bc35f488108a}
\begin{DoxyVerb}Computes the Euclidean distance between two 1-D arrays.

The Euclidean distance between 1-D arrays `u` and `v`, is defined as

.. math::

   {||u-v||}_2

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
euclidean : double
    The Euclidean distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a2c5f8a0b13edfdf2152a08694e390681}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!hamming@{hamming}}
\index{hamming@{hamming}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{hamming}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+hamming (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a2c5f8a0b13edfdf2152a08694e390681}
\begin{DoxyVerb}Computes the Hamming distance between two 1-D arrays.

The Hamming distance between 1-D arrays `u` and `v`, is simply the
proportion of disagreeing components in `u` and `v`. If `u` and `v` are
boolean vectors, the Hamming distance is

.. math::

   \\frac{c_{01} + c_{10}}{n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
hamming : double
    The Hamming distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_af4d07c12f69f8711c53e91be94792655}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!is\+\_\+valid\+\_\+dm@{is\+\_\+valid\+\_\+dm}}
\index{is\+\_\+valid\+\_\+dm@{is\+\_\+valid\+\_\+dm}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{is\+\_\+valid\+\_\+dm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+is\+\_\+valid\+\_\+dm (
\begin{DoxyParamCaption}
\item[{}]{D, }
\item[{}]{tol = {\ttfamily 0.0}, }
\item[{}]{throw = {\ttfamily {\bf False}}, }
\item[{}]{name = {\ttfamily \char`\"{}D\char`\"{}}, }
\item[{}]{warning = {\ttfamily {\bf False}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_af4d07c12f69f8711c53e91be94792655}
\begin{DoxyVerb}Returns True if input array is a valid distance matrix.

Distance matrices must be 2-dimensional numpy arrays containing
doubles. They must have a zero-diagonal, and they must be symmetric.

Parameters
----------
D : ndarray
    The candidate object to test for validity.
tol : float, optional
    The distance matrix should be symmetric. `tol` is the maximum
    difference between entries ``ij`` and ``ji`` for the distance
    metric to be considered symmetric.
throw : bool, optional
    An exception is thrown if the distance matrix passed is not valid.
name : str, optional
    The name of the variable to checked. This is useful if
    throw is set to True so the offending variable can be identified
    in the exception message when an exception is thrown.
warning : bool, optional
    Instead of throwing an exception, a warning message is
    raised.

Returns
-------
valid : bool
    True if the variable `D` passed is a valid distance matrix.

Notes
-----
Small numerical differences in `D` and `D.T` and non-zeroness of
the diagonal are ignored if they are within the tolerance specified
by `tol`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a06ab64b4928636ffa559626804147cea}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!is\+\_\+valid\+\_\+y@{is\+\_\+valid\+\_\+y}}
\index{is\+\_\+valid\+\_\+y@{is\+\_\+valid\+\_\+y}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{is\+\_\+valid\+\_\+y}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+is\+\_\+valid\+\_\+y (
\begin{DoxyParamCaption}
\item[{}]{y, }
\item[{}]{warning = {\ttfamily {\bf False}}, }
\item[{}]{throw = {\ttfamily {\bf False}}, }
\item[{}]{name = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a06ab64b4928636ffa559626804147cea}
\begin{DoxyVerb}Returns True if the input array is a valid condensed distance matrix.

Condensed distance matrices must be 1-dimensional
numpy arrays containing doubles. Their length must be a binomial
coefficient :math:`{n \\choose 2}` for some positive integer n.

Parameters
----------
y : ndarray
    The condensed distance matrix.
warning : bool, optional
    Invokes a warning if the variable passed is not a valid
    condensed distance matrix. The warning message explains why
    the distance matrix is not valid.  `name` is used when
    referencing the offending variable.
throws : throw, optional
    Throws an exception if the variable passed is not a valid
    condensed distance matrix.
name : bool, optional
    Used when referencing the offending variable in the
    warning or exception message.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a68a9627afaa09b2dd14b6d938ae0dc0b}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!jaccard@{jaccard}}
\index{jaccard@{jaccard}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{jaccard}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+jaccard (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a68a9627afaa09b2dd14b6d938ae0dc0b}
\begin{DoxyVerb}Computes the Jaccard-Needham dissimilarity between two boolean 1-D arrays.

The Jaccard-Needham dissimilarity between 1-D boolean arrays `u` and `v`,
is defined as

.. math::

   \\frac{c_{TF} + c_{FT}}
        {c_{TT} + c_{FT} + c_{TF}}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
jaccard : double
    The Jaccard distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_ad9fa0f1a4b1c67bf0c767594f4f0910d}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!kulsinski@{kulsinski}}
\index{kulsinski@{kulsinski}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{kulsinski}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+kulsinski (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_ad9fa0f1a4b1c67bf0c767594f4f0910d}
\begin{DoxyVerb}Computes the Kulsinski dissimilarity between two boolean 1-D arrays.

The Kulsinski dissimilarity between two boolean 1-D arrays `u` and `v`,
is defined as

.. math::

     \\frac{c_{TF} + c_{FT} - c_{TT} + n}
          {c_{FT} + c_{TF} + n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
kulsinski : double
    The Kulsinski distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a3c5d20e0351fcf7e47cbd73ac65babac}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!mahalanobis@{mahalanobis}}
\index{mahalanobis@{mahalanobis}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{mahalanobis}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+mahalanobis (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v, }
\item[{}]{V\+I}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a3c5d20e0351fcf7e47cbd73ac65babac}
\begin{DoxyVerb}Computes the Mahalanobis distance between two 1-D arrays.

The Mahalanobis distance between 1-D arrays `u` and `v`, is defined as

.. math::

   \\sqrt{ (u-v) V^{-1} (u-v)^T }

where ``V`` is the covariance matrix.  Note that the argument `VI`
is the inverse of ``V``.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
VI : ndarray
    The inverse of the covariance matrix.

Returns
-------
mahalanobis : double
    The Mahalanobis distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a7c2d1ce4dccd5adcbc03624d61067a54}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!matching@{matching}}
\index{matching@{matching}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{matching}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+matching (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a7c2d1ce4dccd5adcbc03624d61067a54}
\begin{DoxyVerb}Computes the Matching dissimilarity between two boolean 1-D arrays.

The Matching dissimilarity between two boolean 1-D arrays
`u` and `v`, is defined as

.. math::

   \\frac{c_{TF} + c_{FT}}{n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
matching : double
    The Matching dissimilarity between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a42f964c9b59729e10ee81440c20b682c}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!minkowski@{minkowski}}
\index{minkowski@{minkowski}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{minkowski}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+minkowski (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v, }
\item[{}]{p}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a42f964c9b59729e10ee81440c20b682c}
\begin{DoxyVerb}Computes the Minkowski distance between two 1-D arrays.

The Minkowski distance between 1-D arrays `u` and `v`,
is defined as

.. math::

   {||u-v||}_p = (\\sum{|u_i - v_i|^p})^{1/p}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
p : int
    The order of the norm of the difference :math:`{||u-v||}_p`.

Returns
-------
d : double
    The Minkowski distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a036cab00dbf32d0c3377e2a5963a8e3e}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!num\+\_\+obs\+\_\+dm@{num\+\_\+obs\+\_\+dm}}
\index{num\+\_\+obs\+\_\+dm@{num\+\_\+obs\+\_\+dm}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{num\+\_\+obs\+\_\+dm}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+num\+\_\+obs\+\_\+dm (
\begin{DoxyParamCaption}
\item[{}]{d}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a036cab00dbf32d0c3377e2a5963a8e3e}
\begin{DoxyVerb}Returns the number of original observations that correspond to a
square, redundant distance matrix.

Parameters
----------
d : ndarray
    The target distance matrix.

Returns
-------
num_obs_dm : int
    The number of observations in the redundant distance matrix.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a5ed66732e33c885673c32b2f39a703aa}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!num\+\_\+obs\+\_\+y@{num\+\_\+obs\+\_\+y}}
\index{num\+\_\+obs\+\_\+y@{num\+\_\+obs\+\_\+y}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{num\+\_\+obs\+\_\+y}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+num\+\_\+obs\+\_\+y (
\begin{DoxyParamCaption}
\item[{}]{Y}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a5ed66732e33c885673c32b2f39a703aa}
\begin{DoxyVerb}Returns the number of original observations that correspond to a
condensed distance matrix.

Parameters
----------
Y : ndarray
    Condensed distance matrix.

Returns
-------
n : int
    The number of observations in the condensed distance matrix `Y`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a5ba06c0cf7b841afd1980bbe09663744}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!pdist@{pdist}}
\index{pdist@{pdist}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{pdist}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+pdist (
\begin{DoxyParamCaption}
\item[{}]{X, }
\item[{}]{metric = {\ttfamily 'euclidean'}, }
\item[{}]{p = {\ttfamily 2}, }
\item[{}]{w = {\ttfamily None}, }
\item[{}]{V = {\ttfamily None}, }
\item[{}]{V\+I = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a5ba06c0cf7b841afd1980bbe09663744}
\begin{DoxyVerb}Pairwise distances between observations in n-dimensional space.

The following are common calling conventions.

1. ``Y = pdist(X, 'euclidean')``

   Computes the distance between m points using Euclidean distance
   (2-norm) as the distance metric between the points. The points
   are arranged as m n-dimensional row vectors in the matrix X.

2. ``Y = pdist(X, 'minkowski', p)``

   Computes the distances using the Minkowski distance
   :math:`||u-v||_p` (p-norm) where :math:`p \\geq 1`.

3. ``Y = pdist(X, 'cityblock')``

   Computes the city block or Manhattan distance between the
   points.

4. ``Y = pdist(X, 'seuclidean', V=None)``

   Computes the standardized Euclidean distance. The standardized
   Euclidean distance between two n-vectors ``u`` and ``v`` is

   .. math::

      \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}


   V is the variance vector; V[i] is the variance computed over all
   the i'th components of the points.  If not passed, it is
   automatically computed.

5. ``Y = pdist(X, 'sqeuclidean')``

   Computes the squared Euclidean distance :math:`||u-v||_2^2` between
   the vectors.

6. ``Y = pdist(X, 'cosine')``

   Computes the cosine distance between vectors u and v,

   .. math::

      1 - \\frac{u \\cdot v}
               {{||u||}_2 {||v||}_2}

   where :math:`||*||_2` is the 2-norm of its argument ``*``, and
   :math:`u \\cdot v` is the dot product of ``u`` and ``v``.

7. ``Y = pdist(X, 'correlation')``

   Computes the correlation distance between vectors u and v. This is

   .. math::

      1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}
               {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}

   where :math:`\\bar{v}` is the mean of the elements of vector v,
   and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.

8. ``Y = pdist(X, 'hamming')``

   Computes the normalized Hamming distance, or the proportion of
   those vector elements between two n-vectors ``u`` and ``v``
   which disagree. To save memory, the matrix ``X`` can be of type
   boolean.

9. ``Y = pdist(X, 'jaccard')``

   Computes the Jaccard distance between the points. Given two
   vectors, ``u`` and ``v``, the Jaccard distance is the
   proportion of those elements ``u[i]`` and ``v[i]`` that
   disagree where at least one of them is non-zero.

10. ``Y = pdist(X, 'chebyshev')``

   Computes the Chebyshev distance between the points. The
   Chebyshev distance between two n-vectors ``u`` and ``v`` is the
   maximum norm-1 distance between their respective elements. More
   precisely, the distance is given by

   .. math::

      d(u,v) = \\max_i {|u_i-v_i|}

11. ``Y = pdist(X, 'canberra')``

   Computes the Canberra distance between the points. The
   Canberra distance between two points ``u`` and ``v`` is

   .. math::

     d(u,v) = \\sum_i \\frac{|u_i-v_i|}
                          {|u_i|+|v_i|}


12. ``Y = pdist(X, 'braycurtis')``

   Computes the Bray-Curtis distance between the points. The
   Bray-Curtis distance between two points ``u`` and ``v`` is


   .. math::

        d(u,v) = \\frac{\\sum_i {u_i-v_i}}
                      {\\sum_i {u_i+v_i}}

13. ``Y = pdist(X, 'mahalanobis', VI=None)``

   Computes the Mahalanobis distance between the points. The
   Mahalanobis distance between two points ``u`` and ``v`` is
   :math:`(u-v)(1/V)(u-v)^T` where :math:`(1/V)` (the ``VI``
   variable) is the inverse covariance. If ``VI`` is not None,
   ``VI`` will be used as the inverse covariance matrix.

14. ``Y = pdist(X, 'yule')``

   Computes the Yule distance between each pair of boolean
   vectors. (see yule function documentation)

15. ``Y = pdist(X, 'matching')``

   Computes the matching distance between each pair of boolean
   vectors. (see matching function documentation)

16. ``Y = pdist(X, 'dice')``

   Computes the Dice distance between each pair of boolean
   vectors. (see dice function documentation)

17. ``Y = pdist(X, 'kulsinski')``

   Computes the Kulsinski distance between each pair of
   boolean vectors. (see kulsinski function documentation)

18. ``Y = pdist(X, 'rogerstanimoto')``

   Computes the Rogers-Tanimoto distance between each pair of
   boolean vectors. (see rogerstanimoto function documentation)

19. ``Y = pdist(X, 'russellrao')``

   Computes the Russell-Rao distance between each pair of
   boolean vectors. (see russellrao function documentation)

20. ``Y = pdist(X, 'sokalmichener')``

   Computes the Sokal-Michener distance between each pair of
   boolean vectors. (see sokalmichener function documentation)

21. ``Y = pdist(X, 'sokalsneath')``

   Computes the Sokal-Sneath distance between each pair of
   boolean vectors. (see sokalsneath function documentation)

22. ``Y = pdist(X, 'wminkowski')``

   Computes the weighted Minkowski distance between each pair of
   vectors. (see wminkowski function documentation)

23. ``Y = pdist(X, f)``

   Computes the distance between all pairs of vectors in X
   using the user supplied 2-arity function f. For example,
   Euclidean distance between the vectors could be computed
   as follows::

     dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum()))

   Note that you should avoid passing a reference to one of
   the distance functions defined in this library. For example,::

     dm = pdist(X, sokalsneath)

   would calculate the pair-wise distances between the vectors in
   X using the Python function sokalsneath. This would result in
   sokalsneath being called :math:`{n \\choose 2}` times, which
   is inefficient. Instead, the optimized C version is more
   efficient, and we call it using the following syntax.::

     dm = pdist(X, 'sokalsneath')

Parameters
----------
X : ndarray
    An m by n array of m original observations in an
    n-dimensional space.
metric : string or function
    The distance metric to use. The distance function can
    be 'braycurtis', 'canberra', 'chebyshev', 'cityblock',
    'correlation', 'cosine', 'dice', 'euclidean', 'hamming',
    'jaccard', 'kulsinski', 'mahalanobis', 'matching',
    'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
    'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'.
w : ndarray
    The weight vector (for weighted Minkowski).
p : double
    The p-norm to apply (for Minkowski, weighted and unweighted)
V : ndarray
        The variance vector (for standardized Euclidean).
VI : ndarray
    The inverse of the covariance matrix (for Mahalanobis).

Returns
-------
Y : ndarray
    Returns a condensed distance matrix Y.  For
    each :math:`i` and :math:`j` (where :math:`i<j<n`), the
    metric ``dist(u=X[i], v=X[j])`` is computed and stored in entry ``ij``.

See Also
--------
squareform : converts between condensed distance matrices and
             square distance matrices.

Notes
-----
See ``squareform`` for information on how to calculate the index of
this entry or to convert the condensed distance matrix to a
redundant square matrix.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_ace78ac9a6feba0a188ce3f99bd6062fc}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!rogerstanimoto@{rogerstanimoto}}
\index{rogerstanimoto@{rogerstanimoto}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{rogerstanimoto}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+rogerstanimoto (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_ace78ac9a6feba0a188ce3f99bd6062fc}
\begin{DoxyVerb}Computes the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.

The Rogers-Tanimoto dissimilarity between two boolean 1-D arrays
`u` and `v`, is defined as

.. math::
   \\frac{R}
        {c_{TT} + c_{FF} + R}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n` and :math:`R = 2(c_{TF} + c_{FT})`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
rogerstanimoto : double
    The Rogers-Tanimoto dissimilarity between vectors
    `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_afaa1633ffa1c0ee142e187c314b913f1}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!russellrao@{russellrao}}
\index{russellrao@{russellrao}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{russellrao}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+russellrao (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_afaa1633ffa1c0ee142e187c314b913f1}
\begin{DoxyVerb}Computes the Russell-Rao dissimilarity between two boolean 1-D arrays.

The Russell-Rao dissimilarity between two boolean 1-D arrays, `u` and
`v`, is defined as

.. math::

  \\frac{n - c_{TT}}
       {n}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
russellrao : double
    The Russell-Rao dissimilarity between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a3e57a4b6dbe657d7e38f9daa6eba315a}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!seuclidean@{seuclidean}}
\index{seuclidean@{seuclidean}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{seuclidean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+seuclidean (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v, }
\item[{}]{V}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a3e57a4b6dbe657d7e38f9daa6eba315a}
\begin{DoxyVerb}Returns the standardized Euclidean distance between two 1-D arrays.

The standardized Euclidean distance between `u` and `v`.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
V : (N,) array_like
    `V` is an 1-D array of component variances. It is usually computed
    among a larger collection vectors.

Returns
-------
seuclidean : double
    The standardized Euclidean distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a3a0e6b50f64498cc097d3fcb503ed8da}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!sokalmichener@{sokalmichener}}
\index{sokalmichener@{sokalmichener}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{sokalmichener}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+sokalmichener (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a3a0e6b50f64498cc097d3fcb503ed8da}
\begin{DoxyVerb}Computes the Sokal-Michener dissimilarity between two boolean 1-D arrays.

The Sokal-Michener dissimilarity between boolean 1-D arrays `u` and `v`,
is defined as

.. math::

   \\frac{R}
        {S + R}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n`, :math:`R = 2 * (c_{TF} + c_{FT})` and
:math:`S = c_{FF} + c_{TT}`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
sokalmichener : double
    The Sokal-Michener dissimilarity between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a01b1431beb2b5b5a9e018b23961508db}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!sokalsneath@{sokalsneath}}
\index{sokalsneath@{sokalsneath}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{sokalsneath}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+sokalsneath (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a01b1431beb2b5b5a9e018b23961508db}
\begin{DoxyVerb}Computes the Sokal-Sneath dissimilarity between two boolean 1-D arrays.

The Sokal-Sneath dissimilarity between `u` and `v`,

.. math::

   \\frac{R}
        {c_{TT} + R}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n` and :math:`R = 2(c_{TF} + c_{FT})`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
sokalsneath : double
    The Sokal-Sneath dissimilarity between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a58d74cd7cf9313f0bf10afc5037a9a98}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!sqeuclidean@{sqeuclidean}}
\index{sqeuclidean@{sqeuclidean}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{sqeuclidean}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+sqeuclidean (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a58d74cd7cf9313f0bf10afc5037a9a98}
\begin{DoxyVerb}Computes the squared Euclidean distance between two 1-D arrays.

The squared Euclidean distance between `u` and `v` is defined as

.. math::

   {||u-v||}_2^2.


Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.

Returns
-------
sqeuclidean : double
    The squared Euclidean distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a2a23c7f48657843ae5739fc231745529}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!squareform@{squareform}}
\index{squareform@{squareform}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{squareform}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+squareform (
\begin{DoxyParamCaption}
\item[{}]{X, }
\item[{}]{force = {\ttfamily \char`\"{}no\char`\"{}}, }
\item[{}]{checks = {\ttfamily {\bf True}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a2a23c7f48657843ae5739fc231745529}
\begin{DoxyVerb}Converts a vector-form distance vector to a square-form distance
matrix, and vice-versa.

Parameters
----------
X : ndarray
    Either a condensed or redundant distance matrix.
force : str, optional
    As with MATLAB(TM), if force is equal to 'tovector' or 'tomatrix',
    the input will be treated as a distance matrix or distance vector
    respectively.
checks : bool, optional
    If `checks` is set to False, no checks will be made for matrix
    symmetry nor zero diagonals. This is useful if it is known that
    ``X - X.T1`` is small and ``diag(X)`` is close to zero.
    These values are ignored any way so they do not disrupt the
    squareform transformation.

Returns
-------
Y : ndarray
    If a condensed distance matrix is passed, a redundant one is
    returned, or if a redundant one is passed, a condensed distance
    matrix is returned.

Notes
-----

1. v = squareform(X)

   Given a square d-by-d symmetric distance matrix X,
   ``v=squareform(X)`` returns a ``d * (d-1) / 2`` (or
   `${n \\choose 2}$`) sized vector v.

  v[{n \\choose 2}-{n-i \\choose 2} + (j-i-1)] is the distance
  between points i and j. If X is non-square or asymmetric, an error
  is returned.

2. X = squareform(v)

  Given a d*d(-1)/2 sized v for some integer d>=2 encoding distances
  as described, X=squareform(v) returns a d by d distance matrix X. The
  X[i, j] and X[j, i] values are set to
  v[{n \\choose 2}-{n-i \\choose 2} + (j-u-1)] and all
  diagonal elements are zero.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_aad6bcf15a40337aa59d8c4b652efb7ac}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!wminkowski@{wminkowski}}
\index{wminkowski@{wminkowski}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{wminkowski}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+wminkowski (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v, }
\item[{}]{p, }
\item[{}]{w}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_aad6bcf15a40337aa59d8c4b652efb7ac}
\begin{DoxyVerb}Computes the weighted Minkowski distance between two 1-D arrays.

The weighted Minkowski distance between `u` and `v`, defined as

.. math::

   \\left(\\sum{(w_i |u_i - v_i|^p)}\\right)^{1/p}.

Parameters
----------
u : (N,) array_like
    Input array.
v : (N,) array_like
    Input array.
p : int
    The order of the norm of the difference :math:`{||u-v||}_p`.
w : (N,) array_like
    The weight vector.

Returns
-------
wminkowski : double
    The weighted Minkowski distance between vectors `u` and `v`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1spatial_1_1distance_a2cd113484f0d7ca9328d0ed8b43e9a56}{}\index{scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}!yule@{yule}}
\index{yule@{yule}!scipy\+::spatial\+::distance@{scipy\+::spatial\+::distance}}
\subsubsection[{yule}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+spatial.\+distance.\+yule (
\begin{DoxyParamCaption}
\item[{}]{u, }
\item[{}]{v}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1spatial_1_1distance_a2cd113484f0d7ca9328d0ed8b43e9a56}
\begin{DoxyVerb}Computes the Yule dissimilarity between two boolean 1-D arrays.

The Yule dissimilarity is defined as

.. math::

     \\frac{R}{c_{TT} + c_{FF} + \\frac{R}{2}}

where :math:`c_{ij}` is the number of occurrences of
:math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for
:math:`k < n` and :math:`R = 2.0 * (c_{TF} + c_{FT})`.

Parameters
----------
u : (N,) array_like, bool
    Input array.
v : (N,) array_like, bool
    Input array.

Returns
-------
yule : double
    The Yule dissimilarity between vectors `u` and `v`.\end{DoxyVerb}
 