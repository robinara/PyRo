<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.linalg.special_matrices Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html">special_matrices</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.linalg.special_matrices Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d0a7d30030d80e381f63e2ef971a714"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a1d0a7d30030d80e381f63e2ef971a714">tri</a></td></tr>
<tr class="separator:a1d0a7d30030d80e381f63e2ef971a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c32598aee8dd19083c2d2fdcfb91b71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a1c32598aee8dd19083c2d2fdcfb91b71">tril</a></td></tr>
<tr class="separator:a1c32598aee8dd19083c2d2fdcfb91b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c95b2593bb820dfe81db87975680ae0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a7c95b2593bb820dfe81db87975680ae0">triu</a></td></tr>
<tr class="separator:a7c95b2593bb820dfe81db87975680ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956c5dd0f4f826c84ade4f05e5a9ca71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a956c5dd0f4f826c84ade4f05e5a9ca71">toeplitz</a></td></tr>
<tr class="separator:a956c5dd0f4f826c84ade4f05e5a9ca71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089b43b1d83ca2ce9e2d66359839ea42"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a089b43b1d83ca2ce9e2d66359839ea42">circulant</a></td></tr>
<tr class="separator:a089b43b1d83ca2ce9e2d66359839ea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5c66acb8f68f2d4f943bc3ab4b3fc5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a8d5c66acb8f68f2d4f943bc3ab4b3fc5">hankel</a></td></tr>
<tr class="separator:a8d5c66acb8f68f2d4f943bc3ab4b3fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd30b1c08c1509ebc07176389ae33eb4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#afd30b1c08c1509ebc07176389ae33eb4">hadamard</a></td></tr>
<tr class="separator:afd30b1c08c1509ebc07176389ae33eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a46577eb6a31aec0691067343b05d35"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a0a46577eb6a31aec0691067343b05d35">leslie</a></td></tr>
<tr class="separator:a0a46577eb6a31aec0691067343b05d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02c3d3dccb03921ed43f6093a12ec21"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#af02c3d3dccb03921ed43f6093a12ec21">all_mat</a></td></tr>
<tr class="separator:af02c3d3dccb03921ed43f6093a12ec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb19a49c2da87e83c87b1e2cb823f79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a0eb19a49c2da87e83c87b1e2cb823f79">kron</a></td></tr>
<tr class="separator:a0eb19a49c2da87e83c87b1e2cb823f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4270663b70fed85d7102b6bdcc4fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a1fc4270663b70fed85d7102b6bdcc4fa">block_diag</a></td></tr>
<tr class="separator:a1fc4270663b70fed85d7102b6bdcc4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6693e189c145d981aab4905af81304a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a6693e189c145d981aab4905af81304a9">companion</a></td></tr>
<tr class="separator:a6693e189c145d981aab4905af81304a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2c714feeb8d0db33ec51890be105db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#afb2c714feeb8d0db33ec51890be105db">hilbert</a></td></tr>
<tr class="separator:afb2c714feeb8d0db33ec51890be105db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa7874f9fcfd29ad15ac66a70be2563"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a4aa7874f9fcfd29ad15ac66a70be2563">invhilbert</a></td></tr>
<tr class="separator:a4aa7874f9fcfd29ad15ac66a70be2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e4d88ee3f228d97121c523e9344ad8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a41e4d88ee3f228d97121c523e9344ad8">pascal</a></td></tr>
<tr class="separator:a41e4d88ee3f228d97121c523e9344ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2990f8207533d7748b89fbf2373f39d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a2990f8207533d7748b89fbf2373f39d2">dft</a></td></tr>
<tr class="separator:a2990f8207533d7748b89fbf2373f39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5d4edce99d2a3ae0302b0ae9371ff6fe"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1special__matrices.html#a5d4edce99d2a3ae0302b0ae9371ff6fe">__all__</a></td></tr>
<tr class="separator:a5d4edce99d2a3ae0302b0ae9371ff6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af02c3d3dccb03921ed43f6093a12ec21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.all_mat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1fc4270663b70fed85d7102b6bdcc4fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.block_diag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a block diagonal matrix from provided arrays.

Given the inputs `A`, `B` and `C`, the output will have these
arrays arranged on the diagonal::

    [[A, 0, 0],
     [0, B, 0],
     [0, 0, C]]

Parameters
----------
A, B, C, ... : array_like, up to 2-D
    Input arrays.  A 1-D array or array_like sequence of length `n`is
    treated as a 2-D array with shape ``(1,n)``.

Returns
-------
D : ndarray
    Array with `A`, `B`, `C`, ... on the diagonal.  `D` has the
    same dtype as `A`.

Notes
-----
If all the input arrays are square, the output is known as a
block diagonal matrix.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import block_diag
&gt;&gt;&gt; A = [[1, 0],
...      [0, 1]]
&gt;&gt;&gt; B = [[3, 4, 5],
...      [6, 7, 8]]
&gt;&gt;&gt; C = [[7]]
&gt;&gt;&gt; block_diag(A, B, C)
[[1 0 0 0 0 0]
 [0 1 0 0 0 0]
 [0 0 3 4 5 0]
 [0 0 6 7 8 0]
 [0 0 0 0 0 7]]
&gt;&gt;&gt; block_diag(1.0, [2, 3], [[4, 5], [6, 7]])
array([[ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  2.,  3.,  0.,  0.],
       [ 0.,  0.,  0.,  4.,  5.],
       [ 0.,  0.,  0.,  6.,  7.]])</pre> 
</div>
</div>
<a class="anchor" id="a089b43b1d83ca2ce9e2d66359839ea42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.circulant </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a circulant matrix.

Parameters
----------
c : (N,) array_like
    1-D array, the first column of the matrix.

Returns
-------
A : (N, N) ndarray
    A circulant matrix whose first column is `c`.

See also
--------
toeplitz : Toeplitz matrix
hankel : Hankel matrix

Notes
-----
.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import circulant
&gt;&gt;&gt; circulant([1, 2, 3])
array([[1, 3, 2],
       [2, 1, 3],
       [3, 2, 1]])</pre> 
</div>
</div>
<a class="anchor" id="a6693e189c145d981aab4905af81304a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.companion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a companion matrix.

Create the companion matrix [1]_ associated with the polynomial whose
coefficients are given in `a`.

Parameters
----------
a : (N,) array_like
    1-D array of polynomial coefficients.  The length of `a` must be
    at least two, and ``a[0]`` must not be zero.

Returns
-------
c : (N-1, N-1) ndarray
    The first row of `c` is ``-a[1:]/a[0]``, and the first
    sub-diagonal is all ones.  The data-type of the array is the same
    as the data-type of ``1.0*a[0]``.

Raises
------
ValueError
    If any of the following are true: a) ``a.ndim != 1``;
    b) ``a.size &lt; 2``; c) ``a[0] == 0``.

Notes
-----
.. versionadded:: 0.8.0

References
----------
.. [1] R. A. Horn &amp; C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:
    Cambridge University Press, 1999, pp. 146-7.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import companion
&gt;&gt;&gt; companion([1, -10, 31, -30])
array([[ 10., -31.,  30.],
       [  1.,   0.,   0.],
       [  0.,   1.,   0.]])</pre> 
</div>
</div>
<a class="anchor" id="a2990f8207533d7748b89fbf2373f39d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.dft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Discrete Fourier transform matrix.

Create the matrix that computes the discrete Fourier transform of a
sequence [1]_.  The n-th primitive root of unity used to generate the
matrix is exp(-2*pi*i/n), where i = sqrt(-1).

Parameters
----------
n : int
    Size the matrix to create.
scale : str, optional
    Must be None, 'sqrtn', or 'n'.
    If `scale` is 'sqrtn', the matrix is divided by `sqrt(n)`.
    If `scale` is 'n', the matrix is divided by `n`.
    If `scale` is None (the default), the matrix is not normalized, and the
    return value is simply the Vandermonde matrix of the roots of unity.

Returns
-------
m : (n, n) ndarray
    The DFT matrix.

Notes
-----
When `scale` is None, multiplying a vector by the matrix returned by
`dft` is mathematically equivalent to (but much less efficient than)
the calculation performed by `scipy.fftpack.fft`.

.. versionadded:: 0.14.0

References
----------
.. [1] "DFT matrix", http://en.wikipedia.org/wiki/DFT_matrix

Examples
--------
&gt;&gt;&gt; np.set_printoptions(precision=5, suppress=True)
&gt;&gt;&gt; x = np.array([1, 2, 3, 0, 3, 2, 1, 0])
&gt;&gt;&gt; m = dft(8)
&gt;&gt;&gt; m.dot(x)   # Comute the DFT of x
array([ 12.+0.j,  -2.-2.j,   0.-4.j,  -2.+2.j,   4.+0.j,  -2.-2.j,
        -0.+4.j,  -2.+2.j])

Verify that ``m.dot(x)`` is the same as ``fft(x)``.

&gt;&gt;&gt; from scipy.fftpack import fft
&gt;&gt;&gt; fft(x)     # Same result as m.dot(x)
array([ 12.+0.j,  -2.-2.j,   0.-4.j,  -2.+2.j,   4.+0.j,  -2.-2.j,
         0.+4.j,  -2.+2.j])
</pre> 
</div>
</div>
<a class="anchor" id="afd30b1c08c1509ebc07176389ae33eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.hadamard </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>int</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a Hadamard matrix.

Constructs an n-by-n Hadamard matrix, using Sylvester's
construction.  `n` must be a power of 2.

Parameters
----------
n : int
    The order of the matrix.  `n` must be a power of 2.
dtype : numpy dtype
    The data type of the array to be constructed.

Returns
-------
H : (n, n) ndarray
    The Hadamard matrix.

Notes
-----
.. versionadded:: 0.8.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hadamard
&gt;&gt;&gt; hadamard(2, dtype=complex)
array([[ 1.+0.j,  1.+0.j],
       [ 1.+0.j, -1.-0.j]])
&gt;&gt;&gt; hadamard(4)
array([[ 1,  1,  1,  1],
       [ 1, -1,  1, -1],
       [ 1,  1, -1, -1],
       [ 1, -1, -1,  1]])</pre> 
</div>
</div>
<a class="anchor" id="a8d5c66acb8f68f2d4f943bc3ab4b3fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.hankel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a Hankel matrix.

The Hankel matrix has constant anti-diagonals, with `c` as its
first column and `r` as its last row.  If `r` is not given, then
`r = zeros_like(c)` is assumed.

Parameters
----------
c : array_like
    First column of the matrix.  Whatever the actual shape of `c`, it
    will be converted to a 1-D array.
r : array_like
    Last row of the matrix. If None, ``r = zeros_like(c)`` is assumed.
    r[0] is ignored; the last row of the returned matrix is
    ``[c[-1], r[1:]]``.  Whatever the actual shape of `r`, it will be
    converted to a 1-D array.

Returns
-------
A : (len(c), len(r)) ndarray
    The Hankel matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.

See also
--------
toeplitz : Toeplitz matrix
circulant : circulant matrix

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hankel
&gt;&gt;&gt; hankel([1, 17, 99])
array([[ 1, 17, 99],
       [17, 99,  0],
       [99,  0,  0]])
&gt;&gt;&gt; hankel([1,2,3,4], [4,7,7,8,9])
array([[1, 2, 3, 4, 7],
       [2, 3, 4, 7, 7],
       [3, 4, 7, 7, 8],
       [4, 7, 7, 8, 9]])</pre> 
</div>
</div>
<a class="anchor" id="afb2c714feeb8d0db33ec51890be105db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.hilbert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a Hilbert matrix of order `n`.

Returns the `n` by `n` array with entries `h[i,j] = 1 / (i + j + 1)`.

Parameters
----------
n : int
    The size of the array to create.

Returns
-------
h : (n, n) ndarray
    The Hilbert matrix.

See Also
--------
invhilbert : Compute the inverse of a Hilbert matrix.

Notes
-----
.. versionadded:: 0.10.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import hilbert
&gt;&gt;&gt; hilbert(3)
array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.5       ,  0.33333333,  0.25      ],
       [ 0.33333333,  0.25      ,  0.2       ]])</pre> 
</div>
</div>
<a class="anchor" id="a4aa7874f9fcfd29ad15ac66a70be2563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.invhilbert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exact</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the inverse of the Hilbert matrix of order `n`.

The entries in the inverse of a Hilbert matrix are integers.  When `n`
is greater than 14, some entries in the inverse exceed the upper limit
of 64 bit integers.  The `exact` argument provides two options for
dealing with these large integers.

Parameters
----------
n : int
    The order of the Hilbert matrix.
exact : bool
    If False, the data type of the array that is returned is np.float64,
    and the array is an approximation of the inverse.
    If True, the array is the exact integer inverse array.  To represent
    the exact inverse when n &gt; 14, the returned array is an object array
    of long integers.  For n &lt;= 14, the exact inverse is returned as an
    array with data type np.int64.

Returns
-------
invh : (n, n) ndarray
    The data type of the array is np.float64 if `exact` is False.
    If `exact` is True, the data type is either np.int64 (for n &lt;= 14)
    or object (for n &gt; 14).  In the latter case, the objects in the
    array will be long integers.

See Also
--------
hilbert : Create a Hilbert matrix.

Notes
-----
.. versionadded:: 0.10.0

Examples
--------
&gt;&gt;&gt; from scipy.linalg import invhilbert
&gt;&gt;&gt; invhilbert(4)
array([[   16.,  -120.,   240.,  -140.],
       [ -120.,  1200., -2700.,  1680.],
       [  240., -2700.,  6480., -4200.],
       [ -140.,  1680., -4200.,  2800.]])
&gt;&gt;&gt; invhilbert(4, exact=True)
array([[   16,  -120,   240,  -140],
       [ -120,  1200, -2700,  1680],
       [  240, -2700,  6480, -4200],
       [ -140,  1680, -4200,  2800]], dtype=int64)
&gt;&gt;&gt; invhilbert(16)[7,7]
4.2475099528537506e+19
&gt;&gt;&gt; invhilbert(16, exact=True)[7,7]
42475099528537378560L</pre> 
</div>
</div>
<a class="anchor" id="a0eb19a49c2da87e83c87b1e2cb823f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.kron </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Kronecker product.

The result is the block matrix::

    a[0,0]*b    a[0,1]*b  ... a[0,-1]*b
    a[1,0]*b    a[1,1]*b  ... a[1,-1]*b
    ...
    a[-1,0]*b   a[-1,1]*b ... a[-1,-1]*b

Parameters
----------
a : (M, N) ndarray
    Input array
b : (P, Q) ndarray
    Input array

Returns
-------
A : (M*P, N*Q) ndarray
    Kronecker product of `a` and `b`.

Examples
--------
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; from scipy.linalg import kron
&gt;&gt;&gt; kron(array([[1,2],[3,4]]), array([[1,1,1]]))
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])</pre> 
</div>
</div>
<a class="anchor" id="a0a46577eb6a31aec0691067343b05d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.leslie </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a Leslie matrix.

Given the length n array of fecundity coefficients `f` and the length
n-1 array of survival coefficents `s`, return the associated Leslie matrix.

Parameters
----------
f : (N,) array_like
    The "fecundity" coefficients.
s : (N-1,) array_like
    The "survival" coefficients, has to be 1-D.  The length of `s`
    must be one less than the length of `f`, and it must be at least 1.

Returns
-------
L : (N, N) ndarray
    The array is zero except for the first row,
    which is `f`, and the first sub-diagonal, which is `s`.
    The data-type of the array will be the data-type of ``f[0]+s[0]``.

Notes
-----
.. versionadded:: 0.8.0

The Leslie matrix is used to model discrete-time, age-structured
population growth [1]_ [2]_. In a population with `n` age classes, two sets
of parameters define a Leslie matrix: the `n` "fecundity coefficients",
which give the number of offspring per-capita produced by each age
class, and the `n` - 1 "survival coefficients", which give the
per-capita survival rate of each age class.

References
----------
.. [1] P. H. Leslie, On the use of matrices in certain population
       mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945)
.. [2] P. H. Leslie, Some further notes on the use of matrices in
       population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245
       (Dec. 1948)

Examples
--------
&gt;&gt;&gt; from scipy.linalg import leslie
&gt;&gt;&gt; leslie([0.1, 2.0, 1.0, 0.1], [0.2, 0.8, 0.7])
array([[ 0.1,  2. ,  1. ,  0.1],
       [ 0.2,  0. ,  0. ,  0. ],
       [ 0. ,  0.8,  0. ,  0. ],
       [ 0. ,  0. ,  0.7,  0. ]])</pre> 
</div>
</div>
<a class="anchor" id="a41e4d88ee3f228d97121c523e9344ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.pascal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>'symmetric'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exact</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the n x n Pascal matrix.

The Pascal matrix is a matrix containing the binomial coefficients as
its elements.

.. versionadded:: 0.11.0

Parameters
----------
n : int
    The size of the matrix to create; that is, the result is an n x n
    matrix.
kind : str, optional
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.
exact : bool, optional
    If `exact` is True, the result is either an array of type
    numpy.uint64 (if n &lt;= 35) or an object array of Python long integers.
    If `exact` is False, the coefficients in the matrix are computed using
    `scipy.special.comb` with `exact=False`.  The result will be a floating
    point array, and the values in the array will not be the exact
    coefficients, but this version is much faster than `exact=True`.

Returns
-------
p : (n, n) ndarray
    The Pascal matrix.

Notes
-----
See http://en.wikipedia.org/wiki/Pascal_matrix for more information
about Pascal matrices.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import pascal
&gt;&gt;&gt; pascal(4)
array([[ 1,  1,  1,  1],
       [ 1,  2,  3,  4],
       [ 1,  3,  6, 10],
       [ 1,  4, 10, 20]], dtype=uint64)
&gt;&gt;&gt; pascal(4, kind='lower')
array([[1, 0, 0, 0],
       [1, 1, 0, 0],
       [1, 2, 1, 0],
       [1, 3, 3, 1]], dtype=uint64)
&gt;&gt;&gt; pascal(50)[-1, -1]
25477612258980856902730428600L
&gt;&gt;&gt; from scipy.special import comb
&gt;&gt;&gt; comb(98, 49, exact=True)
25477612258980856902730428600L</pre> 
</div>
</div>
<a class="anchor" id="a956c5dd0f4f826c84ade4f05e5a9ca71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.toeplitz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct a Toeplitz matrix.

The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, ``r == conjugate(c)`` is
assumed.

Parameters
----------
c : array_like
    First column of the matrix.  Whatever the actual shape of `c`, it
    will be converted to a 1-D array.
r : array_like
    First row of the matrix. If None, ``r = conjugate(c)`` is assumed;
    in this case, if c[0] is real, the result is a Hermitian matrix.
    r[0] is ignored; the first row of the returned matrix is
    ``[c[0], r[1:]]``.  Whatever the actual shape of `r`, it will be
    converted to a 1-D array.

Returns
-------
A : (len(c), len(r)) ndarray
    The Toeplitz matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.

See also
--------
circulant : circulant matrix
hankel : Hankel matrix

Notes
-----
The behavior when `c` or `r` is a scalar, or when `c` is complex and
`r` is None, was changed in version 0.8.0.  The behavior in previous
versions was undocumented and is no longer supported.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import toeplitz
&gt;&gt;&gt; toeplitz([1,2,3], [1,4,5,6])
array([[1, 4, 5, 6],
       [2, 1, 4, 5],
       [3, 2, 1, 4]])
&gt;&gt;&gt; toeplitz([1.0, 2+3j, 4-1j])
array([[ 1.+0.j,  2.-3.j,  4.+1.j],
       [ 2.+3.j,  1.+0.j,  2.-3.j],
       [ 4.-1.j,  2.+3.j,  1.+0.j]])</pre> 
</div>
</div>
<a class="anchor" id="a1d0a7d30030d80e381f63e2ef971a714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.tri </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct (N, M) matrix filled with ones at and below the k-th diagonal.

The matrix has A[i,j] == 1 for i &lt;= j + k

Parameters
----------
N : integer
    The size of the first dimension of the matrix.
M : integer or None
    The size of the second dimension of the matrix. If `M` is None,
    `M = N` is assumed.
k : integer
    Number of subdiagonal below which matrix is filled with ones.
    `k` = 0 is the main diagonal, `k` &lt; 0 subdiagonal and `k` &gt; 0
    superdiagonal.
dtype : dtype
    Data type of the matrix.

Returns
-------
tri : (N, M) ndarray
    Tri matrix.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tri
&gt;&gt;&gt; tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])
&gt;&gt;&gt; tri(3, 5, -1, dtype=int)
array([[0, 0, 0, 0, 0],
       [1, 0, 0, 0, 0],
       [1, 1, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a1c32598aee8dd19083c2d2fdcfb91b71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.tril </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a copy of a matrix with elements above the k-th diagonal zeroed.

Parameters
----------
m : array_like
    Matrix whose elements to return
k : integer
    Diagonal above which to zero elements.
    `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
    `k` &gt; 0 superdiagonal.

Returns
-------
tril : ndarray
    Return is the same shape and type as `m`.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import tril
&gt;&gt;&gt; tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])</pre> 
</div>
</div>
<a class="anchor" id="a7c95b2593bb820dfe81db87975680ae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.special_matrices.triu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a copy of a matrix with elements below the k-th diagonal zeroed.

Parameters
----------
m : array_like
    Matrix whose elements to return
k : int, optional
    Diagonal below which to zero elements.
    `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and
    `k` &gt; 0 superdiagonal.

Returns
-------
triu : ndarray
    Return matrix with zeroed elements below the k-th diagonal and has
    same shape and type as `m`.

Examples
--------
&gt;&gt;&gt; from scipy.linalg import triu
&gt;&gt;&gt; triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a5d4edce99d2a3ae0302b0ae9371ff6fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.linalg.special_matrices.__all__</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespacescipy_1_1linalg_1_1special__matrices.html">    1</a></span>&#160;= [<span class="stringliteral">&#39;tri&#39;</span>, <span class="stringliteral">&#39;tril&#39;</span>, <span class="stringliteral">&#39;triu&#39;</span>, <span class="stringliteral">&#39;toeplitz&#39;</span>, <span class="stringliteral">&#39;circulant&#39;</span>, <span class="stringliteral">&#39;hankel&#39;</span>,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;           <span class="stringliteral">&#39;hadamard&#39;</span>, <span class="stringliteral">&#39;leslie&#39;</span>, <span class="stringliteral">&#39;all_mat&#39;</span>, <span class="stringliteral">&#39;kron&#39;</span>, <span class="stringliteral">&#39;block_diag&#39;</span>, <span class="stringliteral">&#39;companion&#39;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;           <span class="stringliteral">&#39;hilbert&#39;</span>, <span class="stringliteral">&#39;invhilbert&#39;</span>, <span class="stringliteral">&#39;pascal&#39;</span>, <span class="stringliteral">&#39;dft&#39;</span>]</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:12 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
