<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.ndimage.measurements Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1ndimage.html">ndimage</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html">measurements</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.ndimage.measurements Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4779cd2460f28fb863d04f22bec5969f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a4779cd2460f28fb863d04f22bec5969f">label</a></td></tr>
<tr class="separator:a4779cd2460f28fb863d04f22bec5969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eb4d217c3674728ca3b74bbf28a5a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a30eb4d217c3674728ca3b74bbf28a5a2">find_objects</a></td></tr>
<tr class="separator:a30eb4d217c3674728ca3b74bbf28a5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad766a883a0d5a42fe9ef21bbad19ac3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#aad766a883a0d5a42fe9ef21bbad19ac3">labeled_comprehension</a></td></tr>
<tr class="separator:aad766a883a0d5a42fe9ef21bbad19ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6499745b71815c9e0e2f1944c7751244"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a6499745b71815c9e0e2f1944c7751244">sum</a></td></tr>
<tr class="separator:a6499745b71815c9e0e2f1944c7751244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62c6610072f012091b8b7c8911a2cb6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#ae62c6610072f012091b8b7c8911a2cb6">mean</a></td></tr>
<tr class="separator:ae62c6610072f012091b8b7c8911a2cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e4c0d6050154775cf7e7bac36cb6a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a07e4c0d6050154775cf7e7bac36cb6a7">variance</a></td></tr>
<tr class="separator:a07e4c0d6050154775cf7e7bac36cb6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e711998894987daa5d8ad808ab153fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a6e711998894987daa5d8ad808ab153fa">standard_deviation</a></td></tr>
<tr class="separator:a6e711998894987daa5d8ad808ab153fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577cd3d8098bf2f636765bfd1b8a5ae7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a577cd3d8098bf2f636765bfd1b8a5ae7">minimum</a></td></tr>
<tr class="separator:a577cd3d8098bf2f636765bfd1b8a5ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e4232e0da6dbfd60a61c84fad65dcb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a79e4232e0da6dbfd60a61c84fad65dcb">maximum</a></td></tr>
<tr class="separator:a79e4232e0da6dbfd60a61c84fad65dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa575b5ebc60e6efea149f43d4a6f45fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#aa575b5ebc60e6efea149f43d4a6f45fa">median</a></td></tr>
<tr class="separator:aa575b5ebc60e6efea149f43d4a6f45fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd34a02403e016620eee0e25a13497f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a5bd34a02403e016620eee0e25a13497f">minimum_position</a></td></tr>
<tr class="separator:a5bd34a02403e016620eee0e25a13497f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaded7d96df41ce4cbd69fe8e6e1c3929"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#aaded7d96df41ce4cbd69fe8e6e1c3929">maximum_position</a></td></tr>
<tr class="separator:aaded7d96df41ce4cbd69fe8e6e1c3929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466908127ff956a6a4a1a32d65fab802"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a466908127ff956a6a4a1a32d65fab802">extrema</a></td></tr>
<tr class="separator:a466908127ff956a6a4a1a32d65fab802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e05486d5384d50578bb640fd51f3c76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a9e05486d5384d50578bb640fd51f3c76">center_of_mass</a></td></tr>
<tr class="separator:a9e05486d5384d50578bb640fd51f3c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d01b47d6054612b07616e61d9fa0f04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a7d01b47d6054612b07616e61d9fa0f04">histogram</a></td></tr>
<tr class="separator:a7d01b47d6054612b07616e61d9fa0f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d723119193ba3fa4b8a676508f6e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#ab82d723119193ba3fa4b8a676508f6e7">watershed_ift</a></td></tr>
<tr class="separator:ab82d723119193ba3fa4b8a676508f6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a17b33fc777402ef9fdbe9d54340d2721"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1measurements.html#a17b33fc777402ef9fdbe9d54340d2721">__all__</a></td></tr>
<tr class="separator:a17b33fc777402ef9fdbe9d54340d2721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9e05486d5384d50578bb640fd51f3c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.center_of_mass </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the center of mass of the values of an array at labels.

Parameters
----------
input : ndarray
    Data from which to calculate center-of-mass.
labels : ndarray, optional
    Labels for objects in `input`, as generated by `ndimage.label`.
    Only used with `index`.  Dimensions must be the same as `input`.
index : int or sequence of ints, optional
    Labels for which to calculate centers-of-mass. If not specified,
    all labels greater than zero are used.  Only used with `labels`.

Returns
-------
center_of_mass : tuple, or list of tuples
    Coordinates of centers-of-mass.

Examples
--------
&gt;&gt;&gt; a = np.array(([0,0,0,0],
                  [0,1,1,0],
                  [0,1,1,0],
                  [0,1,1,0]))
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.measurements.center_of_mass(a)
(2.0, 1.5)

Calculation of multiple objects in an image

&gt;&gt;&gt; b = np.array(([0,1,1,0],
                  [0,1,0,0],
                  [0,0,0,0],
                  [0,0,1,1],
                  [0,0,1,1]))
&gt;&gt;&gt; lbl = ndimage.label(b)[0]
&gt;&gt;&gt; ndimage.measurements.center_of_mass(b, lbl, [1,2])
[(0.33333333333333331, 1.3333333333333333), (3.5, 2.5)]</pre> 
</div>
</div>
<a class="anchor" id="a466908127ff956a6a4a1a32d65fab802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.extrema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the minimums and maximums of the values of an array
at labels, along with their positions.

Parameters
----------
input : ndarray
    Nd-image data to process.
labels : ndarray, optional
    Labels of features in input.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    Labels to include in output.  If None (default), all values where
    non-zero `labels` are used.

Returns
-------
minimums, maximums : int or ndarray
    Values of minimums and maximums in each feature.
min_positions, max_positions : tuple or list of tuples
    Each tuple gives the n-D coordinates of the corresponding minimum
    or maximum.

See Also
--------
maximum, minimum, maximum_position, minimum_position, center_of_mass

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.extrema(a)
(0, 9, (0, 2), (3, 0))

Features to process can be specified using `labels` and `index`:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.extrema(a, lbl, index=np.arange(1, nlbl+1))
(array([1, 4, 3]),
 array([5, 7, 9]),
 [(0.0, 0.0), (1.0, 3.0), (3.0, 1.0)],
 [(1.0, 0.0), (2.0, 3.0), (3.0, 0.0)])

If no index is given, non-zero `labels` are processed:

&gt;&gt;&gt; ndimage.extrema(a, lbl)
(1, 9, (0, 0), (3, 0))</pre> 
</div>
</div>
<a class="anchor" id="a30eb4d217c3674728ca3b74bbf28a5a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.find_objects </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find objects in a labeled array.

Parameters
----------
input : ndarray of ints
    Array containing objects defined by different labels.
max_label : int, optional
    Maximum label to be searched for in `input`. If max_label is not
    given, the positions of all objects are returned.

Returns
-------
object_slices : list of tuples
    A list of tuples, with each tuple containing N slices (with N the
    dimension of the input array).  Slices correspond to the minimal
    parallelepiped that contains the object. If a number is missing,
    None is returned instead of a slice.

See Also
--------
label, center_of_mass

Notes
-----
This function is very useful for isolating a volume of interest inside
a 3-D array, that cannot be "seen through".

Examples
--------
&gt;&gt;&gt; a = np.zeros((6,6), dtype=np.int)
&gt;&gt;&gt; a[2:4, 2:4] = 1
&gt;&gt;&gt; a[4, 4] = 1
&gt;&gt;&gt; a[:2, :3] = 2
&gt;&gt;&gt; a[0, 5] = 3
&gt;&gt;&gt; a
array([[2, 2, 2, 0, 0, 3],
       [2, 2, 2, 0, 0, 0],
       [0, 0, 1, 1, 0, 0],
       [0, 0, 1, 1, 0, 0],
       [0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.find_objects(a)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None)), (slice(0, 1, None), slice(5, 6, None))]
&gt;&gt;&gt; ndimage.find_objects(a, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None))]
&gt;&gt;&gt; ndimage.find_objects(a == 1, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), None]

&gt;&gt;&gt; loc = ndimage.find_objects(a)[0]
&gt;&gt;&gt; a[loc]
array([[1, 1, 0]
       [1, 1, 0]
       [0, 0, 1]])</pre> 
</div>
</div>
<a class="anchor" id="a7d01b47d6054612b07616e61d9fa0f04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.histogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the histogram of the values of an array, optionally at labels.

Histogram calculates the frequency of values in an array within bins
determined by `min`, `max`, and `bins`. The `labels` and `index`
keywords can limit the scope of the histogram to specified sub-regions
within the array.

Parameters
----------
input : array_like
    Data for which to calculate histogram.
min, max : int
    Minimum and maximum values of range of histogram bins.
bins : int
    Number of bins.
labels : array_like, optional
    Labels for objects in `input`.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    Label or labels for which to calculate histogram. If None, all values
    where label is greater than zero are used

Returns
-------
hist : ndarray
    Histogram counts.

Examples
--------
&gt;&gt;&gt; a = np.array([[ 0.    ,  0.2146,  0.5962,  0.    ],
                  [ 0.    ,  0.7778,  0.    ,  0.    ],
                  [ 0.    ,  0.    ,  0.    ,  0.    ],
                  [ 0.    ,  0.    ,  0.7181,  0.2787],
                  [ 0.    ,  0.    ,  0.6573,  0.3094]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.measurements.histogram(a, 0, 1, 10)
array([13,  0,  2,  1,  0,  1,  1,  2,  0,  0])

With labels and no indices, non-zero elements are counted:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.measurements.histogram(a, 0, 1, 10, lbl)
array([0, 0, 2, 1, 0, 1, 1, 2, 0, 0])

Indices can be used to count only certain objects:

&gt;&gt;&gt; ndimage.measurements.histogram(a, 0, 1, 10, lbl, 2)
array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0])</pre> 
</div>
</div>
<a class="anchor" id="a4779cd2460f28fb863d04f22bec5969f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.label </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Label features in an array.

Parameters
----------
input : array_like
    An array-like object to be labeled.  Any non-zero values in `input` are
    counted as features and zero values are considered the background.
structure : array_like, optional
    A structuring element that defines feature connections.
    `structure` must be symmetric.  If no structuring element is provided,
    one is automatically generated with a squared connectivity equal to
    one.  That is, for a 2-D `input` array, the default structuring element
    is::

        [[0,1,0],
         [1,1,1],
         [0,1,0]]

output : (None, data-type, array_like), optional
    If `output` is a data type, it specifies the type of the resulting
    labeled feature array
    If `output` is an array-like object, then `output` will be updated
    with the labeled features from this function.  This function can
    operate in-place, by passing output=input.
    Note that the output must be able to store the largest label, or this
    function will raise an Exception.

Returns
-------
label : ndarray or int
    An integer ndarray where each unique feature in `input` has a unique
    label in the returned array.
num_features : int
    How many objects were found.

    If `output` is None, this function returns a tuple of
    (`labeled_array`, `num_features`).

    If `output` is a ndarray, then it will be updated with values in
    `labeled_array` and only `num_features` will be returned by this
    function.

See Also
--------
find_objects : generate a list of slices for the labeled features (or
               objects); useful for finding features' position or
               dimensions

Examples
--------
Create an image with some features, then label it using the default
(cross-shaped) structuring element:

&gt;&gt;&gt; a = np.array([[0,0,1,1,0,0],
...               [0,0,0,1,0,0],
...               [1,1,0,0,1,0],
...               [0,0,0,1,0,0]])
&gt;&gt;&gt; labeled_array, num_features = label(a)

Each of the 4 features are labeled with a different integer:

&gt;&gt;&gt; print(num_features)
4
&gt;&gt;&gt; print(labeled_array)
array([[0, 0, 1, 1, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [2, 2, 0, 0, 3, 0],
       [0, 0, 0, 4, 0, 0]])

Generate a structuring element that will consider features connected even
if they touch diagonally:

&gt;&gt;&gt; s = generate_binary_structure(2,2)

or,

&gt;&gt;&gt; s = [[1,1,1],
         [1,1,1],
         [1,1,1]]

Label the image using the new structuring element:

&gt;&gt;&gt; labeled_array, num_features = label(a, structure=s)

Show the 2 labeled features (note that features 1, 3, and 4 from above are
now considered a single feature):

&gt;&gt;&gt; print(num_features)
2
&gt;&gt;&gt; print(labeled_array)
array([[0, 0, 1, 1, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [2, 2, 0, 0, 1, 0],
       [0, 0, 0, 1, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="aad766a883a0d5a42fe9ef21bbad19ac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.labeled_comprehension </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pass_positions</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Roughly equivalent to [func(input[labels == i]) for i in index].

Sequentially applies an arbitrary function (that works on array_like input)
to subsets of an n-D image array specified by `labels` and `index`.
The option exists to provide the function with positional parameters as the
second argument.

Parameters
----------
input : array_like
    Data from which to select `labels` to process.
labels : array_like or None
    Labels to objects in `input`.
    If not None, array must be same shape as `input`.
    If None, `func` is applied to raveled `input`.
index : int, sequence of ints or None
    Subset of `labels` to which to apply `func`.
    If a scalar, a single value is returned.
    If None, `func` is applied to all non-zero values of `labels`.
func : callable
    Python function to apply to `labels` from `input`.
out_dtype : dtype
    Dtype to use for `result`.
default : int, float or None
    Default return value when a element of `index` does not exist
    in `labels`.
pass_positions : bool, optional
    If True, pass linear indices to `func` as a second argument.
    Default is False.

Returns
-------
result : ndarray
    Result of applying `func` to each of `labels` to `input` in `index`.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; lbls = np.arange(1, nlbl+1)
&gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, 0)
array([ 2.75,  5.5 ,  6.  ])

Falling back to `default`:

&gt;&gt;&gt; lbls = np.arange(1, nlbl+2)
&gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, -1)
array([ 2.75,  5.5 ,  6.  , -1.  ])

Passing positions:

&gt;&gt;&gt; def fn(val, pos):
...     print("fn says: %s : %s" % (val, pos))
...     return (val.sum()) if (pos.sum() % 2 == 0) else (-val.sum())
...
&gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, fn, float, 0, True)
fn says: [1 2 5 3] : [0 1 4 5]
fn says: [4 7] : [7 11]
fn says: [9 3] : [12 13]
array([ 11.,  11., -12.])</pre> 
</div>
</div>
<a class="anchor" id="a79e4232e0da6dbfd60a61c84fad65dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.maximum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the maximum of the values of an array over labeled regions.

Parameters
----------
input : array_like
    Array_like of values. For each region specified by `labels`, the
    maximal values of `input` over the region is computed.
labels : array_like, optional
    An array of integers marking different regions over which the
    maximum value of `input` is to be computed. `labels` must have the
    same shape as `input`. If `labels` is not specified, the maximum
    over the whole array is returned.
index : array_like, optional
    A list of region labels that are taken into account for computing the
    maxima. If index is None, the maximum over all elements where `labels`
    is non-zero is returned.

Returns
-------
output : float or list of floats
    List of maxima of `input` over the regions determined by `labels` and
    whose index is in `index`. If `index` or `labels` are not specified, a
    float is returned: the maximal value of `input` if `labels` is None,
    and the maximal value of elements where `labels` is greater than zero
    if `index` is None.

See also
--------
label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation

Notes
-----
The function returns a Python list and not a Numpy array, use
`np.array` to convert the list to an array.

Examples
--------
&gt;&gt;&gt; a = np.arange(16).reshape((4,4))
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
&gt;&gt;&gt; labels = np.zeros_like(a)
&gt;&gt;&gt; labels[:2,:2] = 1
&gt;&gt;&gt; labels[2:, 1:3] = 2
&gt;&gt;&gt; labels
array([[1, 1, 0, 0],
       [1, 1, 0, 0],
       [0, 2, 2, 0],
       [0, 2, 2, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.maximum(a)
15.0
&gt;&gt;&gt; ndimage.maximum(a, labels=labels, index=[1,2])
[5.0, 14.0]
&gt;&gt;&gt; ndimage.maximum(a, labels=labels)
14.0

&gt;&gt;&gt; b = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; labels, labels_nb = ndimage.label(b)
&gt;&gt;&gt; labels
array([[1, 1, 0, 0],
       [1, 1, 0, 2],
       [0, 0, 0, 2],
       [3, 3, 0, 0]])
&gt;&gt;&gt; ndimage.maximum(b, labels=labels, index=np.arange(1, labels_nb + 1))
[5.0, 7.0, 9.0]</pre> 
</div>
</div>
<a class="anchor" id="aaded7d96df41ce4cbd69fe8e6e1c3929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.maximum_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the positions of the maximums of the values of an array at labels.

For each region specified by `labels`, the position of the maximum
value of `input` within the region is returned.

Parameters
----------
input : array_like
    Array_like of values.
labels : array_like, optional
    An array of integers marking different regions over which the
    position of the maximum value of `input` is to be computed.
    `labels` must have the same shape as `input`. If `labels` is not
    specified, the location of the first maximum over the whole
    array is returned.

    The `labels` argument only works when `index` is specified.
index : array_like, optional
    A list of region labels that are taken into account for finding the
    location of the maxima.  If `index` is None, the first maximum
    over all elements where `labels` is non-zero is returned.

    The `index` argument only works when `labels` is specified.

Returns
-------
output : list of tuples of floats
    List of tuples of floats that specify the location of maxima of
    `input` over the regions determined by `labels` and whose index
    is in `index`.

    If `index` or `labels` are not specified, a tuple of floats is
    returned specifying the location of the ``first`` maximal value
    of `input`.

See also
--------
label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</pre> 
</div>
</div>
<a class="anchor" id="ae62c6610072f012091b8b7c8911a2cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the mean of the values of an array at labels.

Parameters
----------
input : array_like
    Array on which to compute the mean of elements over distinct
    regions.
labels : array_like, optional
    Array of labels of same shape, or broadcastable to the same shape as
    `input`. All elements sharing the same label form one region over
    which the mean of the elements is computed.
index : int or sequence of ints, optional
    Labels of the objects over which the mean is to be computed.
    Default is None, in which case the mean for all values where label is
    greater than 0 is calculated.

Returns
-------
out : list
    Sequence of same length as `index`, with the mean of the different
    regions labeled by the labels in `index`.

See also
--------
ndimage.variance, ndimage.standard_deviation, ndimage.minimum,
ndimage.maximum, ndimage.sum
ndimage.label

Examples
--------
&gt;&gt;&gt; a = np.arange(25).reshape((5,5))
&gt;&gt;&gt; labels = np.zeros_like(a)
&gt;&gt;&gt; labels[3:5,3:5] = 1
&gt;&gt;&gt; index = np.unique(labels)
&gt;&gt;&gt; labels
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 1],
       [0, 0, 0, 1, 1]])
&gt;&gt;&gt; index
array([0, 1])
&gt;&gt;&gt; ndimage.mean(a, labels=labels, index=index)
[10.285714285714286, 21.0]</pre> 
</div>
</div>
<a class="anchor" id="aa575b5ebc60e6efea149f43d4a6f45fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.median </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the median of the values of an array over labeled regions.

Parameters
----------
input : array_like
    Array_like of values. For each region specified by `labels`, the
    median value of `input` over the region is computed.
labels : array_like, optional
    An array_like of integers marking different regions over which the
    median value of `input` is to be computed. `labels` must have the
    same shape as `input`. If `labels` is not specified, the median
    over the whole array is returned.
index : array_like, optional
    A list of region labels that are taken into account for computing the
    medians. If index is None, the median over all elements where `labels`
    is non-zero is returned.

Returns
-------
median : float or list of floats
    List of medians of `input` over the regions determined by `labels` and
    whose index is in `index`. If `index` or `labels` are not specified, a
    float is returned: the median value of `input` if `labels` is None,
    and the median value of elements where `labels` is greater than zero
    if `index` is None.

See also
--------
label, minimum, maximum, extrema, sum, mean, variance, standard_deviation

Notes
-----
The function returns a Python list and not a Numpy array, use
`np.array` to convert the list to an array.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 1],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
&gt;&gt;&gt; labels, labels_nb = ndimage.label(a)
&gt;&gt;&gt; labels
array([[1, 1, 0, 2],
       [1, 1, 0, 2],
       [0, 0, 0, 2],
       [3, 3, 0, 0]])
&gt;&gt;&gt; ndimage.median(a, labels=labels, index=np.arange(1, labels_nb + 1))
[2.5, 4.0, 6.0]
&gt;&gt;&gt; ndimage.median(a)
1.0
&gt;&gt;&gt; ndimage.median(a, labels=labels)
3.0</pre> 
</div>
</div>
<a class="anchor" id="a577cd3d8098bf2f636765bfd1b8a5ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.minimum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the minimum of the values of an array over labeled regions.

Parameters
----------
input : array_like
    Array_like of values. For each region specified by `labels`, the
    minimal values of `input` over the region is computed.
labels : array_like, optional
    An array_like of integers marking different regions over which the
    minimum value of `input` is to be computed. `labels` must have the
    same shape as `input`. If `labels` is not specified, the minimum
    over the whole array is returned.
index : array_like, optional
    A list of region labels that are taken into account for computing the
    minima. If index is None, the minimum over all elements where `labels`
    is non-zero is returned.

Returns
-------
minimum : float or list of floats
    List of minima of `input` over the regions determined by `labels` and
    whose index is in `index`. If `index` or `labels` are not specified, a
    float is returned: the minimal value of `input` if `labels` is None,
    and the minimal value of elements where `labels` is greater than zero
    if `index` is None.

See also
--------
label, maximum, median, minimum_position, extrema, sum, mean, variance,
standard_deviation

Notes
-----
The function returns a Python list and not a Numpy array, use
`np.array` to convert the list to an array.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
&gt;&gt;&gt; labels, labels_nb = ndimage.label(a)
&gt;&gt;&gt; labels
array([[1, 1, 0, 0],
       [1, 1, 0, 2],
       [0, 0, 0, 2],
       [3, 3, 0, 0]])
&gt;&gt;&gt; ndimage.minimum(a, labels=labels, index=np.arange(1, labels_nb + 1))
[1.0, 4.0, 3.0]
&gt;&gt;&gt; ndimage.minimum(a)
0.0
&gt;&gt;&gt; ndimage.minimum(a, labels=labels)
1.0</pre> 
</div>
</div>
<a class="anchor" id="a5bd34a02403e016620eee0e25a13497f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.minimum_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the positions of the minimums of the values of an array at labels.

Parameters
----------
input : array_like
    Array_like of values.
labels : array_like, optional
    An array of integers marking different regions over which the
    position of the minimum value of `input` is to be computed.
    `labels` must have the same shape as `input`. If `labels` is not
    specified, the location of the first minimum over the whole
    array is returned.

    The `labels` argument only works when `index` is specified.
index : array_like, optional
    A list of region labels that are taken into account for finding the
    location of the minima. If `index` is None, the ``first`` minimum
    over all elements where `labels` is non-zero is returned.

    The `index` argument only works when `labels` is specified.

Returns
-------
output : list of tuples of floats
    Tuple of floats or list of tuples of floats that specify the location
    of minima of `input` over the regions determined by `labels` and
    whose index is in `index`.

    If `index` or `labels` are not specified, a tuple of floats is
    returned specifying the location of the first minimal value of `input`.

See also
--------
label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</pre> 
</div>
</div>
<a class="anchor" id="a6e711998894987daa5d8ad808ab153fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.standard_deviation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the standard deviation of the values of an n-D image array,
optionally at specified sub-regions.

Parameters
----------
input : array_like
    Nd-image data to process.
labels : array_like, optional
    Labels to identify sub-regions in `input`.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    `labels` to include in output.  If None (default), all values where
    `labels` is non-zero are used.

Returns
-------
standard_deviation : float or ndarray
    Values of standard deviation, for each sub-region if `labels` and
    `index` are specified.

See Also
--------
label, variance, maximum, minimum, extrema

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.standard_deviation(a)
2.7585095613392387

Features to process can be specified using `labels` and `index`:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.standard_deviation(a, lbl, index=np.arange(1, nlbl+1))
array([ 1.479,  1.5  ,  3.   ])

If no index is given, non-zero `labels` are processed:

&gt;&gt;&gt; ndimage.standard_deviation(a, lbl)
2.4874685927665499</pre> 
</div>
</div>
<a class="anchor" id="a6499745b71815c9e0e2f1944c7751244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.sum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the sum of the values of the array.

Parameters
----------
input : array_like
    Values of `input` inside the regions defined by `labels`
    are summed together.
labels : array_like of ints, optional
    Assign labels to the values of the array. Has to have the same shape as
    `input`.
index : array_like, optional
    A single label number or a sequence of label numbers of
    the objects to be measured.

Returns
-------
sum : ndarray or scalar
    An array of the sums of values of `input` inside the regions defined
    by `labels` with the same shape as `index`. If 'index' is None or scalar,
    a scalar is returned.

See also
--------
mean, median

Examples
--------
&gt;&gt;&gt; input =  [0,1,2,3]
&gt;&gt;&gt; labels = [1,1,2,2]
&gt;&gt;&gt; sum(input, labels, index=[1,2])
[1.0, 5.0]
&gt;&gt;&gt; sum(input, labels, index=1)
1
&gt;&gt;&gt; sum(input, labels)
6</pre> 
</div>
</div>
<a class="anchor" id="a07e4c0d6050154775cf7e7bac36cb6a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.variance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the variance of the values of an n-D image array, optionally at
specified sub-regions.

Parameters
----------
input : array_like
    Nd-image data to process.
labels : array_like, optional
    Labels defining sub-regions in `input`.
    If not None, must be same shape as `input`.
index : int or sequence of ints, optional
    `labels` to include in output.  If None (default), all values where
    `labels` is non-zero are used.

Returns
-------
variance : float or ndarray
    Values of variance, for each sub-region if `labels` and `index` are
    specified.

See Also
--------
label, standard_deviation, maximum, minimum, extrema

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2, 0, 0],
                  [5, 3, 0, 4],
                  [0, 0, 0, 7],
                  [9, 3, 0, 0]])
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.variance(a)
7.609375

Features to process can be specified using `labels` and `index`:

&gt;&gt;&gt; lbl, nlbl = ndimage.label(a)
&gt;&gt;&gt; ndimage.variance(a, lbl, index=np.arange(1, nlbl+1))
array([ 2.1875,  2.25  ,  9.    ])

If no index is given, all non-zero `labels` are processed:

&gt;&gt;&gt; ndimage.variance(a, lbl)
6.1875</pre> 
</div>
</div>
<a class="anchor" id="ab82d723119193ba3fa4b8a676508f6e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.measurements.watershed_ift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>markers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Apply watershed from markers using an iterative forest transform algorithm.

Parameters
----------
input : array_like
    Input.
markers : array_like
    Markers are points within each watershed that form the beginning
    of the process.  Negative markers are considered background markers
    which are processed after the other markers.
structure : structure element, optional
    A structuring element defining the connectivity of the object can be
    provided. If None, an element is generated with a squared
    connectivity equal to one.
out : ndarray
    An output array can optionally be provided.  The same shape as input.

Returns
-------
watershed_ift : ndarray
    Output.  Same shape as `input`.</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a17b33fc777402ef9fdbe9d54340d2721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.ndimage.measurements.__all__</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespacescipy_1_1ndimage_1_1measurements.html">    1</a></span>&#160;= [<span class="stringliteral">&#39;label&#39;</span>, <span class="stringliteral">&#39;find_objects&#39;</span>, <span class="stringliteral">&#39;labeled_comprehension&#39;</span>, <span class="stringliteral">&#39;sum&#39;</span>, <span class="stringliteral">&#39;mean&#39;</span>,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;           <span class="stringliteral">&#39;variance&#39;</span>, <span class="stringliteral">&#39;standard_deviation&#39;</span>, <span class="stringliteral">&#39;minimum&#39;</span>, <span class="stringliteral">&#39;maximum&#39;</span>, <span class="stringliteral">&#39;median&#39;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;           <span class="stringliteral">&#39;minimum_position&#39;</span>, <span class="stringliteral">&#39;maximum_position&#39;</span>, <span class="stringliteral">&#39;extrema&#39;</span>, <span class="stringliteral">&#39;center_of_mass&#39;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;           <span class="stringliteral">&#39;histogram&#39;</span>, <span class="stringliteral">&#39;watershed_ift&#39;</span>]</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:12 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
