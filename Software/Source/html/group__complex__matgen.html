<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: complex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">complex<div class="ingroups"><a class="el" href="group__testing.html">LAPACK Testing</a> &raquo; <a class="el" href="group__matgen.html">Matrix Generation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga01a45e71da04e1130918ab95dbcd08c7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga01a45e71da04e1130918ab95dbcd08c7">clagge</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KL, KU, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, ISEED, WORK, INFO)</td></tr>
<tr class="memdesc:ga01a45e71da04e1130918ab95dbcd08c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAGGE</b>  <a href="#ga01a45e71da04e1130918ab95dbcd08c7">More...</a><br /></td></tr>
<tr class="separator:ga01a45e71da04e1130918ab95dbcd08c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b4d68bedb34b4e82b4a7cb32be76d24"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga7b4d68bedb34b4e82b4a7cb32be76d24">claghe</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, ISEED, WORK, INFO)</td></tr>
<tr class="memdesc:ga7b4d68bedb34b4e82b4a7cb32be76d24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAGHE</b>  <a href="#ga7b4d68bedb34b4e82b4a7cb32be76d24">More...</a><br /></td></tr>
<tr class="separator:ga7b4d68bedb34b4e82b4a7cb32be76d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43d0be5e9d0999d6a512e6842a6d65f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#gae43d0be5e9d0999d6a512e6842a6d65f">clagsy</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, ISEED, WORK, INFO)</td></tr>
<tr class="memdesc:gae43d0be5e9d0999d6a512e6842a6d65f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAGSY</b>  <a href="#gae43d0be5e9d0999d6a512e6842a6d65f">More...</a><br /></td></tr>
<tr class="separator:gae43d0be5e9d0999d6a512e6842a6d65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cf156a3529004d8ca739e77a1b4e16"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#gad3cf156a3529004d8ca739e77a1b4e16">clahilb</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, X, LDX, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, WORK, INFO, PATH)</td></tr>
<tr class="memdesc:gad3cf156a3529004d8ca739e77a1b4e16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAHILB</b>  <a href="#gad3cf156a3529004d8ca739e77a1b4e16">More...</a><br /></td></tr>
<tr class="separator:gad3cf156a3529004d8ca739e77a1b4e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a28051d16bc46beecf83a6cacad4b37"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga7a28051d16bc46beecf83a6cacad4b37">clakf2</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, Z, LDZ)</td></tr>
<tr class="memdesc:ga7a28051d16bc46beecf83a6cacad4b37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAKF2</b>  <a href="#ga7a28051d16bc46beecf83a6cacad4b37">More...</a><br /></td></tr>
<tr class="separator:ga7a28051d16bc46beecf83a6cacad4b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591e57991ad92ea8cc4ffd534c682bf9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga591e57991ad92ea8cc4ffd534c682bf9">clarge</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, ISEED, WORK, INFO)</td></tr>
<tr class="memdesc:ga591e57991ad92ea8cc4ffd534c682bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLARGE</b>  <a href="#ga591e57991ad92ea8cc4ffd534c682bf9">More...</a><br /></td></tr>
<tr class="separator:ga591e57991ad92ea8cc4ffd534c682bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac45992478d4a059e7d62f403077a78fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex.html">complex</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#gac45992478d4a059e7d62f403077a78fd">clarnd</a> (IDIST, ISEED)</td></tr>
<tr class="memdesc:gac45992478d4a059e7d62f403077a78fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLARND</b>  <a href="#gac45992478d4a059e7d62f403077a78fd">More...</a><br /></td></tr>
<tr class="separator:gac45992478d4a059e7d62f403077a78fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga463c7fe8bfbf095b0c8703935e2b619a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga463c7fe8bfbf095b0c8703935e2b619a">claror</a> (SIDE, INIT, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, ISEED, X, INFO)</td></tr>
<tr class="memdesc:ga463c7fe8bfbf095b0c8703935e2b619a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAROR</b>  <a href="#ga463c7fe8bfbf095b0c8703935e2b619a">More...</a><br /></td></tr>
<tr class="separator:ga463c7fe8bfbf095b0c8703935e2b619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b101f20bbd35d0294b4579e539dc607"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga8b101f20bbd35d0294b4579e539dc607">clarot</a> (LROWS, LLEFT, LRIGHT, NL, C, S, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, XLEFT, XRIGHT)</td></tr>
<tr class="memdesc:ga8b101f20bbd35d0294b4579e539dc607"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAROT</b>  <a href="#ga8b101f20bbd35d0294b4579e539dc607">More...</a><br /></td></tr>
<tr class="separator:ga8b101f20bbd35d0294b4579e539dc607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c84db8fbdfd2f970e682caa31e72a6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#gad3c84db8fbdfd2f970e682caa31e72a6">clatm1</a> (MODE, COND, IRSIGN, IDIST, ISEED, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, INFO)</td></tr>
<tr class="memdesc:gad3c84db8fbdfd2f970e682caa31e72a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATM1</b>  <a href="#gad3c84db8fbdfd2f970e682caa31e72a6">More...</a><br /></td></tr>
<tr class="separator:gad3c84db8fbdfd2f970e682caa31e72a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2689df757dd5958a8c2911a648577d56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex.html">complex</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga2689df757dd5958a8c2911a648577d56">clatm2</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, I, J, KL, KU, IDIST, ISEED, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, IGRADE, DL, DR, IPVTNG, IWORK, SPARSE)</td></tr>
<tr class="memdesc:ga2689df757dd5958a8c2911a648577d56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATM2</b>  <a href="#ga2689df757dd5958a8c2911a648577d56">More...</a><br /></td></tr>
<tr class="separator:ga2689df757dd5958a8c2911a648577d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929f663f785e4b5841d06d9a947d670c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplex.html">complex</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga929f663f785e4b5841d06d9a947d670c">clatm3</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, I, J, ISUB, JSUB, KL, KU, IDIST, ISEED, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, IGRADE, DL, DR, IPVTNG, IWORK, SPARSE)</td></tr>
<tr class="memdesc:ga929f663f785e4b5841d06d9a947d670c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATM3</b>  <a href="#ga929f663f785e4b5841d06d9a947d670c">More...</a><br /></td></tr>
<tr class="separator:ga929f663f785e4b5841d06d9a947d670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b05f57659c673fb19b320ad9737810b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga6b05f57659c673fb19b320ad9737810b">clatm5</a> (PRTYPE, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, C, LDC, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, LDD, E, LDE, F, LDF, R, LDR, L, LDL, ALPHA, QBLCKA, QBLCKB)</td></tr>
<tr class="memdesc:ga6b05f57659c673fb19b320ad9737810b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATM5</b>  <a href="#ga6b05f57659c673fb19b320ad9737810b">More...</a><br /></td></tr>
<tr class="separator:ga6b05f57659c673fb19b320ad9737810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d75b31c19f718d006ac8059071b253"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#gae9d75b31c19f718d006ac8059071b253">clatm6</a> (TYPE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, X, LDX, Y, LDY, ALPHA, BETA, WX, WY, S, DIF)</td></tr>
<tr class="memdesc:gae9d75b31c19f718d006ac8059071b253"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATM6</b>  <a href="#gae9d75b31c19f718d006ac8059071b253">More...</a><br /></td></tr>
<tr class="separator:gae9d75b31c19f718d006ac8059071b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b623095dea5337d8a8cc4e32c7990e0"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga6b623095dea5337d8a8cc4e32c7990e0">clatme</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="superlu__enum__consts_8h.html#af00a42ecad444bbda75cde1b64bd7e72ac04fbbdf0d80a4ad25e565541deeebd7">DIST</a>, ISEED, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, MODE, COND, DMAX, RSIGN, UPPER, SIM, DS, MODES, CONDS, KL, KU, ANORM, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, WORK, INFO)</td></tr>
<tr class="memdesc:ga6b623095dea5337d8a8cc4e32c7990e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATME</b>  <a href="#ga6b623095dea5337d8a8cc4e32c7990e0">More...</a><br /></td></tr>
<tr class="separator:ga6b623095dea5337d8a8cc4e32c7990e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga965cf56889238ff917eba10e6dbea93e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga965cf56889238ff917eba10e6dbea93e">clatmr</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="superlu__enum__consts_8h.html#af00a42ecad444bbda75cde1b64bd7e72ac04fbbdf0d80a4ad25e565541deeebd7">DIST</a>, ISEED, SYM, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, MODE, COND, DMAX, RSIGN, GRADE, DL, MODEL, CONDL, DR, MODER, CONDR, PIVTNG, IPIVOT, KL, KU, SPARSE, ANORM, PACK, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, IWORK, INFO)</td></tr>
<tr class="memdesc:ga965cf56889238ff917eba10e6dbea93e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATMR</b>  <a href="#ga965cf56889238ff917eba10e6dbea93e">More...</a><br /></td></tr>
<tr class="separator:ga965cf56889238ff917eba10e6dbea93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411f64e8d8b980e985c6b0189139dc49"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#ga411f64e8d8b980e985c6b0189139dc49">clatms</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="superlu__enum__consts_8h.html#af00a42ecad444bbda75cde1b64bd7e72ac04fbbdf0d80a4ad25e565541deeebd7">DIST</a>, ISEED, SYM, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, MODE, COND, DMAX, KL, KU, PACK, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, WORK, INFO)</td></tr>
<tr class="memdesc:ga411f64e8d8b980e985c6b0189139dc49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATMS</b>  <a href="#ga411f64e8d8b980e985c6b0189139dc49">More...</a><br /></td></tr>
<tr class="separator:ga411f64e8d8b980e985c6b0189139dc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbcffc07d8119265fdd7ec81f961e75a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__matgen.html#gacbcffc07d8119265fdd7ec81f961e75a">clatmt</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="superlu__enum__consts_8h.html#af00a42ecad444bbda75cde1b64bd7e72ac04fbbdf0d80a4ad25e565541deeebd7">DIST</a>, ISEED, SYM, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, MODE, COND, DMAX, <a class="el" href="splinemodule_8c.html#a3a88bcc63386de30443dacede2e01847">RANK</a>, KL, KU, PACK, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, WORK, INFO)</td></tr>
<tr class="memdesc:gacbcffc07d8119265fdd7ec81f961e75a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATMT</b>  <a href="#gacbcffc07d8119265fdd7ec81f961e75a">More...</a><br /></td></tr>
<tr class="separator:gacbcffc07d8119265fdd7ec81f961e75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is the group of complex LAPACK TESTING MATGEN routines. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga01a45e71da04e1130918ab95dbcd08c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clagge </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAGGE</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLAGGE generates a complex general m by n matrix A, by pre- and post-
 multiplying a real diagonal matrix D with random unitary matrices:
 A = U*D*V. The lower and upper bandwidths may then be reduced to
 kl and ku by additional unitary transformations.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
          The number of nonzero subdiagonals within the band of A.
          0 &lt;= KL &lt;= M-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
          The number of nonzero superdiagonals within the band of A.
          0 &lt;= KU &lt;= N-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (min(M,N))
          The diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The generated m by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= M.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (M+N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0: successful exit
          &lt; 0: if INFO = -i, the i-th argument had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b4d68bedb34b4e82b4a7cb32be76d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine claghe </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAGHE</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLAGHE generates a complex hermitian matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U'. The semi-bandwidth may then be reduced to k by additional
 unitary transformations.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
          The number of nonzero subdiagonals within the band of A.
          0 &lt;= K &lt;= N-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The generated n by n hermitian matrix A (the full matrix is
          stored).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (2*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0: successful exit
          &lt; 0: if INFO = -i, the i-th argument had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gae43d0be5e9d0999d6a512e6842a6d65f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clagsy </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAGSY</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLAGSY generates a complex symmetric matrix A, by pre- and post-
 multiplying a real diagonal matrix D with a random unitary matrix:
 A = U*D*U**T. The semi-bandwidth may then be reduced to k by
 additional unitary transformations.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
          The number of nonzero subdiagonals within the band of A.
          0 &lt;= K &lt;= N-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The generated n by n symmetric matrix A (the full matrix is
          stored).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (2*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0: successful exit
          &lt; 0: if INFO = -i, the i-th argument had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gad3cf156a3529004d8ca739e77a1b4e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clahilb </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension(lda,<a class="el" href="indexexpr_8h.html#ab427e2e2b4d6cec55fa088ea2a692ace">n</a>)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension(ldx, nrhs)&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension(ldb, nrhs)&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension(<a class="el" href="indexexpr_8h.html#ab427e2e2b4d6cec55fa088ea2a692ace">n</a>)&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAHILB</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLAHILB generates an N by N scaled Hilbert matrix in A along with
 NRHS right-hand sides in B and solutions in X such that A*X=B.

 The Hilbert matrix is scaled by M = LCM(1, 2, ..., 2*N-1) so that all
 entries are integers.  The right-hand sides are the first NRHS
 columns of M * the identity matrix, and the solutions are the
 first NRHS columns of the inverse Hilbert matrix.

 The condition number of the Hilbert matrix grows exponentially with
 its size, roughly as O(e ** (3.5*N)).  Additionally, the inverse
 Hilbert matrices beyond a relatively small dimension cannot be
 generated exactly without extra precision.  Precision is exhausted
 when the largest entry in the inverse Hilbert matrix is greater than
 2 to the power of the number of bits in the fraction of the data type
 used plus one, which is 24 for single precision.

 In single, the generated solution is exact for N &lt;= 6 and has
 small componentwise error for 7 &lt;= N &lt;= 11.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of the matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The requested number of right-hand sides.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          The generated scaled Hilbert matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (LDX, NRHS)
          The generated exact solutions.  Currently, the first NRHS
          columns of the inverse Hilbert matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the array X.  LDX &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL array, dimension (LDB, NRHS)
          The generated right-hand sides.  Currently, the first NRHS
          columns of LCM(1, 2, ..., 2*N-1) * the identity matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0: successful exit
          = 1: N is too large; the data is still generated but may not
               be not exact.
          &lt; 0: if INFO = -i, the i-th argument had an illegal value</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a28051d16bc46beecf83a6cacad4b37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clakf2 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAKF2</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Form the 2*M*N by 2*M*N matrix

        Z = [ kron(In, A)  -kron(B', Im) ]
            [ kron(In, D)  -kron(E', Im) ],

 where In is the identity matrix of size n and X' is the transpose
 of X. kron(X, Y) is the Kronecker product between the matrices X
 and Y.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          Size of matrix, must be &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          Size of matrix, must be &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX, dimension ( LDA, M )
          The matrix A in the output matrix Z.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, D, and E. ( LDA &gt;= M+N )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX, dimension ( LDA, N )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX, dimension ( LDA, M )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is COMPLEX, dimension ( LDA, N )

          The matrices used in forming the output matrix Z.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX, dimension ( LDZ, 2*M*N )
          The resultant Kronecker M*N*2 by M*N*2 matrix (see above.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDZ</td><td><pre class="fragment">          LDZ is INTEGER
          The leading dimension of Z. ( LDZ &gt;= 2*M*N )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga591e57991ad92ea8cc4ffd534c682bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clarge </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLARGE</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLARGE pre- and post-multiplies a complex general n by n matrix A
 with a random unitary matrix: A = U*D*U'.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          On entry, the original n by n matrix A.
          On exit, A is overwritten by U*A*U' for some random
          unitary matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (2*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0: successful exit
          &lt; 0: if INFO = -i, the i-th argument had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gac45992478d4a059e7d62f403077a78fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex.html">complex</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> clarnd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLARND</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLARND returns a random complex number from a uniform or normal
 distribution.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is INTEGER
          Specifies the distribution of the random numbers:
          = 1:  real and imaginary parts each uniform (0,1)
          = 2:  real and imaginary parts each uniform (-1,1)
          = 3:  real and imaginary parts each normal (0,1)
          = 4:  uniformly distributed on the disc abs(z) &lt;= 1
          = 5:  uniformly distributed on the circle abs(z) = 1</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  This routine calls the auxiliary routine SLARAN to generate a random
  real number from a uniform (0,1) distribution. The Box-Muller method
  is used to transform numbers from a uniform to a normal distribution.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga463c7fe8bfbf095b0c8703935e2b619a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine claror </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SIDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>INIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAROR</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLAROR pre- or post-multiplies an M by N matrix A by a random
    unitary matrix U, overwriting A. A may optionally be
    initialized to the identity matrix before multiplying by U.
    U is generated using the method of G.W. Stewart
    ( SIAM J. Numer. Anal. 17, 1980, pp. 403-409 ).
    (BLAS-2 version)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SIDE</td><td><pre class="fragment">          SIDE is CHARACTER*1
           SIDE specifies whether A is multiplied on the left or right
           by U.
       SIDE = 'L'   Multiply A on the left (premultiply) by U
       SIDE = 'R'   Multiply A on the right (postmultiply) by UC&gt;       SIDE = 'C'   Multiply A on the left by U and the right by UC&gt;       SIDE = 'T'   Multiply A on the left by U and the right by U'
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INIT</td><td><pre class="fragment">          INIT is CHARACTER*1
           INIT specifies whether or not A should be initialized to
           the identity matrix.
              INIT = 'I'   Initialize A to (a section of) the
                           identity matrix before applying U.
              INIT = 'N'   No initialization.  Apply U to the
                           input matrix A.

           INIT = 'I' may be used to generate square (i.e., unitary)
           or rectangular orthogonal matrices (orthogonality being
           in the sense of CDOTC):

           For square matrices, M=N, and SIDE many be either 'L' or
           'R'; the rows will be orthogonal to each other, as will the
           columns.
           For rectangular matrices where M &lt; N, SIDE = 'R' will
           produce a dense matrix whose rows will be orthogonal and
           whose columns will not, while SIDE = 'L' will produce a
           matrix whose rows will be orthogonal, and whose first M
           columns will be orthogonal, the remaining columns being
           zero.
           For matrices where M &gt; N, just use the previous
           explaination, interchanging 'L' and 'R' and "rows" and
           "columns".

           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
           Number of rows of A. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           Number of columns of A. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension ( LDA, N )
           Input and output array. Overwritten by U A ( if SIDE = 'L' )
           or by A U ( if SIDE = 'R' )
           or by U A U* ( if SIDE = 'C')
           or by U A U' ( if SIDE = 'T') on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
           Leading dimension of A. Must be at least MAX ( 1, M ).
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension ( 4 )
           On entry ISEED specifies the seed of the random number
           generator. The array elements should be between 0 and 4095;
           if not they will be reduced mod 4096.  Also, ISEED(4) must
           be odd.  The random number generator uses a linear
           congruential sequence limited to small integers, and so
           should produce machine independent random numbers. The
           values of ISEED are changed on exit, and can be used in the
           next call to CLAROR to continue the same random number
           sequence.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension ( 3*MAX( M, N ) )
           Workspace. Of length:
               2*M + N if SIDE = 'L',
               2*N + M if SIDE = 'R',
               3*N     if SIDE = 'C' or 'T'.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
           An error flag.  It is set to:
            0  if no error.
            1  if CLARND returned a bad random number (installation
               problem)
           -1  if SIDE is not L, R, C, or T.
           -3  if M is negative.
           -4  if N is negative or if SIDE is C or T and N is not equal
               to M.
           -6  if LDA is less than M.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b101f20bbd35d0294b4579e539dc607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clarot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>LROWS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>LLEFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>LRIGHT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>XLEFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>XRIGHT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAROT</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLAROT applies a (Givens) rotation to two adjacent rows or
    columns, where one element of the first and/or last column/row
    for use on matrices stored in some format other than GE, so
    that elements of the matrix may be used or modified for which
    no array element is provided.

    One example is a symmetric matrix in SB format (bandwidth=4), for
    which UPLO='L':  Two adjacent rows will have the format:

    row j:     C&gt; C&gt; C&gt; C&gt; C&gt; .  .  .  .
    row j+1:      C&gt; C&gt; C&gt; C&gt; C&gt; .  .  .  .

    '*' indicates elements for which storage is provided,
    '.' indicates elements for which no storage is provided, but
    are not necessarily zero; their values are determined by
    symmetry.  ' ' indicates elements which are necessarily zero,
     and have no storage provided.

    Those columns which have two '*'s can be handled by SROT.
    Those columns which have no '*'s can be ignored, since as long
    as the Givens rotations are carefully applied to preserve
    symmetry, their values are determined.
    Those columns which have one '*' have to be handled separately,
    by using separate variables "p" and "q":

    row j:     C&gt; C&gt; C&gt; C&gt; C&gt; p  .  .  .
    row j+1:   q  C&gt; C&gt; C&gt; C&gt; C&gt; .  .  .  .

    The element p would have to be set correctly, then that column
    is rotated, setting p to its new value.  The next call to
    CLAROT would rotate columns j and j+1, using p, and restore
    symmetry.  The element q would start out being zero, and be
    made non-zero by the rotation.  Later, rotations would presumably
    be chosen to zero q out.

    Typical Calling Sequences: rotating the i-th and (i+1)-st rows.
    ------- ------- ---------

      General dense matrix:

              CALL CLAROT(.TRUE.,.FALSE.,.FALSE., N, C,S,
                      A(i,1),LDA, DUMMY, DUMMY)

      General banded matrix in GB format:

              j = MAX(1, i-KL )
              NL = MIN( N, i+KU+1 ) + 1-j
              CALL CLAROT( .TRUE., i-KL.GE.1, i+KU.LT.N, NL, C,S,
                      A(KU+i+1-j,j),LDA-1, XLEFT, XRIGHT )

              [ note that i+1-j is just MIN(i,KL+1) ]

      Symmetric banded matrix in SY format, bandwidth K,
      lower triangle only:

              j = MAX(1, i-K )
              NL = MIN( K+1, i ) + 1
              CALL CLAROT( .TRUE., i-K.GE.1, .TRUE., NL, C,S,
                      A(i,j), LDA, XLEFT, XRIGHT )

      Same, but upper triangle only:

              NL = MIN( K+1, N-i ) + 1
              CALL CLAROT( .TRUE., .TRUE., i+K.LT.N, NL, C,S,
                      A(i,i), LDA, XLEFT, XRIGHT )

      Symmetric banded matrix in SB format, bandwidth K,
      lower triangle only:

              [ same as for SY, except:]
                  . . . .
                      A(i+1-j,j), LDA-1, XLEFT, XRIGHT )

              [ note that i+1-j is just MIN(i,K+1) ]

      Same, but upper triangle only:
                  . . .
                      A(K+1,i), LDA-1, XLEFT, XRIGHT )

      Rotating columns is just the transpose of rotating rows, except
      for GB and SB: (rotating columns i and i+1)

      GB:
              j = MAX(1, i-KU )
              NL = MIN( N, i+KL+1 ) + 1-j
              CALL CLAROT( .TRUE., i-KU.GE.1, i+KL.LT.N, NL, C,S,
                      A(KU+j+1-i,i),LDA-1, XTOP, XBOTTM )

              [note that KU+j+1-i is just MAX(1,KU+2-i)]

      SB: (upper triangle)

                   . . . . . .
                      A(K+j+1-i,i),LDA-1, XTOP, XBOTTM )

      SB: (lower triangle)

                   . . . . . .
                      A(1,i),LDA-1, XTOP, XBOTTM )</pre> <pre class="fragment">  LROWS  - LOGICAL
           If .TRUE., then CLAROT will rotate two rows.  If .FALSE.,
           then it will rotate two columns.
           Not modified.

  LLEFT  - LOGICAL
           If .TRUE., then XLEFT will be used instead of the
           corresponding element of A for the first element in the
           second row (if LROWS=.FALSE.) or column (if LROWS=.TRUE.)
           If .FALSE., then the corresponding element of A will be
           used.
           Not modified.

  LRIGHT - LOGICAL
           If .TRUE., then XRIGHT will be used instead of the
           corresponding element of A for the last element in the
           first row (if LROWS=.FALSE.) or column (if LROWS=.TRUE.) If
           .FALSE., then the corresponding element of A will be used.
           Not modified.

  NL     - INTEGER
           The length of the rows (if LROWS=.TRUE.) or columns (if
           LROWS=.FALSE.) to be rotated.  If XLEFT and/or XRIGHT are
           used, the columns/rows they are in should be included in
           NL, e.g., if LLEFT = LRIGHT = .TRUE., then NL must be at
           least 2.  The number of rows/columns to be rotated
           exclusive of those involving XLEFT and/or XRIGHT may
           not be negative, i.e., NL minus how many of LLEFT and
           LRIGHT are .TRUE. must be at least zero; if not, XERBLA
           will be called.
           Not modified.

  C, S   - COMPLEX
           Specify the Givens rotation to be applied.  If LROWS is
           true, then the matrix ( c  s )
                                 ( _  _ )
                                 (-s  c )  is applied from the left;
           if false, then the transpose (not conjugated) thereof is
           applied from the right.  Note that in contrast to the
           output of CROTG or to most versions of CROT, both C and S
           are complex.  For a Givens rotation, |C|**2 + |S|**2 should
           be 1, but this is not checked.
           Not modified.

  A      - COMPLEX array.
           The array containing the rows/columns to be rotated.  The
           first element of A should be the upper left element to
           be rotated.
           Read and modified.

  LDA    - INTEGER
           The "effective" leading dimension of A.  If A contains
           a matrix stored in GE, HE, or SY format, then this is just
           the leading dimension of A as dimensioned in the calling
           routine.  If A contains a matrix stored in band (GB, HB, or
           SB) format, then this should be *one less* than the leading
           dimension used in the calling routine.  Thus, if A were
           dimensioned A(LDA,*) in CLAROT, then A(1,j) would be the
           j-th element in the first of the two rows to be rotated,
           and A(2,j) would be the j-th in the second, regardless of
           how the array may be stored in the calling routine.  [A
           cannot, however, actually be dimensioned thus, since for
           band format, the row number may exceed LDA, which is not
           legal FORTRAN.]
           If LROWS=.TRUE., then LDA must be at least 1, otherwise
           it must be at least NL minus the number of .TRUE. values
           in XLEFT and XRIGHT.
           Not modified.

  XLEFT  - COMPLEX
           If LLEFT is .TRUE., then XLEFT will be used and modified
           instead of A(2,1) (if LROWS=.TRUE.) or A(1,2)
           (if LROWS=.FALSE.).
           Read and modified.

  XRIGHT - COMPLEX
           If LRIGHT is .TRUE., then XRIGHT will be used and modified
           instead of A(1,NL) (if LROWS=.TRUE.) or A(NL,1)
           (if LROWS=.FALSE.).
           Read and modified.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gad3c84db8fbdfd2f970e682caa31e72a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatm1 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>COND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IRSIGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATM1</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLATM1 computes the entries of D(1..N) as specified by
    MODE, COND and IRSIGN. IDIST and ISEED determine the generation
    of random numbers. CLATM1 is called by CLATMR to generate
    random test matrices for LAPACK programs.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MODE</td><td><pre class="fragment">          MODE is INTEGER
           On entry describes how D is to be computed:
           MODE = 0 means do not change D.
           MODE = 1 sets D(1)=1 and D(2:N)=1.0/COND
           MODE = 2 sets D(1:N-1)=1 and D(N)=1.0/COND
           MODE = 3 sets D(I)=COND**(-(I-1)/(N-1))
           MODE = 4 sets D(i)=1 - (i-1)/(N-1)*(1 - 1/COND)
           MODE = 5 sets D to random numbers in the range
                    ( 1/COND , 1 ) such that their logarithms
                    are uniformly distributed.
           MODE = 6 set D to random numbers from same distribution
                    as the rest of the matrix.
           MODE &lt; 0 has the same meaning as ABS(MODE), except that
              the order of the elements of D is reversed.
           Thus if MODE is positive, D has entries ranging from
              1 to 1/COND, if negative, from 1/COND to 1,
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">COND</td><td><pre class="fragment">          COND is REAL
           On entry, used as described under MODE above.
           If used, it must be &gt;= 1. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IRSIGN</td><td><pre class="fragment">          IRSIGN is INTEGER
           On entry, if MODE neither -6, 0 nor 6, determines sign of
           entries of D
           0 =&gt; leave entries of D unchanged
           1 =&gt; multiply each entry of D by random complex number
                uniformly distributed with absolute value 1</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is CHARACTER*1
           On entry, IDIST specifies the type of distribution to be
           used to generate a random matrix .
           1 =&gt; real and imaginary parts each UNIFORM( 0, 1 )
           2 =&gt; real and imaginary parts each UNIFORM( -1, 1 )
           3 =&gt; real and imaginary parts each NORMAL( 0, 1 )
           4 =&gt; complex number uniform in DISK( 0, 1 )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension ( 4 )
           On entry ISEED specifies the seed of the random number
           generator. The random number generator uses a
           linear congruential sequence limited to small
           integers, and so should produce machine independent
           random numbers. The values of ISEED are changed on
           exit, and can be used in the next call to CLATM1
           to continue the same random number sequence.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array, dimension ( MIN( M , N ) )
           Array to be computed according to MODE, COND and IRSIGN.
           May be changed on exit if MODE is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           Number of entries of D. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
            0  =&gt; normal termination
           -1  =&gt; if MODE not in range -6 to 6
           -2  =&gt; if MODE neither -6, 0 nor 6, and
                  IRSIGN neither 0 nor 1
           -3  =&gt; if MODE neither -6, 0 nor 6 and COND less than 1
           -4  =&gt; if MODE equals 6 or -6 and IDIST not in range 1 to 4
           -7  =&gt; if N negative</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2689df757dd5958a8c2911a648577d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex.html">complex</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> clatm2 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IGRADE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IPVTNG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPARSE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATM2</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLATM2 returns the (I,J) entry of a random matrix of dimension
    (M, N) described by the other paramters. It is called by the
    CLATMR routine in order to build random test matrices. No error
    checking on parameters is done, because this routine is called in
    a tight loop by CLATMR which has already checked the parameters.

    Use of CLATM2 differs from CLATM3 in the order in which the random
    number generator is called to fill in random matrix entries.
    With CLATM2, the generator is called to fill in the pivoted matrix
    columnwise. With CLATM3, the generator is called to fill in the
    matrix columnwise, after which it is pivoted. Thus, CLATM3 can
    be used to construct random matrices which differ only in their
    order of rows and/or columns. CLATM2 is used to construct band
    matrices while avoiding calling the random number generator for
    entries outside the band (and therefore generating random numbers

    The matrix whose (I,J) entry is returned is constructed as
    follows (this routine only computes one entry):

      If I is outside (1..M) or J is outside (1..N), return zero
         (this is convenient for generating matrices in band format).

      Generate a matrix A with random entries of distribution IDIST.

      Set the diagonal to D.

      Grade the matrix, if desired, from the left (by DL) and/or
         from the right (by DR or DL) as specified by IGRADE.

      Permute, if desired, the rows and/or columns as specified by
         IPVTNG and IWORK.

      Band the matrix to have lower bandwidth KL and upper
         bandwidth KU.

      Set random entries to zero as specified by SPARSE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
           Number of rows of matrix. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           Number of columns of matrix. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">          I is INTEGER
           Row of entry to be returned. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td><pre class="fragment">          J is INTEGER
           Column of entry to be returned. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
           Lower bandwidth. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
           Upper bandwidth. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is INTEGER
           On entry, IDIST specifies the type of distribution to be
           used to generate a random matrix .
           1 =&gt; real and imaginary parts each UNIFORM( 0, 1 )
           2 =&gt; real and imaginary parts each UNIFORM( -1, 1 )
           3 =&gt; real and imaginary parts each NORMAL( 0, 1 )
           4 =&gt; complex number uniform in DISK( 0 , 1 )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array of dimension ( 4 )
           Seed for random number generator.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array of dimension ( MIN( I , J ) )
           Diagonal entries of matrix. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IGRADE</td><td><pre class="fragment">          IGRADE is INTEGER
           Specifies grading of matrix as follows:
           0  =&gt; no grading
           1  =&gt; matrix premultiplied by diag( DL )
           2  =&gt; matrix postmultiplied by diag( DR )
           3  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( DR )
           4  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by inv( diag( DL ) )
           5  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( CONJG(DL) )
           6  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( DL )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DL</td><td><pre class="fragment">          DL is COMPLEX array ( I or J, as appropriate )
           Left scale factors for grading matrix.  Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DR</td><td><pre class="fragment">          DR is COMPLEX array ( I or J, as appropriate )
           Right scale factors for grading matrix.  Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IPVTNG</td><td><pre class="fragment">          IPVTNG is INTEGER
           On entry specifies pivoting permutations as follows:
           0 =&gt; none.
           1 =&gt; row pivoting.
           2 =&gt; column pivoting.
           3 =&gt; full pivoting, i.e., on both sides.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array ( I or J, as appropriate )
           This array specifies the permutation used. The
           row (or column) in position K was originally in
           position IWORK( K ).
           This differs from IWORK for CLATM3. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPARSE</td><td><pre class="fragment">          SPARSE is REAL
           Value between 0. and 1.
           On entry specifies the sparsity of the matrix
           if sparse matix is to be generated.
           SPARSE should lie between 0 and 1.
           A uniform ( 0, 1 ) random number x is generated and
           compared to SPARSE; if x is larger the matrix entry
           is unchanged and if x is smaller the entry is set
           to zero. Thus on the average a fraction SPARSE of the
           entries will be set to zero.
           Not modified.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga929f663f785e4b5841d06d9a947d670c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplex.html">complex</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> clatm3 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ISUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>JSUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IGRADE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IPVTNG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPARSE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATM3</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLATM3 returns the (ISUB,JSUB) entry of a random matrix of
    dimension (M, N) described by the other paramters. (ISUB,JSUB)
    is the final position of the (I,J) entry after pivoting
    according to IPVTNG and IWORK. CLATM3 is called by the
    CLATMR routine in order to build random test matrices. No error
    checking on parameters is done, because this routine is called in
    a tight loop by CLATMR which has already checked the parameters.

    Use of CLATM3 differs from CLATM2 in the order in which the random
    number generator is called to fill in random matrix entries.
    With CLATM2, the generator is called to fill in the pivoted matrix
    columnwise. With CLATM3, the generator is called to fill in the
    matrix columnwise, after which it is pivoted. Thus, CLATM3 can
    be used to construct random matrices which differ only in their
    order of rows and/or columns. CLATM2 is used to construct band
    matrices while avoiding calling the random number generator for
    entries outside the band (and therefore generating random numbers
    in different orders for different pivot orders).

    The matrix whose (ISUB,JSUB) entry is returned is constructed as
    follows (this routine only computes one entry):

      If ISUB is outside (1..M) or JSUB is outside (1..N), return zero
         (this is convenient for generating matrices in band format).

      Generate a matrix A with random entries of distribution IDIST.

      Set the diagonal to D.

      Grade the matrix, if desired, from the left (by DL) and/or
         from the right (by DR or DL) as specified by IGRADE.

      Permute, if desired, the rows and/or columns as specified by
         IPVTNG and IWORK.

      Band the matrix to have lower bandwidth KL and upper
         bandwidth KU.

      Set random entries to zero as specified by SPARSE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
           Number of rows of matrix. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           Number of columns of matrix. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">          I is INTEGER
           Row of unpivoted entry to be returned. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td><pre class="fragment">          J is INTEGER
           Column of unpivoted entry to be returned. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISUB</td><td><pre class="fragment">          ISUB is INTEGER
           Row of pivoted entry to be returned. Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">JSUB</td><td><pre class="fragment">          JSUB is INTEGER
           Column of pivoted entry to be returned. Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
           Lower bandwidth. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
           Upper bandwidth. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is INTEGER
           On entry, IDIST specifies the type of distribution to be
           used to generate a random matrix .
           1 =&gt; real and imaginary parts each UNIFORM( 0, 1 )
           2 =&gt; real and imaginary parts each UNIFORM( -1, 1 )
           3 =&gt; real and imaginary parts each NORMAL( 0, 1 )
           4 =&gt; complex number uniform in DISK( 0 , 1 )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array of dimension ( 4 )
           Seed for random number generator.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array of dimension ( MIN( I , J ) )
           Diagonal entries of matrix. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IGRADE</td><td><pre class="fragment">          IGRADE is INTEGER
           Specifies grading of matrix as follows:
           0  =&gt; no grading
           1  =&gt; matrix premultiplied by diag( DL )
           2  =&gt; matrix postmultiplied by diag( DR )
           3  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( DR )
           4  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by inv( diag( DL ) )
           5  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( CONJG(DL) )
           6  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( DL )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DL</td><td><pre class="fragment">          DL is COMPLEX array ( I or J, as appropriate )
           Left scale factors for grading matrix.  Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DR</td><td><pre class="fragment">          DR is COMPLEX array ( I or J, as appropriate )
           Right scale factors for grading matrix.  Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IPVTNG</td><td><pre class="fragment">          IPVTNG is INTEGER
           On entry specifies pivoting permutations as follows:
           0 =&gt; none.
           1 =&gt; row pivoting.
           2 =&gt; column pivoting.
           3 =&gt; full pivoting, i.e., on both sides.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array ( I or J, as appropriate )
           This array specifies the permutation used. The
           row (or column) originally in position K is in
           position IWORK( K ) after pivoting.
           This differs from IWORK for CLATM2. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPARSE</td><td><pre class="fragment">          SPARSE is REAL between 0. and 1.
           On entry specifies the sparsity of the matrix
           if sparse matix is to be generated.
           SPARSE should lie between 0 and 1.
           A uniform ( 0, 1 ) random number x is generated and
           compared to SPARSE; if x is larger the matrix entry
           is unchanged and if x is smaller the entry is set
           to zero. Thus on the average a fraction SPARSE of the
           entries will be set to zero.
           Not modified.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b05f57659c673fb19b320ad9737810b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatm5 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>PRTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldd, * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( <a class="el" href="dblat3_8f.html#a6fd3ddbe863b9e8e6e79ebf9c8594174">lde</a>, * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldf, * )&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldr, * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( <a class="el" href="slsqp__optmz_8f.html#adc7f4e2a6ab895ef2ca82e207b2c3388">ldl</a>, * )&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>QBLCKA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>QBLCKB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATM5</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLATM5 generates matrices involved in the Generalized Sylvester
 equation:

     A * R - L * B = C
     D * R - L * E = F

 They also satisfy (the diagonalization condition)

  [ I -L ] ( [ A  -C ], [ D -F ] ) [ I  R ] = ( [ A    ], [ D    ] )
  [    I ] ( [     B ]  [    E ] ) [    I ]   ( [    B ]  [    E ] )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PRTYPE</td><td><pre class="fragment">          PRTYPE is INTEGER
          "Points" to a certian type of the matrices to generate
          (see futher details).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          Specifies the order of A and D and the number of rows in
          C, F,  R and L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          Specifies the order of B and E and the number of columns in
          C, F, R and L.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, M).
          On exit A M-by-M is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB, N).
          On exit B N-by-N is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX array, dimension (LDC, N).
          On exit C M-by-N is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of C.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array, dimension (LDD, M).
          On exit D M-by-M is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDD</td><td><pre class="fragment">          LDD is INTEGER
          The leading dimension of D.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td><pre class="fragment">          E is COMPLEX array, dimension (LDE, N).
          On exit E N-by-N is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDE</td><td><pre class="fragment">          LDE is INTEGER
          The leading dimension of E.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td><pre class="fragment">          F is COMPLEX array, dimension (LDF, N).
          On exit F M-by-N is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDF</td><td><pre class="fragment">          LDF is INTEGER
          The leading dimension of F.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is COMPLEX array, dimension (LDR, N).
          On exit R M-by-N is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDR</td><td><pre class="fragment">          LDR is INTEGER
          The leading dimension of R.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td><pre class="fragment">          L is COMPLEX array, dimension (LDL, N).
          On exit L M-by-N is initialized according to PRTYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDL</td><td><pre class="fragment">          LDL is INTEGER
          The leading dimension of L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL
          Parameter used in generating PRTYPE = 1 and 5 matrices.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QBLCKA</td><td><pre class="fragment">          QBLCKA is INTEGER
          When PRTYPE = 3, specifies the distance between 2-by-2
          blocks on the diagonal in A. Otherwise, QBLCKA is not
          referenced. QBLCKA &gt; 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QBLCKB</td><td><pre class="fragment">          QBLCKB is INTEGER
          When PRTYPE = 3, specifies the distance between 2-by-2
          blocks on the diagonal in B. Otherwise, QBLCKB is not
          referenced. QBLCKB &gt; 1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  PRTYPE = 1: A and B are Jordan blocks, D and E are identity matrices

             A : if (i == j) then A(i, j) = 1.0
                 if (j == i + 1) then A(i, j) = -1.0
                 else A(i, j) = 0.0,            i, j = 1...M

             B : if (i == j) then B(i, j) = 1.0 - ALPHA
                 if (j == i + 1) then B(i, j) = 1.0
                 else B(i, j) = 0.0,            i, j = 1...N

             D : if (i == j) then D(i, j) = 1.0
                 else D(i, j) = 0.0,            i, j = 1...M

             E : if (i == j) then E(i, j) = 1.0
                 else E(i, j) = 0.0,            i, j = 1...N

             L =  R are chosen from [-10...10],
                  which specifies the right hand sides (C, F).

  PRTYPE = 2 or 3: Triangular and/or quasi- triangular.

             A : if (i &lt;= j) then A(i, j) = [-1...1]
                 else A(i, j) = 0.0,             i, j = 1...M

                 if (PRTYPE = 3) then
                    A(k + 1, k + 1) = A(k, k)
                    A(k + 1, k) = [-1...1]
                    sign(A(k, k + 1) = -(sin(A(k + 1, k))
                        k = 1, M - 1, QBLCKA

             B : if (i &lt;= j) then B(i, j) = [-1...1]
                 else B(i, j) = 0.0,            i, j = 1...N

                 if (PRTYPE = 3) then
                    B(k + 1, k + 1) = B(k, k)
                    B(k + 1, k) = [-1...1]
                    sign(B(k, k + 1) = -(sign(B(k + 1, k))
                        k = 1, N - 1, QBLCKB

             D : if (i &lt;= j) then D(i, j) = [-1...1].
                 else D(i, j) = 0.0,            i, j = 1...M


             E : if (i &lt;= j) then D(i, j) = [-1...1]
                 else E(i, j) = 0.0,            i, j = 1...N

                 L, R are chosen from [-10...10],
                 which specifies the right hand sides (C, F).

  PRTYPE = 4 Full
             A(i, j) = [-10...10]
             D(i, j) = [-1...1]    i,j = 1...M
             B(i, j) = [-10...10]
             E(i, j) = [-1...1]    i,j = 1...N
             R(i, j) = [-10...10]
             L(i, j) = [-1...1]    i = 1..M ,j = 1...N

             L, R specifies the right hand sides (C, F).

  PRTYPE = 5 special case common and/or close eigs.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gae9d75b31c19f718d006ac8059071b253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatm6 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>TYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldy, * )&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>WX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>WY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DIF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATM6</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLATM6 generates test matrices for the generalized eigenvalue
 problem, their corresponding right and left eigenvector matrices,
 and also reciprocal condition numbers for all eigenvalues and
 the reciprocal condition numbers of eigenvectors corresponding to
 the 1th and 5th eigenvalues.

 Test Matrices
 =============

 Two kinds of test matrix pairs
          (A, B) = inverse(YH) * (Da, Db) * inverse(X)
 are used in the tests:

 Type 1:
    Da = 1+a   0    0    0    0    Db = 1   0   0   0   0
          0   2+a   0    0    0         0   1   0   0   0
          0    0   3+a   0    0         0   0   1   0   0
          0    0    0   4+a   0         0   0   0   1   0
          0    0    0    0   5+a ,      0   0   0   0   1
 and Type 2:
    Da = 1+i   0    0       0       0    Db = 1   0   0   0   0
          0   1-i   0       0       0         0   1   0   0   0
          0    0    1       0       0         0   0   1   0   0
          0    0    0 (1+a)+(1+b)i  0         0   0   0   1   0
          0    0    0       0 (1+a)-(1+b)i,   0   0   0   0   1 .

 In both cases the same inverse(YH) and inverse(X) are used to compute
 (A, B), giving the exact eigenvectors to (A,B) as (YH, X):

 YH:  =  1    0   -y    y   -y    X =  1   0  -x  -x   x
         0    1   -y    y   -y         0   1   x  -x  -x
         0    0    1    0    0         0   0   1   0   0
         0    0    0    1    0         0   0   0   1   0
         0    0    0    0    1,        0   0   0   0   1 , where

 a, b, x and y will have all values independently of each other.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TYPE</td><td><pre class="fragment">          TYPE is INTEGER
          Specifies the problem type (see futher details).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          Size of the matrices A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N).
          On exit A N-by-N is initialized according to TYPE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A and of B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDA, N).
          On exit B N-by-N is initialized according to TYPE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (LDX, N).
          On exit X is the N-by-N matrix of right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of X.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is COMPLEX array, dimension (LDY, N).
          On exit Y is the N-by-N matrix of left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDY</td><td><pre class="fragment">          LDY is INTEGER
          The leading dimension of Y.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX

          Weighting constants for matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WX</td><td><pre class="fragment">          WX is COMPLEX
          Constant for right eigenvector matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WY</td><td><pre class="fragment">          WY is COMPLEX
          Constant for left eigenvector matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL array, dimension (N)
          S(i) is the reciprocal condition number for eigenvalue i.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIF</td><td><pre class="fragment">          DIF is REAL array, dimension (N)
          DIF(i) is the reciprocal condition number for eigenvector i.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b623095dea5337d8a8cc4e32c7990e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatme </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>COND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>DMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RSIGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPPER</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SIM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CONDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ANORM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATME</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLATME generates random non-symmetric square matrices with
    specified eigenvalues for testing LAPACK programs.

    CLATME operates by applying the following sequence of
    operations:

    1. Set the diagonal to D, where D may be input or
         computed according to MODE, COND, DMAX, and RSIGN
         as described below.

    2. If UPPER='T', the upper triangle of A is set to random values
         out of distribution DIST.

    3. If SIM='T', A is multiplied on the left by a random matrix
         X, whose singular values are specified by DS, MODES, and
         CONDS, and on the right by X inverse.

    4. If KL &lt; N-1, the lower bandwidth is reduced to KL using
         Householder transformations.  If KU &lt; N-1, the upper
         bandwidth is reduced to KU.

    5. If ANORM is not negative, the matrix is scaled to have
         maximum-element-norm ANORM.

    (Note: since the matrix cannot be reduced beyond Hessenberg form,
     no packing options are available.)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           The number of columns (or rows) of A. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIST</td><td><pre class="fragment">          DIST is CHARACTER*1
           On entry, DIST specifies the type of distribution to be used
           to generate the random eigen-/singular values, and on the
           upper triangle (see UPPER).
           'U' =&gt; UNIFORM( 0, 1 )  ( 'U' for uniform )
           'S' =&gt; UNIFORM( -1, 1 ) ( 'S' for symmetric )
           'N' =&gt; NORMAL( 0, 1 )   ( 'N' for normal )
           'D' =&gt; uniform on the complex disc |z| &lt; 1.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension ( 4 )
           On entry ISEED specifies the seed of the random number
           generator. They should lie between 0 and 4095 inclusive,
           and ISEED(4) should be odd. The random number generator
           uses a linear congruential sequence limited to small
           integers, and so should produce machine independent
           random numbers. The values of ISEED are changed on
           exit, and can be used in the next call to CLATME
           to continue the same random number sequence.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array, dimension ( N )
           This array is used to specify the eigenvalues of A.  If
           MODE=0, then D is assumed to contain the eigenvalues
           otherwise they will be computed according to MODE, COND,
           DMAX, and RSIGN and placed in D.
           Modified if MODE is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MODE</td><td><pre class="fragment">          MODE is INTEGER
           On entry this describes how the eigenvalues are to
           be specified:
           MODE = 0 means use D as input
           MODE = 1 sets D(1)=1 and D(2:N)=1.0/COND
           MODE = 2 sets D(1:N-1)=1 and D(N)=1.0/COND
           MODE = 3 sets D(I)=COND**(-(I-1)/(N-1))
           MODE = 4 sets D(i)=1 - (i-1)/(N-1)*(1 - 1/COND)
           MODE = 5 sets D to random numbers in the range
                    ( 1/COND , 1 ) such that their logarithms
                    are uniformly distributed.
           MODE = 6 set D to random numbers from same distribution
                    as the rest of the matrix.
           MODE &lt; 0 has the same meaning as ABS(MODE), except that
              the order of the elements of D is reversed.
           Thus if MODE is between 1 and 4, D has entries ranging
              from 1 to 1/COND, if between -1 and -4, D has entries
              ranging from 1/COND to 1,
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">COND</td><td><pre class="fragment">          COND is REAL
           On entry, this is used as described under MODE above.
           If used, it must be &gt;= 1. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DMAX</td><td><pre class="fragment">          DMAX is COMPLEX
           If MODE is neither -6, 0 nor 6, the contents of D, as
           computed according to MODE and COND, will be scaled by
           DMAX / max(abs(D(i))).  Note that DMAX need not be
           positive or real: if DMAX is negative or complex (or zero),
           D will be scaled by a negative or complex number (or zero).
           If RSIGN='F' then the largest (absolute) eigenvalue will be
           equal to DMAX.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RSIGN</td><td><pre class="fragment">          RSIGN is CHARACTER*1
           If MODE is not 0, 6, or -6, and RSIGN='T', then the
           elements of D, as computed according to MODE and COND, will
           be multiplied by a random complex number from the unit
           circle |z| = 1.  If RSIGN='F', they will not be.  RSIGN may
           only have the values 'T' or 'F'.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPPER</td><td><pre class="fragment">          UPPER is CHARACTER*1
           If UPPER='T', then the elements of A above the diagonal
           will be set to random numbers out of DIST.  If UPPER='F',
           they will not.  UPPER may only have the values 'T' or 'F'.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SIM</td><td><pre class="fragment">          SIM is CHARACTER*1
           If SIM='T', then A will be operated on by a "similarity
           transform", i.e., multiplied on the left by a matrix X and
           on the right by X inverse.  X = U S V, where U and V are
           random unitary matrices and S is a (diagonal) matrix of
           singular values specified by DS, MODES, and CONDS.  If
           SIM='F', then A will not be transformed.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DS</td><td><pre class="fragment">          DS is REAL array, dimension ( N )
           This array is used to specify the singular values of X,
           in the same way that D specifies the eigenvalues of A.
           If MODE=0, the DS contains the singular values, which
           may not be zero.
           Modified if MODE is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MODES</td><td><pre class="fragment">          MODES is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CONDS</td><td><pre class="fragment">          CONDS is REAL
           Similar to MODE and COND, but for specifying the diagonal
           of S.  MODES=-6 and +6 are not allowed (since they would
           result in randomly ill-conditioned eigenvalues.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
           This specifies the lower bandwidth of the  matrix.  KL=1
           specifies upper Hessenberg form.  If KL is at least N-1,
           then A will have full lower bandwidth.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
           This specifies the upper bandwidth of the  matrix.  KU=1
           specifies lower Hessenberg form.  If KU is at least N-1,
           then A will have full upper bandwidth; if KU and KL
           are both at least N-1, then A will be dense.  Only one of
           KU and KL may be less than N-1.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ANORM</td><td><pre class="fragment">          ANORM is REAL
           If ANORM is not negative, then A will be scaled by a non-
           negative real number to make the maximum-element-norm of A
           to be ANORM.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension ( LDA, N )
           On exit A is the desired test matrix.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
           LDA specifies the first dimension of A as declared in the
           calling program.  LDA must be at least M.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension ( 3*N )
           Workspace.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
           Error code.  On exit, INFO will be set to one of the
           following values:
             0 =&gt; normal return
            -1 =&gt; N negative
            -2 =&gt; DIST illegal string
            -5 =&gt; MODE not in range -6 to 6
            -6 =&gt; COND less than 1.0, and MODE neither -6, 0 nor 6
            -9 =&gt; RSIGN is not 'T' or 'F'
           -10 =&gt; UPPER is not 'T' or 'F'
           -11 =&gt; SIM   is not 'T' or 'F'
           -12 =&gt; MODES=0 and DS has a zero singular value.
           -13 =&gt; MODES is not in the range -5 to 5.
           -14 =&gt; MODES is nonzero and CONDS is less than 1.
           -15 =&gt; KL is less than 1.
           -16 =&gt; KU is less than 1, or KL and KU are both less than
                  N-1.
           -19 =&gt; LDA is less than M.
            1  =&gt; Error return from CLATM1 (computing D)
            2  =&gt; Cannot scale to DMAX (max. eigenvalue is 0)
            3  =&gt; Error return from SLATM1 (computing DS)
            4  =&gt; Error return from CLARGE
            5  =&gt; Zero singular value from SLATM1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga965cf56889238ff917eba10e6dbea93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatmr </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SYM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>COND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>DMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RSIGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>GRADE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODEL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CONDL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODER</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CONDR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>PIVTNG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IPIVOT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPARSE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ANORM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>PACK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATMR</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLATMR generates random matrices of various types for testing
    LAPACK programs.

    CLATMR operates by applying the following sequence of
    operations:

      Generate a matrix A with random entries of distribution DIST
         which is symmetric if SYM='S', Hermitian if SYM='H', and
         nonsymmetric if SYM='N'.

      Set the diagonal to D, where D may be input or
         computed according to MODE, COND, DMAX and RSIGN
         as described below.

      Grade the matrix, if desired, from the left and/or right
         as specified by GRADE. The inputs DL, MODEL, CONDL, DR,
         MODER and CONDR also determine the grading as described
         below.

      Permute, if desired, the rows and/or columns as specified by
         PIVTNG and IPIVOT.

      Set random entries to zero, if desired, to get a random sparse
         matrix as specified by SPARSE.

      Make A a band matrix, if desired, by zeroing out the matrix
         outside a band of lower bandwidth KL and upper bandwidth KU.

      Scale A, if desired, to have maximum entry ANORM.

      Pack the matrix if desired. Options specified by PACK are:
         no packing
         zero out upper half (if symmetric or Hermitian)
         zero out lower half (if symmetric or Hermitian)
         store the upper half columnwise (if symmetric or Hermitian
             or square upper triangular)
         store the lower half columnwise (if symmetric or Hermitian
             or square lower triangular)
             same as upper half rowwise if symmetric
             same as conjugate upper half rowwise if Hermitian
         store the lower triangle in banded format
             (if symmetric or Hermitian)
         store the upper triangle in banded format
             (if symmetric or Hermitian)
         store the entire matrix in banded format

    Note: If two calls to CLATMR differ only in the PACK parameter,
          they will generate mathematically equivalent matrices.

          If two calls to CLATMR both have full bandwidth (KL = M-1
          and KU = N-1), and differ only in the PIVTNG and PACK
          parameters, then the matrices generated will differ only
          in the order of the rows and/or columns, and otherwise
          contain the same data. This consistency cannot be and
          is not maintained with less than full bandwidth.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
           Number of rows of A. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           Number of columns of A. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIST</td><td><pre class="fragment">          DIST is CHARACTER*1
           On entry, DIST specifies the type of distribution to be used
           to generate a random matrix .
           'U' =&gt; real and imaginary parts are independent
                  UNIFORM( 0, 1 )  ( 'U' for uniform )
           'S' =&gt; real and imaginary parts are independent
                  UNIFORM( -1, 1 ) ( 'S' for symmetric )
           'N' =&gt; real and imaginary parts are independent
                  NORMAL( 0, 1 )   ( 'N' for normal )
           'D' =&gt; uniform on interior of unit disk ( 'D' for disk )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
           On entry ISEED specifies the seed of the random number
           generator. They should lie between 0 and 4095 inclusive,
           and ISEED(4) should be odd. The random number generator
           uses a linear congruential sequence limited to small
           integers, and so should produce machine independent
           random numbers. The values of ISEED are changed on
           exit, and can be used in the next call to CLATMR
           to continue the same random number sequence.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SYM</td><td><pre class="fragment">          SYM is CHARACTER*1
           If SYM='S', generated matrix is symmetric.
           If SYM='H', generated matrix is Hermitian.
           If SYM='N', generated matrix is nonsymmetric.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array, dimension (min(M,N))
           On entry this array specifies the diagonal entries
           of the diagonal of A.  D may either be specified
           on entry, or set according to MODE and COND as described
           below. If the matrix is Hermitian, the real part of D
           will be taken. May be changed on exit if MODE is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MODE</td><td><pre class="fragment">          MODE is INTEGER
           On entry describes how D is to be used:
           MODE = 0 means use D as input
           MODE = 1 sets D(1)=1 and D(2:N)=1.0/COND
           MODE = 2 sets D(1:N-1)=1 and D(N)=1.0/COND
           MODE = 3 sets D(I)=COND**(-(I-1)/(N-1))
           MODE = 4 sets D(i)=1 - (i-1)/(N-1)*(1 - 1/COND)
           MODE = 5 sets D to random numbers in the range
                    ( 1/COND , 1 ) such that their logarithms
                    are uniformly distributed.
           MODE = 6 set D to random numbers from same distribution
                    as the rest of the matrix.
           MODE &lt; 0 has the same meaning as ABS(MODE), except that
              the order of the elements of D is reversed.
           Thus if MODE is positive, D has entries ranging from
              1 to 1/COND, if negative, from 1/COND to 1,
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">COND</td><td><pre class="fragment">          COND is REAL
           On entry, used as described under MODE above.
           If used, it must be &gt;= 1. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DMAX</td><td><pre class="fragment">          DMAX is COMPLEX
           If MODE neither -6, 0 nor 6, the diagonal is scaled by
           DMAX / max(abs(D(i))), so that maximum absolute entry
           of diagonal is abs(DMAX). If DMAX is complex (or zero),
           diagonal will be scaled by a complex number (or zero).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RSIGN</td><td><pre class="fragment">          RSIGN is CHARACTER*1
           If MODE neither -6, 0 nor 6, specifies sign of diagonal
           as follows:
           'T' =&gt; diagonal entries are multiplied by a random complex
                  number uniformly distributed with absolute value 1
           'F' =&gt; diagonal unchanged
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GRADE</td><td><pre class="fragment">          GRADE is CHARACTER*1
           Specifies grading of matrix as follows:
           'N'  =&gt; no grading
           'L'  =&gt; matrix premultiplied by diag( DL )
                   (only if matrix nonsymmetric)
           'R'  =&gt; matrix postmultiplied by diag( DR )
                   (only if matrix nonsymmetric)
           'B'  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( DR )
                   (only if matrix nonsymmetric)
           'H'  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( CONJG(DL) )
                   (only if matrix Hermitian or nonsymmetric)
           'S'  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by diag( DL )
                   (only if matrix symmetric or nonsymmetric)
           'E'  =&gt; matrix premultiplied by diag( DL ) and
                         postmultiplied by inv( diag( DL ) )
                         ( 'S' for similarity )
                   (only if matrix nonsymmetric)
                   Note: if GRADE='S', then M must equal N.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DL</td><td><pre class="fragment">          DL is COMPLEX array, dimension (M)
           If MODEL=0, then on entry this array specifies the diagonal
           entries of a diagonal matrix used as described under GRADE
           above. If MODEL is not zero, then DL will be set according
           to MODEL and CONDL, analogous to the way D is set according
           to MODE and COND (except there is no DMAX parameter for DL).
           If GRADE='E', then DL cannot have zero entries.
           Not referenced if GRADE = 'N' or 'R'. Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MODEL</td><td><pre class="fragment">          MODEL is INTEGER
           This specifies how the diagonal array DL is to be computed,
           just as MODE specifies how D is to be computed.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CONDL</td><td><pre class="fragment">          CONDL is REAL
           When MODEL is not zero, this specifies the condition number
           of the computed DL.  Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DR</td><td><pre class="fragment">          DR is COMPLEX array, dimension (N)
           If MODER=0, then on entry this array specifies the diagonal
           entries of a diagonal matrix used as described under GRADE
           above. If MODER is not zero, then DR will be set according
           to MODER and CONDR, analogous to the way D is set according
           to MODE and COND (except there is no DMAX parameter for DR).
           Not referenced if GRADE = 'N', 'L', 'H' or 'S'.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MODER</td><td><pre class="fragment">          MODER is INTEGER
           This specifies how the diagonal array DR is to be computed,
           just as MODE specifies how D is to be computed.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CONDR</td><td><pre class="fragment">          CONDR is REAL
           When MODER is not zero, this specifies the condition number
           of the computed DR.  Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVTNG</td><td><pre class="fragment">          PIVTNG is CHARACTER*1
           On entry specifies pivoting permutations as follows:
           'N' or ' ' =&gt; none.
           'L' =&gt; left or row pivoting (matrix must be nonsymmetric).
           'R' =&gt; right or column pivoting (matrix must be
                  nonsymmetric).
           'B' or 'F' =&gt; both or full pivoting, i.e., on both sides.
                         In this case, M must equal N

           If two calls to CLATMR both have full bandwidth (KL = M-1
           and KU = N-1), and differ only in the PIVTNG and PACK
           parameters, then the matrices generated will differ only
           in the order of the rows and/or columns, and otherwise
           contain the same data. This consistency cannot be
           maintained with less than full bandwidth.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IPIVOT</td><td><pre class="fragment">          IPIVOT is INTEGER array, dimension (N or M)
           This array specifies the permutation used.  After the
           basic matrix is generated, the rows, columns, or both
           are permuted.   If, say, row pivoting is selected, CLATMR
           starts with the *last* row and interchanges the M-th and
           IPIVOT(M)-th rows, then moves to the next-to-last row,
           interchanging the (M-1)-th and the IPIVOT(M-1)-th rows,
           and so on.  In terms of "2-cycles", the permutation is
           (1 IPIVOT(1)) (2 IPIVOT(2)) ... (M IPIVOT(M))
           where the rightmost cycle is applied first.  This is the
           *inverse* of the effect of pivoting in LINPACK.  The idea
           is that factoring (with pivoting) an identity matrix
           which has been inverse-pivoted in this way should
           result in a pivot vector identical to IPIVOT.
           Not referenced if PIVTNG = 'N'. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPARSE</td><td><pre class="fragment">          SPARSE is REAL
           On entry specifies the sparsity of the matrix if a sparse
           matrix is to be generated. SPARSE should lie between
           0 and 1. To generate a sparse matrix, for each matrix entry
           a uniform ( 0, 1 ) random number x is generated and
           compared to SPARSE; if x is larger the matrix entry
           is unchanged and if x is smaller the entry is set
           to zero. Thus on the average a fraction SPARSE of the
           entries will be set to zero.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
           On entry specifies the lower bandwidth of the  matrix. For
           example, KL=0 implies upper triangular, KL=1 implies upper
           Hessenberg, and KL at least M-1 implies the matrix is not
           banded. Must equal KU if matrix is symmetric or Hermitian.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
           On entry specifies the upper bandwidth of the  matrix. For
           example, KU=0 implies lower triangular, KU=1 implies lower
           Hessenberg, and KU at least N-1 implies the matrix is not
           banded. Must equal KL if matrix is symmetric or Hermitian.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ANORM</td><td><pre class="fragment">          ANORM is REAL
           On entry specifies maximum entry of output matrix
           (output matrix will by multiplied by a constant so that
           its largest absolute entry equal ANORM)
           if ANORM is nonnegative. If ANORM is negative no scaling
           is done. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PACK</td><td><pre class="fragment">          PACK is CHARACTER*1
           On entry specifies packing of matrix as follows:
           'N' =&gt; no packing
           'U' =&gt; zero out all subdiagonal entries
                  (if symmetric or Hermitian)
           'L' =&gt; zero out all superdiagonal entries
                  (if symmetric or Hermitian)
           'C' =&gt; store the upper triangle columnwise
                  (only if matrix symmetric or Hermitian or
                   square upper triangular)
           'R' =&gt; store the lower triangle columnwise
                  (only if matrix symmetric or Hermitian or
                   square lower triangular)
                  (same as upper half rowwise if symmetric)
                  (same as conjugate upper half rowwise if Hermitian)
           'B' =&gt; store the lower triangle in band storage scheme
                  (only if matrix symmetric or Hermitian)
           'Q' =&gt; store the upper triangle in band storage scheme
                  (only if matrix symmetric or Hermitian)
           'Z' =&gt; store the entire matrix in band storage scheme
                      (pivoting can be provided for by using this
                      option to store A in the trailing rows of
                      the allocated storage)

           Using these options, the various LAPACK packed and banded
           storage schemes can be obtained:
           GB               - use 'Z'
           PB, HB or TB     - use 'B' or 'Q'
           PP, HP or TP     - use 'C' or 'R'

           If two calls to CLATMR differ only in the PACK parameter,
           they will generate mathematically equivalent matrices.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
           On exit A is the desired test matrix. Only those
           entries of A which are significant on output
           will be referenced (even if A is in packed or band
           storage format). The 'unoccupied corners' of A in
           band format will be zeroed out.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
           on entry LDA specifies the first dimension of A as
           declared in the calling program.
           If PACK='N', 'U' or 'L', LDA must be at least max ( 1, M ).
           If PACK='C' or 'R', LDA must be at least 1.
           If PACK='B', or 'Q', LDA must be MIN ( KU+1, N )
           If PACK='Z', LDA must be at least KUU+KLL+1, where
           KUU = MIN ( KU, N-1 ) and KLL = MIN ( KL, N-1 )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (N or M)
           Workspace. Not referenced if PIVTNG = 'N'. Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
           Error parameter on exit:
             0 =&gt; normal return
            -1 =&gt; M negative or unequal to N and SYM='S' or 'H'
            -2 =&gt; N negative
            -3 =&gt; DIST illegal string
            -5 =&gt; SYM illegal string
            -7 =&gt; MODE not in range -6 to 6
            -8 =&gt; COND less than 1.0, and MODE neither -6, 0 nor 6
           -10 =&gt; MODE neither -6, 0 nor 6 and RSIGN illegal string
           -11 =&gt; GRADE illegal string, or GRADE='E' and
                  M not equal to N, or GRADE='L', 'R', 'B', 'S' or 'E'
                  and SYM = 'H', or GRADE='L', 'R', 'B', 'H' or 'E'
                  and SYM = 'S'
           -12 =&gt; GRADE = 'E' and DL contains zero
           -13 =&gt; MODEL not in range -6 to 6 and GRADE= 'L', 'B', 'H',
                  'S' or 'E'
           -14 =&gt; CONDL less than 1.0, GRADE='L', 'B', 'H', 'S' or 'E',
                  and MODEL neither -6, 0 nor 6
           -16 =&gt; MODER not in range -6 to 6 and GRADE= 'R' or 'B'
           -17 =&gt; CONDR less than 1.0, GRADE='R' or 'B', and
                  MODER neither -6, 0 nor 6
           -18 =&gt; PIVTNG illegal string, or PIVTNG='B' or 'F' and
                  M not equal to N, or PIVTNG='L' or 'R' and SYM='S'
                  or 'H'
           -19 =&gt; IPIVOT contains out of range number and
                  PIVTNG not equal to 'N'
           -20 =&gt; KL negative
           -21 =&gt; KU negative, or SYM='S' or 'H' and KU not equal to KL
           -22 =&gt; SPARSE not in range 0. to 1.
           -24 =&gt; PACK illegal string, or PACK='U', 'L', 'B' or 'Q'
                  and SYM='N', or PACK='C' and SYM='N' and either KL
                  not equal to 0 or N not equal to M, or PACK='R' and
                  SYM='N', and either KU not equal to 0 or N not equal
                  to M
           -26 =&gt; LDA too small
             1 =&gt; Error return from CLATM1 (computing D)
             2 =&gt; Cannot scale diagonal to DMAX (max. entry is 0)
             3 =&gt; Error return from CLATM1 (computing DL)
             4 =&gt; Error return from CLATM1 (computing DR)
             5 =&gt; ANORM is positive, but matrix constructed prior to
                  attempting to scale it to have norm ANORM, is zero</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga411f64e8d8b980e985c6b0189139dc49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatms </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SYM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>COND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>DMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>PACK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATMS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLATMS generates random matrices with specified singular values
    (or hermitian with specified eigenvalues)
    for testing LAPACK programs.

    CLATMS operates by applying the following sequence of
    operations:

      Set the diagonal to D, where D may be input or
         computed according to MODE, COND, DMAX, and SYM
         as described below.

      Generate a matrix with the appropriate band structure, by one
         of two methods:

      Method A:
          Generate a dense M x N matrix by multiplying D on the left
              and the right by random unitary matrices, then:

          Reduce the bandwidth according to KL and KU, using
              Householder transformations.

      Method B:
          Convert the bandwidth-0 (i.e., diagonal) matrix to a
              bandwidth-1 matrix using Givens rotations, "chasing"
              out-of-band elements back, much as in QR; then convert
              the bandwidth-1 to a bandwidth-2 matrix, etc.  Note
              that for reasonably small bandwidths (relative to M and
              N) this requires less storage, as a dense matrix is not
              generated.  Also, for hermitian or symmetric matrices,
              only one triangle is generated.

      Method A is chosen if the bandwidth is a large fraction of the
          order of the matrix, and LDA is at least M (so a dense
          matrix can be stored.)  Method B is chosen if the bandwidth
          is small (&lt; 1/2 N for hermitian or symmetric, &lt; .3 N+M for
          non-symmetric), or LDA is less than M and not less than the
          bandwidth.

      Pack the matrix if desired. Options specified by PACK are:
         no packing
         zero out upper half (if hermitian)
         zero out lower half (if hermitian)
         store the upper half columnwise (if hermitian or upper
               triangular)
         store the lower half columnwise (if hermitian or lower
               triangular)
         store the lower triangle in banded format (if hermitian or
               lower triangular)
         store the upper triangle in banded format (if hermitian or
               upper triangular)
         store the entire matrix in banded format
      If Method B is chosen, and band format is specified, then the
         matrix will be generated in the band format, so no repacking
         will be necessary.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
           The number of rows of A. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           The number of columns of A. N must equal M if the matrix
           is symmetric or hermitian (i.e., if SYM is not 'N')
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIST</td><td><pre class="fragment">          DIST is CHARACTER*1
           On entry, DIST specifies the type of distribution to be used
           to generate the random eigen-/singular values.
           'U' =&gt; UNIFORM( 0, 1 )  ( 'U' for uniform )
           'S' =&gt; UNIFORM( -1, 1 ) ( 'S' for symmetric )
           'N' =&gt; NORMAL( 0, 1 )   ( 'N' for normal )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension ( 4 )
           On entry ISEED specifies the seed of the random number
           generator. They should lie between 0 and 4095 inclusive,
           and ISEED(4) should be odd. The random number generator
           uses a linear congruential sequence limited to small
           integers, and so should produce machine independent
           random numbers. The values of ISEED are changed on
           exit, and can be used in the next call to CLATMS
           to continue the same random number sequence.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SYM</td><td><pre class="fragment">          SYM is CHARACTER*1
           If SYM='H', the generated matrix is hermitian, with
             eigenvalues specified by D, COND, MODE, and DMAX; they
             may be positive, negative, or zero.
           If SYM='P', the generated matrix is hermitian, with
             eigenvalues (= singular values) specified by D, COND,
             MODE, and DMAX; they will not be negative.
           If SYM='N', the generated matrix is nonsymmetric, with
             singular values specified by D, COND, MODE, and DMAX;
             they will not be negative.
           If SYM='S', the generated matrix is (complex) symmetric,
             with singular values specified by D, COND, MODE, and
             DMAX; they will not be negative.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension ( MIN( M, N ) )
           This array is used to specify the singular values or
           eigenvalues of A (see SYM, above.)  If MODE=0, then D is
           assumed to contain the singular/eigenvalues, otherwise
           they will be computed according to MODE, COND, and DMAX,
           and placed in D.
           Modified if MODE is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MODE</td><td><pre class="fragment">          MODE is INTEGER
           On entry this describes how the singular/eigenvalues are to
           be specified:
           MODE = 0 means use D as input
           MODE = 1 sets D(1)=1 and D(2:N)=1.0/COND
           MODE = 2 sets D(1:N-1)=1 and D(N)=1.0/COND
           MODE = 3 sets D(I)=COND**(-(I-1)/(N-1))
           MODE = 4 sets D(i)=1 - (i-1)/(N-1)*(1 - 1/COND)
           MODE = 5 sets D to random numbers in the range
                    ( 1/COND , 1 ) such that their logarithms
                    are uniformly distributed.
           MODE = 6 set D to random numbers from same distribution
                    as the rest of the matrix.
           MODE &lt; 0 has the same meaning as ABS(MODE), except that
              the order of the elements of D is reversed.
           Thus if MODE is positive, D has entries ranging from
              1 to 1/COND, if negative, from 1/COND to 1,
           If SYM='H', and MODE is neither 0, 6, nor -6, then
              the elements of D will also be multiplied by a random
              sign (i.e., +1 or -1.)
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">COND</td><td><pre class="fragment">          COND is REAL
           On entry, this is used as described under MODE above.
           If used, it must be &gt;= 1. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DMAX</td><td><pre class="fragment">          DMAX is REAL
           If MODE is neither -6, 0 nor 6, the contents of D, as
           computed according to MODE and COND, will be scaled by
           DMAX / max(abs(D(i))); thus, the maximum absolute eigen- or
           singular value (which is to say the norm) will be abs(DMAX).
           Note that DMAX need not be positive: if DMAX is negative
           (or zero), D will be scaled by a negative number (or zero).
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
           This specifies the lower bandwidth of the  matrix. For
           example, KL=0 implies upper triangular, KL=1 implies upper
           Hessenberg, and KL being at least M-1 means that the matrix
           has full lower bandwidth.  KL must equal KU if the matrix
           is symmetric or hermitian.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
           This specifies the upper bandwidth of the  matrix. For
           example, KU=0 implies lower triangular, KU=1 implies lower
           Hessenberg, and KU being at least N-1 means that the matrix
           has full upper bandwidth.  KL must equal KU if the matrix
           is symmetric or hermitian.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PACK</td><td><pre class="fragment">          PACK is CHARACTER*1
           This specifies packing of matrix as follows:
           'N' =&gt; no packing
           'U' =&gt; zero out all subdiagonal entries (if symmetric
                  or hermitian)
           'L' =&gt; zero out all superdiagonal entries (if symmetric
                  or hermitian)
           'C' =&gt; store the upper triangle columnwise (only if the
                  matrix is symmetric, hermitian, or upper triangular)
           'R' =&gt; store the lower triangle columnwise (only if the
                  matrix is symmetric, hermitian, or lower triangular)
           'B' =&gt; store the lower triangle in band storage scheme
                  (only if the matrix is symmetric, hermitian, or
                  lower triangular)
           'Q' =&gt; store the upper triangle in band storage scheme
                  (only if the matrix is symmetric, hermitian, or
                  upper triangular)
           'Z' =&gt; store the entire matrix in band storage scheme
                      (pivoting can be provided for by using this
                      option to store A in the trailing rows of
                      the allocated storage)

           Using these options, the various LAPACK packed and banded
           storage schemes can be obtained:
           GB                    - use 'Z'
           PB, SB, HB, or TB     - use 'B' or 'Q'
           PP, SP, HB, or TP     - use 'C' or 'R'

           If two calls to CLATMS differ only in the PACK parameter,
           they will generate mathematically equivalent matrices.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension ( LDA, N )
           On exit A is the desired test matrix.  A is first generated
           in full (unpacked) form, and then packed, if so specified
           by PACK.  Thus, the first M elements of the first N
           columns will always be modified.  If PACK specifies a
           packed or banded storage scheme, all LDA elements of the
           first N columns will be modified; the elements of the
           array which do not correspond to elements of the generated
           matrix are set to zero.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
           LDA specifies the first dimension of A as declared in the
           calling program.  If PACK='N', 'U', 'L', 'C', or 'R', then
           LDA must be at least M.  If PACK='B' or 'Q', then LDA must
           be at least MIN( KL, M-1) (which is equal to MIN(KU,N-1)).
           If PACK='Z', LDA must be large enough to hold the packed
           array: MIN( KU, N-1) + MIN( KL, M-1) + 1.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension ( 3*MAX( N, M ) )
           Workspace.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
           Error code.  On exit, INFO will be set to one of the
           following values:
             0 =&gt; normal return
            -1 =&gt; M negative or unequal to N and SYM='S', 'H', or 'P'
            -2 =&gt; N negative
            -3 =&gt; DIST illegal string
            -5 =&gt; SYM illegal string
            -7 =&gt; MODE not in range -6 to 6
            -8 =&gt; COND less than 1.0, and MODE neither -6, 0 nor 6
           -10 =&gt; KL negative
           -11 =&gt; KU negative, or SYM is not 'N' and KU is not equal to
                  KL
           -12 =&gt; PACK illegal string, or PACK='U' or 'L', and SYM='N';
                  or PACK='C' or 'Q' and SYM='N' and KL is not zero;
                  or PACK='R' or 'B' and SYM='N' and KU is not zero;
                  or PACK='U', 'L', 'C', 'R', 'B', or 'Q', and M is not
                  N.
           -14 =&gt; LDA is less than M, or PACK='Z' and LDA is less than
                  MIN(KU,N-1) + MIN(KL,M-1) + 1.
            1  =&gt; Error return from SLATM1
            2  =&gt; Cannot scale to DMAX (max. sing. value is 0)
            3  =&gt; Error return from CLAGGE, CLAGHE or CLAGSY</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gacbcffc07d8119265fdd7ec81f961e75a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatmt </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SYM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>COND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>DMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>RANK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>PACK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATMT</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CLATMT generates random matrices with specified singular values
    (or hermitian with specified eigenvalues)
    for testing LAPACK programs.

    CLATMT operates by applying the following sequence of
    operations:

      Set the diagonal to D, where D may be input or
         computed according to MODE, COND, DMAX, and SYM
         as described below.

      Generate a matrix with the appropriate band structure, by one
         of two methods:

      Method A:
          Generate a dense M x N matrix by multiplying D on the left
              and the right by random unitary matrices, then:

          Reduce the bandwidth according to KL and KU, using
              Householder transformations.

      Method B:
          Convert the bandwidth-0 (i.e., diagonal) matrix to a
              bandwidth-1 matrix using Givens rotations, "chasing"
              out-of-band elements back, much as in QR; then convert
              the bandwidth-1 to a bandwidth-2 matrix, etc.  Note
              that for reasonably small bandwidths (relative to M and
              N) this requires less storage, as a dense matrix is not
              generated.  Also, for hermitian or symmetric matrices,
              only one triangle is generated.

      Method A is chosen if the bandwidth is a large fraction of the
          order of the matrix, and LDA is at least M (so a dense
          matrix can be stored.)  Method B is chosen if the bandwidth
          is small (&lt; 1/2 N for hermitian or symmetric, &lt; .3 N+M for
          non-symmetric), or LDA is less than M and not less than the
          bandwidth.

      Pack the matrix if desired. Options specified by PACK are:
         no packing
         zero out upper half (if hermitian)
         zero out lower half (if hermitian)
         store the upper half columnwise (if hermitian or upper
               triangular)
         store the lower half columnwise (if hermitian or lower
               triangular)
         store the lower triangle in banded format (if hermitian or
               lower triangular)
         store the upper triangle in banded format (if hermitian or
               upper triangular)
         store the entire matrix in banded format
      If Method B is chosen, and band format is specified, then the
         matrix will be generated in the band format, so no repacking
         will be necessary.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
           The number of rows of A. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           The number of columns of A. N must equal M if the matrix
           is symmetric or hermitian (i.e., if SYM is not 'N')
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIST</td><td><pre class="fragment">          DIST is CHARACTER*1
           On entry, DIST specifies the type of distribution to be used
           to generate the random eigen-/singular values.
           'U' =&gt; UNIFORM( 0, 1 )  ( 'U' for uniform )
           'S' =&gt; UNIFORM( -1, 1 ) ( 'S' for symmetric )
           'N' =&gt; NORMAL( 0, 1 )   ( 'N' for normal )
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension ( 4 )
           On entry ISEED specifies the seed of the random number
           generator. They should lie between 0 and 4095 inclusive,
           and ISEED(4) should be odd. The random number generator
           uses a linear congruential sequence limited to small
           integers, and so should produce machine independent
           random numbers. The values of ISEED are changed on
           exit, and can be used in the next call to CLATMT
           to continue the same random number sequence.
           Changed on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SYM</td><td><pre class="fragment">          SYM is CHARACTER*1
           If SYM='H', the generated matrix is hermitian, with
             eigenvalues specified by D, COND, MODE, and DMAX; they
             may be positive, negative, or zero.
           If SYM='P', the generated matrix is hermitian, with
             eigenvalues (= singular values) specified by D, COND,
             MODE, and DMAX; they will not be negative.
           If SYM='N', the generated matrix is nonsymmetric, with
             singular values specified by D, COND, MODE, and DMAX;
             they will not be negative.
           If SYM='S', the generated matrix is (complex) symmetric,
             with singular values specified by D, COND, MODE, and
             DMAX; they will not be negative.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension ( MIN( M, N ) )
           This array is used to specify the singular values or
           eigenvalues of A (see SYM, above.)  If MODE=0, then D is
           assumed to contain the singular/eigenvalues, otherwise
           they will be computed according to MODE, COND, and DMAX,
           and placed in D.
           Modified if MODE is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MODE</td><td><pre class="fragment">          MODE is INTEGER
           On entry this describes how the singular/eigenvalues are to
           be specified:
           MODE = 0 means use D as input
           MODE = 1 sets D(1)=1 and D(2:RANK)=1.0/COND
           MODE = 2 sets D(1:RANK-1)=1 and D(RANK)=1.0/COND
           MODE = 3 sets D(I)=COND**(-(I-1)/(RANK-1))
           MODE = 4 sets D(i)=1 - (i-1)/(N-1)*(1 - 1/COND)
           MODE = 5 sets D to random numbers in the range
                    ( 1/COND , 1 ) such that their logarithms
                    are uniformly distributed.
           MODE = 6 set D to random numbers from same distribution
                    as the rest of the matrix.
           MODE &lt; 0 has the same meaning as ABS(MODE), except that
              the order of the elements of D is reversed.
           Thus if MODE is positive, D has entries ranging from
              1 to 1/COND, if negative, from 1/COND to 1,
           If SYM='H', and MODE is neither 0, 6, nor -6, then
              the elements of D will also be multiplied by a random
              sign (i.e., +1 or -1.)
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">COND</td><td><pre class="fragment">          COND is REAL
           On entry, this is used as described under MODE above.
           If used, it must be &gt;= 1. Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DMAX</td><td><pre class="fragment">          DMAX is REAL
           If MODE is neither -6, 0 nor 6, the contents of D, as
           computed according to MODE and COND, will be scaled by
           DMAX / max(abs(D(i))); thus, the maximum absolute eigen- or
           singular value (which is to say the norm) will be abs(DMAX).
           Note that DMAX need not be positive: if DMAX is negative
           (or zero), D will be scaled by a negative number (or zero).
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RANK</td><td><pre class="fragment">          RANK is INTEGER
           The rank of matrix to be generated for modes 1,2,3 only.
           D( RANK+1:N ) = 0.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
           This specifies the lower bandwidth of the  matrix. For
           example, KL=0 implies upper triangular, KL=1 implies upper
           Hessenberg, and KL being at least M-1 means that the matrix
           has full lower bandwidth.  KL must equal KU if the matrix
           is symmetric or hermitian.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
           This specifies the upper bandwidth of the  matrix. For
           example, KU=0 implies lower triangular, KU=1 implies lower
           Hessenberg, and KU being at least N-1 means that the matrix
           has full upper bandwidth.  KL must equal KU if the matrix
           is symmetric or hermitian.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PACK</td><td><pre class="fragment">          PACK is CHARACTER*1
           This specifies packing of matrix as follows:
           'N' =&gt; no packing
           'U' =&gt; zero out all subdiagonal entries (if symmetric
                  or hermitian)
           'L' =&gt; zero out all superdiagonal entries (if symmetric
                  or hermitian)
           'C' =&gt; store the upper triangle columnwise (only if the
                  matrix is symmetric, hermitian, or upper triangular)
           'R' =&gt; store the lower triangle columnwise (only if the
                  matrix is symmetric, hermitian, or lower triangular)
           'B' =&gt; store the lower triangle in band storage scheme
                  (only if the matrix is symmetric, hermitian, or
                  lower triangular)
           'Q' =&gt; store the upper triangle in band storage scheme
                  (only if the matrix is symmetric, hermitian, or
                  upper triangular)
           'Z' =&gt; store the entire matrix in band storage scheme
                      (pivoting can be provided for by using this
                      option to store A in the trailing rows of
                      the allocated storage)

           Using these options, the various LAPACK packed and banded
           storage schemes can be obtained:
           GB                    - use 'Z'
           PB, SB, HB, or TB     - use 'B' or 'Q'
           PP, SP, HB, or TP     - use 'C' or 'R'

           If two calls to CLATMT differ only in the PACK parameter,
           they will generate mathematically equivalent matrices.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension ( LDA, N )
           On exit A is the desired test matrix.  A is first generated
           in full (unpacked) form, and then packed, if so specified
           by PACK.  Thus, the first M elements of the first N
           columns will always be modified.  If PACK specifies a
           packed or banded storage scheme, all LDA elements of the
           first N columns will be modified; the elements of the
           array which do not correspond to elements of the generated
           matrix are set to zero.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
           LDA specifies the first dimension of A as declared in the
           calling program.  If PACK='N', 'U', 'L', 'C', or 'R', then
           LDA must be at least M.  If PACK='B' or 'Q', then LDA must
           be at least MIN( KL, M-1) (which is equal to MIN(KU,N-1)).
           If PACK='Z', LDA must be large enough to hold the packed
           array: MIN( KU, N-1) + MIN( KL, M-1) + 1.
           Not modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension ( 3*MAX( N, M ) )
           Workspace.
           Modified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
           Error code.  On exit, INFO will be set to one of the
           following values:
             0 =&gt; normal return
            -1 =&gt; M negative or unequal to N and SYM='S', 'H', or 'P'
            -2 =&gt; N negative
            -3 =&gt; DIST illegal string
            -5 =&gt; SYM illegal string
            -7 =&gt; MODE not in range -6 to 6
            -8 =&gt; COND less than 1.0, and MODE neither -6, 0 nor 6
           -10 =&gt; KL negative
           -11 =&gt; KU negative, or SYM is not 'N' and KU is not equal to
                  KL
           -12 =&gt; PACK illegal string, or PACK='U' or 'L', and SYM='N';
                  or PACK='C' or 'Q' and SYM='N' and KL is not zero;
                  or PACK='R' or 'B' and SYM='N' and KU is not zero;
                  or PACK='U', 'L', 'C', 'R', 'B', or 'Q', and M is not
                  N.
           -14 =&gt; LDA is less than M, or PACK='Z' and LDA is less than
                  MIN(KU,N-1) + MIN(KL,M-1) + 1.
            1  =&gt; Error return from SLATM7
            2  =&gt; Cannot scale to DMAX (max. sing. value is 0)
            3  =&gt; Error return from CLAGGE, CLAGHE or CLAGSY</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:25:22 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
