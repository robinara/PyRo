<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: packages/scipy-0.14.0/scipy/sparse/linalg/dsolve/SuperLU/SRC/slu_sdefs.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_57252c80289af05466fbe77c678891c1.html">packages</a></li><li class="navelem"><a class="el" href="dir_ddf9433626c48ee2897d59790861d1d7.html">scipy-0.14.0</a></li><li class="navelem"><a class="el" href="dir_858e2d91629607ed5d60a80404dc9ef5.html">scipy</a></li><li class="navelem"><a class="el" href="dir_bd789bd717b324b07d117eeb3375d4ab.html">sparse</a></li><li class="navelem"><a class="el" href="dir_4da7b85b574def59405e3eaa8deb0970.html">linalg</a></li><li class="navelem"><a class="el" href="dir_de2a93bb0a221cfd28d5b220976efa42.html">dsolve</a></li><li class="navelem"><a class="el" href="dir_582e3cf870217c9627d6d5de12c0bef2.html">SuperLU</a></li><li class="navelem"><a class="el" href="dir_a575a5e35ad3d6ab3514c3e7a6921579.html">SRC</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">slu_sdefs.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for real operations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &quot;<a class="el" href="slu__Cnames_8h_source.html">slu_Cnames.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="supermatrix_8h_source.html">supermatrix.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="slu__util_8h_source.html">slu_util.h</a>&quot;</code><br />
</div>
<p><a href="slu__sdefs_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab6fd6105e64ed14a0c9281326f05e623"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a></td></tr>
<tr class="separator:ab6fd6105e64ed14a0c9281326f05e623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44bbae3b1218d951ed229c461a5f14b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a44bbae3b1218d951ed229c461a5f14b6">sgssv</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="memdesc:a44bbae3b1218d951ed229c461a5f14b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver routines.  <a href="#a44bbae3b1218d951ed229c461a5f14b6">More...</a><br /></td></tr>
<tr class="separator:a44bbae3b1218d951ed229c461a5f14b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6a37b565522c7c77a173826588deee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a4d6a37b565522c7c77a173826588deee">sgssvx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, void *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float *, float *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:a4d6a37b565522c7c77a173826588deee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6cdbb84f0fbd4cbce7a64ea1f7eb20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aff6cdbb84f0fbd4cbce7a64ea1f7eb20">sgsisv</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:aff6cdbb84f0fbd4cbce7a64ea1f7eb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57375a81b174861bcb68ed11861a4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab57375a81b174861bcb68ed11861a4f5">sgsisx</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, void *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:ab57375a81b174861bcb68ed11861a4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3d30eea43abc536793244e7564e70d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#abb3d30eea43abc536793244e7564e70d">sCreate_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, float *, int *, int *, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="memdesc:abb3d30eea43abc536793244e7564e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supernodal LU factor related.  <a href="#abb3d30eea43abc536793244e7564e70d">More...</a><br /></td></tr>
<tr class="separator:abb3d30eea43abc536793244e7564e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77496309d539716f616365a2515aa653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a77496309d539716f616365a2515aa653">sCreate_CompRow_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, float *, int *, int *, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="separator:a77496309d539716f616365a2515aa653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7369dba9a8c3e34a27bdc9eba73cbe3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a7369dba9a8c3e34a27bdc9eba73cbe3e">sCopy_CompCol_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="memdesc:a7369dba9a8c3e34a27bdc9eba73cbe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy matrix <a class="el" href="classA.html">A</a> into matrix B.  <a href="#a7369dba9a8c3e34a27bdc9eba73cbe3e">More...</a><br /></td></tr>
<tr class="separator:a7369dba9a8c3e34a27bdc9eba73cbe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98118f5539f098beff0b70c041c2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aca98118f5539f098beff0b70c041c2e6">sCreate_Dense_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, float *, int, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="separator:aca98118f5539f098beff0b70c041c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4386b0d87e1c8886b58fcf9d243bc12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#af4386b0d87e1c8886b58fcf9d243bc12">sCreate_SuperNode_Matrix</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int, float *, int *, int *, int *, int *, int *, <a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>, <a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>, <a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>)</td></tr>
<tr class="separator:af4386b0d87e1c8886b58fcf9d243bc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef26ab4351b4ab39c2ef3d0ff5d6cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a5ef26ab4351b4ab39c2ef3d0ff5d6cb5">sCopy_Dense_Matrix</a> (int, int, float *, int, float *, int)</td></tr>
<tr class="separator:a5ef26ab4351b4ab39c2ef3d0ff5d6cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8086902aa8be3fc7d04c3c82ec3a79dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a8086902aa8be3fc7d04c3c82ec3a79dc">countnz</a> (const int, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a8086902aa8be3fc7d04c3c82ec3a79dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L.  <a href="#a8086902aa8be3fc7d04c3c82ec3a79dc">More...</a><br /></td></tr>
<tr class="separator:a8086902aa8be3fc7d04c3c82ec3a79dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8eb367a0a2fcdf734738bc9630df85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aae8eb367a0a2fcdf734738bc9630df85">ilu_countnz</a> (const int, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:aae8eb367a0a2fcdf734738bc9630df85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of nonzeros in factors L and U.  <a href="#aae8eb367a0a2fcdf734738bc9630df85">More...</a><br /></td></tr>
<tr class="separator:aae8eb367a0a2fcdf734738bc9630df85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7061332d759d7e4d73c1b2e5cb0bf2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a7061332d759d7e4d73c1b2e5cb0bf2bf">fixupL</a> (const int, const int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a7061332d759d7e4d73c1b2e5cb0bf2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix up the data storage lsub for L-subscripts. It removes the subscript sets for structural pruning, and applies permuation to the remaining subscripts.  <a href="#a7061332d759d7e4d73c1b2e5cb0bf2bf">More...</a><br /></td></tr>
<tr class="separator:a7061332d759d7e4d73c1b2e5cb0bf2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef6f98786d0bd76103237385ddbeb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aaef6f98786d0bd76103237385ddbeb9f">sallocateA</a> (int, int, float **, int **, int **)</td></tr>
<tr class="memdesc:aaef6f98786d0bd76103237385ddbeb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for original matrix <a class="el" href="classA.html">A</a>.  <a href="#aaef6f98786d0bd76103237385ddbeb9f">More...</a><br /></td></tr>
<tr class="separator:aaef6f98786d0bd76103237385ddbeb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af006a81b576fffa92a1c848ac3191c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#af006a81b576fffa92a1c848ac3191c70">sgstrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int *, void *, int, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:af006a81b576fffa92a1c848ac3191c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d54c8dfc11f1e034b4b7175be60ffb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ad9d54c8dfc11f1e034b4b7175be60ffb">ssnode_dfs</a> (const int, const int, const int *, const int *, const int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:ad9d54c8dfc11f1e034b4b7175be60ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e60255360fae0b1458da070690a3a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a60e60255360fae0b1458da070690a3a2">ssnode_bmod</a> (const int, const int, const int, float *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="memdesc:a60e60255360fae0b1458da070690a3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates within the relaxed snode.  <a href="#a60e60255360fae0b1458da070690a3a2">More...</a><br /></td></tr>
<tr class="separator:a60e60255360fae0b1458da070690a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77baf210393e04fa71d4e73b5e60e556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a77baf210393e04fa71d4e73b5e60e556">spanel_dfs</a> (const int, const int, const int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, float *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a77baf210393e04fa71d4e73b5e60e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51486936a9ff5079afed80eb5bf8a3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a51486936a9ff5079afed80eb5bf8a3e0">spanel_bmod</a> (const int, const int, const int, const int, float *, float *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:a51486936a9ff5079afed80eb5bf8a3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dc9300377cb7240572ba34a31af3d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a20dc9300377cb7240572ba34a31af3d1">scolumn_dfs</a> (const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a20dc9300377cb7240572ba34a31af3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21004feb23626f7ea648b46657a257a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ae21004feb23626f7ea648b46657a257a">scolumn_bmod</a> (const int, const int, float *, float *, int *, int *, int, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:ae21004feb23626f7ea648b46657a257a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a312149bcf091fcc8adbd0c536cb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a249a312149bcf091fcc8adbd0c536cb2">scopy_to_ucol</a> (int, int, int *, int *, int *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a249a312149bcf091fcc8adbd0c536cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ddf03faedae25b4d73e0b6b33bf50c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ad7ddf03faedae25b4d73e0b6b33bf50c">spivotL</a> (const int, const double, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:ad7ddf03faedae25b4d73e0b6b33bf50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9da2c45289246ef663fc4a96d1ad78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#acf9da2c45289246ef663fc4a96d1ad78">spruneL</a> (const int, const int *, const int, const int, const int *, const int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:acf9da2c45289246ef663fc4a96d1ad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab345670a95db3f9c4b9c451224db8227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab345670a95db3f9c4b9c451224db8227">sreadmt</a> (int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="separator:ab345670a95db3f9c4b9c451224db8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79adc3c2d496feb17f359aa303211fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab79adc3c2d496feb17f359aa303211fc">sGenXtrue</a> (int, int, float *, int)</td></tr>
<tr class="separator:ab79adc3c2d496feb17f359aa303211fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b784b5551863e8d50047ee280c34cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ac8b784b5551863e8d50047ee280c34cf">sFillRHS</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, int, float *, int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="memdesc:ac8b784b5551863e8d50047ee280c34cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let rhs[i] = sum of i-th row of <a class="el" href="classA.html">A</a>, so the solution vector is all 1's.  <a href="#ac8b784b5551863e8d50047ee280c34cf">More...</a><br /></td></tr>
<tr class="separator:ac8b784b5551863e8d50047ee280c34cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea450a9c52512127d6eaaebf0a65f9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aea450a9c52512127d6eaaebf0a65f9ce">sgstrs</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:aea450a9c52512127d6eaaebf0a65f9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22204c4186c4412ee33cd16285ee6bb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a22204c4186c4412ee33cd16285ee6bb0">sgsitrf</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int, int, int *, void *, int, int *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:a22204c4186c4412ee33cd16285ee6bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69557d06b4e300aa6aca944561f3bb32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a69557d06b4e300aa6aca944561f3bb32">sldperm</a> (int, int, int, int[], int[], float[], int[], float[], float[])</td></tr>
<tr class="separator:a69557d06b4e300aa6aca944561f3bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714eccb6cd0fb1fc0920e8a52489f1a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a714eccb6cd0fb1fc0920e8a52489f1a5">ilu_ssnode_dfs</a> (const int, const int, const int *, const int *, const int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:a714eccb6cd0fb1fc0920e8a52489f1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b3297a15ace9ac5abd65c5e708f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aa91b3297a15ace9ac5abd65c5e708f2d">ilu_spanel_dfs</a> (const int, const int, const int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, float *, float *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:aa91b3297a15ace9ac5abd65c5e708f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2366ea3e2cdcbf51b976432fc43616"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aab2366ea3e2cdcbf51b976432fc43616">ilu_scolumn_dfs</a> (const int, const int, int *, int *, int *, int *, int *, int *, int *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="separator:aab2366ea3e2cdcbf51b976432fc43616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a18be483569110edc1665d13e260e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a35a18be483569110edc1665d13e260e3">ilu_scopy_to_ucol</a> (int, int, int *, int *, int *, float *, int, <a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>, double, int, float *, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, float *)</td></tr>
<tr class="separator:a35a18be483569110edc1665d13e260e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f61e0a95c151f53f8a400bc9c6192e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab7f61e0a95c151f53f8a400bc9c6192e">ilu_spivotL</a> (const int, const double, int *, int *, int, int *, int *, int *, int *, double, <a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>, float, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *)</td></tr>
<tr class="separator:ab7f61e0a95c151f53f8a400bc9c6192e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e67d3b2d715a388ca99bb28387fb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a5f5e67d3b2d715a388ca99bb28387fb9">ilu_sdrop_row</a> (<a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *, int, int, double, int, int *, double *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, float *, float *, int)</td></tr>
<tr class="separator:a5f5e67d3b2d715a388ca99bb28387fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbdb406f2fb8b186f0f8d3a4cd2d60d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a3dbdb406f2fb8b186f0f8d3a4cd2d60d">sgsequ</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float *, float *, float *, int *)</td></tr>
<tr class="memdesc:a3dbdb406f2fb8b186f0f8d3a4cd2d60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver related.  <a href="#a3dbdb406f2fb8b186f0f8d3a4cd2d60d">More...</a><br /></td></tr>
<tr class="separator:a3dbdb406f2fb8b186f0f8d3a4cd2d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4b556cd9d484f53606d114f83649d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#afe4b556cd9d484f53606d114f83649d4">slaqgs</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, float, float, float, char *)</td></tr>
<tr class="separator:afe4b556cd9d484f53606d114f83649d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c910cf12639a22a03727ad204575b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a1c910cf12639a22a03727ad204575b3b">sgscon</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:a1c910cf12639a22a03727ad204575b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8787465a6296109b9a306d5a315ff8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#acb8787465a6296109b9a306d5a315ff8">sPivotGrowth</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="separator:acb8787465a6296109b9a306d5a315ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae824bcb507f76ad3053d845352fb6b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ae824bcb507f76ad3053d845352fb6b3d">sgsrfs</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, int *, int *, char *, float *, float *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="separator:ae824bcb507f76ad3053d845352fb6b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d287b6b9bcaf72a692343e614c429c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aa6d287b6b9bcaf72a692343e614c429c">sp_strsv</a> (char *, char *, char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *, int *)</td></tr>
<tr class="memdesc:aa6d287b6b9bcaf72a692343e614c429c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves one of the systems of equations A*x = b, or <a class="el" href="classA.html">A</a>'*x = b.  <a href="#aa6d287b6b9bcaf72a692343e614c429c">More...</a><br /></td></tr>
<tr class="separator:aa6d287b6b9bcaf72a692343e614c429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e543b2d14781b56ef349114012b4fc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a9e543b2d14781b56ef349114012b4fc9">sp_sgemv</a> (char *, float, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, int, float, float *, int)</td></tr>
<tr class="memdesc:a9e543b2d14781b56ef349114012b4fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A'*x + beta*y,.  <a href="#a9e543b2d14781b56ef349114012b4fc9">More...</a><br /></td></tr>
<tr class="separator:a9e543b2d14781b56ef349114012b4fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b4a0e44c32443df609069021d27812"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a35b4a0e44c32443df609069021d27812">sp_sgemm</a> (char *, char *, int, int, int, float, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *, int, float, float *, int)</td></tr>
<tr class="separator:a35b4a0e44c32443df609069021d27812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c1dd1b8332f4366d5c5112219fdb3a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a47c1dd1b8332f4366d5c5112219fdb3a">slamch_</a> (char *)</td></tr>
<tr class="separator:a47c1dd1b8332f4366d5c5112219fdb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68715ec86cde90aa31fec07164d6ea6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#af68715ec86cde90aa31fec07164d6ea6">sLUMemInit</a> (<a class="el" href="superlu__enum__consts_8h.html#ac785c8235480e5cfef9848d89c047c0a">fact_t</a>, void *, int, int, int, int, int, float, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *, int **, float **)</td></tr>
<tr class="memdesc:af68715ec86cde90aa31fec07164d6ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-related.  <a href="#af68715ec86cde90aa31fec07164d6ea6">More...</a><br /></td></tr>
<tr class="separator:af68715ec86cde90aa31fec07164d6ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b2859bf1ef1900506dfa702574c6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab5b2859bf1ef1900506dfa702574c6ad">sSetRWork</a> (int, int, float *, float **, float **)</td></tr>
<tr class="memdesc:ab5b2859bf1ef1900506dfa702574c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up pointers for real working arrays.  <a href="#ab5b2859bf1ef1900506dfa702574c6ad">More...</a><br /></td></tr>
<tr class="separator:ab5b2859bf1ef1900506dfa702574c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9035f0d2a50cf5d8e29287572bd1be83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a9035f0d2a50cf5d8e29287572bd1be83">sLUWorkFree</a> (int *, float *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a9035f0d2a50cf5d8e29287572bd1be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the working storage used by factor routines.  <a href="#a9035f0d2a50cf5d8e29287572bd1be83">More...</a><br /></td></tr>
<tr class="separator:a9035f0d2a50cf5d8e29287572bd1be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af26d0426eb0bb63755880f2e67e7b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a9af26d0426eb0bb63755880f2e67e7b7">sLUMemXpand</a> (int, int, <a class="el" href="superlu__enum__consts_8h.html#abd31f838aefffa46191d0d7dc36a96b2">MemType</a>, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a9af26d0426eb0bb63755880f2e67e7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the data structures for L and U during the factorization.  <a href="#a9af26d0426eb0bb63755880f2e67e7b7">More...</a><br /></td></tr>
<tr class="separator:a9af26d0426eb0bb63755880f2e67e7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42361c3ce2ba81d149ffba01fbd6f138"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a42361c3ce2ba81d149ffba01fbd6f138">floatMalloc</a> (int)</td></tr>
<tr class="separator:a42361c3ce2ba81d149ffba01fbd6f138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1230bff11a9e47c35555299bcdcf1b"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a3e1230bff11a9e47c35555299bcdcf1b">floatCalloc</a> (int)</td></tr>
<tr class="separator:a3e1230bff11a9e47c35555299bcdcf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50ebebf3a620086366b6c310d52d681"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ab50ebebf3a620086366b6c310d52d681">smemory_usage</a> (const int, const int, const int, const int)</td></tr>
<tr class="separator:ab50ebebf3a620086366b6c310d52d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1357f9a3b2ffb9522883ad84affa63e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a1357f9a3b2ffb9522883ad84affa63e3">sQuerySpace</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *)</td></tr>
<tr class="separator:a1357f9a3b2ffb9522883ad84affa63e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb260ae3f26e2179b1cf33c3e754d6f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#adb260ae3f26e2179b1cf33c3e754d6f1">ilu_sQuerySpace</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *)</td></tr>
<tr class="separator:adb260ae3f26e2179b1cf33c3e754d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734dbf3f5d66b2a53d88e69daaad729e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a734dbf3f5d66b2a53d88e69daaad729e">sreadhb</a> (int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="memdesc:a734dbf3f5d66b2a53d88e69daaad729e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary routines.  <a href="#a734dbf3f5d66b2a53d88e69daaad729e">More...</a><br /></td></tr>
<tr class="separator:a734dbf3f5d66b2a53d88e69daaad729e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad992a573876b4abfe192ec2bc207f6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ad992a573876b4abfe192ec2bc207f6b0">sreadrb</a> (int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="separator:ad992a573876b4abfe192ec2bc207f6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99cb18465c8992235a7bc003237f692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#ae99cb18465c8992235a7bc003237f692">sreadtriple</a> (int *, int *, int *, float **, int **, int **)</td></tr>
<tr class="separator:ae99cb18465c8992235a7bc003237f692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4be8ddf6a62ef48ca8dfc3a6992634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aef4be8ddf6a62ef48ca8dfc3a6992634">sCompRow_to_CompCol</a> (int, int, int, float *, int *, int *, float **, int **, int **)</td></tr>
<tr class="memdesc:aef4be8ddf6a62ef48ca8dfc3a6992634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a row compressed storage into a column compressed storage.  <a href="#aef4be8ddf6a62ef48ca8dfc3a6992634">More...</a><br /></td></tr>
<tr class="separator:aef4be8ddf6a62ef48ca8dfc3a6992634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d734e40276e89a3ef04bf79bc21acb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a2d734e40276e89a3ef04bf79bc21acb6">sfill</a> (float *, int, float)</td></tr>
<tr class="memdesc:a2d734e40276e89a3ef04bf79bc21acb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a float precision array with a given value.  <a href="#a2d734e40276e89a3ef04bf79bc21acb6">More...</a><br /></td></tr>
<tr class="separator:a2d734e40276e89a3ef04bf79bc21acb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0eeda28d139bf88878880edd3cca5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aba0eeda28d139bf88878880edd3cca5a">sinf_norm_error</a> (int, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, float *)</td></tr>
<tr class="memdesc:aba0eeda28d139bf88878880edd3cca5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the inf-norm of the error vector.  <a href="#aba0eeda28d139bf88878880edd3cca5a">More...</a><br /></td></tr>
<tr class="separator:aba0eeda28d139bf88878880edd3cca5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca8047332d0b0c161945583ecb3435d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#adca8047332d0b0c161945583ecb3435d">PrintPerf</a> (<a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *, <a class="el" href="structmem__usage__t.html">mem_usage_t</a> *, float, float, float *, float *, char *)</td></tr>
<tr class="separator:adca8047332d0b0c161945583ecb3435d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d44fe59660f87330b0172151a76141"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a98d44fe59660f87330b0172151a76141">sqselect</a> (int, float *, int)</td></tr>
<tr class="separator:a98d44fe59660f87330b0172151a76141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd6efad9d9fb7aef8a984f5e3cff66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a5cd6efad9d9fb7aef8a984f5e3cff66b">sPrint_CompCol_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="memdesc:a5cd6efad9d9fb7aef8a984f5e3cff66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines for debugging.  <a href="#a5cd6efad9d9fb7aef8a984f5e3cff66b">More...</a><br /></td></tr>
<tr class="separator:a5cd6efad9d9fb7aef8a984f5e3cff66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb289a84407c9cbbb33cdf3dbb1dacbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aeb289a84407c9cbbb33cdf3dbb1dacbe">sPrint_SuperNode_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="separator:aeb289a84407c9cbbb33cdf3dbb1dacbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b29c47333295f4aa744e541e277ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a25b29c47333295f4aa744e541e277ea0">sPrint_Dense_Matrix</a> (char *, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *)</td></tr>
<tr class="separator:a25b29c47333295f4aa744e541e277ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297455c494a78c098b2bf418edbc6b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a297455c494a78c098b2bf418edbc6b16">sprint_lu_col</a> (char *, int, int, int *, <a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *)</td></tr>
<tr class="memdesc:a297455c494a78c098b2bf418edbc6b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic print of column "jcol" in the U/L factor.  <a href="#a297455c494a78c098b2bf418edbc6b16">More...</a><br /></td></tr>
<tr class="separator:a297455c494a78c098b2bf418edbc6b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0c06e9adc1e29a0ab2e78c38119bb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#aad0c06e9adc1e29a0ab2e78c38119bb4">print_double_vec</a> (char *, int, double *)</td></tr>
<tr class="separator:aad0c06e9adc1e29a0ab2e78c38119bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e1e8ccffc9a076461dbd042ae91654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slu__sdefs_8h.html#a46e1e8ccffc9a076461dbd042ae91654">check_tempv</a> (int, float *)</td></tr>
<tr class="separator:a46e1e8ccffc9a076461dbd042ae91654"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for real operations. </p>
<pre> 
&ndash; SuperLU routine (version 4.1) &ndash;
Univ. of California Berkeley, Xerox Palo Alto Research Center,
and Lawrence Berkeley National Lab.
November, 2010</pre><pre>Global data structures used in LU factorization -</pre><pre>  nsuper: #supernodes = nsuper + 1, numbered [0, nsuper].
  (xsup,supno): supno[i] is the supernode no to which i belongs;
 xsup(s) points to the beginning of the s-th supernode.
 e.g.   supno 0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
         xsup 0 1 2 4 7 12
 Note: dfs will be performed on supernode rep. relative to the new 
       row pivoting ordering</pre><pre>  (xlsub,lsub): lsub[*] contains the compressed subscript of
 rectangular supernodes; xlsub[j] points to the starting
 location of the j-th column in lsub[*]. Note that xlsub 
 is indexed by column.
 Storage: original row subscripts
</p><pre class="fragment">During the course of sparse LU factorization, we also use
</pre><p>
 (xlsub,lsub) for the purpose of symmetric pruning. For each
 supernode {s,s+1,...,t=s+r} with first column s and last
 column t, the subscript set
    lsub[j], j=xlsub[s], .., xlsub[s+1]-1
 is the structure of column s (i.e. structure of this supernode).
 It is used for the storage of numerical values.
 Furthermore,
    lsub[j], j=xlsub[t], .., xlsub[t+1]-1
 is the structure of the last column t of this supernode.
 It is for the purpose of symmetric pruning. Therefore, the
 structural subscripts can be rearranged without making physical
 interchanges among the numerical values.</pre><pre> However, if the supernode has only one column, then we
 only keep one set of subscripts. For any subscript interchange
 performed, similar interchange must be done on the numerical
 values.</pre><pre> The last column structures (for pruning) will be removed
 after the numercial LU factorization phase.</pre><pre>  (xlusup,lusup): lusup[*] contains the numerical values of the
 rectangular supernodes; xlusup[j] points to the starting
 location of the j-th column in storage vector lusup[*]
 Note: xlusup is indexed by column.
 Each rectangular supernode is stored by column-major
 scheme, consistent with Fortran 2-dim array storage.</pre><pre>  (xusub,ucol,usub): ucol[*] stores the numerical values of
 U-columns outside the rectangular supernodes. The row
 subscript of nonzero ucol[k] is stored in usub[k].
 xusub[i] points to the starting location of column i in ucol.
 Storage: new row subscripts; that is subscripts of PA.
</pre> </div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab6fd6105e64ed14a0c9281326f05e623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="slu__cdefs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a46e1e8ccffc9a076461dbd042ae91654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_tempv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8086902aa8be3fc7d04c3c82ec3a79dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void countnz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the total number of nonzeros in factors L and U, and in the symmetrically reduced L. </p>

</div>
</div>
<a class="anchor" id="a7061332d759d7e4d73c1b2e5cb0bf2bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fixupL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fix up the data storage lsub for L-subscripts. It removes the subscript sets for structural pruning, and applies permuation to the remaining subscripts. </p>

</div>
</div>
<a class="anchor" id="a3e1230bff11a9e47c35555299bcdcf1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* floatCalloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42361c3ce2ba81d149ffba01fbd6f138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* floatMalloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae8eb367a0a2fcdf734738bc9630df85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilu_countnz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the total number of nonzeros in factors L and U. </p>

</div>
</div>
<a class="anchor" id="aab2366ea3e2cdcbf51b976432fc43616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_scolumn_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  ILU_SCOLUMN_DFS performs a symbolic factorization on column jcol, and
  decide the supernode boundary.</pre><pre>  This routine does not use numeric values, but only use the RHS
  row indices to start the dfs.</pre><pre>  <a class="el" href="classA.html">A</a> supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives. The routine returns a list of such supernodal
  representatives in topological order of the dfs that generates them.
  The location of the first nonzero in each such supernodal segment
  (supernodal entry location) is also returned.</pre><pre><h1>Local parameters
</h1>
</pre><pre>
  nseg: no of segments in current U[*,j]
  jsuper: jsuper=EMPTY if column j does not belong to the same
 supernode as j-1. Otherwise, jsuper=nsuper.</pre><pre>  marker2: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure</pre><pre><h1>Return value
</h1>
</pre><pre>
    0  success;
</p><blockquote class="doxtable">
<p>0  number of bytes allocated when run out of space.
</p>
</blockquote>
</pre> 
</div>
</div>
<a class="anchor" id="a35a18be483569110edc1665d13e260e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_scopy_to_ucol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f5e67d3b2d715a388ca99bb28387fb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_sdrop_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa91b3297a15ace9ac5abd65c5e708f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ilu_spanel_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>  Performs a symbolic factorization on a panel of columns [jcol, jcol+w).</pre><pre>  <a class="el" href="classA.html">A</a> supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives.</pre><pre>  The routine returns one list of the supernodal representatives
  in topological order of the dfs that generates them. This list is
  a superset of the topological order of each individual column within
  the panel.
  The location of the first nonzero in each supernodal segment
  (supernodal entry location) is also returned. Each column has a
  separate list for this purpose.</pre><pre>  Two marker arrays are used for dfs:
    marker[i] == jj, if i was visited during dfs of current column jj;
    marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</pre><pre>  marker: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure
</pre> 
</div>
</div>
<a class="anchor" id="ab7f61e0a95c151f53f8a400bc9c6192e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_spivotL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>usepr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diagind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iswap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fill_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0cb73c13a7c2390c3a9a0a8913477ff0">milu_t</a>&#160;</td>
          <td class="paramname"><em>milu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>drop_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  Performs the numerical pivoting on the current column of L,
  and the CDIV operation.</pre><pre>  Pivot policy:
  (1) Compute thresh = u * max_(i&gt;=j) <a class="el" href="slamch_8c.html#a3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>;
  (2) IF user specifies pivot row k and <a class="el" href="slamch_8c.html#a3aa069ac3980707dae1e0530f50d59e4">abs(A_kj)</a> &gt;= thresh THEN
      pivot row = k;
  ELSE IF <a class="el" href="slamch_8c.html#a3aa069ac3980707dae1e0530f50d59e4">abs(A_jj)</a> &gt;= thresh THEN
      pivot row = j;
  ELSE
      pivot row = m;</pre><pre>  Note: If you absolutely want to use a given pivot order, then set u=0.0.</pre><pre>  Return value: 0     success;
       i &gt; 0  U(i,i) is exactly zero.
</pre> 
</div>
</div>
<a class="anchor" id="adb260ae3f26e2179b1cf33c3e754d6f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_sQuerySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
mem_usage consists of the following fields:</p><ul>
<li>for_lu (float)
     The amount of space used in bytes for the L data structures.</li>
<li>total_needed (float)
     The amount of space needed in bytes to perform factorization.

</li>
</ul>
</pre>
</div>
</div>
<a class="anchor" id="a714eccb6cd0fb1fc0920e8a52489f1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ilu_ssnode_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
   <a class="el" href="ilu__ssnode__dfs_8c.html#a510a9174e442a65aaa83f9ce97390f85">ilu_ssnode_dfs()</a> - Determine the union of the row structures of those
   columns within the relaxed snode.
   Note: The relaxed snodes are leaves of the supernodal etree, therefore,
   the portion outside the rectangular supernode must be zero.</pre><pre><h1>Return value
</h1>
</pre><pre>
    0   success;
   &gt;0   number of bytes allocated when run out of memory.
</pre> 
</div>
</div>
<a class="anchor" id="aad0c06e9adc1e29a0ab2e78c38119bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_double_vec </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adca8047332d0b0c161945583ecb3435d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintPerf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaef6f98786d0bd76103237385ddbeb9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sallocateA </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage for original matrix <a class="el" href="classA.html">A</a>. </p>

</div>
</div>
<a class="anchor" id="ae21004feb23626f7ea648b46657a257a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scolumn_bmod </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fpanelc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose:
</h1>
</pre><pre>
Performs numeric block updates (sup-col) in topological order.
It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
Special processing on the supernodal portion of L[*,j]
Return value:   0 - successful return
              &gt; 0 - number of bytes allocated when run out of space
</pre> 
</div>
</div>
<a class="anchor" id="a20dc9300377cb7240572ba34a31af3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scolumn_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  SCOLUMN_DFS performs a symbolic factorization on column jcol, and
  decide the supernode boundary.</pre><pre>  This routine does not use numeric values, but only use the RHS 
  row indices to start the dfs.</pre><pre>  <a class="el" href="classA.html">A</a> supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives. The routine returns a list of such supernodal 
  representatives in topological order of the dfs that generates them.
  The location of the first nonzero in each such supernodal segment
  (supernodal entry location) is also returned.</pre><pre><h1>Local parameters
</h1>
</pre><pre>
  nseg: no of segments in current U[*,j]
  jsuper: jsuper=EMPTY if column j does not belong to the same
 supernode as j-1. Otherwise, jsuper=nsuper.</pre><pre>  marker2: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure</pre><pre><h1>Return value
</h1>
</pre><pre>
    0  success;
</p><blockquote class="doxtable">
<p>0  number of bytes allocated when run out of space.
</p>
</blockquote>
</pre> 
</div>
</div>
<a class="anchor" id="aef4be8ddf6a62ef48ca8dfc3a6992634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCompRow_to_CompCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a row compressed storage into a column compressed storage. </p>

</div>
</div>
<a class="anchor" id="a7369dba9a8c3e34a27bdc9eba73cbe3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCopy_CompCol_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy matrix <a class="el" href="classA.html">A</a> into matrix B. </p>

</div>
</div>
<a class="anchor" id="a5ef26ab4351b4ab39c2ef3d0ff5d6cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCopy_Dense_Matrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a two-dimensional matrix X to another matrix Y.</p>

</div>
</div>
<a class="anchor" id="a249a312149bcf091fcc8adbd0c536cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scopy_to_ucol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb3d30eea43abc536793244e7564e70d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_CompCol_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supernodal LU factor related. </p>

</div>
</div>
<a class="anchor" id="a77496309d539716f616365a2515aa653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_CompRow_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca98118f5539f098beff0b70c041c2e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_Dense_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4386b0d87e1c8886b58fcf9d243bc12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sCreate_SuperNode_Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a9d2ddedeb2a3d92e950811c61d0b8796">Stype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a7987cb2a28ec879b39a90e9e48e29190">Dtype_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="supermatrix_8h.html#a5962adac634f3feebe487ad443802d60">Mtype_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d734e40276e89a3ef04bf79bc21acb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sfill </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a float precision array with a given value. </p>

</div>
</div>
<a class="anchor" id="ac8b784b5551863e8d50047ee280c34cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sFillRHS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let rhs[i] = sum of i-th row of <a class="el" href="classA.html">A</a>, so the solution vector is all 1's. </p>

</div>
</div>
<a class="anchor" id="ab79adc3c2d496feb17f359aa303211fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sGenXtrue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c910cf12639a22a03727ad204575b3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgscon </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>anorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SGSCON estimates the reciprocal of the condition number of a general 
  real matrix <a class="el" href="classA.html">A</a>, in either the 1-norm or the infinity-norm, using   
  the LU factorization computed by SGETRF.   *</pre><pre>  An estimate is obtained for norm(inv(A)), and the reciprocal of the   
  condition number is computed as   
     RCOND = 1 / ( norm(A) * norm(inv(A)) ).</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>   NORM    (input) char*
           Specifies whether the 1-norm condition number or the   
           infinity-norm condition number is required:   
           = '1' or 'O':  1-norm;   
           = 'I':         Infinity-norm.</pre><pre>   L       (input) SuperMatrix*
           The factor L from the factorization Pr*A*Pc=L*U as computed by
           <a class="el" href="sgstrf_8c.html#a2428d5d7ef46cf9a08069d9f55901284">sgstrf()</a>. Use compressed row subscripts storage for supernodes,
           i.e., L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>   U       (input) SuperMatrix*
           The factor U from the factorization Pr*A*Pc=L*U as computed by
           <a class="el" href="sgstrf_8c.html#a2428d5d7ef46cf9a08069d9f55901284">sgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
           Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>   ANORM   (input) float
           If NORM = '1' or 'O', the 1-norm of the original matrix <a class="el" href="classA.html">A</a>.   
           If NORM = 'I', the infinity-norm of the original matrix <a class="el" href="classA.html">A</a>.</pre><pre>   RCOND   (output) float*
          The reciprocal of the condition number of the matrix <a class="el" href="classA.html">A</a>,   
          computed as RCOND = 1/(norm(A) * norm(inv(A))).</pre><pre>   INFO    (output) int*
          = 0:  successful exit   
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value   
</p><hr/>

</pre> 
</div>
</div>
<a class="anchor" id="a3dbdb406f2fb8b186f0f8d3a4cd2d60d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsequ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver related. </p>
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SGSEQU computes row and column scalings intended to equilibrate an   
  M-by-N sparse matrix <a class="el" href="classA.html">A</a> and reduce its condition number. R returns the row
  scale factors and C the column scale factors, chosen to try to make   
  the largest element in each row and column of the matrix B with   
  elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.</pre><pre>  R(i) and C(j) are restricted to be between SMLNUM = smallest safe   
  number and BIGNUM = largest safe number.  Use of these scaling   
  factors is not guaranteed to reduce the condition number of <a class="el" href="classA.html">A</a> but   
  works well in practice.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>  <a class="el" href="classA.html">A</a>       (input) SuperMatrix*
          The matrix of dimension (A-&gt;nrow, A-&gt;ncol) whose equilibration
          factors are to be computed. The type of <a class="el" href="classA.html">A</a> can be:
          Stype = SLU_NC; Dtype = SLU_S; Mtype = SLU_GE.</pre><pre>  R       (output) float*, size A-&gt;nrow
          If INFO = 0 or INFO &gt; M, R contains the row scale factors   
          for <a class="el" href="classA.html">A</a>.</pre><pre>  C       (output) float*, size A-&gt;ncol
          If INFO = 0,  C contains the column scale factors for <a class="el" href="classA.html">A</a>.</pre><pre>  ROWCND  (output) float*
          If INFO = 0 or INFO &gt; M, ROWCND contains the ratio of the   
          smallest R(i) to the largest R(i).  If ROWCND &gt;= 0.1 and   
          AMAX is neither too large nor too small, it is not worth   
          scaling by R.</pre><pre>  COLCND  (output) float*
          If INFO = 0, COLCND contains the ratio of the smallest   
          C(i) to the largest C(i).  If COLCND &gt;= 0.1, it is not   
          worth scaling by C.</pre><pre>  AMAX    (output) float*
          Absolute value of largest matrix element.  If AMAX is very   
          close to overflow or very close to underflow, the matrix   
          should be scaled.</pre><pre>  INFO    (output) int*
          = 0:  successful exit   
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value   
          &gt; 0:  if INFO = i,  and i is   
                &lt;= A-&gt;nrow:  the i-th row of <a class="el" href="classA.html">A</a> is exactly zero   
                &gt;  A-&gt;ncol:  the (i-M)-th column of <a class="el" href="classA.html">A</a> is exactly zero   
</p><hr/>

</pre> 
</div>
</div>
<a class="anchor" id="aff6cdbb84f0fbd4cbce7a64ea1f7eb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsisv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab57375a81b174861bcb68ed11861a4f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsisx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>recip_pivot_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSISX computes an approximate solutions of linear equations
A*X=B or <a class="el" href="classA.html">A</a>'*X=B, using the ILU factorization from <a class="el" href="sgsitrf_8c.html#a25788392a605519048cafa995b641fcc">sgsitrf()</a>.
An estimation of the condition number is provided. 
The routine performs the following steps:</pre><pre>  1. If <a class="el" href="classA.html">A</a> is stored column-wise (A-&gt;Stype = SLU_NC):</pre><pre> 1.1. If options-&gt;Equil = YES or options-&gt;RowPerm = LargeDiag, scaling
      factors are computed to equilibrate the system:
      options-&gt;Trans = NOTRANS:
     diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
      options-&gt;Trans = TRANS:
     (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
      options-&gt;Trans = CONJ:
     (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
      Whether or not the system will be equilibrated depends on the
      scaling of the matrix <a class="el" href="classA.html">A</a>, but if equilibration is used, <a class="el" href="classA.html">A</a> is
      overwritten by diag(R)*A*diag(C) and B by diag(R)*B
      (if options-&gt;Trans=NOTRANS) or diag(C)*B (if options-&gt;Trans
      = TRANS or CONJ).</pre><pre> 1.2. Permute columns of <a class="el" href="classA.html">A</a>, forming A*Pc, where Pc is a permutation
      matrix that usually preserves sparsity.
      For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre> 1.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
      factor the matrix <a class="el" href="classA.html">A</a> (after equilibration if options-&gt;Equil = YES)
      as Pr*A*Pc = L*U, with Pr determined by partial pivoting.</pre><pre> 1.4. Compute the reciprocal pivot growth factor.</pre><pre> 1.5. If some U(i,i) = 0, so that U is exactly singular, then the
      routine fills a small number on the diagonal entry, that is
    U(i,i) = ||A(:,i)||_oo * options-&gt;ILU_FillTol ** (1 - i / n),
      and info will be increased by 1. The factored form of <a class="el" href="classA.html">A</a> is used
      to estimate the condition number of the preconditioner. If the
      reciprocal of the condition number is less than machine precision,
      info = A-&gt;ncol+1 is returned as a warning, but the routine still
      goes on to solve for X.</pre><pre> 1.6. The system of equations is solved for X using the factored form
      of <a class="el" href="classA.html">A</a>.</pre><pre> 1.7. options-&gt;IterRefine is not used</pre><pre> 1.8. If equilibration was used, the matrix X is premultiplied by
      diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
      (if options-&gt;Trans = TRANS or CONJ) so that it solves the
      original system before equilibration.</pre><pre> 1.9. options for ILU only
      1) If options-&gt;RowPerm = LargeDiag, MC64 is used to scale and
    permute the matrix to an I-matrix, that is Pr*Dr*A*Dc has
    entries of modulus 1 on the diagonal and off-diagonal entries
    of modulus at most 1. If MC64 fails, <a class="el" href="dgsequ_8c.html#aaf22b247cc134fb0ba90285e84ccebb4" title="Driver related. ">dgsequ()</a> is used to
    equilibrate the system.
             ( Default: LargeDiag )
      2) options-&gt;ILU_DropTol = tau is the threshold for dropping.
    For L, it is used directly (for the whole row in a supernode);
    For U, ||A(:,i)||_oo * tau is used as the threshold
         for the    i-th column.
    If a secondary dropping rule is required, tau will
         also be used to compute the second threshold.
             ( Default: 1e-4 )
      3) options-&gt;ILU_FillFactor = gamma, used as the initial guess
    of memory growth.
    If a secondary dropping rule is required, it will also
             be used as an upper bound of the memory.
             ( Default: 10 )
      4) options-&gt;ILU_DropRule specifies the dropping rule.
    Option        Meaning
    ======        ===========
    DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau).
    DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma*nnz(<a class="el" href="classA.html">A</a>)/n.
    DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column,
              p = gamma * nnz(A(:,j)).
    DROP_AREA:    Variation of ILUTP, for j-th column, use
              nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory.
    DROP_DYNAMIC: Modify the threshold tau during factorizaion:
              If nnz(L(:,1:j)) / nnz(A(:,1:j)) &gt; gamma
              tau_L(j) := MIN(tau_0, tau_L(j-1) * 2);
              Otherwise
              tau_L(j) := MAX(tau_0, tau_L(j-1) / 2);
              tau_U(j) uses the similar rule.
              NOTE: the thresholds used by L and U are separate.
    DROP_INTERP:  Compute the second dropping threshold by
              interpolation instead of sorting (default).
              In this case, the actual fill ratio is not
              guaranteed smaller than gamma.
    DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive.
    ( Default: DROP_BASIC | DROP_AREA )
      5) options-&gt;ILU_Norm is the criterion of measuring the magnitude
    of a row in a supernode of L. ( Default is INF_NORM )
    options-&gt;ILU_Norm   RowSize(x[1:n])
    =================   ===============
    ONE_NORM        ||x||_1 / n
    TWO_NORM        ||x||_2 / sqrt(n)
    INF_NORM        max{|x[i]|}
      6) options-&gt;ILU_MILU specifies the type of MILU's variation.
    = SILU: do not perform Modified ILU;
    = SMILU_1 (not recommended):
        U(i,i) := U(i,i) + sum(dropped entries);
    = SMILU_2:
        U(i,i) := U(i,i) + <a class="el" href="ilu__zpivotL_8c.html#a95ed41486ca0ed53262e4b8934d4afac">SGN(U(i,i))</a> * sum(dropped entries);
    = SMILU_3:
        U(i,i) := U(i,i) + <a class="el" href="ilu__zpivotL_8c.html#a95ed41486ca0ed53262e4b8934d4afac">SGN(U(i,i))</a> * sum(|dropped entries|);
    NOTE: Even SMILU_1 does not preserve the column sum because of
    late dropping.
             ( Default: SILU )
      7) options-&gt;ILU_FillTol is used as the perturbation when
    encountering zero pivots. If some U(i,i) = 0, so that U is
    exactly singular, then
       U(i,i) := ||A(:,i)|| * options-&gt;ILU_FillTol ** (1 - i / n).
             ( Default: 1e-2 )</pre><pre>  2. If <a class="el" href="classA.html">A</a> is stored row-wise (A-&gt;Stype = SLU_NR), apply the above algorithm
 to the transpose of <a class="el" href="classA.html">A</a>:</pre><pre> 2.1. If options-&gt;Equil = YES or options-&gt;RowPerm = LargeDiag, scaling
      factors are computed to equilibrate the system:
      options-&gt;Trans = NOTRANS:
     diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
      options-&gt;Trans = TRANS:
     (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
      options-&gt;Trans = CONJ:
     (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
      Whether or not the system will be equilibrated depends on the
      scaling of the matrix <a class="el" href="classA.html">A</a>, but if equilibration is used, <a class="el" href="classA.html">A</a>' is
      overwritten by diag(R)*A'*diag(C) and B by diag(R)*B
      (if trans='N') or diag(C)*B (if trans = 'T' or 'C').</pre><pre> 2.2. Permute columns of transpose(A) (rows of <a class="el" href="classA.html">A</a>),
      forming transpose(A)*Pc, where Pc is a permutation matrix that
      usually preserves sparsity.
      For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre> 2.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
      factor the transpose(A) (after equilibration if
      options-&gt;Fact = YES) as Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc = L*U with the
      permutation Pr determined by partial pivoting.</pre><pre> 2.4. Compute the reciprocal pivot growth factor.</pre><pre> 2.5. If some U(i,i) = 0, so that U is exactly singular, then the
      routine fills a small number on the diagonal entry, that is
     U(i,i) = ||A(:,i)||_oo * options-&gt;ILU_FillTol ** (1 - i / n).
      And info will be increased by 1. The factored form of <a class="el" href="classA.html">A</a> is used
      to estimate the condition number of the preconditioner. If the
      reciprocal of the condition number is less than machine precision,
      info = A-&gt;ncol+1 is returned as a warning, but the routine still
      goes on to solve for X.</pre><pre> 2.6. The system of equations is solved for X using the factored form
      of transpose(A).</pre><pre> 2.7. If options-&gt;IterRefine is not used.</pre><pre> 2.8. If equilibration was used, the matrix X is premultiplied by
      diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
      (if options-&gt;Trans = TRANS or CONJ) so that it solves the
      original system before equilibration.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
    The structure defines the input parameters to control
    how the LU decomposition will be performed and how the
    system will be solved.</pre><pre><a class="el" href="classA.html">A</a>      (input/output) SuperMatrix*
    <a class="el" href="classMatrix.html">Matrix</a> <a class="el" href="classA.html">A</a> in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
    of the linear equations is A-&gt;nrow. Currently, the type of <a class="el" href="classA.html">A</a> can be:
    Stype = SLU_NC or SLU_NR, Dtype = SLU_S, Mtype = SLU_GE.
    In the future, more general <a class="el" href="classA.html">A</a> may be handled.</pre><pre>    On entry, If options-&gt;Fact = FACTORED and equed is not 'N',
    then <a class="el" href="classA.html">A</a> must have been equilibrated by the scaling factors in
    R and/or C.
    On exit, <a class="el" href="classA.html">A</a> is not modified
        if options-&gt;Equil = NO, or
        if options-&gt;Equil = YES but equed = 'N' on exit, or
        if options-&gt;RowPerm = NO.</pre><pre>    Otherwise, if options-&gt;Equil = YES and equed is not 'N',
    <a class="el" href="classA.html">A</a> is scaled as follows:
    If A-&gt;Stype = SLU_NC:
      equed = 'R':  <a class="el" href="classA.html">A</a> := diag(R) * <a class="el" href="classA.html">A</a>
      equed = 'C':  <a class="el" href="classA.html">A</a> := <a class="el" href="classA.html">A</a> * diag(C)
      equed = 'B':  <a class="el" href="classA.html">A</a> := diag(R) * <a class="el" href="classA.html">A</a> * diag(C).
    If A-&gt;Stype = SLU_NR:
      equed = 'R':  transpose(A) := diag(R) * transpose(A)
      equed = 'C':  transpose(A) := transpose(A) * diag(C)
      equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C).</pre><pre>        If options-&gt;RowPerm = LargeDiag, MC64 is used to scale and permute
           the matrix to an I-matrix, that is <a class="el" href="classA.html">A</a> is modified as follows:
           P*Dr*A*Dc has entries of modulus 1 on the diagonal and 
           off-diagonal entries of modulus at most 1. P is a permutation
           obtained from MC64.
           If MC64 fails, <a class="el" href="sgsequ_8c.html#ad8a808e807e38c32c08cfbeadb088f08" title="Driver related. ">sgsequ()</a> is used to equilibrate the system,
           and <a class="el" href="classA.html">A</a> is scaled as above, but no permutation is involved.
           On exit, <a class="el" href="classA.html">A</a> is restored to the orginal row numbering, so
           Dr*A*Dc is returned.</pre><pre>perm_c  (input/output) int*
    If A-&gt;Stype = SLU_NC, Column permutation vector of size A-&gt;ncol,
    which defines the permutation matrix Pc; perm_c[i] = j means
    column i of <a class="el" href="classA.html">A</a> is in position j in A*Pc.
    On exit, perm_c may be overwritten by the product of the input
    perm_c and a permutation that postorders the elimination tree
    of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
    is already in postorder.</pre><pre>    If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow,
    which describes permutation of columns of transpose(A) 
    (rows of <a class="el" href="classA.html">A</a>) as described above.</pre><pre>perm_r  (input/output) int*
    If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
    which defines the permutation matrix Pr, and is determined
    by MC64 first then followed by partial pivoting.
        perm_r[i] = j means row i of <a class="el" href="classA.html">A</a> is in position j in Pr*A.</pre><pre>    If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
    determines permutation of rows of transpose(A)
    (columns of <a class="el" href="classA.html">A</a>) as described above.</pre><pre>    If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
    will try to use the input perm_r, unless a certain threshold
    criterion is violated. In that case, perm_r is overwritten by a
    new permutation determined by partial pivoting or diagonal
    threshold pivoting.
    Otherwise, perm_r is output argument.</pre><pre>etree   (input/output) int*,  dimension (A-&gt;ncol)
    Elimination tree of Pc'*A'*A*Pc.
    If options-&gt;Fact != FACTORED and options-&gt;Fact != DOFACT,
    etree is an input argument, otherwise it is an output argument.
    Note: etree is a vector of parent pointers for a forest whose
    vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><pre>equed   (input/output) char*
    Specifies the form of equilibration that was done.
    = 'N': No equilibration.
    = 'R': Row equilibration, i.e., <a class="el" href="classA.html">A</a> was premultiplied by diag(R).
    = 'C': Column equilibration, i.e., <a class="el" href="classA.html">A</a> was postmultiplied by diag(C).
    = 'B': Both row and column equilibration, i.e., <a class="el" href="classA.html">A</a> was replaced 
      by diag(R)*A*diag(C).
    If options-&gt;Fact = FACTORED, equed is an input argument,
    otherwise it is an output argument.</pre><pre>R      (input/output) float*, dimension (A-&gt;nrow)
    The row scale factors for <a class="el" href="classA.html">A</a> or transpose(A).
    If equed = 'R' or 'B', <a class="el" href="classA.html">A</a> (if A-&gt;Stype = SLU_NC) or transpose(A)
        (if A-&gt;Stype = SLU_NR) is multiplied on the left by diag(R).
    If equed = 'N' or 'C', R is not accessed.
    If options-&gt;Fact = FACTORED, R is an input argument,
        otherwise, R is output.
    If options-&gt;Fact = FACTORED and equed = 'R' or 'B', each element
        of R must be positive.</pre><pre>C      (input/output) float*, dimension (A-&gt;ncol)
    The column scale factors for <a class="el" href="classA.html">A</a> or transpose(A).
    If equed = 'C' or 'B', <a class="el" href="classA.html">A</a> (if A-&gt;Stype = SLU_NC) or transpose(A)
        (if A-&gt;Stype = SLU_NR) is multiplied on the right by diag(C).
    If equed = 'N' or 'R', C is not accessed.
    If options-&gt;Fact = FACTORED, C is an input argument,
        otherwise, C is output.
    If options-&gt;Fact = FACTORED and equed = 'C' or 'B', each element
        of C must be positive.</pre><pre>L      (output) SuperMatrix*
    The factor L from the factorization
        Pr*A*Pc=L*U     (if A-&gt;Stype SLU_= NC) or
        Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc=L*U  (if A-&gt;Stype = SLU_NR).
    Uses compressed row subscripts storage for supernodes, i.e.,
    L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U      (output) SuperMatrix*
    The factor U from the factorization
        Pr*A*Pc=L*U     (if A-&gt;Stype = SLU_NC) or
        Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc=L*U  (if A-&gt;Stype = SLU_NR).
    Uses column-wise storage scheme, i.e., U has types:
    Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>work    (workspace/output) void*, size (lwork) (in bytes)
    User supplied workspace, should be large enough
    to hold data structures for factors L and U.
    On exit, if fact is not 'F', L and U point to this array.</pre><pre>lwork   (input) int
    Specifies the size of work array in bytes.
    = 0:  allocate space internally by system malloc;
    &gt; 0:  use user-supplied work array of length lwork in bytes,
     returns error if space runs out.
    = -1: the routine guesses the amount of space needed without
     performing the factorization, and returns it in
     mem_usage-&gt;total_needed; no other side effects.</pre><pre>    See argument 'mem_usage' for memory usage statistics.</pre><pre>B      (input/output) SuperMatrix*
    B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
    On entry, the right hand side matrix.
    If B-&gt;ncol = 0, only LU decomposition is performed, the triangular
           solve is skipped.
    On exit,
       if equed = 'N', B is not modified; otherwise
       if A-&gt;Stype = SLU_NC:
     if options-&gt;Trans = NOTRANS and equed = 'R' or 'B',
        B is overwritten by diag(R)*B;
     if options-&gt;Trans = TRANS or CONJ and equed = 'C' of 'B',
        B is overwritten by diag(C)*B;
       if A-&gt;Stype = SLU_NR:
     if options-&gt;Trans = NOTRANS and equed = 'C' or 'B',
        B is overwritten by diag(C)*B;
     if options-&gt;Trans = TRANS or CONJ and equed = 'R' of 'B',
        B is overwritten by diag(R)*B.</pre><pre>X      (output) SuperMatrix*
    X has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
    If info = 0 or info = A-&gt;ncol+1, X contains the solution matrix
    to the original system of equations. Note that <a class="el" href="classA.html">A</a> and B are modified
    on exit if equed is not 'N', and the solution to the equilibrated
    system is inv(diag(C))*X if options-&gt;Trans = NOTRANS and
    equed = 'C' or 'B', or inv(diag(R))*X if options-&gt;Trans = 'T' or 'C'
    and equed = 'R' or 'B'.</pre><pre>recip_pivot_growth (output) float*
    The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ).
    The infinity norm is used. If recip_pivot_growth is much less
    than 1, the stability of the LU factorization could be poor.</pre><pre>rcond   (output) float*
    The estimate of the reciprocal condition number of the matrix <a class="el" href="classA.html">A</a>
    after equilibration (if done). If rcond is less than the machine
    precision (in particular, if rcond = 0), the matrix is singular
    to working precision. This condition is indicated by a return
    code of info &gt; 0.</pre><pre>mem_usage (output) mem_usage_t*
    Record the memory usage statistics, consisting of following fields:</p><ul>
<li>for_lu (float)
      The amount of space used in bytes for L data structures.</li>
<li>total_needed (float)
      The amount of space needed in bytes to perform factorization.</li>
<li>expansions (int)
      The number of memory expansions during the LU factorization.</li>
</ul>
</pre><pre>stat   (output) SuperLUStat_t*
   Record the statistics on runtime and floating-point operation count.
   See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
    = 0: successful exit
    &lt; 0: if info = -i, the i-th argument had an illegal value
    &gt; 0: if info = i, and i is
    &lt;= A-&gt;ncol: number of zero pivots. They are replaced by small
          entries due to options-&gt;ILU_FillTol.
    = A-&gt;ncol+1: U is nonsingular, but RCOND is less than machine
          precision, meaning that the matrix is singular to
          working precision. Nevertheless, the solution and
          error bounds are computed because there are a number
          of situations where the computed solution can be more
          accurate than the value of RCOND would suggest.
    &gt; A-&gt;ncol+1: number of bytes allocated when memory allocation
          failure occurred, plus A-&gt;ncol.
</pre> 
</div>
</div>
<a class="anchor" id="a22204c4186c4412ee33cd16285ee6bb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsitrf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSITRF computes an ILU factorization of a general sparse m-by-n
matrix <a class="el" href="classA.html">A</a> using partial pivoting with row interchanges.
The factorization has the form
    Pr * <a class="el" href="classA.html">A</a> = L * U
where Pr is a row permutation matrix, L is lower triangular with unit
diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper
triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><pre>See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
    The structure defines the input parameters to control
    how the ILU decomposition will be performed.</pre><pre><a class="el" href="classA.html">A</a>       (input) SuperMatrix*
     Original matrix <a class="el" href="classA.html">A</a>, permuted by columns, of dimension
     (A-&gt;nrow, A-&gt;ncol). The type of <a class="el" href="classA.html">A</a> can be:
     Stype = SLU_NCP; Dtype = SLU_S; Mtype = SLU_GE.</pre><pre>relax    (input) int
     To control degree of relaxing supernodes. If the number
     of nodes (columns) in a subtree of the elimination tree is less
     than relax, this subtree is considered as one supernode,
     regardless of the row structures of those columns.</pre><pre>panel_size (input) int
     <a class="el" href="classA.html">A</a> panel consists of at most panel_size consecutive columns.</pre><pre>etree    (input) int*, dimension (A-&gt;ncol)
     Elimination tree of <a class="el" href="classA.html">A</a>'*A.
     Note: etree is a vector of parent pointers for a forest whose
     vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
     On input, the columns of <a class="el" href="classA.html">A</a> should be permuted so that the
     etree is in a certain postorder.</pre><pre>work     (input/output) void*, size (lwork) (in bytes)
     User-supplied work space and space for the output data structures.
     Not referenced if lwork = 0;</pre><pre>lwork   (input) int
    Specifies the size of work array in bytes.
    = 0:  allocate space internally by system malloc;
    &gt; 0:  use user-supplied work array of length lwork in bytes,
     returns error if space runs out.
    = -1: the routine guesses the amount of space needed without
     performing the factorization, and returns it in
     *info; no other side effects.</pre><pre>perm_c   (input) int*, dimension (A-&gt;ncol)
     Column permutation vector, which defines the
     permutation matrix Pc; perm_c[i] = j means column i of <a class="el" href="classA.html">A</a> is
     in position j in A*Pc.
     When searching for diagonal, perm_c[*] is applied to the
     row subscripts of <a class="el" href="classA.html">A</a>, so that diagonal threshold pivoting
     can find the diagonal of <a class="el" href="classA.html">A</a>, rather than that of A*Pc.</pre><pre>perm_r   (input/output) int*, dimension (A-&gt;nrow)
     Row permutation vector which defines the permutation matrix Pr,
     perm_r[i] = j means row i of <a class="el" href="classA.html">A</a> is in position j in Pr*A.
     If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
        will try to use the input perm_r, unless a certain threshold
        criterion is violated. In that case, perm_r is overwritten by
        a new permutation determined by partial pivoting or diagonal
        threshold pivoting.
     Otherwise, perm_r is output argument;</pre><pre>L       (output) SuperMatrix*
     The factor L from the factorization Pr*A=L*U; use compressed row
     subscripts storage for supernodes, i.e., L has type:
     Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U       (output) SuperMatrix*
     The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
     storage scheme, i.e., U has types: Stype = SLU_NC,
     Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>stat     (output) SuperLUStat_t*
     Record the statistics on runtime and floating-point operation count.
     See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info     (output) int*
     = 0: successful exit
     &lt; 0: if info = -i, the i-th argument had an illegal value
     &gt; 0: if info = i, and i is
        &lt;= A-&gt;ncol: number of zero pivots. They are replaced by small
      entries according to options-&gt;ILU_FillTol.
        &gt; A-&gt;ncol: number of bytes allocated when memory allocation
      failure occurred, plus A-&gt;ncol. If lwork = -1, it is
      the estimated amount of space needed, plus A-&gt;ncol.
</p><hr/>
</pre><pre><h1>Local Working Arrays:
</h1>
</pre><pre>
  m = number of rows in the matrix
  n = number of columns in the matrix</pre><pre>  marker[0:3*m-1]: marker[i] = j means that node i has been
 reached when working on column j.
 Storage: relative to original row subscripts
 NOTE: There are 4 of them:
       marker/marker1 are used for panel dfs, see (ilu_)<a class="el" href="dpanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols. ">dpanel_dfs.c</a>;
       marker2 is used for inner-factorization, see (ilu)_dcolumn_dfs.c;
       marker_relax(has its own space) is used for relaxed supernodes.</pre><pre>  parent[0:m-1]: parent vector used during dfs
 Storage: relative to new row subscripts</pre><pre>  xplore[0:m-1]: xplore[i] gives the location of the next (dfs)
 unexplored neighbor of i in lsub[*]</pre><pre>  segrep[0:nseg-1]: contains the list of supernodal representatives
 in topological order of the dfs. <a class="el" href="classA.html">A</a> supernode representative is the
 last column of a supernode.
 The maximum size of segrep[] is n.</pre><pre>  repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a
 supernodal representative r, repfnz[r] is the location of the first
 nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
 indicates the supernode r has been explored.
 NOTE: There are W of them, each used for one column of a panel.</pre><pre>  panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below
 the panel diagonal. These are filled in during <a class="el" href="dpanel__dfs_8c.html#a2a809488b87d2c1a9b2a574b726e8517">dpanel_dfs()</a>, and are
 used later in the inner LU factorization within the panel.
 panel_lsub[]/dense[] pair forms the SPA data structure.
 NOTE: There are W of them.</pre><pre>  dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
       NOTE: there are W of them.</pre><pre>  tempv[0:*]: real temporary used for dense numeric kernels;
 The size of this array is defined by <a class="el" href="slu__util_8h.html#a06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a>.
 It is also used by the dropping routine <a class="el" href="ilu__ddrop__row_8c.html#a380317801e05b11930fd1e094db34179">ilu_ddrop_row()</a>.
</pre> 
</div>
</div>
<a class="anchor" id="ae824bcb507f76ad3053d845352fb6b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgsrfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SGSRFS improves the computed solution to a system of linear   
  equations and provides error bounds and backward error estimates for 
  the solution.</pre><pre>  If equilibration was performed, the system becomes:
          (diag(R)*A_original*diag(C)) * X = diag(R)*B_original.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>trans   (input) trans_t
         Specifies the form of the system of equations:
         = NOTRANS: <a class="el" href="classA.html">A</a> * X = B  (No transpose)
         = TRANS:   <a class="el" href="classA.html">A</a>'* X = B  (Transpose)
         = CONJ:    A**H * X = B  (Conjugate transpose)</pre><pre>  <a class="el" href="classA.html">A</a>       (input) SuperMatrix*
          The original matrix <a class="el" href="classA.html">A</a> in the system, or the scaled <a class="el" href="classA.html">A</a> if
          equilibration was done. The type of <a class="el" href="classA.html">A</a> can be:
          Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_GE.</pre><pre>  L       (input) SuperMatrix*
      The factor L from the factorization Pr*A*Pc=L*U. Use
          compressed row subscripts storage for supernodes, 
          i.e., L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>  U       (input) SuperMatrix*
          The factor U from the factorization Pr*A*Pc=L*U as computed by
          <a class="el" href="sgstrf_8c.html#a2428d5d7ef46cf9a08069d9f55901284">sgstrf()</a>. Use column-wise storage scheme, 
          i.e., U has types: Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>  perm_c  (input) int*, dimension (A-&gt;ncol)
      Column permutation vector, which defines the 
          permutation matrix Pc; perm_c[i] = j means column i of <a class="el" href="classA.html">A</a> is 
          in position j in A*Pc.</pre><pre>  perm_r  (input) int*, dimension (A-&gt;nrow)
          Row permutation vector, which defines the permutation matrix Pr;
          perm_r[i] = j means row i of <a class="el" href="classA.html">A</a> is in position j in Pr*A.</pre><pre>  equed   (input) Specifies the form of equilibration that was done.
          = 'N': No equilibration.
          = 'R': Row equilibration, i.e., <a class="el" href="classA.html">A</a> was premultiplied by diag(R).
          = 'C': Column equilibration, i.e., <a class="el" href="classA.html">A</a> was postmultiplied by
                 diag(C).
          = 'B': Both row and column equilibration, i.e., <a class="el" href="classA.html">A</a> was replaced 
                 by diag(R)*A*diag(C).</pre><pre>  R       (input) float*, dimension (A-&gt;nrow)
          The row scale factors for <a class="el" href="classA.html">A</a>.
          If equed = 'R' or 'B', <a class="el" href="classA.html">A</a> is premultiplied by diag(R).
          If equed = 'N' or 'C', R is not accessed.</pre><pre>  C       (input) float*, dimension (A-&gt;ncol)
          The column scale factors for <a class="el" href="classA.html">A</a>.
          If equed = 'C' or 'B', <a class="el" href="classA.html">A</a> is postmultiplied by diag(C).
          If equed = 'N' or 'R', C is not accessed.</pre><pre>  B       (input) SuperMatrix*
          B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
          The right hand side matrix B.
          if equed = 'R' or 'B', B is premultiplied by diag(R).</pre><pre>  X       (input/output) SuperMatrix*
          X has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
          On entry, the solution matrix X, as computed by <a class="el" href="sgstrs_8c.html#a9b6e1e555af9cf109ef3a584054a91e2">sgstrs()</a>.
          On exit, the improved solution matrix X.
          if *equed = 'C' or 'B', X should be premultiplied by diag(C)
              in order to obtain the solution to the original system.</pre><pre>  FERR    (output) float*, dimension (B-&gt;ncol)   
          The estimated forward error bound for each solution vector   
          X(j) (the j-th column of the solution matrix X).   
          If XTRUE is the true solution corresponding to X(j), FERR(j) 
          is an estimated upper bound for the magnitude of the largest 
          element in (X(j) - XTRUE) divided by the magnitude of the   
          largest element in X(j).  The estimate is as reliable as   
          the estimate for RCOND, and is almost always a slight   
          overestimate of the true error.</pre><pre>  BERR    (output) float*, dimension (B-&gt;ncol)   
          The componentwise relative backward error of each solution   
          vector X(j) (i.e., the smallest relative change in   
          any element of <a class="el" href="classA.html">A</a> or B that makes X(j) an exact solution).</pre><pre>  stat     (output) SuperLUStat_t*
           Record the statistics on runtime and floating-point operation count.
           See util.h for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>  info    (output) int*   
          = 0:  successful exit   
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre><pre><h1>Internal Parameters   
</h1>
</pre><pre></pre><pre>   ITMAX is the maximum number of steps of iterative refinement.</pre><pre></pre> 
</div>
</div>
<a class="anchor" id="a44bbae3b1218d951ed229c461a5f14b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgssv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver routines. </p>
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSSV solves the system of linear equations A*X=B, using the
LU factorization from SGSTRF. It performs the following steps:</pre><pre>  1. If <a class="el" href="classA.html">A</a> is stored column-wise (A-&gt;Stype = SLU_NC):</pre><pre>     1.1. Permute the columns of <a class="el" href="classA.html">A</a>, forming A*Pc, where Pc
          is a permutation matrix. For more details of this step, 
          see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     1.2. Factor <a class="el" href="classA.html">A</a> as Pr*A*Pc=L*U with the permutation Pr determined
          by Gaussian elimination with partial pivoting.
          L is unit lower triangular with offdiagonal entries
          bounded by 1 in magnitude, and U is upper triangular.</pre><pre>     1.3. Solve the system of equations A*X=B using the factored
          form of <a class="el" href="classA.html">A</a>.</pre><pre>  2. If <a class="el" href="classA.html">A</a> is stored row-wise (A-&gt;Stype = SLU_NR), apply the
     above algorithm to the transpose of <a class="el" href="classA.html">A</a>:</pre><pre>     2.1. Permute columns of transpose(A) (rows of <a class="el" href="classA.html">A</a>),
          forming transpose(A)*Pc, where Pc is a permutation matrix. 
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     2.2. Factor <a class="el" href="classA.html">A</a> as Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc=L*U with the permutation Pr
          determined by Gaussian elimination with partial pivoting.
          L is unit lower triangular with offdiagonal entries
          bounded by 1 in magnitude, and U is upper triangular.</pre><pre>     2.3. Solve the system of equations A*X=B using the factored
          form of <a class="el" href="classA.html">A</a>.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the LU decomposition will be performed and how the
        system will be solved.</pre><pre><a class="el" href="classA.html">A</a>       (input) SuperMatrix*
        <a class="el" href="classMatrix.html">Matrix</a> <a class="el" href="classA.html">A</a> in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
        of linear equations is A-&gt;nrow. Currently, the type of <a class="el" href="classA.html">A</a> can be:
        Stype = SLU_NC or SLU_NR; Dtype = SLU_S; Mtype = SLU_GE.
        In the future, more general <a class="el" href="classA.html">A</a> may be handled.</pre><pre>perm_c  (input/output) int*
        If A-&gt;Stype = SLU_NC, column permutation vector of size A-&gt;ncol
        which defines the permutation matrix Pc; perm_c[i] = j means 
        column i of <a class="el" href="classA.html">A</a> is in position j in A*Pc.
        If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow
        which describes permutation of columns of transpose(A) 
        (rows of <a class="el" href="classA.html">A</a>) as described above.</pre><pre>        If options-&gt;ColPerm = MY_PERMC or options-&gt;Fact = SamePattern or
           options-&gt;Fact = SamePattern_SameRowPerm, it is an input argument.
           On exit, perm_c may be overwritten by the product of the input
           perm_c and a permutation that postorders the elimination tree
           of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
           is already in postorder.
        Otherwise, it is an output argument.</pre><pre>perm_r  (input/output) int*
        If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
        which defines the permutation matrix Pr, and is determined 
        by partial pivoting.  perm_r[i] = j means row i of <a class="el" href="classA.html">A</a> is in 
        position j in Pr*A.
        If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
        determines permutation of rows of transpose(A)
        (columns of <a class="el" href="classA.html">A</a>) as described above.</pre><pre>        If options-&gt;RowPerm = MY_PERMR or
           options-&gt;Fact = SamePattern_SameRowPerm, perm_r is an
           input argument.
        otherwise it is an output argument.</pre><pre>L       (output) SuperMatrix*
        The factor L from the factorization 
            Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
            Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses compressed row subscripts storage for supernodes, i.e.,
        L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U       (output) SuperMatrix*
    The factor U from the factorization 
            Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
            Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses column-wise storage scheme, i.e., U has types:
        Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>B       (input/output) SuperMatrix*
        B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        On entry, the right hand side matrix.
        On exit, the solution matrix if info = 0;</pre><pre>stat   (output) SuperLUStat_t*
       Record the statistics on runtime and floating-point operation count.
       See util.h for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
    = 0: successful exit
        &gt; 0: if info = i, and i is
            &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
               been completed, but the factor U is exactly singular,
               so the solution could not be computed.
            &gt; A-&gt;ncol: number of bytes allocated when memory allocation
               failure occurred, plus A-&gt;ncol.
</pre> 
</div>
</div>
<a class="anchor" id="a4d6a37b565522c7c77a173826588deee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgssvx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>recip_pivot_growth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ferr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSSVX solves the system of linear equations A*X=B or <a class="el" href="classA.html">A</a>'*X=B, using
the LU factorization from <a class="el" href="sgstrf_8c.html#a2428d5d7ef46cf9a08069d9f55901284">sgstrf()</a>. Error bounds on the solution and
a condition estimate are also provided. It performs the following steps:</pre><pre>  1. If <a class="el" href="classA.html">A</a> is stored column-wise (A-&gt;Stype = SLU_NC):</pre><pre>     1.1. If options-&gt;Equil = YES, scaling factors are computed to
          equilibrate the system:
          options-&gt;Trans = NOTRANS:
              diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
          options-&gt;Trans = TRANS:
              (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
          options-&gt;Trans = CONJ:
              (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
          Whether or not the system will be equilibrated depends on the
          scaling of the matrix <a class="el" href="classA.html">A</a>, but if equilibration is used, <a class="el" href="classA.html">A</a> is
          overwritten by diag(R)*A*diag(C) and B by diag(R)*B
          (if options-&gt;Trans=NOTRANS) or diag(C)*B (if options-&gt;Trans
          = TRANS or CONJ).</pre><pre>     1.2. Permute columns of <a class="el" href="classA.html">A</a>, forming A*Pc, where Pc is a permutation
          matrix that usually preserves sparsity.
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     1.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
          factor the matrix <a class="el" href="classA.html">A</a> (after equilibration if options-&gt;Equil = YES)
          as Pr*A*Pc = L*U, with Pr determined by partial pivoting.</pre><pre>     1.4. Compute the reciprocal pivot growth factor.</pre><pre>     1.5. If some U(i,i) = 0, so that U is exactly singular, then the
          routine returns with info = i. Otherwise, the factored form of 
          <a class="el" href="classA.html">A</a> is used to estimate the condition number of the matrix <a class="el" href="classA.html">A</a>. If
          the reciprocal of the condition number is less than machine
          precision, info = A-&gt;ncol+1 is returned as a warning, but the
          routine still goes on to solve for X and computes error bounds
          as described below.</pre><pre>     1.6. The system of equations is solved for X using the factored form
          of <a class="el" href="classA.html">A</a>.</pre><pre>     1.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
          applied to improve the computed solution matrix and calculate
          error bounds and backward error estimates for it.</pre><pre>     1.8. If equilibration was used, the matrix X is premultiplied by
          diag(C) (if options-&gt;Trans = NOTRANS) or diag(R)
          (if options-&gt;Trans = TRANS or CONJ) so that it solves the
          original system before equilibration.</pre><pre>  2. If <a class="el" href="classA.html">A</a> is stored row-wise (A-&gt;Stype = SLU_NR), apply the above algorithm
     to the transpose of <a class="el" href="classA.html">A</a>:</pre><pre>     2.1. If options-&gt;Equil = YES, scaling factors are computed to
          equilibrate the system:
          options-&gt;Trans = NOTRANS:
              diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B
          options-&gt;Trans = TRANS:
              (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
          options-&gt;Trans = CONJ:
              (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
          Whether or not the system will be equilibrated depends on the
          scaling of the matrix <a class="el" href="classA.html">A</a>, but if equilibration is used, <a class="el" href="classA.html">A</a>' is
          overwritten by diag(R)*A'*diag(C) and B by diag(R)*B 
          (if trans='N') or diag(C)*B (if trans = 'T' or 'C').</pre><pre>     2.2. Permute columns of transpose(A) (rows of <a class="el" href="classA.html">A</a>), 
          forming transpose(A)*Pc, where Pc is a permutation matrix that 
          usually preserves sparsity.
          For more details of this step, see <a class="el" href="sp__preorder_8c.html" title="Permute and performs functions on columns of orginal matrix. ">sp_preorder.c</a>.</pre><pre>     2.3. If options-&gt;Fact != FACTORED, the LU decomposition is used to
          factor the transpose(A) (after equilibration if 
          options-&gt;Fact = YES) as Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc = L*U with the
          permutation Pr determined by partial pivoting.</pre><pre>     2.4. Compute the reciprocal pivot growth factor.</pre><pre>     2.5. If some U(i,i) = 0, so that U is exactly singular, then the
          routine returns with info = i. Otherwise, the factored form 
          of transpose(A) is used to estimate the condition number of the
          matrix <a class="el" href="classA.html">A</a>. If the reciprocal of the condition number
          is less than machine precision, info = A-&gt;nrow+1 is returned as
          a warning, but the routine still goes on to solve for X and
          computes error bounds as described below.</pre><pre>     2.6. The system of equations is solved for X using the factored form
          of transpose(A).</pre><pre>     2.7. If options-&gt;IterRefine != NOREFINE, iterative refinement is
          applied to improve the computed solution matrix and calculate
          error bounds and backward error estimates for it.</pre><pre>     2.8. If equilibration was used, the matrix X is premultiplied by
          diag(C) (if options-&gt;Trans = NOTRANS) or diag(R) 
          (if options-&gt;Trans = TRANS or CONJ) so that it solves the
          original system before equilibration.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the LU decomposition will be performed and how the
        system will be solved.</pre><pre><a class="el" href="classA.html">A</a>       (input/output) SuperMatrix*
        <a class="el" href="classMatrix.html">Matrix</a> <a class="el" href="classA.html">A</a> in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol). The number
        of the linear equations is A-&gt;nrow. Currently, the type of <a class="el" href="classA.html">A</a> can be:
        Stype = SLU_NC or SLU_NR, Dtype = SLU_D, Mtype = SLU_GE.
        In the future, more general <a class="el" href="classA.html">A</a> may be handled.</pre><pre>        On entry, If options-&gt;Fact = FACTORED and equed is not 'N', 
        then <a class="el" href="classA.html">A</a> must have been equilibrated by the scaling factors in
        R and/or C.  
        On exit, <a class="el" href="classA.html">A</a> is not modified if options-&gt;Equil = NO, or if 
        options-&gt;Equil = YES but equed = 'N' on exit.
        Otherwise, if options-&gt;Equil = YES and equed is not 'N',
        <a class="el" href="classA.html">A</a> is scaled as follows:
        If A-&gt;Stype = SLU_NC:
          equed = 'R':  <a class="el" href="classA.html">A</a> := diag(R) * <a class="el" href="classA.html">A</a>
          equed = 'C':  <a class="el" href="classA.html">A</a> := <a class="el" href="classA.html">A</a> * diag(C)
          equed = 'B':  <a class="el" href="classA.html">A</a> := diag(R) * <a class="el" href="classA.html">A</a> * diag(C).
        If A-&gt;Stype = SLU_NR:
          equed = 'R':  transpose(A) := diag(R) * transpose(A)
          equed = 'C':  transpose(A) := transpose(A) * diag(C)
          equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C).</pre><pre>perm_c  (input/output) int*
    If A-&gt;Stype = SLU_NC, Column permutation vector of size A-&gt;ncol,
        which defines the permutation matrix Pc; perm_c[i] = j means
        column i of <a class="el" href="classA.html">A</a> is in position j in A*Pc.
        On exit, perm_c may be overwritten by the product of the input
        perm_c and a permutation that postorders the elimination tree
        of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree
        is already in postorder.</pre><pre>        If A-&gt;Stype = SLU_NR, column permutation vector of size A-&gt;nrow,
        which describes permutation of columns of transpose(A) 
        (rows of <a class="el" href="classA.html">A</a>) as described above.</pre><pre>perm_r  (input/output) int*
        If A-&gt;Stype = SLU_NC, row permutation vector of size A-&gt;nrow, 
        which defines the permutation matrix Pr, and is determined
        by partial pivoting.  perm_r[i] = j means row i of <a class="el" href="classA.html">A</a> is in 
        position j in Pr*A.</pre><pre>        If A-&gt;Stype = SLU_NR, permutation vector of size A-&gt;ncol, which
        determines permutation of rows of transpose(A)
        (columns of <a class="el" href="classA.html">A</a>) as described above.</pre><pre>        If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
        will try to use the input perm_r, unless a certain threshold
        criterion is violated. In that case, perm_r is overwritten by a
        new permutation determined by partial pivoting or diagonal
        threshold pivoting.
        Otherwise, perm_r is output argument.</pre><pre>etree   (input/output) int*,  dimension (A-&gt;ncol)
        Elimination tree of Pc'*A'*A*Pc.
        If options-&gt;Fact != FACTORED and options-&gt;Fact != DOFACT,
        etree is an input argument, otherwise it is an output argument.
        Note: etree is a vector of parent pointers for a forest whose
        vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.</pre><pre>equed   (input/output) char*
        Specifies the form of equilibration that was done.
        = 'N': No equilibration.
        = 'R': Row equilibration, i.e., <a class="el" href="classA.html">A</a> was premultiplied by diag(R).
        = 'C': Column equilibration, i.e., <a class="el" href="classA.html">A</a> was postmultiplied by diag(C).
        = 'B': Both row and column equilibration, i.e., <a class="el" href="classA.html">A</a> was replaced 
               by diag(R)*A*diag(C).
        If options-&gt;Fact = FACTORED, equed is an input argument,
        otherwise it is an output argument.</pre><pre>R       (input/output) float*, dimension (A-&gt;nrow)
        The row scale factors for <a class="el" href="classA.html">A</a> or transpose(A).
        If equed = 'R' or 'B', <a class="el" href="classA.html">A</a> (if A-&gt;Stype = SLU_NC) or transpose(A)
            (if A-&gt;Stype = SLU_NR) is multiplied on the left by diag(R).
        If equed = 'N' or 'C', R is not accessed.
        If options-&gt;Fact = FACTORED, R is an input argument,
            otherwise, R is output.
        If options-&gt;zFact = FACTORED and equed = 'R' or 'B', each element
            of R must be positive.</pre><pre>C       (input/output) float*, dimension (A-&gt;ncol)
        The column scale factors for <a class="el" href="classA.html">A</a> or transpose(A).
        If equed = 'C' or 'B', <a class="el" href="classA.html">A</a> (if A-&gt;Stype = SLU_NC) or transpose(A)
            (if A-&gt;Stype = SLU_NR) is multiplied on the right by diag(C).
        If equed = 'N' or 'R', C is not accessed.
        If options-&gt;Fact = FACTORED, C is an input argument,
            otherwise, C is output.
        If options-&gt;Fact = FACTORED and equed = 'C' or 'B', each element
            of C must be positive.</pre><pre>L       (output) SuperMatrix*
    The factor L from the factorization
            Pr*A*Pc=L*U              (if A-&gt;Stype SLU_= NC) or
            Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses compressed row subscripts storage for supernodes, i.e.,
        L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U       (output) SuperMatrix*
    The factor U from the factorization
            Pr*A*Pc=L*U              (if A-&gt;Stype = SLU_NC) or
            Pr*transpose(<a class="el" href="classA.html">A</a>)*Pc=L*U   (if A-&gt;Stype = SLU_NR).
        Uses column-wise storage scheme, i.e., U has types:
        Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>work    (workspace/output) void*, size (lwork) (in bytes)
        User supplied workspace, should be large enough
        to hold data structures for factors L and U.
        On exit, if fact is not 'F', L and U point to this array.</pre><pre>lwork   (input) int
        Specifies the size of work array in bytes.
        = 0:  allocate space internally by system malloc;
        &gt; 0:  use user-supplied work array of length lwork in bytes,
              returns error if space runs out.
        = -1: the routine guesses the amount of space needed without
              performing the factorization, and returns it in
              mem_usage-&gt;total_needed; no other side effects.</pre><pre>        See argument 'mem_usage' for memory usage statistics.</pre><pre>B       (input/output) SuperMatrix*
        B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        On entry, the right hand side matrix.
        If B-&gt;ncol = 0, only LU decomposition is performed, the triangular
                        solve is skipped.
        On exit,
           if equed = 'N', B is not modified; otherwise
           if A-&gt;Stype = SLU_NC:
              if options-&gt;Trans = NOTRANS and equed = 'R' or 'B',
                 B is overwritten by diag(R)*B;
              if options-&gt;Trans = TRANS or CONJ and equed = 'C' of 'B',
                 B is overwritten by diag(C)*B;
           if A-&gt;Stype = SLU_NR:
              if options-&gt;Trans = NOTRANS and equed = 'C' or 'B',
                 B is overwritten by diag(C)*B;
              if options-&gt;Trans = TRANS or CONJ and equed = 'R' of 'B',
                 B is overwritten by diag(R)*B.</pre><pre>X       (output) SuperMatrix*
        X has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE. 
        If info = 0 or info = A-&gt;ncol+1, X contains the solution matrix
        to the original system of equations. Note that <a class="el" href="classA.html">A</a> and B are modified
        on exit if equed is not 'N', and the solution to the equilibrated
        system is inv(diag(C))*X if options-&gt;Trans = NOTRANS and
        equed = 'C' or 'B', or inv(diag(R))*X if options-&gt;Trans = 'T' or 'C'
        and equed = 'R' or 'B'.</pre><pre>recip_pivot_growth (output) float*
        The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ).
        The infinity norm is used. If recip_pivot_growth is much less
        than 1, the stability of the LU factorization could be poor.</pre><pre>rcond   (output) float*
        The estimate of the reciprocal condition number of the matrix <a class="el" href="classA.html">A</a>
        after equilibration (if done). If rcond is less than the machine
        precision (in particular, if rcond = 0), the matrix is singular
        to working precision. This condition is indicated by a return
        code of info &gt; 0.</pre><pre>FERR    (output) float*, dimension (B-&gt;ncol)   
        The estimated forward error bound for each solution vector   
        X(j) (the j-th column of the solution matrix X).   
        If XTRUE is the true solution corresponding to X(j), FERR(j) 
        is an estimated upper bound for the magnitude of the largest 
        element in (X(j) - XTRUE) divided by the magnitude of the   
        largest element in X(j).  The estimate is as reliable as   
        the estimate for RCOND, and is almost always a slight   
        overestimate of the true error.
        If options-&gt;IterRefine = NOREFINE, ferr = 1.0.</pre><pre>BERR    (output) float*, dimension (B-&gt;ncol)
        The componentwise relative backward error of each solution   
        vector X(j) (i.e., the smallest relative change in   
        any element of <a class="el" href="classA.html">A</a> or B that makes X(j) an exact solution).
        If options-&gt;IterRefine = NOREFINE, berr = 1.0.</pre><pre>mem_usage (output) mem_usage_t*
        Record the memory usage statistics, consisting of following fields:</p><ul>
<li>for_lu (float)
          The amount of space used in bytes for L data structures.</li>
<li>total_needed (float)
          The amount of space needed in bytes to perform factorization.</li>
<li>expansions (int)
          The number of memory expansions during the LU factorization.</li>
</ul>
</pre><pre>stat   (output) SuperLUStat_t*
       Record the statistics on runtime and floating-point operation count.
       See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
        = 0: successful exit   
        &lt; 0: if info = -i, the i-th argument had an illegal value   
        &gt; 0: if info = i, and i is   
             &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has   
                   been completed, but the factor U is exactly   
                   singular, so the solution and error bounds   
                   could not be computed.   
             = A-&gt;ncol+1: U is nonsingular, but RCOND is less than machine
                   precision, meaning that the matrix is singular to
                   working precision. Nevertheless, the solution and
                   error bounds are computed because there are a number
                   of situations where the computed solution can be more
                   accurate than the value of RCOND would suggest.   
             &gt; A-&gt;ncol+1: number of bytes allocated when memory allocation
                   failure occurred, plus A-&gt;ncol.
</pre> 
</div>
</div>
<a class="anchor" id="af006a81b576fffa92a1c848ac3191c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgstrf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__options__t.html">superlu_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>etree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSTRF computes an LU factorization of a general sparse m-by-n
matrix <a class="el" href="classA.html">A</a> using partial pivoting with row interchanges.
The factorization has the form
    Pr * <a class="el" href="classA.html">A</a> = L * U
where Pr is a row permutation matrix, L is lower triangular with unit
diagonal elements (lower trapezoidal if A-&gt;nrow &gt; A-&gt;ncol), and U is upper 
triangular (upper trapezoidal if A-&gt;nrow &lt; A-&gt;ncol).</pre><pre>See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>options (input) superlu_options_t*
        The structure defines the input parameters to control
        how the LU decomposition will be performed.</pre><pre><a class="el" href="classA.html">A</a>        (input) SuperMatrix*
     Original matrix <a class="el" href="classA.html">A</a>, permuted by columns, of dimension
         (A-&gt;nrow, A-&gt;ncol). The type of <a class="el" href="classA.html">A</a> can be:
         Stype = SLU_NCP; Dtype = SLU_S; Mtype = SLU_GE.</pre><pre>relax    (input) int
         To control degree of relaxing supernodes. If the number
         of nodes (columns) in a subtree of the elimination tree is less
         than relax, this subtree is considered as one supernode,
         regardless of the row structures of those columns.</pre><pre>panel_size (input) int
         <a class="el" href="classA.html">A</a> panel consists of at most panel_size consecutive columns.</pre><pre>etree    (input) int*, dimension (A-&gt;ncol)
         Elimination tree of <a class="el" href="classA.html">A</a>'*A.
         Note: etree is a vector of parent pointers for a forest whose
         vertices are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.
         On input, the columns of <a class="el" href="classA.html">A</a> should be permuted so that the
         etree is in a certain postorder.</pre><pre>work     (input/output) void*, size (lwork) (in bytes)
         User-supplied work space and space for the output data structures.
         Not referenced if lwork = 0;</pre><pre>lwork   (input) int
        Specifies the size of work array in bytes.
        = 0:  allocate space internally by system malloc;
        &gt; 0:  use user-supplied work array of length lwork in bytes,
              returns error if space runs out.
        = -1: the routine guesses the amount of space needed without
              performing the factorization, and returns it in
              *info; no other side effects.</pre><pre>perm_c   (input) int*, dimension (A-&gt;ncol)
     Column permutation vector, which defines the 
         permutation matrix Pc; perm_c[i] = j means column i of <a class="el" href="classA.html">A</a> is 
         in position j in A*Pc.
         When searching for diagonal, perm_c[*] is applied to the
         row subscripts of <a class="el" href="classA.html">A</a>, so that diagonal threshold pivoting
         can find the diagonal of <a class="el" href="classA.html">A</a>, rather than that of A*Pc.</pre><pre>perm_r   (input/output) int*, dimension (A-&gt;nrow)
         Row permutation vector which defines the permutation matrix Pr,
         perm_r[i] = j means row i of <a class="el" href="classA.html">A</a> is in position j in Pr*A.
         If options-&gt;Fact = SamePattern_SameRowPerm, the pivoting routine
            will try to use the input perm_r, unless a certain threshold
            criterion is violated. In that case, perm_r is overwritten by
            a new permutation determined by partial pivoting or diagonal
            threshold pivoting.
         Otherwise, perm_r is output argument;</pre><pre>L        (output) SuperMatrix*
         The factor L from the factorization Pr*A=L*U; use compressed row 
         subscripts storage for supernodes, i.e., L has type: 
         Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U        (output) SuperMatrix*
     The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
         storage scheme, i.e., U has types: Stype = SLU_NC, 
         Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>stat     (output) SuperLUStat_t*
         Record the statistics on runtime and floating-point operation count.
         See <a class="el" href="slu__util_8h.html" title="Utility header file. ">slu_util.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info     (output) int*
         = 0: successful exit
         &lt; 0: if info = -i, the i-th argument had an illegal value
         &gt; 0: if info = i, and i is
            &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
               been completed, but the factor U is exactly singular,
               and division by zero will occur if it is used to solve a
               system of equations.
            &gt; A-&gt;ncol: number of bytes allocated when memory allocation
               failure occurred, plus A-&gt;ncol. If lwork = -1, it is
               the estimated amount of space needed, plus A-&gt;ncol.
</p><hr/>
</pre><pre><h1>Local Working Arrays: 
</h1>
</pre><pre>
  m = number of rows in the matrix
  n = number of columns in the matrix</pre><pre>  xprune[0:n-1]: xprune[*] points to locations in subscript 
 vector lsub[*]. For column i, xprune[i] denotes the point where 
 structural pruning begins. I.e. only xlsub[i],..,xprune[i]-1 need 
 to be traversed for symbolic factorization.</pre><pre>  marker[0:3*m-1]: marker[i] = j means that node i has been 
 reached when working on column j.
 Storage: relative to original row subscripts
 NOTE: There are 3 of them: marker/marker1 are used for panel dfs, 
       see <a class="el" href="spanel__dfs_8c.html" title="Peforms a symbolic factorization on a panel of symbols. ">spanel_dfs.c</a>; marker2 is used for inner-factorization,
           see <a class="el" href="scolumn__dfs_8c.html" title="Performs a symbolic factorization. ">scolumn_dfs.c</a>.</pre><pre>  parent[0:m-1]: parent vector used during dfs
     Storage: relative to new row subscripts</pre><pre>  xplore[0:m-1]: xplore[i] gives the location of the next (dfs) 
 unexplored neighbor of i in lsub[*]</pre><pre>  segrep[0:nseg-1]: contains the list of supernodal representatives
 in topological order of the dfs. <a class="el" href="classA.html">A</a> supernode representative is the 
 last column of a supernode.
     The maximum size of segrep[] is n.</pre><pre>  repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a 
 supernodal representative r, repfnz[r] is the location of the first 
 nonzero in this segment.  It is also used during the dfs: repfnz[r]&gt;0
 indicates the supernode r has been explored.
 NOTE: There are W of them, each used for one column of a panel.</pre><pre>  panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below 
     the panel diagonal. These are filled in during <a class="el" href="slu__sdefs_8h.html#a77baf210393e04fa71d4e73b5e60e556">spanel_dfs()</a>, and are
     used later in the inner LU factorization within the panel.
 panel_lsub[]/dense[] pair forms the SPA data structure.
 NOTE: There are W of them.</pre><pre>  dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;
           NOTE: there are W of them.</pre><pre>  tempv[0:*]: real temporary used for dense numeric kernels;
 The size of this array is defined by <a class="el" href="slu__util_8h.html#a06193b28f40a4779ae7737711642eb45">NUM_TEMPV()</a> in <a class="el" href="slu__sdefs_8h.html" title="Header file for real operations. ">slu_sdefs.h</a>.
</pre> 
</div>
</div>
<a class="anchor" id="aea450a9c52512127d6eaaebf0a65f9ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgstrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62">trans_t</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>SGSTRS solves a system of linear equations A*X=B or <a class="el" href="classA.html">A</a>'*X=B
with <a class="el" href="classA.html">A</a> sparse and B dense, using the LU factorization computed by
SGSTRF.</pre><pre>See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>trans   (input) trans_t
         Specifies the form of the system of equations:
         = NOTRANS: <a class="el" href="classA.html">A</a> * X = B  (No transpose)
         = TRANS:   <a class="el" href="classA.html">A</a>'* X = B  (Transpose)
         = CONJ:    A**H * X = B  (Conjugate transpose)</pre><pre>L       (input) SuperMatrix*
        The factor L from the factorization Pr*A*Pc=L*U as computed by
        <a class="el" href="sgstrf_8c.html#a2428d5d7ef46cf9a08069d9f55901284">sgstrf()</a>. Use compressed row subscripts storage for supernodes,
        i.e., L has types: Stype = SLU_SC, Dtype = SLU_S, Mtype = SLU_TRLU.</pre><pre>U       (input) SuperMatrix*
        The factor U from the factorization Pr*A*Pc=L*U as computed by
        <a class="el" href="sgstrf_8c.html#a2428d5d7ef46cf9a08069d9f55901284">sgstrf()</a>. Use column-wise storage scheme, i.e., U has types:
        Stype = SLU_NC, Dtype = SLU_S, Mtype = SLU_TRU.</pre><pre>perm_c  (input) int*, dimension (L-&gt;ncol)
    Column permutation vector, which defines the 
        permutation matrix Pc; perm_c[i] = j means column i of <a class="el" href="classA.html">A</a> is 
        in position j in A*Pc.</pre><pre>perm_r  (input) int*, dimension (L-&gt;nrow)
        Row permutation vector, which defines the permutation matrix Pr; 
        perm_r[i] = j means row i of <a class="el" href="classA.html">A</a> is in position j in Pr*A.</pre><pre>B       (input/output) SuperMatrix*
        B has types: Stype = SLU_DN, Dtype = SLU_S, Mtype = SLU_GE.
        On entry, the right hand side matrix.
        On exit, the solution matrix if info = 0;</pre><pre>stat     (output) SuperLUStat_t*
         Record the statistics on runtime and floating-point operation count.
         See util.h for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.</pre><pre>info    (output) int*
       = 0: successful exit
    &lt; 0: if info = -i, the i-th argument had an illegal value
</pre> 
</div>
</div>
<a class="anchor" id="aba0eeda28d139bf88878880edd3cca5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sinf_norm_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the inf-norm of the error vector. </p>

</div>
</div>
<a class="anchor" id="a47c1dd1b8332f4366d5c5112219fdb3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float slamch_ </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cmach</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>    SLAMCH determines single precision machine parameters.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>    CMACH   (input) CHARACTER*1   
            Specifies the value to be returned by SLAMCH:   
            = 'E' or 'e',   SLAMCH := eps   
            = 'S' or 's ,   SLAMCH := sfmin   
            = 'B' or 'b',   SLAMCH := base   
            = 'P' or 'p',   SLAMCH := eps*base   
            = 'N' or 'n',   SLAMCH := t   
            = 'R' or 'r',   SLAMCH := rnd   
            = 'M' or 'm',   SLAMCH := emin   
            = 'U' or 'u',   SLAMCH := rmin   
            = 'L' or 'l',   SLAMCH := emax   
            = 'O' or 'o',   SLAMCH := rmax</pre><pre>            where</pre><pre>            eps   = relative machine precision   
            sfmin = safe minimum, such that 1/sfmin does not overflow   
            base  = base of the machine   
            prec  = eps*base   
            t     = number of (base) digits in the mantissa   
            rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise   
            emin  = minimum exponent before (gradual) underflow   
            rmin  = underflow threshold - base**(emin-1)   
            emax  = largest exponent before overflow   
            rmax  = overflow threshold  - (base**emax)*(1-eps)   
</p><hr/>

</pre> 
</div>
</div>
<a class="anchor" id="afe4b556cd9d484f53606d114f83649d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slaqgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rowcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>colcnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>equed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  SLAQGS equilibrates a general sparse M by N matrix <a class="el" href="classA.html">A</a> using the row and   
  scaling factors in the vectors R and C.</pre><pre>  See <a class="el" href="supermatrix_8h.html" title="Defines matrix types. ">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure.</pre><pre><h1>Arguments   
</h1>
</pre><pre></pre><pre>  <a class="el" href="classA.html">A</a>       (input/output) SuperMatrix*
          On exit, the equilibrated matrix.  See EQUED for the form of 
          the equilibrated matrix. The type of <a class="el" href="classA.html">A</a> can be:
     Stype = NC; Dtype = SLU_S; Mtype = GE.</pre><pre>  R       (input) float*, dimension (A-&gt;nrow)
          The row scale factors for <a class="el" href="classA.html">A</a>.</pre><pre>  C       (input) float*, dimension (A-&gt;ncol)
          The column scale factors for <a class="el" href="classA.html">A</a>.</pre><pre>  ROWCND  (input) float
          Ratio of the smallest R(i) to the largest R(i).</pre><pre>  COLCND  (input) float
          Ratio of the smallest C(i) to the largest C(i).</pre><pre>  AMAX    (input) float
          Absolute value of largest matrix entry.</pre><pre>  EQUED   (output) char*
          Specifies the form of equilibration that was done.   
          = 'N':  No equilibration   
          = 'R':  Row equilibration, i.e., <a class="el" href="classA.html">A</a> has been premultiplied by  
                  diag(R).   
          = 'C':  Column equilibration, i.e., <a class="el" href="classA.html">A</a> has been postmultiplied  
                  by diag(C).   
          = 'B':  Both row and column equilibration, i.e., <a class="el" href="classA.html">A</a> has been
                  replaced by diag(R) * <a class="el" href="classA.html">A</a> * diag(C).</pre><pre><h1>Internal Parameters   
</h1>
</pre><pre></pre><pre>  THRESH is a threshold value used to decide if row or column scaling   
  should be done based on the ratio of the row or column scaling   
  factors.  If ROWCND &lt; THRESH, row scaling is done, and if   
  COLCND &lt; THRESH, column scaling is done.</pre><pre>  LARGE and SMALL are threshold values used to decide if row scaling   
  should be done based on the absolute size of the largest matrix   
  element.  If AMAX &gt; LARGE or AMAX &lt; SMALL, row scaling is done.   
</p><hr/>

</pre> 
</div>
</div>
<a class="anchor" id="a69557d06b4e300aa6aca944561f3bb32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sldperm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af68715ec86cde90aa31fec07164d6ea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sLUMemInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#ac785c8235480e5cfef9848d89c047c0a">fact_t</a>&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>annz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fill_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory-related. </p>
<p>Memory-related.</p>
<pre>
For those unpredictable size, estimate as fill_ratio * nnz(A).
Return value:
    If lwork = -1, return the estimated amount of space required, plus n;
    otherwise, return the amount of space actually allocated when
    memory allocation failure occurred.
</pre> 
</div>
</div>
<a class="anchor" id="a9af26d0426eb0bb63755880f2e67e7b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sLUMemXpand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__enum__consts_8h.html#abd31f838aefffa46191d0d7dc36a96b2">MemType</a>&#160;</td>
          <td class="paramname"><em>mem_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the data structures for L and U during the factorization. </p>
<pre>
Return value:   0 - successful return
              &gt; 0 - number of bytes allocated when run out of space
</pre> 
</div>
</div>
<a class="anchor" id="a9035f0d2a50cf5d8e29287572bd1be83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sLUWorkFree </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the working storage used by factor routines. </p>

</div>
</div>
<a class="anchor" id="ab50ebebf3a620086366b6c310d52d681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smemory_usage </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35b4a0e44c32443df609069021d27812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_sgemm </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  sp_s performs one of the matrix-matrix operations</pre><pre>     C := alpha*op( <a class="el" href="classA.html">A</a> )*op( B ) + beta*C,</pre><pre>  where  op( X ) is one of</pre><pre>     op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),</pre><pre>  alpha and beta are scalars, and <a class="el" href="classA.html">A</a>, B and C are matrices, with op( A ) 
  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</pre><pre><h1>Parameters   
</h1>
</pre><pre></pre><pre>  TRANSA - (input) char*
           On entry, TRANSA specifies the form of op( A ) to be used in 
           the matrix multiplication as follows:   
              TRANSA = 'N' or 'n',  op( A ) = <a class="el" href="classA.html">A</a>.   
              TRANSA = 'T' or 't',  op( A ) = <a class="el" href="classA.html">A</a>'.   
              TRANSA = 'C' or 'c',  op( A ) = conjg( <a class="el" href="classA.html">A</a>' ).   
           Unchanged on exit.</pre><pre>  TRANSB - (input) char*
           On entry, TRANSB specifies the form of op( B ) to be used in 
           the matrix multiplication as follows:   
              TRANSB = 'N' or 'n',  op( B ) = B.   
              TRANSB = 'T' or 't',  op( B ) = B'.   
              TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).   
           Unchanged on exit.</pre><pre>  M      - (input) int   
           On entry,  M  specifies  the number of rows of the matrix 
      op( A ) and of the matrix C.  M must be at least zero. 
      Unchanged on exit.</pre><pre>  N      - (input) int
           On entry,  N specifies the number of columns of the matrix 
      op( B ) and the number of columns of the matrix C. N must be 
      at least zero.
      Unchanged on exit.</pre><pre>  K      - (input) int
           On entry, K specifies the number of columns of the matrix 
      op( A ) and the number of rows of the matrix op( B ). K must 
      be at least  zero.   
          Unchanged on exit.</pre><pre>  ALPHA  - (input) float
           On entry, ALPHA specifies the scalar alpha.</pre><pre>  <a class="el" href="classA.html">A</a>      - (input) SuperMatrix*
           <a class="el" href="classMatrix.html">Matrix</a> <a class="el" href="classA.html">A</a> with a sparse format, of dimension (A-&gt;nrow, A-&gt;ncol).
           Currently, the type of <a class="el" href="classA.html">A</a> can be:
               Stype = NC or NCP; Dtype = SLU_S; Mtype = GE. 
           In the future, more general <a class="el" href="classA.html">A</a> can be handled.</pre><pre>  B      - FLOAT PRECISION array of DIMENSION ( LDB, kb ), where kb is 
           n when TRANSB = 'N' or 'n',  and is  k otherwise.   
           Before entry with  TRANSB = 'N' or 'n',  the leading k by n 
           part of the array B must contain the matrix B, otherwise 
           the leading n by k part of the array B must contain the 
           matrix B.   
           Unchanged on exit.</pre><pre>  LDB    - (input) int
           On entry, LDB specifies the first dimension of B as declared 
           in the calling (sub) program. LDB must be at least <a class="el" href="slamch_8c.html#affe776513b24d84b39af8ab0930fef7f">max( 1, n )</a>.  
           Unchanged on exit.</pre><pre>  BETA   - (input) float
           On entry, BETA specifies the scalar beta. When BETA is   
           supplied as zero then C need not be set on input.</pre><pre>  C      - FLOAT PRECISION array of DIMENSION ( LDC, n ).   
           Before entry, the leading m by n part of the array C must 
           contain the matrix C,  except when beta is zero, in which 
           case C need not be set on entry.   
           On exit, the array C is overwritten by the m by n matrix 
      ( alpha*op( <a class="el" href="classA.html">A</a> )*B + beta*C ).</pre><pre>  LDC    - (input) int
           On entry, LDC specifies the first dimension of C as declared 
           in the calling (sub)program. LDC must be at least <a class="el" href="slamch_8c.html#affe776513b24d84b39af8ab0930fef7f">max(1,m)</a>.   
           Unchanged on exit.</pre><pre>  ==== Sparse Level 3 Blas routine.   
</pre> 
</div>
</div>
<a class="anchor" id="a9e543b2d14781b56ef349114012b4fc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_sgemv </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A'*x + beta*y,. </p>
<pre>
<h1>Purpose   
</h1>
</pre><pre></pre><pre>  <a class="el" href="ssp__blas2_8c.html#a3a14fab0d3fc42c621199aed6962ab3e" title="Performs one of the matrix-vector operations y := alpha*A*x + beta*y, or y := alpha*A&#39;*x + beta*y...">sp_sgemv()</a>  performs one of the matrix-vector operations   
     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   
  where alpha and beta are scalars, x and y are vectors and <a class="el" href="classA.html">A</a> is a
  sparse A-&gt;nrow by A-&gt;ncol matrix.</pre><pre><h1>Parameters   
</h1>
</pre><pre></pre><pre>  TRANS  - (input) char*
           On entry, TRANS specifies the operation to be performed as   
           follows:   
              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.   
              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.   
              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.</pre><pre>  ALPHA  - (input) float
           On entry, ALPHA specifies the scalar alpha.</pre><pre>  <a class="el" href="classA.html">A</a>      - (input) SuperMatrix*
           <a class="el" href="classMatrix.html">Matrix</a> <a class="el" href="classA.html">A</a> with a sparse format, of dimension (A-&gt;nrow, A-&gt;ncol).
           Currently, the type of <a class="el" href="classA.html">A</a> can be:
               Stype = NC or NCP; Dtype = SLU_S; Mtype = GE. 
           In the future, more general <a class="el" href="classA.html">A</a> can be handled.</pre><pre>  X      - (input) float*, array of DIMENSION at least   
           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'   
           and at least   
           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.   
           Before entry, the incremented array X must contain the   
           vector x.</pre><pre>  INCX   - (input) int
           On entry, INCX specifies the increment for the elements of   
           X. INCX must not be zero.</pre><pre>  BETA   - (input) float
           On entry, BETA specifies the scalar beta. When BETA is   
           supplied as zero then Y need not be set on input.</pre><pre>  Y      - (output) float*,  array of DIMENSION at least   
           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'   
           and at least   
           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.   
           Before entry with BETA non-zero, the incremented array Y   
           must contain the vector y. On exit, Y is overwritten by the 
           updated vector y.</pre><pre>  INCY   - (input) int
           On entry, INCY specifies the increment for the elements of   
           Y. INCY must not be zero.</pre><pre>  ==== Sparse Level 2 Blas routine.   
</pre> 
</div>
</div>
<a class="anchor" id="aa6d287b6b9bcaf72a692343e614c429c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_strsv </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves one of the systems of equations A*x = b, or <a class="el" href="classA.html">A</a>'*x = b. </p>
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>  <a class="el" href="ssp__blas2_8c.html#ab9e8302d09840e67df27ddd4defaa621" title="Solves one of the systems of equations A*x = b, or A&#39;*x = b. ">sp_strsv()</a> solves one of the systems of equations   
      A*x = b,   or   <a class="el" href="classA.html">A</a>'*x = b,
  where b and x are n element vectors and <a class="el" href="classA.html">A</a> is a sparse unit , or   
  non-unit, upper or lower triangular matrix.   
  No test for singularity or near-singularity is included in this   
  routine. Such tests must be performed before calling this routine.</pre><pre><h1>Parameters   
</h1>
</pre><pre></pre><pre>  uplo   - (input) char*
           On entry, uplo specifies whether the matrix is an upper or   
            lower triangular matrix as follows:   
               uplo = 'U' or 'u'   <a class="el" href="classA.html">A</a> is an upper triangular matrix.   
               uplo = 'L' or 'l'   <a class="el" href="classA.html">A</a> is a lower triangular matrix.</pre><pre>  trans  - (input) char*
            On entry, trans specifies the equations to be solved as   
            follows:   
               trans = 'N' or 'n'   A*x = b.   
               trans = 'T' or 't'   <a class="el" href="classA.html">A</a>'*x = b.
               trans = 'C' or 'c'   <a class="el" href="classA.html">A</a>'*x = b.</pre><pre>  diag   - (input) char*
            On entry, diag specifies whether or not <a class="el" href="classA.html">A</a> is unit   
            triangular as follows:   
               diag = 'U' or 'u'   <a class="el" href="classA.html">A</a> is assumed to be unit triangular.   
               diag = 'N' or 'n'   <a class="el" href="classA.html">A</a> is not assumed to be unit   
                                   triangular.</pre><pre>  L       - (input) SuperMatrix*
        The factor L from the factorization Pr*A*Pc=L*U. Use
            compressed row subscripts storage for supernodes,
            i.e., L has types: Stype = SC, Dtype = SLU_S, Mtype = TRLU.</pre><pre>  U       - (input) SuperMatrix*
         The factor U from the factorization Pr*A*Pc=L*U.
         U has types: Stype = NC, Dtype = SLU_S, Mtype = TRU.</pre><pre>  x       - (input/output) float*
            Before entry, the incremented array X must contain the n   
            element right-hand side vector b. On exit, X is overwritten 
            with the solution vector x.</pre><pre>  info    - (output) int*
            If *info = -i, the i-th argument had an illegal value.
</pre> 
</div>
</div>
<a class="anchor" id="a51486936a9ff5079afed80eb5bf8a3e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spanel_bmod </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>   Performs numeric block updates (sup-panel) in topological order.
   It features: col-col, 2cols-col, 3cols-col, and sup-col updates.
   Special processing on the supernodal portion of L[*,j]</pre><pre>   Before entering this routine, the original nonzeros in the panel 
   were already copied into the spa[m,w].</pre><pre>   Updated/Output parameters-
   dense[0:m-1,w]: L[*,j:j+w-1] and U[*,j:j+w-1] are returned 
   collectively in the m-by-w vector dense[*]. 
</pre> 
</div>
</div>
<a class="anchor" id="a77baf210393e04fa71d4e73b5e60e556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spanel_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>  Performs a symbolic factorization on a panel of columns [jcol, jcol+w).</pre><pre>  <a class="el" href="classA.html">A</a> supernode representative is the last column of a supernode.
  The nonzeros in U[*,j] are segments that end at supernodal
  representatives.</pre><pre>  The routine returns one list of the supernodal representatives
  in topological order of the dfs that generates them. This list is
  a superset of the topological order of each individual column within
  the panel. 
  The location of the first nonzero in each supernodal segment
  (supernodal entry location) is also returned. Each column has a 
  separate list for this purpose.</pre><pre>  Two marker arrays are used for dfs:
    marker[i] == jj, if i was visited during dfs of current column jj;
    marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</pre><pre>  marker: A-row &ndash;&gt; A-row/col (0/1)
  repfnz: SuperA-col &ndash;&gt; PA-row
  parent: SuperA-col &ndash;&gt; SuperA-col
  xplore: SuperA-col &ndash;&gt; index to L-structure
</pre> 
</div>
</div>
<a class="anchor" id="acb8787465a6296109b9a306d5a315ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sPivotGrowth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre></pre><pre>Compute the reciprocal pivot growth factor of the leading ncols columns
of the matrix, using the formula:
    min_j ( max_i(abs(A_ij)) / max_i(abs(U_ij)) )</pre><pre><h1>Arguments
</h1>
</pre><pre></pre><pre>ncols    (input) int
         The number of columns of matrices <a class="el" href="classA.html">A</a>, L and U.</pre><pre><a class="el" href="classA.html">A</a>        (input) SuperMatrix*
     Original matrix <a class="el" href="classA.html">A</a>, permuted by columns, of dimension
         (A-&gt;nrow, A-&gt;ncol). The type of <a class="el" href="classA.html">A</a> can be:
         Stype = NC; Dtype = SLU_S; Mtype = GE.</pre><pre>L        (output) SuperMatrix*
         The factor L from the factorization Pr*A=L*U; use compressed row 
         subscripts storage for supernodes, i.e., L has type: 
         Stype = SC; Dtype = SLU_S; Mtype = TRLU.</pre><pre>U        (output) SuperMatrix*
     The factor U from the factorization Pr*A*Pc=L*U. Use column-wise
         storage scheme, i.e., U has types: Stype = NC;
         Dtype = SLU_S; Mtype = TRU.
</pre> 
</div>
</div>
<a class="anchor" id="ad7ddf03faedae25b4d73e0b6b33bf50c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spivotL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>usepr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iperm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iperm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  Performs the numerical pivoting on the current column of L,
  and the CDIV operation.</pre><pre>  Pivot policy:
  (1) Compute thresh = u * max_(i&gt;=j) <a class="el" href="slamch_8c.html#a3aa069ac3980707dae1e0530f50d59e4">abs(A_ij)</a>;
  (2) IF user specifies pivot row k and <a class="el" href="slamch_8c.html#a3aa069ac3980707dae1e0530f50d59e4">abs(A_kj)</a> &gt;= thresh THEN
          pivot row = k;
      ELSE IF <a class="el" href="slamch_8c.html#a3aa069ac3980707dae1e0530f50d59e4">abs(A_jj)</a> &gt;= thresh THEN
          pivot row = j;
      ELSE
          pivot row = m;</pre><pre>  Note: If you absolutely want to use a given pivot order, then set u=0.0.</pre><pre>  Return value: 0      success;
                i &gt; 0  U(i,i) is exactly zero.
</pre> 
</div>
</div>
<a class="anchor" id="a5cd6efad9d9fb7aef8a984f5e3cff66b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sPrint_CompCol_Matrix </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines for debugging. </p>

</div>
</div>
<a class="anchor" id="a25b29c47333295f4aa744e541e277ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sPrint_Dense_Matrix </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a297455c494a78c098b2bf418edbc6b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sprint_lu_col </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagnostic print of column "jcol" in the U/L factor. </p>

</div>
</div>
<a class="anchor" id="aeb289a84407c9cbbb33cdf3dbb1dacbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sPrint_SuperNode_Matrix </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf9da2c45289246ef663fc4a96d1ad78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spruneL </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
  Prunes the L-structure of supernodes whose L-structure
  contains the current pivot row "pivrow"
</pre> 
</div>
</div>
<a class="anchor" id="a98d44fe59660f87330b0172151a76141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sqselect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1357f9a3b2ffb9522883ad84affa63e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sQuerySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__usage__t.html">mem_usage_t</a> *&#160;</td>
          <td class="paramname"><em>mem_usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
mem_usage consists of the following fields:</p><ul>
<li>for_lu (float)
     The amount of space used in bytes for the L data structures.</li>
<li>total_needed (float)
     The amount of space needed in bytes to perform factorization.

</li>
</ul>
</pre>
</div>
</div>
<a class="anchor" id="a734dbf3f5d66b2a53d88e69daaad729e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadhb </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary routines. </p>

</div>
</div>
<a class="anchor" id="ab345670a95db3f9c4b9c451224db8227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadmt </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad992a573876b4abfe192ec2bc207f6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadrb </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae99cb18465c8992235a7bc003237f692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sreadtriple </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5b2859bf1ef1900506dfa702574c6ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sSetRWork </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up pointers for real working arrays. </p>

</div>
</div>
<a class="anchor" id="a60e60255360fae0b1458da070690a3a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ssnode_bmod </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs numeric block updates within the relaxed snode. </p>

</div>
</div>
<a class="anchor" id="ad9d54c8dfc11f1e034b4b7175be60ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ssnode_dfs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>asub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>xa_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlobalLU__t.html">GlobalLU_t</a> *&#160;</td>
          <td class="paramname"><em>Glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
<h1>Purpose
</h1>
</pre><pre>
   <a class="el" href="ssnode__dfs_8c.html#a5b66817c89ddf9f74e4773b49dc72872">ssnode_dfs()</a> - Determine the union of the row structures of those 
   columns within the relaxed snode.
   Note: The relaxed snodes are leaves of the supernodal etree, therefore, 
   the portion outside the rectangular supernode must be zero.</pre><pre><h1>Return value
</h1>
</pre><pre>
    0   success;
   &gt;0   number of bytes allocated when run out of memory.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:25:19 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
