<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: complex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">complex<div class="ingroups"><a class="el" href="group__testing.html">LAPACK Testing</a> &raquo; <a class="el" href="group__eig.html">Eigenvalue and Singular value</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga799e97bf0e79c0869e150c5de4e12e2a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga799e97bf0e79c0869e150c5de4e12e2a">cbdt01</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KD, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, Q, LDQ, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, PT, LDPT, WORK, RWORK, RESID)</td></tr>
<tr class="memdesc:ga799e97bf0e79c0869e150c5de4e12e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CBDT01</b>  <a href="#ga799e97bf0e79c0869e150c5de4e12e2a">More...</a><br /></td></tr>
<tr class="separator:ga799e97bf0e79c0869e150c5de4e12e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53408064a3478ae56564bbf12b391aba"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga53408064a3478ae56564bbf12b391aba">cbdt02</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, C, LDC, U, LDU, WORK, RWORK, RESID)</td></tr>
<tr class="memdesc:ga53408064a3478ae56564bbf12b391aba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CBDT02</b>  <a href="#ga53408064a3478ae56564bbf12b391aba">More...</a><br /></td></tr>
<tr class="separator:ga53408064a3478ae56564bbf12b391aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e31f7060577f077726594263453bef"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gab4e31f7060577f077726594263453bef">cbdt03</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KD, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, S, VT, LDVT, WORK, RESID)</td></tr>
<tr class="memdesc:gab4e31f7060577f077726594263453bef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CBDT03</b>  <a href="#gab4e31f7060577f077726594263453bef">More...</a><br /></td></tr>
<tr class="separator:gab4e31f7060577f077726594263453bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca7ddf2fd131cc637d9678a346bd445"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga3ca7ddf2fd131cc637d9678a346bd445">cchkbb</a> (NSIZES, MVAL, NVAL, NWDTHS, KK, NTYPES, DOTYPE, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, AB, LDAB, BD, BE, Q, LDQ, P, LDP, C, LDC, CC, WORK, LWORK, RWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga3ca7ddf2fd131cc637d9678a346bd445"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKBB</b>  <a href="#ga3ca7ddf2fd131cc637d9678a346bd445">More...</a><br /></td></tr>
<tr class="separator:ga3ca7ddf2fd131cc637d9678a346bd445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44246338e3797ea8686b9db821963411"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga44246338e3797ea8686b9db821963411">cchkbd</a> (NSIZES, MVAL, NVAL, NTYPES, DOTYPE, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, BD, BE, S1, S2, X, LDX, Y, Z, Q, LDQ, PT, LDPT, U, VT, WORK, LWORK, RWORK, NOUT, INFO)</td></tr>
<tr class="memdesc:ga44246338e3797ea8686b9db821963411"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKBD</b>  <a href="#ga44246338e3797ea8686b9db821963411">More...</a><br /></td></tr>
<tr class="separator:ga44246338e3797ea8686b9db821963411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73239f7fc944d68873460e586be5953"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gae73239f7fc944d68873460e586be5953">cchkbk</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:gae73239f7fc944d68873460e586be5953"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKBK</b>  <a href="#gae73239f7fc944d68873460e586be5953">More...</a><br /></td></tr>
<tr class="separator:gae73239f7fc944d68873460e586be5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6abf11ff426c1ca494ccdce417484e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga0c6abf11ff426c1ca494ccdce417484e">cchkbl</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:ga0c6abf11ff426c1ca494ccdce417484e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKBL</b>  <a href="#ga0c6abf11ff426c1ca494ccdce417484e">More...</a><br /></td></tr>
<tr class="separator:ga0c6abf11ff426c1ca494ccdce417484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33af268bb77b50a691195ec96919e2f4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga33af268bb77b50a691195ec96919e2f4">cchkec</a> (<a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, TSTERR, NIN, NOUT)</td></tr>
<tr class="memdesc:ga33af268bb77b50a691195ec96919e2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKEC</b>  <a href="#ga33af268bb77b50a691195ec96919e2f4">More...</a><br /></td></tr>
<tr class="separator:ga33af268bb77b50a691195ec96919e2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53604133fb9ee893edcbd41d3863c2b4"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga53604133fb9ee893edcbd41d3863c2b4">cchkee</a></td></tr>
<tr class="memdesc:ga53604133fb9ee893edcbd41d3863c2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKEE</b>  <a href="#ga53604133fb9ee893edcbd41d3863c2b4">More...</a><br /></td></tr>
<tr class="separator:ga53604133fb9ee893edcbd41d3863c2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712d308fd40a2f0f279fe4a0c8544a30"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga712d308fd40a2f0f279fe4a0c8544a30">cchkgg</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, TSTDIF, THRSHN, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, H, T, S1, S2, P1, P2, U, LDU, V, Q, Z, ALPHA1, BETA1, ALPHA3, BETA3, EVECTL, EVECTR, WORK, LWORK, RWORK, LLWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga712d308fd40a2f0f279fe4a0c8544a30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKGG</b>  <a href="#ga712d308fd40a2f0f279fe4a0c8544a30">More...</a><br /></td></tr>
<tr class="separator:ga712d308fd40a2f0f279fe4a0c8544a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c55aad209e2f68c34d7959912ee253"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga38c55aad209e2f68c34d7959912ee253">cchkgk</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:ga38c55aad209e2f68c34d7959912ee253"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKGK</b>  <a href="#ga38c55aad209e2f68c34d7959912ee253">More...</a><br /></td></tr>
<tr class="separator:ga38c55aad209e2f68c34d7959912ee253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ae0be71db106e536d22d0982164f3e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga38ae0be71db106e536d22d0982164f3e">cchkgl</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:ga38ae0be71db106e536d22d0982164f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKGL</b>  <a href="#ga38ae0be71db106e536d22d0982164f3e">More...</a><br /></td></tr>
<tr class="separator:ga38ae0be71db106e536d22d0982164f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga392b1b165355ea949383c3c5f701b0e1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga392b1b165355ea949383c3c5f701b0e1">cchkhb</a> (NSIZES, NN, NWDTHS, KK, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, SD, SE, U, LDU, WORK, LWORK, RWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga392b1b165355ea949383c3c5f701b0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKHB</b>  <a href="#ga392b1b165355ea949383c3c5f701b0e1">More...</a><br /></td></tr>
<tr class="separator:ga392b1b165355ea949383c3c5f701b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9958096d169e0e3ce8fb70643cec936"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaf9958096d169e0e3ce8fb70643cec936">cchkhs</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, T1, T2, U, LDU, Z, UZ, W1, W3, EVECTL, EVECTR, EVECTY, EVECTX, UU, TAU, WORK, NWORK, RWORK, IWORK, SELECT, RESULT, INFO)</td></tr>
<tr class="memdesc:gaf9958096d169e0e3ce8fb70643cec936"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKHS</b>  <a href="#gaf9958096d169e0e3ce8fb70643cec936">More...</a><br /></td></tr>
<tr class="separator:gaf9958096d169e0e3ce8fb70643cec936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525d1a2df6511f9a488f0dd914a45baa"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga525d1a2df6511f9a488f0dd914a45baa">cchkst</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, AP, SD, SE, D1, D2, D3, D4, D5, WA1, WA2, WA3, WR, U, LDU, V, VP, TAU, Z, WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga525d1a2df6511f9a488f0dd914a45baa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCHKST</b>  <a href="#ga525d1a2df6511f9a488f0dd914a45baa">More...</a><br /></td></tr>
<tr class="separator:ga525d1a2df6511f9a488f0dd914a45baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab577d9fd38a6d67157f0b7a22090bd76"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gab577d9fd38a6d67157f0b7a22090bd76">cckcsd</a> (NM, MVAL, PVAL, QVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, MMAX, X, XF, U1, U2, V1T, V2T, THETA, IWORK, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:gab577d9fd38a6d67157f0b7a22090bd76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCKCSD</b>  <a href="#gab577d9fd38a6d67157f0b7a22090bd76">More...</a><br /></td></tr>
<tr class="separator:gab577d9fd38a6d67157f0b7a22090bd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f888d1e47ac0a876793161ada51c49"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga02f888d1e47ac0a876793161ada51c49">cckglm</a> (NN, NVAL, MVAL, PVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, B, BF, X, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:ga02f888d1e47ac0a876793161ada51c49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCKGLM</b>  <a href="#ga02f888d1e47ac0a876793161ada51c49">More...</a><br /></td></tr>
<tr class="separator:ga02f888d1e47ac0a876793161ada51c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0da4fbc5a2c02b848f49c0dd9c3f893"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gac0da4fbc5a2c02b848f49c0dd9c3f893">cckgqr</a> (NM, MVAL, NP, PVAL, NN, NVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, AQ, AR, TAUA, B, BF, BZ, BT, BWK, TAUB, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:gac0da4fbc5a2c02b848f49c0dd9c3f893"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCKGQR</b>  <a href="#gac0da4fbc5a2c02b848f49c0dd9c3f893">More...</a><br /></td></tr>
<tr class="separator:gac0da4fbc5a2c02b848f49c0dd9c3f893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab332c713db9ff9a65c6b4ee66173021c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gab332c713db9ff9a65c6b4ee66173021c">cckgsv</a> (NM, MVAL, PVAL, NVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, B, BF, U, V, Q, ALPHA, BETA, R, IWORK, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:gab332c713db9ff9a65c6b4ee66173021c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCKGSV</b>  <a href="#gab332c713db9ff9a65c6b4ee66173021c">More...</a><br /></td></tr>
<tr class="separator:gab332c713db9ff9a65c6b4ee66173021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0a12a9548976fc736b24a730538084"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga5b0a12a9548976fc736b24a730538084">ccklse</a> (NN, MVAL, PVAL, NVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, B, BF, X, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:ga5b0a12a9548976fc736b24a730538084"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCKLSE</b>  <a href="#ga5b0a12a9548976fc736b24a730538084">More...</a><br /></td></tr>
<tr class="separator:ga5b0a12a9548976fc736b24a730538084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5cdc631c988f7e170b0829ef5e1b08"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gafa5cdc631c988f7e170b0829ef5e1b08">ccsdts</a> (M, P, Q, X, XF, LDX, U1, LDU1, U2, LDU2, V1T, LDV1T, V2T, LDV2T, THETA, IWORK, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gafa5cdc631c988f7e170b0829ef5e1b08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CCSDTS</b>  <a href="#gafa5cdc631c988f7e170b0829ef5e1b08">More...</a><br /></td></tr>
<tr class="separator:gafa5cdc631c988f7e170b0829ef5e1b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9768e84ddc8b8b97e11717e35c5269fe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga9768e84ddc8b8b97e11717e35c5269fe">cdrges</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, S, T, Q, LDQ, Z, ALPHA, BETA, WORK, LWORK, RWORK, RESULT, BWORK, INFO)</td></tr>
<tr class="memdesc:ga9768e84ddc8b8b97e11717e35c5269fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRGES</b>  <a href="#ga9768e84ddc8b8b97e11717e35c5269fe">More...</a><br /></td></tr>
<tr class="separator:ga9768e84ddc8b8b97e11717e35c5269fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ee1e6b74cbcaedfebbee8b8784c2a2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gac1ee1e6b74cbcaedfebbee8b8784c2a2">cdrgev</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, S, T, Q, LDQ, Z, QE, LDQE, ALPHA, BETA, ALPHA1, BETA1, WORK, LWORK, RWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:gac1ee1e6b74cbcaedfebbee8b8784c2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRGEV</b>  <a href="#gac1ee1e6b74cbcaedfebbee8b8784c2a2">More...</a><br /></td></tr>
<tr class="separator:gac1ee1e6b74cbcaedfebbee8b8784c2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21eb09898bd5e7259abc7e07868c3687"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga21eb09898bd5e7259abc7e07868c3687">cdrgsx</a> (NSIZE, NCMAX, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIN, NOUT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, AI, BI, Z, Q, ALPHA, BETA, C, LDC, S, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:ga21eb09898bd5e7259abc7e07868c3687"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRGSX</b>  <a href="#ga21eb09898bd5e7259abc7e07868c3687">More...</a><br /></td></tr>
<tr class="separator:ga21eb09898bd5e7259abc7e07868c3687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4baee2f642cf143c6b713d3f12e56bf"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gac4baee2f642cf143c6b713d3f12e56bf">cdrgvx</a> (NSIZE, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIN, NOUT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, AI, BI, ALPHA, BETA, VL, VR, ILO, IHI, LSCALE, RSCALE, S, STRU, DIF, DIFTRU, WORK, LWORK, RWORK, IWORK, LIWORK, RESULT, BWORK, INFO)</td></tr>
<tr class="memdesc:gac4baee2f642cf143c6b713d3f12e56bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRGVX</b>  <a href="#gac4baee2f642cf143c6b713d3f12e56bf">More...</a><br /></td></tr>
<tr class="separator:gac4baee2f642cf143c6b713d3f12e56bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b82bbab7031b4a887831d1cf3d3ac42"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga2b82bbab7031b4a887831d1cf3d3ac42">cdrvbd</a> (NSIZES, MM, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, U, LDU, VT, LDVT, ASAV, USAV, VTSAV, S, SSAV, E, WORK, LWORK, RWORK, IWORK, NOUNIT, INFO)</td></tr>
<tr class="memdesc:ga2b82bbab7031b4a887831d1cf3d3ac42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVBD</b>  <a href="#ga2b82bbab7031b4a887831d1cf3d3ac42">More...</a><br /></td></tr>
<tr class="separator:ga2b82bbab7031b4a887831d1cf3d3ac42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a71405b6c399d8003237c6dd21b3855"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga7a71405b6c399d8003237c6dd21b3855">cdrves</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, HT, W, WT, VS, LDVS, RESULT, WORK, NWORK, RWORK, IWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:ga7a71405b6c399d8003237c6dd21b3855"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVES</b>  <a href="#ga7a71405b6c399d8003237c6dd21b3855">More...</a><br /></td></tr>
<tr class="separator:ga7a71405b6c399d8003237c6dd21b3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83586dc59c82790361b0de5fe25bf0f3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga83586dc59c82790361b0de5fe25bf0f3">cdrvev</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, W, W1, VL, LDVL, VR, LDVR, LRE, LDLRE, RESULT, WORK, NWORK, RWORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga83586dc59c82790361b0de5fe25bf0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVEV</b>  <a href="#ga83586dc59c82790361b0de5fe25bf0f3">More...</a><br /></td></tr>
<tr class="separator:ga83586dc59c82790361b0de5fe25bf0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4d21e3f556cbcb6998be9aeede7151"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga6d4d21e3f556cbcb6998be9aeede7151">cdrvgg</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, THRSHN, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, S, T, S2, T2, Q, LDQ, Z, ALPHA1, BETA1, ALPHA2, BETA2, VL, VR, WORK, LWORK, RWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga6d4d21e3f556cbcb6998be9aeede7151"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVGG</b>  <a href="#ga6d4d21e3f556cbcb6998be9aeede7151">More...</a><br /></td></tr>
<tr class="separator:ga6d4d21e3f556cbcb6998be9aeede7151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00458f67544e6b941bb4b947d54e239f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga00458f67544e6b941bb4b947d54e239f">cdrvsg</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, LDZ, AB, BB, AP, BP, WORK, NWORK, RWORK, LRWORK, IWORK, LIWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga00458f67544e6b941bb4b947d54e239f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVSG</b>  <a href="#ga00458f67544e6b941bb4b947d54e239f">More...</a><br /></td></tr>
<tr class="separator:ga00458f67544e6b941bb4b947d54e239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd6f59fe241010a772c2d06a9d11d89"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gacbd6f59fe241010a772c2d06a9d11d89">cdrvst</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, D1, D2, D3, WA1, WA2, WA3, U, LDU, V, TAU, Z, WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:gacbd6f59fe241010a772c2d06a9d11d89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVST</b>  <a href="#gacbd6f59fe241010a772c2d06a9d11d89">More...</a><br /></td></tr>
<tr class="separator:gacbd6f59fe241010a772c2d06a9d11d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga730ba08b058674ceabf267420c5c4d01"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga730ba08b058674ceabf267420c5c4d01">cdrvsx</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIUNIT, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, HT, W, WT, WTMP, VS, LDVS, VS1, RESULT, WORK, LWORK, RWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:ga730ba08b058674ceabf267420c5c4d01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVSX</b>  <a href="#ga730ba08b058674ceabf267420c5c4d01">More...</a><br /></td></tr>
<tr class="separator:ga730ba08b058674ceabf267420c5c4d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de5d5cdd79b4ab56fd984ac860f1b36"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga2de5d5cdd79b4ab56fd984ac860f1b36">cdrvvx</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIUNIT, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, W, W1, VL, LDVL, VR, LDVR, LRE, LDLRE, RCONDV, RCNDV1, RCDVIN, RCONDE, RCNDE1, RCDEIN, SCALE, SCALE1, RESULT, WORK, NWORK, RWORK, INFO)</td></tr>
<tr class="memdesc:ga2de5d5cdd79b4ab56fd984ac860f1b36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CDRVVX</b>  <a href="#ga2de5d5cdd79b4ab56fd984ac860f1b36">More...</a><br /></td></tr>
<tr class="separator:ga2de5d5cdd79b4ab56fd984ac860f1b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b4c5d969bcab15b8a414bfab72943a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga50b4c5d969bcab15b8a414bfab72943a">cerrbd</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:ga50b4c5d969bcab15b8a414bfab72943a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CERRBD</b>  <a href="#ga50b4c5d969bcab15b8a414bfab72943a">More...</a><br /></td></tr>
<tr class="separator:ga50b4c5d969bcab15b8a414bfab72943a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5751920655807ca8c7faae007dba9342"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga5751920655807ca8c7faae007dba9342">cerrec</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:ga5751920655807ca8c7faae007dba9342"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CERREC</b>  <a href="#ga5751920655807ca8c7faae007dba9342">More...</a><br /></td></tr>
<tr class="separator:ga5751920655807ca8c7faae007dba9342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f3d64318a49dca7ee6ae69057e89d4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga39f3d64318a49dca7ee6ae69057e89d4">cerred</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:ga39f3d64318a49dca7ee6ae69057e89d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CERRED</b>  <a href="#ga39f3d64318a49dca7ee6ae69057e89d4">More...</a><br /></td></tr>
<tr class="separator:ga39f3d64318a49dca7ee6ae69057e89d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5237e7f50365662c99c5af4d41ecb194"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga5237e7f50365662c99c5af4d41ecb194">cerrgg</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:ga5237e7f50365662c99c5af4d41ecb194"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CERRGG</b>  <a href="#ga5237e7f50365662c99c5af4d41ecb194">More...</a><br /></td></tr>
<tr class="separator:ga5237e7f50365662c99c5af4d41ecb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62986bd8f34d0f8e039c639d25fb926"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gad62986bd8f34d0f8e039c639d25fb926">cerrhs</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:gad62986bd8f34d0f8e039c639d25fb926"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CERRHS</b>  <a href="#gad62986bd8f34d0f8e039c639d25fb926">More...</a><br /></td></tr>
<tr class="separator:gad62986bd8f34d0f8e039c639d25fb926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c64251a2e100d6629de57e93674dfe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaf0c64251a2e100d6629de57e93674dfe">cerrst</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:gaf0c64251a2e100d6629de57e93674dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CERRST</b>  <a href="#gaf0c64251a2e100d6629de57e93674dfe">More...</a><br /></td></tr>
<tr class="separator:gaf0c64251a2e100d6629de57e93674dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d2226b2f8806aa9b110c167c93bedf"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gab6d2226b2f8806aa9b110c167c93bedf">cget02</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58">TRANS</a>, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, X, LDX, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, RWORK, RESID)</td></tr>
<tr class="memdesc:gab6d2226b2f8806aa9b110c167c93bedf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET02</b>  <a href="#gab6d2226b2f8806aa9b110c167c93bedf">More...</a><br /></td></tr>
<tr class="separator:gab6d2226b2f8806aa9b110c167c93bedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbf4135e14f662ed4f3486c218d7132"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga3dbf4135e14f662ed4f3486c218d7132">cget10</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga3dbf4135e14f662ed4f3486c218d7132"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET10</b>  <a href="#ga3dbf4135e14f662ed4f3486c218d7132">More...</a><br /></td></tr>
<tr class="separator:ga3dbf4135e14f662ed4f3486c218d7132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7f4c1d3cb97e0b5812937d39270e81"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaba7f4c1d3cb97e0b5812937d39270e81">cget22</a> (TRANSA, TRANSE, TRANSW, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, E, LDE, W, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gaba7f4c1d3cb97e0b5812937d39270e81"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET22</b>  <a href="#gaba7f4c1d3cb97e0b5812937d39270e81">More...</a><br /></td></tr>
<tr class="separator:gaba7f4c1d3cb97e0b5812937d39270e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348eb5544a2d2680f42ba665fcd5b81c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga348eb5544a2d2680f42ba665fcd5b81c">cget23</a> (COMP, ISRT, BALANC, JTYPE, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, ISEED, NOUNIT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, W, W1, VL, LDVL, VR, LDVR, LRE, LDLRE, RCONDV, RCNDV1, RCDVIN, RCONDE, RCNDE1, RCDEIN, SCALE, SCALE1, RESULT, WORK, LWORK, RWORK, INFO)</td></tr>
<tr class="memdesc:ga348eb5544a2d2680f42ba665fcd5b81c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET23</b>  <a href="#ga348eb5544a2d2680f42ba665fcd5b81c">More...</a><br /></td></tr>
<tr class="separator:ga348eb5544a2d2680f42ba665fcd5b81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb74cf216cc7b889b8b724e1917e0cd7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gafb74cf216cc7b889b8b724e1917e0cd7">cget24</a> (COMP, JTYPE, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, ISEED, NOUNIT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, HT, W, WT, WTMP, VS, LDVS, VS1, RCDEIN, RCDVIN, NSLCT, ISLCT, ISRT, RESULT, WORK, LWORK, RWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:gafb74cf216cc7b889b8b724e1917e0cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET24</b>  <a href="#gafb74cf216cc7b889b8b724e1917e0cd7">More...</a><br /></td></tr>
<tr class="separator:gafb74cf216cc7b889b8b724e1917e0cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749fac66036c4311ca3a1fc5f29bc4ad"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga749fac66036c4311ca3a1fc5f29bc4ad">cget35</a> (RMAX, LMAX, NINFO, KNT, NIN)</td></tr>
<tr class="memdesc:ga749fac66036c4311ca3a1fc5f29bc4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET35</b>  <a href="#ga749fac66036c4311ca3a1fc5f29bc4ad">More...</a><br /></td></tr>
<tr class="separator:ga749fac66036c4311ca3a1fc5f29bc4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf911ed8696d5b150c4d44077b2132b34"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaf911ed8696d5b150c4d44077b2132b34">cget36</a> (RMAX, LMAX, NINFO, KNT, NIN)</td></tr>
<tr class="memdesc:gaf911ed8696d5b150c4d44077b2132b34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET36</b>  <a href="#gaf911ed8696d5b150c4d44077b2132b34">More...</a><br /></td></tr>
<tr class="separator:gaf911ed8696d5b150c4d44077b2132b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70075f042e15dc8f5bc26c15d38759ca"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga70075f042e15dc8f5bc26c15d38759ca">cget37</a> (RMAX, LMAX, NINFO, KNT, NIN)</td></tr>
<tr class="memdesc:ga70075f042e15dc8f5bc26c15d38759ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET37</b>  <a href="#ga70075f042e15dc8f5bc26c15d38759ca">More...</a><br /></td></tr>
<tr class="separator:ga70075f042e15dc8f5bc26c15d38759ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31605f4f439bba3ee9ce9c1c24df2e7c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga31605f4f439bba3ee9ce9c1c24df2e7c">cget38</a> (RMAX, LMAX, NINFO, KNT, NIN)</td></tr>
<tr class="memdesc:ga31605f4f439bba3ee9ce9c1c24df2e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET38</b>  <a href="#ga31605f4f439bba3ee9ce9c1c24df2e7c">More...</a><br /></td></tr>
<tr class="separator:ga31605f4f439bba3ee9ce9c1c24df2e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab476cc3251f71c95e0a4a42bcd6d7885"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gab476cc3251f71c95e0a4a42bcd6d7885">cget51</a> (ITYPE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, U, LDU, V, LDV, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gab476cc3251f71c95e0a4a42bcd6d7885"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET51</b>  <a href="#gab476cc3251f71c95e0a4a42bcd6d7885">More...</a><br /></td></tr>
<tr class="separator:gab476cc3251f71c95e0a4a42bcd6d7885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad38988d8cb0400e6a532510a3819e1b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaad38988d8cb0400e6a532510a3819e1b">cget52</a> (LEFT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, E, LDE, ALPHA, BETA, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gaad38988d8cb0400e6a532510a3819e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET52</b>  <a href="#gaad38988d8cb0400e6a532510a3819e1b">More...</a><br /></td></tr>
<tr class="separator:gaad38988d8cb0400e6a532510a3819e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbfe7ec0c6aeaf712ca2c79001146e4b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gafbfe7ec0c6aeaf712ca2c79001146e4b">cget54</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, S, LDS, T, LDT, U, LDU, V, LDV, WORK, RESULT)</td></tr>
<tr class="memdesc:gafbfe7ec0c6aeaf712ca2c79001146e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGET54</b>  <a href="#gafbfe7ec0c6aeaf712ca2c79001146e4b">More...</a><br /></td></tr>
<tr class="separator:gafbfe7ec0c6aeaf712ca2c79001146e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4283cb04f906b24363d97745e2ce10bd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga4283cb04f906b24363d97745e2ce10bd">cglmts</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, P, <a class="el" href="classA.html">A</a>, AF, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, BF, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, DF, X, U, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga4283cb04f906b24363d97745e2ce10bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGLMTS</b>  <a href="#ga4283cb04f906b24363d97745e2ce10bd">More...</a><br /></td></tr>
<tr class="separator:ga4283cb04f906b24363d97745e2ce10bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28909ffc04948989e0c6bf3dedaed598"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga28909ffc04948989e0c6bf3dedaed598">cgqrts</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, P, <a class="el" href="classA.html">A</a>, AF, Q, R, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, TAUA, B, BF, Z, T, BWK, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, TAUB, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga28909ffc04948989e0c6bf3dedaed598"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGQRTS</b>  <a href="#ga28909ffc04948989e0c6bf3dedaed598">More...</a><br /></td></tr>
<tr class="separator:ga28909ffc04948989e0c6bf3dedaed598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5f303c97976c8ca2871a3a253e2113"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gabe5f303c97976c8ca2871a3a253e2113">cgrqts</a> (M, P, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, AF, Q, R, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, TAUA, B, BF, Z, T, BWK, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, TAUB, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gabe5f303c97976c8ca2871a3a253e2113"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGRQTS</b>  <a href="#gabe5f303c97976c8ca2871a3a253e2113">More...</a><br /></td></tr>
<tr class="separator:gabe5f303c97976c8ca2871a3a253e2113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7553f6e0d22cd4f061e493c45d2ff5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga5d7553f6e0d22cd4f061e493c45d2ff5">cgsvts</a> (M, P, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, AF, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, BF, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, U, LDU, V, LDV, Q, LDQ, ALPHA, BETA, R, LDR, IWORK, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga5d7553f6e0d22cd4f061e493c45d2ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CGSVTS</b>  <a href="#ga5d7553f6e0d22cd4f061e493c45d2ff5">More...</a><br /></td></tr>
<tr class="separator:ga5d7553f6e0d22cd4f061e493c45d2ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96644c54365d8da1b272d9ad4412d38f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga96644c54365d8da1b272d9ad4412d38f">chbt21</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KA, KS, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga96644c54365d8da1b272d9ad4412d38f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CHBT21</b>  <a href="#ga96644c54365d8da1b272d9ad4412d38f">More...</a><br /></td></tr>
<tr class="separator:ga96644c54365d8da1b272d9ad4412d38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f6db849fd0d68eaa2e68917e36a38e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga25f6db849fd0d68eaa2e68917e36a38e">chet21</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KBAND, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, V, LDV, TAU, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga25f6db849fd0d68eaa2e68917e36a38e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CHET21</b>  <a href="#ga25f6db849fd0d68eaa2e68917e36a38e">More...</a><br /></td></tr>
<tr class="separator:ga25f6db849fd0d68eaa2e68917e36a38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d76f9028abf55ff509d2fb0a58ed763"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga0d76f9028abf55ff509d2fb0a58ed763">chet22</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, KBAND, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, V, LDV, TAU, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga0d76f9028abf55ff509d2fb0a58ed763"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CHET22</b>  <a href="#ga0d76f9028abf55ff509d2fb0a58ed763">More...</a><br /></td></tr>
<tr class="separator:ga0d76f9028abf55ff509d2fb0a58ed763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0279384c87f94223fdf27a4d97f4f7d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaf0279384c87f94223fdf27a4d97f4f7d">chkxer</a> (SRNAMT, INFOT, NOUT, LERR, OK)</td></tr>
<tr class="memdesc:gaf0279384c87f94223fdf27a4d97f4f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CHKXER</b>  <a href="#gaf0279384c87f94223fdf27a4d97f4f7d">More...</a><br /></td></tr>
<tr class="separator:gaf0279384c87f94223fdf27a4d97f4f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa33d87ed9b63b7751f2e0111cec1eb47"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaa33d87ed9b63b7751f2e0111cec1eb47">chpt21</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KBAND, AP, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, VP, TAU, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gaa33d87ed9b63b7751f2e0111cec1eb47"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CHPT21</b>  <a href="#gaa33d87ed9b63b7751f2e0111cec1eb47">More...</a><br /></td></tr>
<tr class="separator:gaa33d87ed9b63b7751f2e0111cec1eb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cd77400ba8f6d9e0cc2b316f549fb7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga30cd77400ba8f6d9e0cc2b316f549fb7">chst01</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, ILO, IHI, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, LDH, Q, LDQ, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga30cd77400ba8f6d9e0cc2b316f549fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CHST01</b>  <a href="#ga30cd77400ba8f6d9e0cc2b316f549fb7">More...</a><br /></td></tr>
<tr class="separator:ga30cd77400ba8f6d9e0cc2b316f549fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0239c5b213ef1d200099e057195d13f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gab0239c5b213ef1d200099e057195d13f">clarfy</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, V, INCV, TAU, C, LDC, WORK)</td></tr>
<tr class="memdesc:gab0239c5b213ef1d200099e057195d13f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLARFY</b>  <a href="#gab0239c5b213ef1d200099e057195d13f">More...</a><br /></td></tr>
<tr class="separator:gab0239c5b213ef1d200099e057195d13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275bf58dfd5af715eea76b14ff5f6023"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga275bf58dfd5af715eea76b14ff5f6023">clarhs</a> (PATH, XTYPE, UPLO, <a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58">TRANS</a>, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KL, KU, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, X, LDX, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, ISEED, INFO)</td></tr>
<tr class="memdesc:ga275bf58dfd5af715eea76b14ff5f6023"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLARHS</b>  <a href="#ga275bf58dfd5af715eea76b14ff5f6023">More...</a><br /></td></tr>
<tr class="separator:ga275bf58dfd5af715eea76b14ff5f6023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a0faa6bcbc4df466ebfab225b826a5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga30a0faa6bcbc4df466ebfab225b826a5">clatm4</a> (ITYPE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, NZ1, NZ2, RSIGN, AMAGN, <a class="el" href="superlu__enum__consts_8h.html#af00a42ecad444bbda75cde1b64bd7e72a9b5c151728d8512307565994c89919d5">RCOND</a>, TRIANG, IDIST, ISEED, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:ga30a0faa6bcbc4df466ebfab225b826a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLATM4</b>  <a href="#ga30a0faa6bcbc4df466ebfab225b826a5">More...</a><br /></td></tr>
<tr class="separator:ga30a0faa6bcbc4df466ebfab225b826a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c4512d4a10ff8cc0050e0aaa112b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga90c4512d4a10ff8cc0050e0aaa112b5f">clctes</a> (Z, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>)</td></tr>
<tr class="memdesc:ga90c4512d4a10ff8cc0050e0aaa112b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLCTES</b>  <a href="#ga90c4512d4a10ff8cc0050e0aaa112b5f">More...</a><br /></td></tr>
<tr class="separator:ga90c4512d4a10ff8cc0050e0aaa112b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2475404f498a9fc9f7146da5a6829ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gaf2475404f498a9fc9f7146da5a6829ad">clctsx</a> (ALPHA, BETA)</td></tr>
<tr class="memdesc:gaf2475404f498a9fc9f7146da5a6829ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLCTSX</b>  <a href="#gaf2475404f498a9fc9f7146da5a6829ad">More...</a><br /></td></tr>
<tr class="separator:gaf2475404f498a9fc9f7146da5a6829ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e6951c28a4f982e487adfaf3fc6c989"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga5e6951c28a4f982e487adfaf3fc6c989">clsets</a> (M, P, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, AF, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, BF, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, C, CF, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, DF, X, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga5e6951c28a4f982e487adfaf3fc6c989"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLSETS</b>  <a href="#ga5e6951c28a4f982e487adfaf3fc6c989">More...</a><br /></td></tr>
<tr class="separator:ga5e6951c28a4f982e487adfaf3fc6c989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ee535a3f54f2c0ea6d2da4f7d8fa84"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga93ee535a3f54f2c0ea6d2da4f7d8fa84">csbmv</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, K, ALPHA, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, X, INCX, BETA, Y, INCY)</td></tr>
<tr class="memdesc:ga93ee535a3f54f2c0ea6d2da4f7d8fa84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSBMV</b>  <a href="#ga93ee535a3f54f2c0ea6d2da4f7d8fa84">More...</a><br /></td></tr>
<tr class="separator:ga93ee535a3f54f2c0ea6d2da4f7d8fa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba73334a6847224855e1cd46190a57e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga7ba73334a6847224855e1cd46190a57e">csgt01</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, Z, LDZ, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga7ba73334a6847224855e1cd46190a57e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSGT01</b>  <a href="#ga7ba73334a6847224855e1cd46190a57e">More...</a><br /></td></tr>
<tr class="separator:ga7ba73334a6847224855e1cd46190a57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9f3211db914cec239828108033783a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga0d9f3211db914cec239828108033783a">cslect</a> (Z)</td></tr>
<tr class="memdesc:ga0d9f3211db914cec239828108033783a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSLECT</b>  <a href="#ga0d9f3211db914cec239828108033783a">More...</a><br /></td></tr>
<tr class="separator:ga0d9f3211db914cec239828108033783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bad51cd5228d6748888b32aaa29b8e4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga1bad51cd5228d6748888b32aaa29b8e4">cstt21</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KBAND, AD, AE, SD, SE, U, LDU, WORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga1bad51cd5228d6748888b32aaa29b8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSTT21</b>  <a href="#ga1bad51cd5228d6748888b32aaa29b8e4">More...</a><br /></td></tr>
<tr class="separator:ga1bad51cd5228d6748888b32aaa29b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e28ed198349b9824bd5809a4b72b8f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga26e28ed198349b9824bd5809a4b72b8f">cstt22</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, KBAND, AD, AE, SD, SE, U, LDU, WORK, LDWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga26e28ed198349b9824bd5809a4b72b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSTT22</b>  <a href="#ga26e28ed198349b9824bd5809a4b72b8f">More...</a><br /></td></tr>
<tr class="separator:ga26e28ed198349b9824bd5809a4b72b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9b6679b2002fda89e08e1a922e3aeb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#ga9a9b6679b2002fda89e08e1a922e3aeb">cunt01</a> (ROWCOL, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, U, LDU, WORK, LWORK, RWORK, RESID)</td></tr>
<tr class="memdesc:ga9a9b6679b2002fda89e08e1a922e3aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CUNT01</b>  <a href="#ga9a9b6679b2002fda89e08e1a922e3aeb">More...</a><br /></td></tr>
<tr class="separator:ga9a9b6679b2002fda89e08e1a922e3aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5dc85ead2be87d8497fd4f2c4d903d1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complex__eig.html#gab5dc85ead2be87d8497fd4f2c4d903d1">cunt03</a> (RC, MU, MV, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, K, U, LDU, V, LDV, WORK, LWORK, RWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:gab5dc85ead2be87d8497fd4f2c4d903d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CUNT03</b>  <a href="#gab5dc85ead2be87d8497fd4f2c4d903d1">More...</a><br /></td></tr>
<tr class="separator:gab5dc85ead2be87d8497fd4f2c4d903d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is the group of complex LAPACK TESTING EIG routines. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga799e97bf0e79c0869e150c5de4e12e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cbdt01 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>PT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDPT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CBDT01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CBDT01 reconstructs a general matrix A from its bidiagonal form
    A = Q * B * P'
 where Q (m by min(m,n)) and P' (min(m,n) by n) are unitary
 matrices and B is bidiagonal.

 The test ratio to test the reduction is
    RESID = norm( A - Q * B * PT ) / ( n * norm(A) * EPS )
 where PT = P' and EPS is the machine precision.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrices A and Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and P'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KD</td><td><pre class="fragment">          KD is INTEGER
          If KD = 0, B is diagonal and the array E is not referenced.
          If KD = 1, the reduction was performed by xGEBRD; B is upper
          bidiagonal if M &gt;= N, and lower bidiagonal if M &lt; N.
          If KD = -1, the reduction was performed by xGBBRD; B is
          always upper bidiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The m by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDQ,N)
          The m by min(m,n) unitary matrix Q in the reduction
          A = Q * B * P'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (min(M,N))
          The diagonal elements of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (min(M,N)-1)
          The superdiagonal elements of the bidiagonal matrix B if
          m &gt;= n, or the subdiagonal elements of B if m &lt; n.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PT</td><td><pre class="fragment">          PT is COMPLEX array, dimension (LDPT,N)
          The min(m,n) by n unitary matrix P' in the reduction
          A = Q * B * P'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDPT</td><td><pre class="fragment">          LDPT is INTEGER
          The leading dimension of the array PT.
          LDPT &gt;= max(1,min(M,N)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (M+N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is REAL
          The test ratio:  norm(A - Q * B * P') / ( n * norm(A) * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga53408064a3478ae56564bbf12b391aba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cbdt02 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CBDT02</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CBDT02 tests the change of basis C = U' * B by computing the residual

    RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),

 where B and C are M by N matrices, U is an M by M orthogonal matrix,
 and EPS is the machine precision.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrices B and C and the order of
          the matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices B and C.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,N)
          The m by n matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX array, dimension (LDC,N)
          The m by n matrix C, assumed to contain U' * B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of the array C.  LDC &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU,M)
          The m by m orthogonal matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U.  LDU &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is REAL
          RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab4e31f7060577f077726594263453bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cbdt03 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CBDT03</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CBDT03 reconstructs a bidiagonal matrix B from its SVD:
    S = U' * B * V
 where U and V are orthogonal matrices and S is diagonal.

 The test ratio to test the singular value decomposition is
    RESID = norm( B - U * S * VT ) / ( n * norm(B) * EPS )
 where VT = V' and EPS is the machine precision.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the matrix B is upper or lower bidiagonal.
          = 'U':  Upper bidiagonal
          = 'L':  Lower bidiagonal</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KD</td><td><pre class="fragment">          KD is INTEGER
          The bandwidth of the bidiagonal matrix B.  If KD = 1, the
          matrix B is bidiagonal, and if KD = 0, B is diagonal and E is
          not referenced.  If KD is greater than 1, it is assumed to be
          1, and if KD is less than 0, it is assumed to be 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The n diagonal elements of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N-1)
          The (n-1) superdiagonal elements of the bidiagonal matrix B
          if UPLO = 'U', or the (n-1) subdiagonal elements of B if
          UPLO = 'L'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU,N)
          The n by n orthogonal matrix U in the reduction B = U'*A*P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U.  LDU &gt;= max(1,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL array, dimension (N)
          The singular values from the SVD of B, sorted in decreasing
          order.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is COMPLEX array, dimension (LDVT,N)
          The n by n orthogonal matrix V' in the reduction
          B = U * S * V'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
          The leading dimension of the array VT.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (2*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is REAL
          The test ratio:  norm(B - U * S * V') / ( n * norm(A) * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ca7ddf2fd131cc637d9678a346bd445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkbb </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWDTHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>KK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldab, * )&#160;</td>
          <td class="paramname"><em>AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>BD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( <a class="el" href="slsqp__optmz_8f.html#ac230f990daa202f79a01fd76eb954ff4">ldp</a>, * )&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>CC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKBB</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKBB tests the reduction of a general complex rectangular band
 matrix to real bidiagonal form.

 CGBBRD factors a general band matrix A as  Q B P* , where * means
 conjugate transpose, B is upper bidiagonal, and Q and P are unitary;
 CGBBRD can also overwrite a given matrix C with Q* C .

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix C are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x M
    P:          N x N
    B:          min(M,N) x min(M,N)
    C:          M x NRHS

 For each generated matrix, 4 tests are performed:

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 (4)   | Y - Q' C | / ( |Y| max(M,NRHS) ulp ), where Y = Q' C.

 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).
          If NSIZES is zero, CCHKBB does nothing.  NSIZES must be at
          least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix column dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWDTHS</td><td><pre class="fragment">          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          CCHKBB does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KK</td><td><pre class="fragment">          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CCHKBB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of columns in the "right-hand side" matrix C.
          If NRHS = 0, then the operations on the right-hand side will
          not be tested. NRHS must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CCHKBB to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension
                            (LDA, max(NN))
          Used to hold the matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AB</td><td><pre class="fragment">          AB is REAL array, dimension (LDAB, max(NN))
          Used to hold A in band storage format.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDAB</td><td><pre class="fragment">          LDAB is INTEGER
          The leading dimension of AB.  It must be at least 2 (not 1!)
          and at least max( KK )+1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BD</td><td><pre class="fragment">          BD is REAL array, dimension (max(NN))
          Used to hold the diagonal of the bidiagonal matrix computed
          by CGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BE</td><td><pre class="fragment">          BE is REAL array, dimension (max(NN))
          Used to hold the off-diagonal of the bidiagonal matrix
          computed by CGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDQ, max(NN))
          Used to hold the unitary matrix Q computed by CGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td><pre class="fragment">          P is COMPLEX array, dimension (LDP, max(NN))
          Used to hold the unitary matrix P computed by CGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDP</td><td><pre class="fragment">          LDP is INTEGER
          The leading dimension of P.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX array, dimension (LDC, max(NN))
          Used to hold the matrix C updated by CGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CC</td><td><pre class="fragment">          CC is COMPLEX array, dimension (LDC, max(NN))
          Used to hold a copy of the matrix C.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga44246338e3797ea8686b9db821963411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkbd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>BD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>PT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDPT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKBD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKBD checks the singular value decomposition (SVD) routines.

 CGEBRD reduces a complex general m by n matrix A to real upper or
 lower bidiagonal form by an orthogonal transformation: Q' * A * P = B
 (or A = Q * B * P').  The matrix B is upper bidiagonal if m &gt;= n
 and lower bidiagonal if m &lt; n.

 CUNGBR generates the orthogonal matrices Q and P' from CGEBRD.
 Note that Q and P are not necessarily square.

 CBDSQR computes the singular value decomposition of the bidiagonal
 matrix B as B = U S V'.  It is called three times to compute
    1)  B = U S1 V', where S1 is the diagonal matrix of singular
        values and the columns of the matrices U and V are the left
        and right singular vectors, respectively, of B.
    2)  Same as 1), but the singular values are stored in S2 and the
        singular vectors are not computed.
    3)  A = (UQ) S (P'V'), the SVD of the original matrix A.
 In addition, CBDSQR has an option to apply the left orthogonal matrix
 U to a matrix X, useful in least squares applications.

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix X are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x min(M,N) (but M x M if NRHS &gt; 0)
    P:          min(M,N) x N
    B:          min(M,N) x min(M,N)
    U, V:       min(M,N) x min(M,N)
    S1, S2      diagonal, order min(M,N)
    X:          M x NRHS

 For each generated matrix, 14 tests are performed:

 Test CGEBRD and CUNGBR

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 Test CBDSQR on bidiagonal matrix B

 (4)   | B - U S1 VT | / ( |B| min(M,N) ulp ), VT = V'

 (5)   | Y - U Z | / ( |Y| max(min(M,N),k) ulp ), where Y = Q' X
                                                  and   Z = U' Y.
 (6)   | I - U' U | / ( min(M,N) ulp )

 (7)   | I - VT VT' | / ( min(M,N) ulp )

 (8)   S1 contains min(M,N) nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (9)   0 if the true singular values of B are within THRESH of
       those in S1.  2*THRESH if they are not.  (Tested using
       SSVDCH)

 (10)  | S1 - S2 | / ( |S1| ulp ), where S2 is computed without
                                   computing U and V.

 Test CBDSQR on matrix A

 (11)  | A - (QU) S (VT PT) | / ( |A| max(M,N) ulp )

 (12)  | X - (QU) Z | / ( |X| max(M,k) ulp )

 (13)  | I - (QU)'(QU) | / ( M ulp )

 (14)  | I - (VT PT) (PT'VT') | / ( N ulp )

 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )

 Special case:
 (16) A bidiagonal matrix with random entries chosen from a
      logarithmic distribution on [ulp^2,ulp^(-2)]  (I.e., each
      entry is  e^x, where x is chosen uniformly on
      [ 2 log(ulp), -2 log(ulp) ] .)  For *this* type:
      (a) CGEBRD is not called to reduce it to bidiagonal form.
      (b) the bidiagonal is  min(M,N) x min(M,N); if M&lt;N, the
          matrix will be lower bidiagonal, otherwise upper.
      (c) only tests 5--8 and 14 are performed.

 A subset of the full set of matrix types may be selected through
 the logical array DOTYPE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CCHKBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of columns in the "right-hand side" matrices X, Y,
          and Z, used in testing CBDSQR.  If NRHS = 0, then the
          operations on the right-hand side will not be tested.
          NRHS must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The values of ISEED are changed on exit, and can be
          used in the next call to CCHKBD to continue the same random
          number sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.  Note that the
          expected value of the test ratios is O(1), so THRESH should
          be a reasonably small multiple of 1, e.g., 10 or 100.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,NMAX)
          where NMAX is the maximum value of N in NVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,MMAX),
          where MMAX is the maximum value of M in MVAL.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BD</td><td><pre class="fragment">          BD is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BE</td><td><pre class="fragment">          BE is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S1</td><td><pre class="fragment">          S1 is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S2</td><td><pre class="fragment">          S2 is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (LDX,NRHS)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the arrays X, Y, and Z.
          LDX &gt;= max(1,MMAX).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is COMPLEX array, dimension (LDX,NRHS)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension (LDX,NRHS)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDQ,MMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ &gt;= max(1,MMAX).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PT</td><td><pre class="fragment">          PT is COMPLEX array, dimension (LDPT,NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDPT</td><td><pre class="fragment">          LDPT is INTEGER
          The leading dimension of the arrays PT, U, and V.
          LDPT &gt;= max(1, max(min(MVAL(j),NVAL(j)))).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is COMPLEX array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          3(M+N) and  M(M + max(M,N,k) + 1) + N*min(M,N)  for all
          pairs  (M,N)=(MM(j),NN(j))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension
                      (5*max(min(M,N)))</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some MM(j) &lt; 0
           -3: Some NN(j) &lt; 0
           -4: NTYPES &lt; 0
           -6: NRHS  &lt; 0
           -8: THRESH &lt; 0
          -11: LDA &lt; 1 or LDA &lt; MMAX, where MMAX is max( MM(j) ).
          -17: LDB &lt; 1 or LDB &lt; MMAX.
          -21: LDQ &lt; 1 or LDQ &lt; MMAX.
          -23: LDP &lt; 1 or LDP &lt; MNMAX.
          -27: LWORK too small.
          If  CLATMR, CLATMS, CGEBRD, CUNGBR, or CBDSQR,
              returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NTEST           The number of tests performed, or which can
                     be performed so far, for the current matrix.
     MMAX            Largest value in NN.
     NMAX            Largest value in NN.
     MNMIN           min(MM(j), NN(j)) (the dimension of the bidiagonal
                     matrix.)
     MNMAX           The maximum value of MNMIN for j=1,...,NSIZES.
     NFAIL           The number of tests which have exceeded THRESH
     COND, IMODE     Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     RTOVFL, RTUNFL  Square roots of the previous 2 values.
     ULP, ULPINV     Finest relative precision and its inverse.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gae73239f7fc944d68873460e586be5953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkbk </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKBK</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKBK tests CGEBAK, a routine for backward transformation of
 the computed right or left eigenvectors if the orginal matrix
 was preprocessed by balance subroutine CGEBAL.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c6abf11ff426c1ca494ccdce417484e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkbl </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKBL</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKBL tests CGEBAL, a routine for balancing a general complex
 matrix and isolating some of its eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga33af268bb77b50a691195ec96919e2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkec </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>TSTERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKEC</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKEC tests eigen- condition estimation routines
        CTRSYL, CTREXC, CTRSNA, CTRSEN

 In all cases, the routine runs through a fixed set of numerical
 examples, subjects them to various tests, and compares the test
 results to a threshold THRESH. In addition, CTRSNA and CTRSEN are
 tested by reading in precomputed examples from a file (on input unit
 NIN).  Output is written to output unit NOUT.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          Threshold for residual tests.  A computed test ratio passes
          the threshold if it is less than THRESH.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TSTERR</td><td><pre class="fragment">          TSTERR is LOGICAL
          Flag that indicates whether error exits are to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga53604133fb9ee893edcbd41d3863c2b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program cchkee </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKEE</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKEE tests the COMPLEX LAPACK subroutines for the matrix
 eigenvalue problem.  The test paths in this version are

 NEP (Nonsymmetric Eigenvalue Problem):
     Test CGEHRD, CUNGHR, CHSEQR, CTREVC, CHSEIN, and CUNMHR

 SEP (Hermitian Eigenvalue Problem):
     Test CHETRD, CUNGTR, CSTEQR, CSTERF, CSTEIN, CSTEDC,
     and drivers CHEEV(X), CHBEV(X), CHPEV(X),
                 CHEEVD,   CHBEVD,   CHPEVD

 SVD (Singular Value Decomposition):
     Test CGEBRD, CUNGBR, and CBDSQR
     and the drivers CGESVD, CGESDD

 CEV (Nonsymmetric Eigenvalue/eigenvector Driver):
     Test CGEEV

 CES (Nonsymmetric Schur form Driver):
     Test CGEES

 CVX (Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test CGEEVX

 CSX (Nonsymmetric Schur form Expert Driver):
     Test CGEESX

 CGG (Generalized Nonsymmetric Eigenvalue Problem):
     Test CGGHRD, CGGBAL, CGGBAK, CHGEQZ, and CTGEVC
     and the driver routines CGEGS and CGEGV

 CGS (Generalized Nonsymmetric Schur form Driver):
     Test CGGES

 CGV (Generalized Nonsymmetric Eigenvalue/eigenvector Driver):
     Test CGGEV

 CGX (Generalized Nonsymmetric Schur form Expert Driver):
     Test CGGESX

 CXV (Generalized Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test CGGEVX

 CSG (Hermitian Generalized Eigenvalue Problem):
     Test CHEGST, CHEGV, CHEGVD, CHEGVX, CHPGST, CHPGV, CHPGVD,
     CHPGVX, CHBGST, CHBGV, CHBGVD, and CHBGVX

 CHB (Hermitian Band Eigenvalue Problem):
     Test CHBTRD

 CBB (Band Singular Value Decomposition):
     Test CGBBRD

 CEC (Eigencondition estimation):
     Test CTRSYL, CTREXC, CTRSNA, and CTRSEN

 CBL (Balancing a general matrix)
     Test CGEBAL

 CBK (Back transformation on a balanced matrix)
     Test CGEBAK

 CGL (Balancing a matrix pair)
     Test CGGBAL

 CGK (Back transformation on a matrix pair)
     Test CGGBAK

 GLM (Generalized Linear Regression Model):
     Tests CGGGLM

 GQR (Generalized QR and RQ factorizations):
     Tests CGGQRF and CGGRQF

 GSV (Generalized Singular Value Decomposition):
     Tests CGGSVD, CGGSVP, CTGSJA, CLAGS2, CLAPLL, and CLAPMT

 CSD (CS decomposition):
     Tests CUNCSD

 LSE (Constrained Linear Least Squares):
     Tests CGGLSE

 Each test path has a different set of inputs, but the data sets for
 the driver routines xEV, xES, xVX, and xSX can be concatenated in a
 single input file.  The first line of input should contain one of the
 3-character path names in columns 1-3.  The number of remaining lines
 depends on what is found on the first line.

 The number of matrix types used in testing is often controllable from
 the input file.  The number of matrix types for each path, and the
 test routine that describes them, is as follows:

 Path name(s)  Types    Test routine

 CHS or NEP      21     CCHKHS
 CST or SEP      21     CCHKST (routines)
                 18     CDRVST (drivers)
 CBD or SVD      16     CCHKBD (routines)
                  5     CDRVBD (drivers)
 CEV             21     CDRVEV
 CES             21     CDRVES
 CVX             21     CDRVVX
 CSX             21     CDRVSX
 CGG             26     CCHKGG (routines)
                 26     CDRVGG (drivers)
 CGS             26     CDRGES
 CGX              5     CDRGSX
 CGV             26     CDRGEV
 CXV              2     CDRGVX
 CSG             21     CDRVSG
 CHB             15     CCHKHB
 CBB             15     CCHKBB
 CEC              -     CCHKEC
 CBL              -     CCHKBL
 CBK              -     CCHKBK
 CGL              -     CCHKGL
 CGK              -     CCHKGK
 GLM              8     CCKGLM
 GQR              8     CCKGQR
 GSV              8     CCKGSV
 CSD              3     CCKCSD
 LSE              8     CCKLSE

-----------------------------------------------------------------------

 NEP input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NX, NS, and
          MAXB.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  INMIN, INTEGER array, dimension (NPARMS)
          LAHQR vs TTQRE crossover point, &gt;= 11

 line 9:  INWIN, INTEGER array, dimension (NPARMS)
          recommended deflation window size

 line 10: INIBL, INTEGER array, dimension (NPARMS)
          nibble crossover point

 line 11:  ISHFTS, INTEGER array, dimension (NPARMS)
          number of simultaneous shifts)

 line 12:  IACC22, INTEGER array, dimension (NPARMS)
          select structured matrix multiply: 0, 1 or 2)

 line 13: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.  To have all of the test
          ratios printed, use THRESH = 0.0 .

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  The remaining lines occur in sets of 1 or 2 and allow
          the user to specify the matrix types.  Each line contains
          a 3-character path name in columns 1-3, and the number
          of matrix types must be the first nonblank item in columns
          4-80.  If the number of matrix types is at least 1 but is
          less than the maximum number of possible types, a second
          line will be read to get the numbers of the matrix types to
          be used.  For example,
 NEP 21
          requests all of the matrix types for the nonsymmetric
          eigenvalue problem, while
 NEP  4
 9 10 11 12
          requests only matrices of type 9, 10, 11, and 12.

          The valid 3-character path names are 'NEP' or 'CHS' for the
          nonsymmetric eigenvalue routines.

-----------------------------------------------------------------------

 SEP or CSG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, and NX.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 10: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 11: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 12: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 12 was 2:

 line 13: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 13-EOF:  Lines specifying matrix types, as for NEP.
          The valid 3-character path names are 'SEP' or 'CST' for the
          Hermitian eigenvalue routines and driver routines, and
          'CSG' for the routines for the Hermitian generalized
          eigenvalue problem.

-----------------------------------------------------------------------

 SVD input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 5:  NPARMS, INTEGER
          Number of values of the parameter NB, NBMIN, NX, and NRHS.

 line 6:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 7:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 8:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 9:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path names are 'SVD' or 'CBD' for both the
          SVD routines and the SVD driver routines.

-----------------------------------------------------------------------

 CEV and CES data files:

 line 1:  'CEV' or 'CES' in columns 1 to 3.

 line 2:  NSIZES, INTEGER
          Number of sizes of matrices to use. Should be at least 0
          and at most 20. If NSIZES = 0, no testing is done
          (although the remaining  3 lines are still read).

 line 3:  NN, INTEGER array, dimension(NSIZES)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHSEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 8 and following:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CEV' to test CGEEV, or
          'CES' to test CGEES.

-----------------------------------------------------------------------

 The CVX data has two parts. The first part is identical to CEV,
 and the second part consists of test matrices with precomputed
 solutions.

 line 1:  'CVX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  NEWSD, INTEGER

 If line 6 was 2:

 line 7:  INTEGER array, dimension (4)

 lines 8 and following: The first line contains 'CVX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 1+N+N**2 lines, where N is
          its dimension. The first line contains the dimension N and
          ISRT (two integers). ISRT indicates whether the last N lines
          are sorted by increasing real part of the eigenvalue
          (ISRT=0) or by increasing imaginary part (ISRT=1). The next
          N**2 lines contain the matrix rowwise, one entry per line.
          The last N lines correspond to each eigenvalue. Each of
          these last N lines contains 4 real values: the real part of
          the eigenvalues, the imaginary part of the eigenvalue, the
          reciprocal condition number of the eigenvalues, and the
          reciprocal condition number of the vector eigenvector. The
          end of data is indicated by dimension N=0. Even if no data
          is to be tested, there must be at least one line containing
          N=0.

-----------------------------------------------------------------------

 The CSX data is like CVX. The first part is identical to CEV, and the
 second part consists of test matrices with precomputed solutions.

 line 1:  'CSX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  NEWSD, INTEGER

 If line 6 was 2:

 line 7:  INTEGER array, dimension (4)

 lines 8 and following: The first line contains 'CSX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 3+N**2 lines, where N is
          its dimension. The first line contains the dimension N, the
          dimension M of an invariant subspace, and ISRT. The second
          line contains M integers, identifying the eigenvalues in the
          invariant subspace (by their position in a list of
          eigenvalues ordered by increasing real part (if ISRT=0) or
          by increasing imaginary part (if ISRT=1)). The next N**2
          lines contain the matrix rowwise. The last line contains the
          reciprocal condition number for the average of the selected
          eigenvalues, and the reciprocal condition number for the
          corresponding right invariant subspace. The end of data in
          indicated by a line containing N=0, M=0, and ISRT = 0.  Even
          if no data is to be tested, there must be at least one line
          containing N=0, M=0 and ISRT=0.

-----------------------------------------------------------------------

 CGG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NBCOL, NS, and
          MAXB.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for NBMIN, the minimum row dimension for blocks.

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of shifts.

 line 8:  MXBVAL, INTEGER array, dimension (NPARMS)
          The values for MAXB, used in determining minimum blocksize.

 line 9:  NBCOL, INTEGER array, dimension (NPARMS)
          The values for NBCOL, the minimum column dimension for
          blocks.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 16-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CGG' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 CGS and CGV input files:

 line 1:  'CGS' or 'CGV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension(NN)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 17 was 2:

 line 7:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 7-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CGS' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 CGX input file:
 line 1:  'CGX' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer).  The next line contains an integer k such
          that only the last k eigenvalues will be selected and appear
          in the leading diagonal blocks of $A$ and $B$. The next N*N
          lines contain the matrix A, one element per line. The next N*N
          lines contain the matrix B. The last line contains the
          reciprocal of the eigenvalue cluster condition number and the
          reciprocal of the deflating subspace (associated with the
          selected eigencluster) condition number.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 CXV input files:
 line 1:  'CXV' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer). The next N*N lines contain the matrix A, one
          element per line. The next N*N lines contain the matrix B.
          The next line contains the reciprocals of the eigenvalue
          condition numbers.  The last line contains the reciprocals of
          the eigenvector condition numbers.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 CHB input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix dimension K.

 line 6:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 8-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CHB'.

-----------------------------------------------------------------------

 CBB input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix bandwidth K.

 line 6:  NPARMS, INTEGER
          Number of values of the parameter NRHS

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 9 was 2:

 line 10: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 10-EOF:  Lines specifying matrix types, as for SVD.
          The 3-character path name is 'CBB'.

-----------------------------------------------------------------------

 CEC input file:

 line  2: THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 lines  3-EOF:

 Input for testing the eigencondition routines consists of a set of
 specially constructed test cases and their solutions.  The data
 format is not intended to be modified by the user.

-----------------------------------------------------------------------

 CBL and CBK input files:

 line 1:  'CBL' in columns 1-3 to test CGEBAL, or 'CBK' in
          columns 1-3 to test CGEBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 CGL and CGK input files:

 line 1:  'CGL' in columns 1-3 to test CGGBAL, or 'CGK' in
          columns 1-3 to test CGGBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 GLM data file:

 line 1:  'GLM' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension), note M &lt;= N &lt;= M+P.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GLM' for the generalized
          linear regression model routines.

-----------------------------------------------------------------------

 GQR data file:

 line 1:  'GQR' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GQR' for the generalized
          QR and RQ routines.

-----------------------------------------------------------------------

 GSV data file:

 line 1:  'GSV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 CSD data file:

 line 1:  'CSD' in columns 1 to 3.

 line 2:  NM, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NM)
          Values of M (row and column dimension of orthogonal matrix).

 line 4:  PVAL, INTEGER array, dimension(NM)
          Values of P (row dimension of top-left block).

 line 5:  NVAL, INTEGER array, dimension(NM)
          Values of N (column dimension of top-left block).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CSD' for the CSD routine.

-----------------------------------------------------------------------

 LSE data file:

 line 1:  'LSE' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N, note P &lt;= N &lt;= P+M.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 NMAX is currently set to 132 and must be at least 12 for some of the
 precomputed examples, and LWORK = NMAX*(5*NMAX+20) in the parameter
 statements below.  For SVD, we assume NRHS may be as big as N.  The
 parameter NEED is set to 14 to allow for 14 N-by-N matrices for CGG.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ga712d308fd40a2f0f279fe4a0c8544a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkgg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>TSTDIF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRSHN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>LLWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 15 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKGG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKGG  checks the nonsymmetric generalized eigenvalue problem
 routines.
                                H          H        H
 CGGHRD factors A and B as U H V  and U T V , where   means conjugate
 transpose, H is hessenberg, T is triangular and U and V are unitary.

                                 H          H
 CHGEQZ factors H and T as  Q S Z  and Q P Z , where P and S are upper
 triangular and Q and Z are unitary.  It also computes the generalized
 eigenvalues (alpha(1),beta(1)),...,(alpha(n),beta(n)), where
 alpha(j)=S(j,j) and beta(j)=P(j,j) -- thus, w(j) = alpha(j)/beta(j)
 is a root of the generalized eigenvalue problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 CTGEVC computes the matrix L of left eigenvectors and the matrix R
 of right eigenvectors for the matrix pair ( S, P ).  In the
 description below,  l and r are left and right eigenvectors
 corresponding to the generalized eigenvalues (alpha,beta).

 When CCHKGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 13
 tests will be performed.  The first twelve "test ratios" should be
 small -- O(1).  They will be compared with the threshhold THRESH:

                  H
 (1)   | A - U H V  | / ( |A| n ulp )

                  H
 (2)   | B - U T V  | / ( |B| n ulp )

               H
 (3)   | I - UU  | / ( n ulp )

               H
 (4)   | I - VV  | / ( n ulp )

                  H
 (5)   | H - Q S Z  | / ( |H| n ulp )

                  H
 (6)   | T - Q P Z  | / ( |T| n ulp )

               H
 (7)   | I - QQ  | / ( n ulp )

               H
 (8)   | I - ZZ  | / ( n ulp )

 (9)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of
                           H
       | (beta A - alpha B) l | / ( ulp max( |beta A|, |alpha B| ) )

 (10)  max over all left eigenvalue/-vector pairs (beta/alpha,l') of
                           H
       | (beta H - alpha T) l' | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors l' are the result of passing Q to
       STGEVC and back transforming (JOB='B').

 (11)  max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 (12)  max over all right eigenvalue/-vector pairs (beta/alpha,r') of

       | (beta H - alpha T) r' | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors r' are the result of passing Z to
       STGEVC and back transforming (JOB='B').

 The last three test ratios will usually be small, but there is no
 mathematical requirement that they be so.  They are therefore
 compared with THRESH only if TSTDIF is .TRUE.

 (13)  | S(Q,Z computed) - S(Q,Z not computed) | / ( |S| ulp )

 (14)  | P(Q,Z computed) - P(Q,Z not computed) | / ( |P| ulp )

 (15)  max( |alpha(Q,Z computed) - alpha(Q,Z not computed)|/|S| ,
            |beta(Q,Z computed) - beta(Q,Z not computed)|/|P| ) / ulp

 In addition, the normalization of L and R are checked, and compared
 with the threshhold THRSHN.

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is P*D1, P is a random unitary diagonal
                       matrix (i.e., with random magnitude 1 entries
                       on the diagonal), and D1=diag( 0, 1,..., N-1 )
                       (i.e., a diagonal matrix with D1(1,1)=0,
                       D1(2,2)=1, ..., D1(N,N)=N-1.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1=P*diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2=Q*diag( 0, N-3, N-4,..., 1, 0, 0 ), and
                        P and Q are random unitary diagonal matrices.
           t   t
 (16) U ( J , J ) V     where U and V are random unitary matrices.

 (17) U ( T1, T2 ) V    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        P*( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        Q*( 0, N-3, N-4,..., 1, 0, 0 )

 (18) U ( T1, T2 ) V    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) U ( T1, T2 ) V    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) U ( big*T1, small*T2 ) V   diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) U ( small*T1, big*T2 ) V   diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) U ( small*T1, small*T2 ) V diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) U ( big*T1, big*T2 ) V     diag(T1) = P*( 0, 0, 1, ..., N-3, 0 )
                                 diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) U ( T1, T2 ) V     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CCHKGG does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CCHKGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CCHKGG to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TSTDIF</td><td><pre class="fragment">          TSTDIF is LOGICAL
          Specifies whether test ratios 13-15 will be computed and
          compared with THRESH.
          = .FALSE.: Only test ratios 1-12 will be computed and tested.
                     Ratios 13-15 will be set to zero.
          = .TRUE.:  All the test ratios 1-15 will be computed and
                     tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRSHN</td><td><pre class="fragment">          THRSHN is REAL
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, H, T, S1, P1, S2, and P2.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDA, max(NN))
          The upper Hessenberg matrix computed from A by CGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is COMPLEX array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by CGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S1</td><td><pre class="fragment">          S1 is COMPLEX array, dimension (LDA, max(NN))
          The Schur (upper triangular) matrix computed from H by CHGEQZ
          when Q and Z are also computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S2</td><td><pre class="fragment">          S2 is COMPLEX array, dimension (LDA, max(NN))
          The Schur (upper triangular) matrix computed from H by CHGEQZ
          when Q and Z are not computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P1</td><td><pre class="fragment">          P1 is COMPLEX array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by CHGEQZ
          when Q and Z are also computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td><pre class="fragment">          P2 is COMPLEX array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by CHGEQZ
          when Q and Z are not computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, max(NN))
          The (left) unitary matrix computed by CGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U, V, Q, Z, EVECTL, and EVECTR.  It
          must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension (LDU, max(NN))
          The (right) unitary matrix computed by CGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDU, max(NN))
          The (left) unitary matrix computed by CHGEQZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension (LDU, max(NN))
          The (left) unitary matrix computed by CHGEQZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA1</td><td><pre class="fragment">          ALPHA1 is COMPLEX array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA1</td><td><pre class="fragment">          BETA1 is COMPLEX array, dimension (max(NN))
          The generalized eigenvalues of (A,B) computed by CHGEQZ
          when Q, Z, and the full Schur matrices are computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA3</td><td><pre class="fragment">          ALPHA3 is COMPLEX array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA3</td><td><pre class="fragment">          BETA3 is COMPLEX array, dimension (max(NN))
          The generalized eigenvalues of (A,B) computed by CHGEQZ
          when neither Q, Z, nor the Schur matrices are computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EVECTL</td><td><pre class="fragment">          EVECTL is COMPLEX array, dimension (LDU, max(NN))
          The (lower triangular) left eigenvector matrix for the
          matrices in S1 and P1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EVECTR</td><td><pre class="fragment">          EVECTR is COMPLEX array, dimension (LDU, max(NN))
          The (upper triangular) right eigenvector matrix for the
          matrices in S1 and P1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( 4*N, 2 * N**2, 1 ), for all N=NN(j).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (2*max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LLWORK</td><td><pre class="fragment">          LLWORK is LOGICAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga38c55aad209e2f68c34d7959912ee253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkgk </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKGK</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKGK tests CGGBAK, a routine for backward balancing  of
 a matrix pair (A, B).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga38ae0be71db106e536d22d0982164f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkgl </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKGL</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKGL tests CGGBAL, a routine for balancing a matrix pair (A, B).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga392b1b165355ea949383c3c5f701b0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkhb </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWDTHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>KK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKHB</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKHB tests the reduction of a Hermitian band matrix to tridiagonal
 from, used with the Hermitian eigenvalue problem.

 CHBTRD factors a Hermitian band matrix A as  U S U* , where * means
 conjugate transpose, S is symmetric tridiagonal, and U is unitary.
 CHBTRD can use either just the lower or just the upper triangle
 of A; CCHKHB checks both cases.

 When CCHKHB is called, a number of matrix "sizes" ("n's"), a number
 of bandwidths ("k's"), and a number of matrix "types" are
 specified.  For each size ("n"), each bandwidth ("k") less than or
 equal to "n", and each type of matrix, one matrix will be generated
 and used to test the hermitian banded reduction routine.  For each
 matrix, a number of tests will be performed:

 (1)     | A - V S V* | / ( |A| n ulp )  computed by CHBTRD with
                                         UPLO='U'

 (2)     | I - UU* | / ( n ulp )

 (3)     | A - V S V* | / ( |A| n ulp )  computed by CHBTRD with
                                         UPLO='L'

 (4)     | I - UU* | / ( n ulp )

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U* D U, where U is unitary and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U* D U, where U is unitary and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U* D U, where U is unitary and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Hermitian matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CCHKHB does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWDTHS</td><td><pre class="fragment">          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          CCHKHB does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KK</td><td><pre class="fragment">          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CCHKHB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CCHKHB to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension
                            (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 2 (not 1!)
          and at least max( KK )+1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is REAL array, dimension (max(NN))
          Used to hold the diagonal of the tridiagonal matrix computed
          by CHBTRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is REAL array, dimension (max(NN))
          Used to hold the off-diagonal of the tridiagonal matrix
          computed by CHBTRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, max(NN))
          Used to hold the unitary matrix computed by CHBTRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9958096d169e0e3ce8fb70643cec936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkhs </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>UZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>UU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SELECT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 14 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKHS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CCHKHS  checks the nonsymmetric eigenvalue problem routines.

            CGEHRD factors A as  U H U' , where ' means conjugate
            transpose, H is hessenberg, and U is unitary.

            CUNGHR generates the unitary matrix U.

            CUNMHR multiplies a matrix by the unitary matrix U.

            CHSEQR factors H as  Z T Z' , where Z is unitary and T
            is upper triangular.  It also computes the eigenvalues,
            w(1), ..., w(n); we define a diagonal matrix W whose
            (diagonal) entries are the eigenvalues.

            CTREVC computes the left eigenvector matrix L and the
            right eigenvector matrix R for the matrix T.  The
            columns of L are the complex conjugates of the left
            eigenvectors of T.  The columns of R are the right
            eigenvectors of T.  L is lower triangular, and R is
            upper triangular.

            CHSEIN computes the left eigenvector matrix Y and the
            right eigenvector matrix X for the matrix H.  The
            columns of Y are the complex conjugates of the left
            eigenvectors of H.  The columns of X are the right
            eigenvectors of H.  Y is lower triangular, and X is
            upper triangular.

    When CCHKHS is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 14
    tests will be performed:

    (1)     | A - U H U**H | / ( |A| n ulp )

    (2)     | I - UU**H | / ( n ulp )

    (3)     | H - Z T Z**H | / ( |H| n ulp )

    (4)     | I - ZZ**H | / ( n ulp )

    (5)     | A - UZ H (UZ)**H | / ( |A| n ulp )

    (6)     | I - UZ (UZ)**H | / ( n ulp )

    (7)     | T(Z computed) - T(Z not computed) | / ( |T| ulp )

    (8)     | W(Z computed) - W(Z not computed) | / ( |W| ulp )

    (9)     | TR - RW | / ( |T| |R| ulp )

    (10)    | L**H T - W**H L | / ( |T| |L| ulp )

    (11)    | HX - XW | / ( |H| |X| ulp )

    (12)    | Y**H H - W**H Y | / ( |H| |Y| ulp )

    (13)    | AX - XW | / ( |A| |X| ulp )

    (14)    | Y**H A - W**H Y | / ( |A| |Y| ulp )

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by SQRT( overflow threshold )
    (8)  Same as (4), but multiplied by SQRT( underflow threshold )

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random complex
         angles on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is unitary and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP &lt; |z| &lt; 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from   ULP &lt; |z| &lt; 1   and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by SQRT( overflow threshold )
    (18) Same as (16), but multiplied by SQRT( underflow threshold )

    (19) Nonsymmetric matrix with random entries chosen from |z| &lt; 1
    (20) Same as (19), but multiplied by SQRT( overflow threshold )
    (21) Same as (19), but multiplied by SQRT( underflow threshold )</pre> <pre class="fragment">  NSIZES - INTEGER
           The number of sizes of matrices to use.  If it is zero,
           CCHKHS does nothing.  It must be at least zero.
           Not modified.

  NN     - INTEGER array, dimension (NSIZES)
           An array containing the sizes to be used for the matrices.
           Zero values will be skipped.  The values must be at least
           zero.
           Not modified.

  NTYPES - INTEGER
           The number of elements in DOTYPE.   If it is zero, CCHKHS
           does nothing.  It must be at least zero.  If it is MAXTYP+1
           and NSIZES is 1, then an additional type, MAXTYP+1 is
           defined, which is to use whatever matrix is in A.  This
           is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
           DOTYPE(MAXTYP+1) is .TRUE. .
           Not modified.

  DOTYPE - LOGICAL array, dimension (NTYPES)
           If DOTYPE(j) is .TRUE., then for each size in NN a
           matrix of that size and of type j will be generated.
           If NTYPES is smaller than the maximum number of types
           defined (PARAMETER MAXTYP), then types NTYPES+1 through
           MAXTYP will not be generated.  If NTYPES is larger
           than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
           will be ignored.
           Not modified.

  ISEED  - INTEGER array, dimension (4)
           On entry ISEED specifies the seed of the random number
           generator. The array elements should be between 0 and 4095;
           if not they will be reduced mod 4096.  Also, ISEED(4) must
           be odd.  The random number generator uses a linear
           congruential sequence limited to small integers, and so
           should produce machine independent random numbers. The
           values of ISEED are changed on exit, and can be used in the
           next call to CCHKHS to continue the same random number
           sequence.
           Modified.

  THRESH - REAL
           A test will count as "failed" if the "error", computed as
           described above, exceeds THRESH.  Note that the error
           is scaled to be O(1), so THRESH should be a reasonably
           small multiple of 1, e.g., 10 or 100.  In particular,
           it should not depend on the precision (single vs. double)
           or the size of the matrix.  It must be at least zero.
           Not modified.

  NOUNIT - INTEGER
           The FORTRAN unit number for printing out error messages
           (e.g., if a routine returns IINFO not equal to 0.)
           Not modified.

  A      - COMPLEX array, dimension (LDA,max(NN))
           Used to hold the matrix whose eigenvalues are to be
           computed.  On exit, A contains the last matrix actually
           used.
           Modified.

  LDA    - INTEGER
           The leading dimension of A, H, T1 and T2.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  H      - COMPLEX array, dimension (LDA,max(NN))
           The upper hessenberg matrix computed by CGEHRD.  On exit,
           H contains the Hessenberg form of the matrix in A.
           Modified.

  T1     - COMPLEX array, dimension (LDA,max(NN))
           The Schur (="quasi-triangular") matrix computed by CHSEQR
           if Z is computed.  On exit, T1 contains the Schur form of
           the matrix in A.
           Modified.

  T2     - COMPLEX array, dimension (LDA,max(NN))
           The Schur matrix computed by CHSEQR when Z is not computed.
           This should be identical to T1.
           Modified.

  LDU    - INTEGER
           The leading dimension of U, Z, UZ and UU.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  U      - COMPLEX array, dimension (LDU,max(NN))
           The unitary matrix computed by CGEHRD.
           Modified.

  Z      - COMPLEX array, dimension (LDU,max(NN))
           The unitary matrix computed by CHSEQR.
           Modified.

  UZ     - COMPLEX array, dimension (LDU,max(NN))
           The product of U times Z.
           Modified.

  W1     - COMPLEX array, dimension (max(NN))
           The eigenvalues of A, as computed by a full Schur
           decomposition H = Z T Z'.  On exit, W1 contains the
           eigenvalues of the matrix in A.
           Modified.

  W3     - COMPLEX array, dimension (max(NN))
           The eigenvalues of A, as computed by a partial Schur
           decomposition (Z not computed, T only computed as much
           as is necessary for determining eigenvalues).  On exit,
           W3 contains the eigenvalues of the matrix in A, possibly
           perturbed by CHSEIN.
           Modified.

  EVECTL - COMPLEX array, dimension (LDU,max(NN))
           The conjugate transpose of the (upper triangular) left
           eigenvector matrix for the matrix in T1.
           Modified.

  EVECTR - COMPLEX array, dimension (LDU,max(NN))
           The (upper triangular) right eigenvector matrix for the
           matrix in T1.
           Modified.

  EVECTY - COMPLEX array, dimension (LDU,max(NN))
           The conjugate transpose of the left eigenvector matrix
           for the matrix in H.
           Modified.

  EVECTX - COMPLEX array, dimension (LDU,max(NN))
           The right eigenvector matrix for the matrix in H.
           Modified.

  UU     - COMPLEX array, dimension (LDU,max(NN))
           Details of the unitary matrix computed by CGEHRD.
           Modified.

  TAU    - COMPLEX array, dimension (max(NN))
           Further details of the unitary matrix computed by CGEHRD.
           Modified.

  WORK   - COMPLEX array, dimension (NWORK)
           Workspace.
           Modified.

  NWORK  - INTEGER
           The number of entries in WORK.  NWORK &gt;= 4*NN(j)*NN(j) + 2.

  RWORK  - REAL array, dimension (max(NN))
           Workspace.  Could be equivalenced to IWORK, but not SELECT.
           Modified.

  IWORK  - INTEGER array, dimension (max(NN))
           Workspace.
           Modified.

  SELECT - LOGICAL array, dimension (max(NN))
           Workspace.  Could be equivalenced to IWORK, but not RWORK.
           Modified.

  RESULT - REAL array, dimension (14)
           The values computed by the fourteen tests described above.
           The values are currently limited to 1/ulp, to avoid
           overflow.
           Modified.

  INFO   - INTEGER
           If 0, then everything ran OK.
            -1: NSIZES &lt; 0
            -2: Some NN(j) &lt; 0
            -3: NTYPES &lt; 0
            -6: THRESH &lt; 0
            -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
           -14: LDU &lt; 1 or LDU &lt; NMAX.
           -26: NWORK too small.
           If  CLATMR, CLATMS, or CLATME returns an error code, the
               absolute value of it is returned.
           If 1, then CHSEQR could not find all the shifts.
           If 2, then the EISPACK code (for small blocks) failed.
           If &gt;2, then 30*N iterations were not enough to find an
               eigenvalue or to decompose the problem.
           Modified.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     MTEST           The number of tests defined: care must be taken
                     that (1) the size of RESULT, (2) the number of
                     tests actually performed, and (3) MTEST agree.
     NTEST           The number of tests performed on this matrix
                     so far.  This should be less than MTEST, and
                     equal to it by the last test.  It will be less
                     if any of the routines being tested indicates
                     that it could not compute the matrices that
                     would be tested.
     NMAX            Largest value in NN.
     NMATS           The number of matrices generated so far.
     NERRS           The number of tests which have exceeded THRESH
                     so far (computed by SLAFTS).
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTOVFL, RTUNFL,
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selects whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga525d1a2df6511f9a488f0dd914a45baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cchkst </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WA3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LRWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCHKST</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCHKST  checks the Hermitian eigenvalue problem routines.

    CHETRD factors A as  U S U* , where * means conjugate transpose,
    S is real symmetric tridiagonal, and U is unitary.
    CHETRD can use either just the lower or just the upper triangle
    of A; CCHKST checks both cases.
    U is represented as a product of Householder
    transformations, whose vectors are stored in the first
    n-1 columns of V, and whose scale factors are in TAU.

    CHPTRD does the same as CHETRD, except that A and V are stored
    in "packed" format.

    CUNGTR constructs the matrix U from the contents of V and TAU.

    CUPGTR constructs the matrix U from the contents of VP and TAU.

    CSTEQR factors S as  Z D1 Z* , where Z is the unitary
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal.  D2 is the matrix of
    eigenvalues computed when Z is not computed.

    SSTERF computes D3, the matrix of eigenvalues, by the
    PWK method, which does not yield eigenvectors.

    CPTEQR factors S as  Z4 D4 Z4* , for a
    Hermitian positive definite tridiagonal matrix.
    D5 is the matrix of eigenvalues computed when Z is not
    computed.

    SSTEBZ computes selected eigenvalues.  WA1, WA2, and
    WA3 will denote eigenvalues computed to high
    absolute accuracy, with different range options.
    WR will denote eigenvalues computed to high relative
    accuracy.

    CSTEIN computes Y, the eigenvectors of S, given the
    eigenvalues.

    CSTEDC factors S as Z D1 Z* , where Z is the unitary
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option). It may also
    update an input unitary matrix, usually the output
    from CHETRD/CUNGTR or CHPTRD/CUPGTR ('V' option). It may
    also just compute eigenvalues ('N' option).

    CSTEMR factors S as Z D1 Z* , where Z is the unitary
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option).  CSTEMR
    uses the Relatively Robust Representation whenever possible.

 When CCHKST is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the Hermitian eigenroutines.  For each matrix, a number
 of tests will be performed:

 (1)     | A - V S V* | / ( |A| n ulp ) CHETRD( UPLO='U', ... )

 (2)     | I - UV* | / ( n ulp )        CUNGTR( UPLO='U', ... )

 (3)     | A - V S V* | / ( |A| n ulp ) CHETRD( UPLO='L', ... )

 (4)     | I - UV* | / ( n ulp )        CUNGTR( UPLO='L', ... )

 (5-8)   Same as 1-4, but for CHPTRD and CUPGTR.

 (9)     | S - Z D Z* | / ( |S| n ulp ) CSTEQR('V',...)

 (10)    | I - ZZ* | / ( n ulp )        CSTEQR('V',...)

 (11)    | D1 - D2 | / ( |D1| ulp )        CSTEQR('N',...)

 (12)    | D1 - D3 | / ( |D1| ulp )        SSTERF

 (13)    0 if the true eigenvalues (computed by sturm count)
         of S are within THRESH of
         those in D1.  2*THRESH if they are not.  (Tested using
         SSTECH)

 For S positive definite,

 (14)    | S - Z4 D4 Z4* | / ( |S| n ulp ) CPTEQR('V',...)

 (15)    | I - Z4 Z4* | / ( n ulp )        CPTEQR('V',...)

 (16)    | D4 - D5 | / ( 100 |D4| ulp )       CPTEQR('N',...)

 When S is also diagonally dominant by the factor gamma &lt; 1,

 (17)    max | D4(i) - WR(i) | / ( |D4(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              SSTEBZ( 'A', 'E', ...)

 (18)    | WA1 - D3 | / ( |D3| ulp )          SSTEBZ( 'A', 'E', ...)

 (19)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
                                              SSTEBZ( 'I', 'E', ...)

 (20)    | S - Y WA1 Y* | / ( |S| n ulp )  SSTEBZ, CSTEIN

 (21)    | I - Y Y* | / ( n ulp )          SSTEBZ, CSTEIN

 (22)    | S - Z D Z* | / ( |S| n ulp )    CSTEDC('I')

 (23)    | I - ZZ* | / ( n ulp )           CSTEDC('I')

 (24)    | S - Z D Z* | / ( |S| n ulp )    CSTEDC('V')

 (25)    | I - ZZ* | / ( n ulp )           CSTEDC('V')

 (26)    | D1 - D2 | / ( |D1| ulp )           CSTEDC('V') and
                                              CSTEDC('N')

 Test 27 is disabled at the moment because CSTEMR does not
 guarantee high relatvie accuracy.

 (27)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              CSTEMR('V', 'A')

 (28)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              CSTEMR('V', 'I')

 Tests 29 through 34 are disable at present because CSTEMR
 does not handle partial specturm requests.

 (29)    | S - Z D Z* | / ( |S| n ulp )    CSTEMR('V', 'I')

 (30)    | I - ZZ* | / ( n ulp )           CSTEMR('V', 'I')

 (31)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         CSTEMR('N', 'I') vs. CSTEMR('V', 'I')

 (32)    | S - Z D Z* | / ( |S| n ulp )    CSTEMR('V', 'V')

 (33)    | I - ZZ* | / ( n ulp )           CSTEMR('V', 'V')

 (34)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         CSTEMR('N', 'V') vs. CSTEMR('V', 'V')

 (35)    | S - Z D Z* | / ( |S| n ulp )    CSTEMR('V', 'A')

 (36)    | I - ZZ* | / ( n ulp )           CSTEMR('V', 'A')

 (37)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         CSTEMR('N', 'A') vs. CSTEMR('V', 'A')

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U* D U, where U is unitary and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U* D U, where U is unitary and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U* D U, where U is unitary and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Hermitian matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )
 (16) Same as (8), but diagonal elements are all positive.
 (17) Same as (9), but diagonal elements are all positive.
 (18) Same as (10), but diagonal elements are all positive.
 (19) Same as (16), but multiplied by SQRT( overflow threshold )
 (20) Same as (16), but multiplied by SQRT( underflow threshold )
 (21) A diagonally dominant tridiagonal matrix with geometrically
      spaced diagonal entries 1, ..., ULP.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CCHKST does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CCHKST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CCHKST to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array of
                                  dimension ( LDA , max(NN) )
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AP</td><td><pre class="fragment">          AP is COMPLEX array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix A stored in packed format.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is REAL array of
                             dimension( max(NN) )
          The diagonal of the tridiagonal matrix computed by CHETRD.
          On exit, SD and SE contain the tridiagonal form of the
          matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is REAL array of
                             dimension( max(NN) )
          The off-diagonal of the tridiagonal matrix computed by
          CHETRD.  On exit, SD and SE contain the tridiagonal form of
          the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D1</td><td><pre class="fragment">          D1 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by CSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D2</td><td><pre class="fragment">          D2 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by CSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D3</td><td><pre class="fragment">          D3 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by SSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D4</td><td><pre class="fragment">          D4 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by CPTEQR(V).
          ZPTEQR factors S as  Z4 D4 Z4*
          On exit, the eigenvalues in D4 correspond with the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D5</td><td><pre class="fragment">          D5 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by ZPTEQR(N)
          when Z is not computed. On exit, the
          eigenvalues in D4 correspond with the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WA1</td><td><pre class="fragment">          WA1 is REAL array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by SSTEBZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WA2</td><td><pre class="fragment">          WA2 is REAL array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by SSTEBZ.
          Choose random values for IL and IU, and ask for the
          IL-th through IU-th eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WA3</td><td><pre class="fragment">          WA3 is REAL array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by SSTEBZ.
          Determine the values VL and VU of the IL-th and IU-th
          eigenvalues and ask for all eigenvalues in this range.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different options.
          as computed by DSTEBZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array of
                             dimension( LDU, max(NN) ).
          The unitary matrix computed by CHETRD + CUNGTR.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U, Z, and V.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array of
                             dimension( LDU, max(NN) ).
          The Housholder vectors computed by CHETRD in reducing A to
          tridiagonal form.  The vectors computed with UPLO='U' are
          in the upper triangle, and the vectors computed with UPLO='L'
          are in the lower triangle.  (As described in CHETRD, the
          sub- and superdiagonal are not set to 1, although the
          true Householder vector has a 1 in that position.  The
          routines that use V, such as CUNGTR, set those entries to
          1 before using them, and then restore them later.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VP</td><td><pre class="fragment">          VP is COMPLEX array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix V stored in packed format.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is COMPLEX array of
                             dimension( max(NN) )
          The Householder factors computed by CHETRD in reducing A
          to tridiagonal form.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array of
                             dimension( LDU, max(NN) ).
          The unitary matrix of eigenvectors computed by CSTEQR,
          CPTEQR, and CSTEIN.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array of
                      dimension( LWORK )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          1 + 4 * Nmax + 2 * Nmax * lg Nmax + 3 * Nmax**2
          where Nmax = max( NN(j), 2 ) and lg = log base 2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array,
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          The number of entries in IWORK.  This must be at least
                  6 + 6*Nmax + 5 * Nmax * lg Nmax 
          where Nmax = max( NN(j), 2 ) and lg = log base 2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LRWORK</td><td><pre class="fragment">          LRWORK is INTEGER
          The number of entries in LRWORK (dimension( ??? )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (26)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -5: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -23: LDU &lt; 1 or LDU &lt; NMAX.
          -29: LWORK too small.
          If  CLATMR, CLATMS, CHETRD, CUNGTR, CSTEQR, SSTERF,
              or CUNMC2 returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NBLOCK          Blocksize as returned by ENVIR.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab577d9fd38a6d67157f0b7a22090bd76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cckcsd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>QVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>XF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V1T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V2T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>THETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCKCSD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCKCSD tests CUNCSD:
        the CSD for an M-by-M unitary matrix X partitioned as
        [ X11 X12; X21 X22 ]. X11 is P-by-Q.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NM</td><td><pre class="fragment">          NM is INTEGER
          The number of values of M contained in the vector MVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QVAL</td><td><pre class="fragment">          QVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MMAX</td><td><pre class="fragment">          MMAX is INTEGER
          The maximum value permitted for M, used in dimensioning the
          work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">XF</td><td><pre class="fragment">          XF is COMPLEX array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U1</td><td><pre class="fragment">          U1 is COMPLEX array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is COMPLEX array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V1T</td><td><pre class="fragment">          V1T is COMPLEX array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V2T</td><td><pre class="fragment">          V2T is COMPLEX array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">THETA</td><td><pre class="fragment">          THETA is REAL array, dimension (MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If CLAROR returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga02f888d1e47ac0a876793161ada51c49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cckglm </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCKGLM</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCKGLM tests CGGGLM - subroutine for solving generalized linear
                       model problem.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER
          The number of values of N, M and P contained in the vectors
          NVAL, MVAL and PVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix row dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESID &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (4*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If CLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gac0da4fbc5a2c02b848f49c0dd9c3f893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cckgqr </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCKGQR</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCKGQR tests
 CGGQRF: GQR factorization for N-by-M matrix A and N-by-P matrix B,
 CGGRQF: GRQ factorization for M-by-N matrix A and P-by-N matrix B.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NM</td><td><pre class="fragment">          NM is INTEGER
          The number of values of M contained in the vector MVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row(column) dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NP</td><td><pre class="fragment">          NP is INTEGER
          The number of values of P contained in the vector PVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row(column) dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER
          The number of values of N contained in the vector NVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AQ</td><td><pre class="fragment">          AQ is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AR</td><td><pre class="fragment">          AR is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUA</td><td><pre class="fragment">          TAUA is COMPLEX array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BZ</td><td><pre class="fragment">          BZ is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BT</td><td><pre class="fragment">          BT is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWK</td><td><pre class="fragment">          BWK is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUB</td><td><pre class="fragment">          TAUB is COMPLEX array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If CLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab332c713db9ff9a65c6b4ee66173021c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cckgsv </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCKGSV</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCKGSV tests CGGSVD:
        the GSVD for M-by-N matrix A and P-by-N matrix B.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NM</td><td><pre class="fragment">          NM is INTEGER
          The number of values of M contained in the vector MVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If CLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b0a12a9548976fc736b24a730538084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ccklse </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCKLSE</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCKLSE tests CGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER
          The number of values of (M,P,N) contained in the vectors
          (MVAL, PVAL, NVAL).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (5*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If CLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gafa5cdc631c988f7e170b0829ef5e1b08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ccsdts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>XF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu1, * )&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu2, * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv1t, * )&#160;</td>
          <td class="paramname"><em>V1T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV1T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv2t, * )&#160;</td>
          <td class="paramname"><em>V2T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV2T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>THETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 15 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CCSDTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CCSDTS tests CUNCSD, which, given an M-by-M partitioned unitary
 matrix X,
              Q  M-Q
       X = [ X11 X12 ] P   ,
           [ X21 X22 ] M-P

 computes the CSD

       [ U1    ]**T * [ X11 X12 ] * [ V1    ]
       [    U2 ]      [ X21 X22 ]   [    V2 ]

                             [  I  0  0 |  0  0  0 ]
                             [  0  C  0 |  0 -S  0 ]
                             [  0  0  0 |  0  0 -I ]
                           = [---------------------] = [ D11 D12 ] .
                             [  0  0  0 |  I  0  0 ]   [ D21 D22 ]
                             [  0  S  0 |  0  C  0 ]
                             [  0  0  I |  0  0  0 ]

 and also SORCSD2BY1, which, given
          Q
       [ X11 ] P   ,
       [ X21 ] M-P

 computes the 2-by-1 CSD

                                     [  I  0  0 ]
                                     [  0  C  0 ]
                                     [  0  0  0 ]
       [ U1    ]**T * [ X11 ] * V1 = [----------] = [ D11 ] ,
       [    U2 ]      [ X21 ]        [  0  0  0 ]   [ D21 ]
                                     [  0  S  0 ]
                                     [  0  0  I ]</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix X.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix X11.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is INTEGER
          The number of columns of the matrix X11.  Q &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (LDX,M)
          The M-by-M matrix X.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">XF</td><td><pre class="fragment">          XF is COMPLEX array, dimension (LDX,M)
          Details of the CSD of X, as returned by CUNCSD;
          see CUNCSD for further details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the arrays X and XF.
          LDX &gt;= max( 1,M ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U1</td><td><pre class="fragment">          U1 is COMPLEX array, dimension(LDU1,P)
          The P-by-P unitary matrix U1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU1</td><td><pre class="fragment">          LDU1 is INTEGER
          The leading dimension of the array U1. LDU &gt;= max(1,P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is COMPLEX array, dimension(LDU2,M-P)
          The (M-P)-by-(M-P) unitary matrix U2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU2</td><td><pre class="fragment">          LDU2 is INTEGER
          The leading dimension of the array U2. LDU &gt;= max(1,M-P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V1T</td><td><pre class="fragment">          V1T is COMPLEX array, dimension(LDV1T,Q)
          The Q-by-Q unitary matrix V1T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV1T</td><td><pre class="fragment">          LDV1T is INTEGER
          The leading dimension of the array V1T. LDV1T &gt;=
          max(1,Q).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V2T</td><td><pre class="fragment">          V2T is COMPLEX array, dimension(LDV2T,M-Q)
          The (M-Q)-by-(M-Q) unitary matrix V2T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV2T</td><td><pre class="fragment">          LDV2T is INTEGER
          The leading dimension of the array V2T. LDV2T &gt;=
          max(1,M-Q).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">THETA</td><td><pre class="fragment">          THETA is REAL array, dimension MIN(P,M-P,Q,M-Q)
          The CS values of X; the essentially diagonal matrices C and
          S are constructed from THETA; see subroutine CUNCSD for
          details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (15)
          The test ratios:
          First, the 2-by-2 CSD:
          RESULT(1) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(2) = norm( U1'*X12*V2 - D12 ) / ( MAX(1,P,M-Q)*EPS2 )
          RESULT(3) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(4) = norm( U2'*X22*V2 - D22 ) / ( MAX(1,M-P,M-Q)*EPS2 )
          RESULT(5) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(6) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(7) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(8) = norm( I - V2T'*V2T ) / ( MAX(1,M-Q)*ULP )
          RESULT(9) = 0        if THETA is in increasing order and
                               all angles are in [0,pi/2];
                    = ULPINV   otherwise.
          Then, the 2-by-1 CSD:
          RESULT(10) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(11) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(12) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(13) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(14) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(15) = 0        if THETA is in increasing order and
                                all angles are in [0,pi/2];
                     = ULPINV   otherwise.
          ( EPS2 = MAX( norm( I - X'*X ) / M, ULP ). )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9768e84ddc8b8b97e11717e35c5269fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrges </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 13 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRGES</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CDRGES checks the nonsymmetric generalized eigenvalue (Schur form)
 problem driver CGGES.

 CGGES factors A and B as Q*S*Z'  and Q*T*Z' , where ' means conjugate
 transpose, S and T are  upper triangular (i.e., in generalized Schur
 form), and Q and Z are unitary. It also computes the generalized
 eigenvalues (alpha(j),beta(j)), j=1,...,n.  Thus,
 w(j) = alpha(j)/beta(j) is a root of the characteristic equation

                 det( A - w(j) B ) = 0

 Optionally it also reorder the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms.

 When CDRGES is called, a number of matrix "sizes" ("N's") and a
 number of matrix "TYPES" are specified.  For each size ("N")
 and each TYPE of matrix, a pair of matrices (A, B) will be generated
 and used for testing. For each matrix pair, the following 13 tests
 will be performed and compared with the threshhold THRESH except
 the tests (5), (11) and (13).


 (1)   | A - Q S Z' | / ( |A| n ulp ) (no sorting of eigenvalues)


 (2)   | B - Q T Z' | / ( |B| n ulp ) (no sorting of eigenvalues)


 (3)   | I - QQ' | / ( n ulp ) (no sorting of eigenvalues)


 (4)   | I - ZZ' | / ( n ulp ) (no sorting of eigenvalues)

 (5)   if A is in Schur form (i.e. triangular form) (no sorting of
       eigenvalues)

 (6)   if eigenvalues = diagonal elements of the Schur form (S, T),
       i.e., test the maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       (no sorting of eigenvalues)

 (7)   | (A,B) - Q (S,T) Z' | / ( |(A,B)| n ulp )
       (with sorting of eigenvalues).

 (8)   | I - QQ' | / ( n ulp ) (with sorting of eigenvalues).

 (9)   | I - ZZ' | / ( n ulp ) (with sorting of eigenvalues).

 (10)  if A is in Schur form (i.e. quasi-triangular form)
       (with sorting of eigenvalues).

 (11)  if eigenvalues = diagonal elements of the Schur form (S, T),
       i.e. test the maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       (with sorting of eigenvalues).

 (12)  if sorting worked and SDIM is the number of eigenvalues
       which were CELECTed.

 Test Matrices
 =============

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRGES does nothing.  NSIZES &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRGES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A on input.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRGES to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  THRESH &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is COMPLEX array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by CGGES.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is COMPLEX array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by CGGES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDQ, max(NN))
          The (left) orthogonal matrix computed by CGGES.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by CGGES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by CGGES.
          ALPHA(k) / BETA(k) is the k-th generalized eigenvalue of A
          and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.  LWORK &gt;= 3*N*N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension ( 8*N )
          Real workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gac1ee1e6b74cbcaedfebbee8b8784c2a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrgev </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldqe, * )&#160;</td>
          <td class="paramname"><em>QE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRGEV</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CDRGEV checks the nonsymmetric generalized eigenvalue problem driver
 routine CGGEV.

 CGGEV computes for a pair of n-by-n nonsymmetric matrices (A,B) the
 generalized eigenvalues and, optionally, the left and right
 eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio  alpha/beta = w, such that A - w*B is singular.  It is
 usually represented as the pair (alpha,beta), as there is reasonalbe
 interpretation for beta=0, and even for both being zero.

 A right generalized eigenvector corresponding to a generalized
 eigenvalue  w  for a pair of matrices (A,B) is a vector r  such that
 (A - wB) * r = 0.  A left generalized eigenvector is a vector l such
 that l**H * (A - wB) = 0, where l**H is the conjugate-transpose of l.

 When CDRGEV is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, a pair of matrices (A, B) will be generated
 and used for testing.  For each matrix pair, the following tests
 will be performed and compared with the threshhold THRESH.

 Results from CGGEV:

 (1)  max over all left eigenvalue/-vector pairs (alpha/beta,l) of

      | VL**H * (beta A - alpha B) |/( ulp max(|beta A|, |alpha B|) )

      where VL**H is the conjugate-transpose of VL.

 (2)  | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

 (3)  max over all left eigenvalue/-vector pairs (alpha/beta,r) of

      | (beta A - alpha B) * VR | / ( ulp max(|beta A|, |alpha B|) )

 (4)  | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

 (5)  W(full) = W(partial)
      W(full) denotes the eigenvalues computed when both l and r
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and r, or only W and l are
      computed.

 (6)  VL(full) = VL(partial)
      VL(full) denotes the left eigenvectors computed when both l
      and r are computed, and VL(partial) denotes the result
      when only l is computed.

 (7)  VR(full) = VR(partial)
      VR(full) denotes the right eigenvectors computed when both l
      and r are also computed, and VR(partial) denotes the result
      when only l is computed.


 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CDRGES does nothing.  NSIZES &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CDRGEV
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRGES to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IERR not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is COMPLEX array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by CGGEV.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is COMPLEX array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by CGGEV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDQ, max(NN))
          The (left) eigenvectors matrix computed by CGGEV.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by CGGEV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">QE</td><td><pre class="fragment">          QE is COMPLEX array, dimension( LDQ, max(NN) )
          QE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQE</td><td><pre class="fragment">          LDQE is INTEGER
          The leading dimension of QE. LDQE &gt;= max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by CGGEV.
          ( ALPHAR(k)+ALPHAI(k)*i ) / BETA(k) is the k-th
          generalized eigenvalue of A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA1</td><td><pre class="fragment">          ALPHA1 is COMPLEX array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA1</td><td><pre class="fragment">          BETA1 is COMPLEX array, dimension (max(NN))

          Like ALPHAR, ALPHAI, BETA, these arrays contain the
          eigenvalues of A and B, but those computed when CGGEV only
          computes a partial eigendecomposition, i.e. not the
          eigenvalues and left and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  LWORK &gt;= N*(N+1)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (8*N)
          Real workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga21eb09898bd5e7259abc7e07868c3687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrgsx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NCMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>BI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRGSX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CDRGSX checks the nonsymmetric generalized eigenvalue (Schur form)
 problem expert driver CGGESX.

 CGGES factors A and B as Q*S*Z'  and Q*T*Z' , where ' means conjugate
 transpose, S and T are  upper triangular (i.e., in generalized Schur
 form), and Q and Z are unitary. It also computes the generalized
 eigenvalues (alpha(j),beta(j)), j=1,...,n.  Thus,
 w(j) = alpha(j)/beta(j) is a root of the characteristic equation

                 det( A - w(j) B ) = 0

 Optionally it also reorders the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms; computes a reciprocal condition number for the average
 of the selected eigenvalues; and computes a reciprocal condition
 number for the right and left deflating subspaces corresponding to
 the selected eigenvalues.

 When CDRGSX is called with NSIZE &gt; 0, five (5) types of built-in
 matrix pairs are used to test the routine CGGESX.

 When CDRGSX is called with NSIZE = 0, it reads in test matrix data
 to test CGGESX.
 (need more details on what kind of read-in data are needed).

 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH except for the tests (7) and (9):

 (1)   | A - Q S Z' | / ( |A| n ulp )

 (2)   | B - Q T Z' | / ( |B| n ulp )

 (3)   | I - QQ' | / ( n ulp )

 (4)   | I - ZZ' | / ( n ulp )

 (5)   if A is in Schur form (i.e. triangular form)

 (6)   maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

 (7)   if sorting worked and SDIM is the number of eigenvalues
       which were selected.

 (8)   the estimated value DIF does not differ from the true values of
       Difu and Difl more than a factor 10*THRESH. If the estimate DIF
       equals zero the corresponding true values of Difu and Difl
       should be less than EPS*norm(A, B). If the true value of Difu
       and Difl equal zero, the estimate DIF should be less than
       EPS*norm(A, B).

 (9)   If INFO = N+3 is returned by CGGESX, the reordering "failed"
       and we check that DIF = PL = PR = 0 and that the true value of
       Difu and Difl is &lt; EPS*norm(A, B). We count the events when
       INFO=N+3.

 For read-in test matrices, the same tests are run except that the
 exact value for DIF (and PL) is input data.  Additionally, there is
 one more test run for read-in test matrices:

 (10)  the estimated value PL does not differ from the true value of
       PLTRU more than a factor THRESH. If the estimate PL equals
       zero the corresponding true value of PLTRU should be less than
       EPS*norm(A, B). If the true value of PLTRU equal zero, the
       estimate PL should be less than EPS*norm(A, B).

 Note that for the built-in tests, a total of 10*NSIZE*(NSIZE-1)
 matrix pairs are generated and tested. NSIZE should be kept small.

 SVD (routine CGESVD) is used for computing the true value of DIF_u
 and DIF_l when testing the built-in test problems.

 Built-in Test Matrices
 ======================

 All built-in test matrices are the 2 by 2 block of triangular
 matrices

          A = [ A11 A12 ]    and      B = [ B11 B12 ]
              [     A22 ]                 [     B22 ]

 where for different type of A11 and A22 are given as the following.
 A12 and B12 are chosen so that the generalized Sylvester equation

          A11*R - L*A22 = -A12
          B11*R - L*B22 = -B12

 have prescribed solution R and L.

 Type 1:  A11 = J_m(1,-1) and A_22 = J_k(1-a,1).
          B11 = I_m, B22 = I_k
          where J_k(a,b) is the k-by-k Jordan block with ``a'' on
          diagonal and ``b'' on superdiagonal.

 Type 2:  A11 = (a_ij) = ( 2(.5-sin(i)) ) and
          B11 = (b_ij) = ( 2(.5-sin(ij)) ) for i=1,...,m, j=i,...,m
          A22 = (a_ij) = ( 2(.5-sin(i+j)) ) and
          B22 = (b_ij) = ( 2(.5-sin(ij)) ) for i=m+1,...,k, j=i,...,k

 Type 3:  A11, A22 and B11, B22 are chosen as for Type 2, but each
          second diagonal block in A_11 and each third diagonal block
          in A_22 are made as 2 by 2 blocks.

 Type 4:  A11 = ( 20(.5 - sin(ij)) ) and B22 = ( 2(.5 - sin(i+j)) )
             for i=1,...,m,  j=1,...,m and
          A22 = ( 20(.5 - sin(i+j)) ) and B22 = ( 2(.5 - sin(ij)) )
             for i=m+1,...,k,  j=m+1,...,k

 Type 5:  (A,B) and have potentially close or common eigenvalues and
          very large departure from block diagonality A_11 is chosen
          as the m x m leading submatrix of A_1:
                  |  1  b                            |
                  | -b  1                            |
                  |        1+d  b                    |
                  |         -b 1+d                   |
           A_1 =  |                  d  1            |
                  |                 -1  d            |
                  |                        -d  1     |
                  |                        -1 -d     |
                  |                               1  |
          and A_22 is chosen as the k x k leading submatrix of A_2:
                  | -1  b                            |
                  | -b -1                            |
                  |       1-d  b                     |
                  |       -b  1-d                    |
           A_2 =  |                 d 1+b            |
                  |               -1-b d             |
                  |                       -d  1+b    |
                  |                      -1+b  -d    |
                  |                              1-d |
          and matrix B are chosen as identity matrices (see SLATM5).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZE</td><td><pre class="fragment">          NSIZE is INTEGER
          The maximum size of the matrices to use. NSIZE &gt;= 0.
          If NSIZE = 0, no built-in tests matrices are used, but
          read-in test matrices are used to test SGGESX.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NCMAX</td><td><pre class="fragment">          NCMAX is INTEGER
          Maximum allowable NMAX for generating Kroneker matrix
          in call to CLAKF2</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  THRESH &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Z and Q,
          LDA &gt;= max( 1, NSIZE ). For the read-in test,
          LDA &gt;= max( 1, N ), N is the size of the test matrices.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AI</td><td><pre class="fragment">          AI is COMPLEX array, dimension (LDA, NSIZE)
          Copy of A, modified by CGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BI</td><td><pre class="fragment">          BI is COMPLEX array, dimension (LDA, NSIZE)
          Copy of B, modified by CGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension (LDA, NSIZE)
          Z holds the left Schur vectors computed by CGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDA, NSIZE)
          Q holds the right Schur vectors computed by CGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX array, dimension (NSIZE)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX array, dimension (NSIZE)

          On exit, ALPHA/BETA are the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX array, dimension (LDC, LDC)
          Store the matrix generated by subroutine CLAKF2, this is the
          matrix formed by Kronecker products used for estimating
          DIF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of C. LDC &gt;= max(1, LDA*LDA/2 ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL array, dimension (LDC)
          Singular values of C</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.  LWORK &gt;= 3*NSIZE*NSIZE/2</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array,
                                 dimension (5*NSIZE*NSIZE/2 - 4)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (LIWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          The dimension of the array IWORK. LIWORK &gt;= NSIZE + 2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (NSIZE)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gac4baee2f642cf143c6b713d3f12e56bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrgvx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>BI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>LSCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RSCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>STRU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DIF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFTRU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 4 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRGVX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CDRGVX checks the nonsymmetric generalized eigenvalue problem
 expert driver CGGEVX.

 CGGEVX computes the generalized eigenvalues, (optionally) the left
 and/or right eigenvectors, (optionally) computes a balancing
 transformation to improve the conditioning, and (optionally)
 reciprocal condition numbers for the eigenvalues and eigenvectors.

 When CDRGVX is called with NSIZE &gt; 0, two types of test matrix pairs
 are generated by the subroutine SLATM6 and test the driver CGGEVX.
 The test matrices have the known exact condition numbers for
 eigenvalues. For the condition numbers of the eigenvectors
 corresponding the first and last eigenvalues are also know
 ``exactly'' (see CLATM6).
 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH.

 (1) max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

     where l**H is the conjugate tranpose of l.

 (2) max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 (3) The condition number S(i) of eigenvalues computed by CGGEVX
     differs less than a factor THRESH from the exact S(i) (see
     CLATM6).

 (4) DIF(i) computed by CTGSNA differs less than a factor 10*THRESH
     from the exact value (for the 1st and 5th vectors only).

 Test Matrices
 =============

 Two kinds of test matrix pairs
          (A, B) = inverse(YH) * (Da, Db) * inverse(X)
 are used in the tests:

 1: Da = 1+a   0    0    0    0    Db = 1   0   0   0   0
          0   2+a   0    0    0         0   1   0   0   0
          0    0   3+a   0    0         0   0   1   0   0
          0    0    0   4+a   0         0   0   0   1   0
          0    0    0    0   5+a ,      0   0   0   0   1 , and

 2: Da =  1   -1    0    0    0    Db = 1   0   0   0   0
          1    1    0    0    0         0   1   0   0   0
          0    0    1    0    0         0   0   1   0   0
          0    0    0   1+a  1+b        0   0   0   1   0
          0    0    0  -1-b  1+a ,      0   0   0   0   1 .

 In both cases the same inverse(YH) and inverse(X) are used to compute
 (A, B), giving the exact eigenvectors to (A,B) as (YH, X):

 YH:  =  1    0   -y    y   -y    X =  1   0  -x  -x   x
         0    1   -y    y   -y         0   1   x  -x  -x
         0    0    1    0    0         0   0   1   0   0
         0    0    0    1    0         0   0   0   1   0
         0    0    0    0    1,        0   0   0   0   1 , where

 a, b, x and y will have all values independently of each other from
 { sqrt(sqrt(ULP)),  0.1,  1,  10,  1/sqrt(sqrt(ULP)) }.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZE</td><td><pre class="fragment">          NSIZE is INTEGER
          The number of sizes of matrices to use.  NSIZE must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIN will be
          tested.  If it is not zero, then N = 5.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Ao, and Bo.
          It must be at least 1 and at least NSIZE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AI</td><td><pre class="fragment">          AI is COMPLEX array, dimension (LDA, NSIZE)
          Copy of A, modified by CGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BI</td><td><pre class="fragment">          BI is COMPLEX array, dimension (LDA, NSIZE)
          Copy of B, modified by CGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX array, dimension (NSIZE)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX array, dimension (NSIZE)

          On exit, ALPHA/BETA are the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is COMPLEX array, dimension (LDA, NSIZE)
          VL holds the left eigenvectors computed by CGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is COMPLEX array, dimension (LDA, NSIZE)
          VR holds the right eigenvectors computed by CGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ILO</td><td><pre class="fragment">        ILO is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IHI</td><td><pre class="fragment">        IHI is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LSCALE</td><td><pre class="fragment">        LSCALE is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RSCALE</td><td><pre class="fragment">        RSCALE is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">        S is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">STRU</td><td><pre class="fragment">        STRU is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIF</td><td><pre class="fragment">        DIF is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFTRU</td><td><pre class="fragment">        DIFTRU is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          Leading dimension of WORK.  LWORK &gt;= 2*N*N + 2*N</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (6*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (LIWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          Leading dimension of IWORK.  LIWORK &gt;= N+2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">        RESULT is REAL array, dimension (4)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b82bbab7031b4a887831d1cf3d3ac42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrvbd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>ASAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>USAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VTSAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SSAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVBD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CDRVBD checks the singular value decomposition (SVD) driver CGESVD
 and CGESDD.
 CGESVD and CGESDD factors A = U diag(S) VT, where U and VT are
 unitary and diag(S) is diagonal with the entries of the array S on
 its diagonal. The entries of S are the singular values, nonnegative
 and stored in decreasing order.  U and VT can be optionally not
 computed, overwritten on A, or computed partially.

 A is M by N. Let MNMIN = min( M, N ). S has dimension MNMIN.
 U can be M by M or M by MNMIN. VT can be N by N or MNMIN by N.

 When CDRVBD is called, a number of matrix "sizes" (M's and N's)
 and a number of matrix "types" are specified.  For each size (M,N)
 and each type of matrix, and for the minimal workspace as well as
 workspace adequate to permit blocking, an  M x N  matrix "A" will be
 generated and used to test the SVD routines.  For each matrix, A will
 be factored as A = U diag(S) VT and the following 12 tests computed:

 Test for CGESVD:

 (1)   | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (2)   | I - U'U | / ( M ulp )

 (3)   | I - VT VT' | / ( N ulp )

 (4)   S contains MNMIN nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (5)   | U - Upartial | / ( M ulp ) where Upartial is a partially
       computed U.

 (6)   | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
       computed VT.

 (7)   | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
       vector of singular values from the partial SVD

 Test for CGESDD:

 (1)   | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (2)   | I - U'U | / ( M ulp )

 (3)   | I - VT VT' | / ( N ulp )

 (4)   S contains MNMIN nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (5)   | U - Upartial | / ( M ulp ) where Upartial is a partially
       computed U.

 (6)   | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
       computed VT.

 (7)   | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
       vector of singular values from the partial SVD

 The "sizes" are specified by the arrays MM(1:NSIZES) and
 NN(1:NSIZES); the value of each element pair (MM(j),NN(j))
 specifies one size.  The "types" are specified by a logical array
 DOTYPE( 1:NTYPES ); if DOTYPE(j) is .TRUE., then matrix type "j"
 will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.
 (3)  A matrix of the form  U D V, where U and V are unitary and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.
 (4)  Same as (3), but multiplied by the underflow-threshold / ULP.
 (5)  Same as (3), but multiplied by the overflow-threshold * ULP.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CDRVBD does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MM</td><td><pre class="fragment">          MM is INTEGER array, dimension (NSIZES)
          An array containing the matrix "heights" to be used.  For
          each j=1,...,NSIZES, if MM(j) is zero, then MM(j) and NN(j)
          will be ignored.  The MM(j) values must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the matrix "widths" to be used.  For
          each j=1,...,NSIZES, if NN(j) is zero, then MM(j) and NN(j)
          will be ignored.  The NN(j) values must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CDRVBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVBD to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,max(NN))
          Used to hold the matrix whose singular values are to be
          computed.  On exit, A contains the last matrix actually
          used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( MM ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU,max(MM))
          Used to hold the computed matrix of right singular vectors.
          On exit, U contains the last such vectors actually computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  It must be at
          least 1 and at least max( MM ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is COMPLEX array, dimension (LDVT,max(NN))
          Used to hold the computed matrix of left singular vectors.
          On exit, VT contains the last such vectors actually computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
          The leading dimension of VT.  It must be at
          least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ASAV</td><td><pre class="fragment">          ASAV is COMPLEX array, dimension (LDA,max(NN))
          Used to hold a different copy of the matrix whose singular
          values are to be computed.  On exit, A contains the last
          matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">USAV</td><td><pre class="fragment">          USAV is COMPLEX array, dimension (LDU,max(MM))
          Used to hold a different copy of the computed matrix of
          right singular vectors. On exit, USAV contains the last such
          vectors actually computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VTSAV</td><td><pre class="fragment">          VTSAV is COMPLEX array, dimension (LDVT,max(NN))
          Used to hold a different copy of the computed matrix of
          left singular vectors. On exit, VTSAV contains the last such
          vectors actually computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL array, dimension (max(min(MM,NN)))
          Contains the computed singular values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSAV</td><td><pre class="fragment">          SSAV is REAL array, dimension (max(min(MM,NN)))
          Contains another copy of the computed singular values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (max(min(MM,NN)))
          Workspace for CGESVD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          MAX(3*MIN(M,N)+MAX(M,N)**2,5*MIN(M,N),3*MAX(M,N)) for all
          pairs  (M,N)=(MM(j),NN(j))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array,
                      dimension ( 5*max(max(MM,NN)) )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension at least 8*min(M,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some MM(j) &lt; 0
           -3: Some NN(j) &lt; 0
           -4: NTYPES &lt; 0
           -7: THRESH &lt; 0
          -10: LDA &lt; 1 or LDA &lt; MMAX, where MMAX is max( MM(j) ).
          -12: LDU &lt; 1 or LDU &lt; MMAX.
          -14: LDVT &lt; 1 or LDVT &lt; NMAX, where NMAX is max( NN(j) ).
          -21: LWORK too small.
          If  CLATMS, or CGESVD returns an error code, the
              absolute value of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a71405b6c399d8003237c6dd21b3855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrves </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>HT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 13 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVES</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CDRVES checks the nonsymmetric eigenvalue (Schur form) problem
    driver CGEES.

    When CDRVES is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 13
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if W are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if W are eigenvalues of T
            1/ulp otherwise
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP &lt; |z| &lt; 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP &lt; |z| &lt; 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CDRVES does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CDRVES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVES to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by CGEES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HT</td><td><pre class="fragment">          HT is COMPLEX array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by CGEES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX array, dimension (max(NN))
          The computed eigenvalues of A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WT</td><td><pre class="fragment">          WT is COMPLEX array, dimension (max(NN))
          Like W, this array contains the eigenvalues of A,
          but those computed when CGEES only computes a partial
          eigendecomposition, i.e. not Schur vectors</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS</td><td><pre class="fragment">          VS is COMPLEX array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVS</td><td><pre class="fragment">          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (13)
          The values computed by the 13 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (NWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWORK</td><td><pre class="fragment">          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -6: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -15: LDVS &lt; 1 or LDVS &lt; NMAX, where NMAX is max( NN(j) ).
          -18: NWORK too small.
          If  CLATMR, CLATMS, CLATME or CGEES returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------
     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.
             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Select whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga83586dc59c82790361b0de5fe25bf0f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrvev </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldlre, * )&#160;</td>
          <td class="paramname"><em>LRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDLRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 7 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVEV</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CDRVEV  checks the nonsymmetric eigenvalue problem driver CGEEV.

    When CDRVEV is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 7
    tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a diagonal matrix with diagonal entries W(j).

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate-transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when both VR and VL
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and VR, or only W and VL are
      computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when both VR
      and VL are computed, and VR(partial) denotes the result
      when only VR is computed.

     (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when both VR
      and VL are also computed, and VL(partial) denotes the result
      when only VL is computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random complex
         angles on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is unitary and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP &lt; |z| &lt; 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP &lt; |z| &lt; 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from |z| &lt; 1
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CDRVEV does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CDRVEV
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVEV to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max(NN).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by CGEEV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX array, dimension (max(NN))
          The eigenvalues of A. On exit, W are the eigenvalues of
          the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W1</td><td><pre class="fragment">          W1 is COMPLEX array, dimension (max(NN))
          Like W, this array contains the eigenvalues of A,
          but those computed when CGEEV only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is COMPLEX array, dimension (LDVL, max(NN))
          VL holds the computed left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is COMPLEX array, dimension (LDVR, max(NN))
          VR holds the computed right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LRE</td><td><pre class="fragment">          LRE is COMPLEX array, dimension (LDLRE, max(NN))
          LRE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDLRE</td><td><pre class="fragment">          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (7)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (NWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWORK</td><td><pre class="fragment">          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (2*max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -6: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -14: LDVL &lt; 1 or LDVL &lt; NMAX, where NMAX is max( NN(j) ).
          -16: LDVR &lt; 1 or LDVR &lt; NMAX, where NMAX is max( NN(j) ).
          -18: LDLRE &lt; 1 or LDLRE &lt; NMAX, where NMAX is max( NN(j) ).
          -21: NWORK too small.
          If  CLATMR, CLATMS, CLATME or CGEEV returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d4d21e3f556cbcb6998be9aeede7151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrvgg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRSHN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVGG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CDRVGG  checks the nonsymmetric generalized eigenvalue driver
 routines.
                               T          T        T
 CGEGS factors A and B as Q S Z  and Q T Z , where   means
 transpose, T is upper triangular, S is in generalized Schur form
 (upper triangular), and Q and Z are unitary.  It also
 computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), where alpha(j)=S(j,j) and beta(j)=T(j,j) --
 thus, w(j) = alpha(j)/beta(j) is a root of the generalized
 eigenvalue problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 CGEGV computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), the matrix L whose columns contain the
 generalized left eigenvectors l, and the matrix R whose columns
 contain the generalized right eigenvectors r for the pair (A,B).

 When CDRVGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 7
 tests will be performed and compared with the threshhold THRESH:

 Results from CGEGS:

                  H
 (1)   | A - Q S Z  | / ( |A| n ulp )

                  H
 (2)   | B - Q T Z  | / ( |B| n ulp )

               H
 (3)   | I - QQ  | / ( n ulp )

               H
 (4)   | I - ZZ  | / ( n ulp )

 (5)   maximum over j of D(j)  where:

                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

 Results from CGEGV:

 (6)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

       where l**H is the conjugate tranpose of l.

 (7)   max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random unitary matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CDRVGG does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, CDRVGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVGG to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRSHN</td><td><pre class="fragment">          THRSHN is REAL
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, S, T, S2, and T2.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is COMPLEX array, dimension (LDA, max(NN))
          The upper triangular matrix computed from A by CGEGS.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is COMPLEX array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by CGEGS.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S2</td><td><pre class="fragment">          S2 is COMPLEX array, dimension (LDA, max(NN))
          The matrix computed from A by CGEGV.  This will be the
          Schur (upper triangular) form of some matrix related to A,
          but will not, in general, be the same as S.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T2</td><td><pre class="fragment">          T2 is COMPLEX array, dimension (LDA, max(NN))
          The matrix computed from B by CGEGV.  This will be the
          Schur form of some matrix related to B, but will not, in
          general, be the same as T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDQ, max(NN))
          The (left) unitary matrix computed by CGEGS.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q, Z, VL, and VR.  It must
          be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension (LDQ, max(NN))
          The (right) unitary matrix computed by CGEGS.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA1</td><td><pre class="fragment">          ALPHA1 is COMPLEX array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA1</td><td><pre class="fragment">          BETA1 is COMPLEX array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by CGEGS.
          ALPHA1(k) / BETA1(k)  is the k-th generalized eigenvalue of
          the matrices in A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA2</td><td><pre class="fragment">          ALPHA2 is COMPLEX array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA2</td><td><pre class="fragment">          BETA2 is COMPLEX array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by CGEGV.
          ALPHA2(k) / BETA2(k)  is the k-th generalized eigenvalue of
          the matrices in A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is COMPLEX array, dimension (LDQ, max(NN))
          The (lower triangular) left eigenvector matrix for the
          matrices in A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is COMPLEX array, dimension (LDQ, max(NN))
          The (upper triangular) right eigenvector matrix for the
          matrices in A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          MAX( 2*N, N*(NB+1), (k+1)*(2*k+N+1) ), where "k" is the
          sum of the blocksize and number-of-shifts for CHGEQZ, and
          NB is the greatest of the blocksizes for CGEQRF, CUNMQR,
          and CUNGQR.  (The blocksizes and the number-of-shifts are
          retrieved through calls to ILAENV.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (8*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (7)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga00458f67544e6b941bb4b947d54e239f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrvsg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LRWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVSG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      CDRVSG checks the complex Hermitian generalized eigenproblem
      drivers.

              CHEGV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem.

              CHEGVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem using a divide and conquer algorithm.

              CHEGVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem.

              CHPGV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem in packed storage.

              CHPGVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem in packed storage using a divide and
              conquer algorithm.

              CHPGVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite generalized
              eigenproblem in packed storage.

              CHBGV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite banded
              generalized eigenproblem.

              CHBGVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite banded
              generalized eigenproblem using a divide and conquer
              algorithm.

              CHBGVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian-definite banded
              generalized eigenproblem.

      When CDRVSG is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix A of the given type will be
      generated; a random well-conditioned matrix B is also generated
      and the pair (A,B) is used to test the drivers.

      For each pair (A,B), the following tests are performed:

      (1) CHEGV with ITYPE = 1 and UPLO ='U':

              | A Z - B Z D | / ( |A| |Z| n ulp )

      (2) as (1) but calling CHPGV
      (3) as (1) but calling CHBGV
      (4) as (1) but with UPLO = 'L'
      (5) as (4) but calling CHPGV
      (6) as (4) but calling CHBGV

      (7) CHEGV with ITYPE = 2 and UPLO ='U':

              | A B Z - Z D | / ( |A| |Z| n ulp )

      (8) as (7) but calling CHPGV
      (9) as (7) but with UPLO = 'L'
      (10) as (9) but calling CHPGV

      (11) CHEGV with ITYPE = 3 and UPLO ='U':

              | B A Z - Z D | / ( |A| |Z| n ulp )

      (12) as (11) but calling CHPGV
      (13) as (11) but with UPLO = 'L'
      (14) as (13) but calling CHPGV

      CHEGVD, CHPGVD and CHBGVD performed the same 14 tests.

      CHEGVX, CHPGVX and CHBGVX performed the above 14 tests with
      the parameter RANGE = 'A', 'N' and 'I', respectively.

      The "sizes" are specified by an array NN(1:NSIZES); the value of
      each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      This type is used for the matrix A which has half-bandwidth KA.
      B is generated as a well-conditioned positive definite matrix
      with half-bandwidth KB (&lt;= KA).
      Currently, the list of possible types for A is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced entries
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced entries
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
           and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U* D U, where U is unitary and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U* D U, where U is unitary and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U* D U, where U is unitary and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) Hermitian matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold )

      (16) Same as (8), but with KA = 1 and KB = 1
      (17) Same as (8), but with KA = 2 and KB = 1
      (18) Same as (8), but with KA = 2 and KB = 2
      (19) Same as (8), but with KA = 3 and KB = 1
      (20) Same as (8), but with KA = 3 and KB = 2
      (21) Same as (8), but with KA = 3 and KB = 3</pre> <pre class="fragment">  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CDRVSG does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, CDRVSG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVSG to continue the same random number
          sequence.
          Modified.

  THRESH  REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       COMPLEX array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  B       COMPLEX array, dimension (LDB , max(NN))
          Used to hold the Hermitian positive definite matrix for
          the generailzed problem.
          On exit, B contains the last matrix actually
          used.
          Modified.

  LDB     INTEGER
          The leading dimension of B.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D       REAL array, dimension (max(NN))
          The eigenvalues of A. On exit, the eigenvalues in D
          correspond with the matrix in A.
          Modified.

  Z       COMPLEX array, dimension (LDZ, max(NN))
          The matrix of eigenvectors.
          Modified.

  LDZ     INTEGER
          The leading dimension of ZZ.  It must be at least 1 and
          at least max( NN ).
          Not modified.

  AB      COMPLEX array, dimension (LDA, max(NN))
          Workspace.
          Modified.

  BB      COMPLEX array, dimension (LDB, max(NN))
          Workspace.
          Modified.

  AP      COMPLEX array, dimension (max(NN)**2)
          Workspace.
          Modified.

  BP      COMPLEX array, dimension (max(NN)**2)
          Workspace.
          Modified.

  WORK    COMPLEX array, dimension (NWORK)
          Workspace.
          Modified.

  NWORK   INTEGER
          The number of entries in WORK.  This must be at least
          2*N + N**2  where  N = max( NN(j), 2 ).
          Not modified.

  RWORK   REAL array, dimension (LRWORK)
          Workspace.
          Modified.

  LRWORK  INTEGER
          The number of entries in RWORK.  This must be at least
          max( 7*N, 1 + 4*N + 2*N*lg(N) + 3*N**2 ) where
          N = max( NN(j) ) and lg( N ) = smallest integer k such
          that 2**k &gt;= N .
          Not modified.

  IWORK   INTEGER array, dimension (LIWORK))
          Workspace.
          Modified.

  LIWORK  INTEGER
          The number of entries in IWORK.  This must be at least
          2 + 5*max( NN(j) ).
          Not modified.

  RESULT  REAL array, dimension (70)
          The values computed by the 70 tests described above.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -5: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -16: LDZ &lt; 1 or LDZ &lt; NMAX.
          -21: NWORK too small.
          -23: LRWORK too small.
          -25: LIWORK too small.
          If  CLATMR, CLATMS, CHEGV, CHPGV, CHBGV, CHEGVD, CHPGVD,
              CHPGVD, CHEGVX, CHPGVX, CHBGVX returns an error code,
              the absolute value of it is returned.
          Modified.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests that have been run
                       on this matrix.
       NTESTT          The total number of tests for this call.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by SLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gacbd6f59fe241010a772c2d06a9d11d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrvst </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WA3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LRWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVST</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      CDRVST  checks the Hermitian eigenvalue problem drivers.

              CHEEVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix,
              using a divide-and-conquer algorithm.

              CHEEVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix.

              CHEEVR computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix
              using the Relatively Robust Representation where it can.

              CHPEVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix in packed
              storage, using a divide-and-conquer algorithm.

              CHPEVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix in packed
              storage.

              CHBEVD computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian band matrix,
              using a divide-and-conquer algorithm.

              CHBEVX computes selected eigenvalues and, optionally,
              eigenvectors of a complex Hermitian band matrix.

              CHEEV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix.

              CHPEV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian matrix in packed
              storage.

              CHBEV computes all eigenvalues and, optionally,
              eigenvectors of a complex Hermitian band matrix.

      When CDRVST is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix will be generated and used
      to test the appropriate drivers.  For each matrix and each
      driver routine called, the following tests will be performed:

      (1)     | A - Z D Z' | / ( |A| n ulp )

      (2)     | I - Z Z' | / ( n ulp )

      (3)     | D1 - D2 | / ( |D1| ulp )

      where Z is the matrix of eigenvectors returned when the
      eigenvector option is given and D1 and D2 are the eigenvalues
      returned with and without the eigenvector option.

      The "sizes" are specified by an array NN(1:NSIZES); the value of
      each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      Currently, the list of possible types is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced entries
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced entries
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
           and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U* D U, where U is unitary and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U* D U, where U is unitary and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U* D U, where U is unitary and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) Symmetric matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold )
      (16) A band matrix with half bandwidth randomly chosen between
           0 and N-1, with evenly spaced eigenvalues 1, ..., ULP
           with random signs.
      (17) Same as (16), but multiplied by SQRT( overflow threshold )
      (18) Same as (16), but multiplied by SQRT( underflow threshold )</pre> <pre class="fragment">  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          CDRVST does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, CDRVST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVST to continue the same random number
          sequence.
          Modified.

  THRESH  REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       COMPLEX array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D1      REAL array, dimension (max(NN))
          The eigenvalues of A, as computed by CSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.
          Modified.

  D2      REAL array, dimension (max(NN))
          The eigenvalues of A, as computed by CSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.
          Modified.

  D3      REAL array, dimension (max(NN))
          The eigenvalues of A, as computed by SSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.
          Modified.

  WA1     REAL array, dimension

  WA2     REAL array, dimension

  WA3     REAL array, dimension

  U       COMPLEX array, dimension (LDU, max(NN))
          The unitary matrix computed by CHETRD + CUNGC3.
          Modified.

  LDU     INTEGER
          The leading dimension of U, Z, and V.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  V       COMPLEX array, dimension (LDU, max(NN))
          The Housholder vectors computed by CHETRD in reducing A to
          tridiagonal form.
          Modified.

  TAU     COMPLEX array, dimension (max(NN))
          The Householder factors computed by CHETRD in reducing A
          to tridiagonal form.
          Modified.

  Z       COMPLEX array, dimension (LDU, max(NN))
          The unitary matrix of eigenvectors computed by CHEEVD,
          CHEEVX, CHPEVD, CHPEVX, CHBEVD, and CHBEVX.
          Modified.

  WORK  - COMPLEX array of dimension ( LWORK )
           Workspace.
           Modified.

  LWORK - INTEGER
           The number of entries in WORK.  This must be at least
           2*max( NN(j), 2 )**2.
           Not modified.

  RWORK   REAL array, dimension (3*max(NN))
           Workspace.
           Modified.

  LRWORK - INTEGER
           The number of entries in RWORK.

  IWORK   INTEGER array, dimension (6*max(NN))
          Workspace.
          Modified.

  LIWORK - INTEGER
           The number of entries in IWORK.

  RESULT  REAL array, dimension (??)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -5: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -16: LDU &lt; 1 or LDU &lt; NMAX.
          -21: LWORK too small.
          If  SLATMR, SLATMS, CHETRD, SORGC3, CSTEQR, SSTERF,
              or SORMC2 returns an error code, the
              absolute value of it is returned.
          Modified.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by SLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga730ba08b058674ceabf267420c5c4d01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrvsx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>HT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WTMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 17 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVSX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CDRVSX checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver CGEESX.

    CDRVSX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When CDRVSX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 15
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if W are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if W are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare W with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP &lt; |z| &lt; 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP &lt; |z| &lt; 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalue
    average and right invariant subspace. For these matrices, in
    addition to tests (1) to (15) we will compute the following two
    tests:

   (16)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal average eigenvalue condition number
      computed by CGEESX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.

   (17)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right invariant subspace condition
      number computed by CGEESX and RCDVIN (the precomputed true
      value) is supplied as input. cond(RCONDV) is the condition
      number of RCONDV, and takes errors in computing RCONDV into
      account, so that the resulting quantity should be O(ULP).
      cond(RCONDV) is essentially given by norm(A)/RCONDE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVSX to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIUNIT</td><td><pre class="fragment">          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by CGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HT</td><td><pre class="fragment">          HT is COMPLEX array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by CGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX array, dimension (max(NN))
          The computed eigenvalues of A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WT</td><td><pre class="fragment">          WT is COMPLEX array, dimension (max(NN))
          Like W, this array contains the eigenvalues of A,
          but those computed when CGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WTMP</td><td><pre class="fragment">          WTMP is COMPLEX array, dimension (max(NN))
          More temporary storage for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS</td><td><pre class="fragment">          VS is COMPLEX array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVS</td><td><pre class="fragment">          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS1</td><td><pre class="fragment">          VS1 is COMPLEX array, dimension (LDVS, max(NN))
          VS1 holds another copy of the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(1,2*NN(j)**2) for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  successful exit.
            &lt;0,  input parameter -INFO is incorrect
            &gt;0,  CLATMR, CLATMS, CLATME or CGET24 returned an error
                 code and INFO is its absolute value

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------
     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.
             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2de5d5cdd79b4ab56fd984ac860f1b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cdrvvx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldlre, * )&#160;</td>
          <td class="paramname"><em>LRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDLRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDVIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDEIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 11 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CDRVVX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CDRVVX  checks the nonsymmetric eigenvalue problem expert driver
    CGEEVX.

    CDRVVX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When CDRVVX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified in the calling sequence.
    For each size ("n") and each type of matrix, one matrix will be
    generated and used to test the nonsymmetric eigenroutines.  For
    each matrix, 9 tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a diagonal matrix with diagonal entries W(j).

    (2)     | A**H  * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     RCONDV(full) = RCONDV(partial)

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random complex angles.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random complex angles.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random complex angles.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is unitary and
         T has evenly spaced entries 1, ..., ULP with random complex
         angles on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is unitary and
         T has geometrically spaced entries 1, ..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (11) A matrix of the form  U' T U, where U is unitary and
         T has "clustered" entries 1, ULP,..., ULP with random
         complex angles on the diagonal and random O(1) entries in
         the upper triangle.

    (12) A matrix of the form  U' T U, where U is unitary and
         T has complex eigenvalues randomly chosen from
         ULP &lt; |z| &lt; 1   and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random complex angles on the diagonal
         and random O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random complex angles on the diagonal and random O(1)
         entries in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has complex eigenvalues randomly chosen
         from ULP &lt; |z| &lt; 1 and random O(1) entries in the upper
         triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from |z| &lt; 1
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalues
    and right eigenvectors. For these matrices, in addition to tests
    (1) to (9) we will compute the following two tests:

   (10)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by CGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by CGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to CDRVVX to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIUNIT</td><td><pre class="fragment">          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, max(NN,12))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN, 12 ). (12 is the
          dimension of the largest matrix on the precomputed
          input file.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDA, max(NN,12))
          Another copy of the test matrix A, modified by CGEEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX array, dimension (max(NN,12))
          Contains the eigenvalues of A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W1</td><td><pre class="fragment">          W1 is COMPLEX array, dimension (max(NN,12))
          Like W, this array contains the eigenvalues of A,
          but those computed when CGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is COMPLEX array, dimension (LDVL, max(NN,12))
          VL holds the computed left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN,12)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is COMPLEX array, dimension (LDVR, max(NN,12))
          VR holds the computed right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN,12)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LRE</td><td><pre class="fragment">          LRE is COMPLEX array, dimension (LDLRE, max(NN,12))
          LRE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDLRE</td><td><pre class="fragment">          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN,12))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDV</td><td><pre class="fragment">          RCONDV is REAL array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDV1</td><td><pre class="fragment">          RCNDV1 is REAL array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDVIN</td><td><pre class="fragment">          RCDVIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDE</td><td><pre class="fragment">          RCONDE is REAL array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDE1</td><td><pre class="fragment">          RCNDE1 is REAL array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDEIN</td><td><pre class="fragment">          RCDEIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is REAL array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE1</td><td><pre class="fragment">          SCALE1 is REAL array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (11)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (NWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWORK</td><td><pre class="fragment">          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(6*12+2*12**2,6*NN(j)+2*NN(j)**2) =
          max(    360     ,6*NN(j)+2*NN(j)**2)    for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (2*max(NN,12))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  then successful exit.
          If &lt;0, then input paramter -INFO is incorrect.
          If &gt;0, CLATMR, CLATMS, CLATME or CGET23 returned an error
                 code, and INFO is its absolute value.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN or 12.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga50b4c5d969bcab15b8a414bfab72943a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cerrbd </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CERRBD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CERRBD tests the error exits for CGEBRD, CUNGBR, CUNMBR, and CBDSQR.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5751920655807ca8c7faae007dba9342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cerrec </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CERREC</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CERREC tests the error exits for the routines for eigen- condition
 estimation for REAL matrices:
    CTRSYL, CTREXC, CTRSNA and CTRSEN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga39f3d64318a49dca7ee6ae69057e89d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cerred </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CERRED</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CERRED tests the error exits for the eigenvalue driver routines for
 REAL matrices:

 PATH  driver   description
 ----  ------   -----------
 CEV   CGEEV    find eigenvalues/eigenvectors for nonsymmetric A
 CES   CGEES    find eigenvalues/Schur form for nonsymmetric A
 CVX   CGEEVX   CGEEV + balancing and condition estimation
 CSX   CGEESX   CGEES + balancing and condition estimation
 CBD   CGESVD   compute SVD of an M-by-N matrix A
       CGESDD   compute SVD of an M-by-N matrix A(by divide and
                conquer)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5237e7f50365662c99c5af4d41ecb194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cerrgg </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CERRGG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CERRGG tests the error exits for CGGES, CGGESX, CGGEV, CGGEVX,
 CGGGLM, CGGHRD, CGGLSE, CGGQRF, CGGRQF, CGGSVD, CGGSVP, CHGEQZ,
 CTGEVC, CTGEXC, CTGSEN, CTGSJA, CTGSNA, CTGSYL and CUNCSD.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gad62986bd8f34d0f8e039c639d25fb926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cerrhs </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CERRHS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CERRHS tests the error exits for CGEBAK, CGEBAL, CGEHRD, CUNGHR,
 CUNMHR, CHSEQR, CHSEIN, and CTREVC.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0c64251a2e100d6629de57e93674dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cerrst </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CERRST</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CERRST tests the error exits for CHETRD, CUNGTR, CUNMTR, CHPTRD,
 CUNGTR, CUPMTR, CSTEQR, CSTEIN, CPTEQR, CHBTRD,
 CHEEV, CHEEVX, CHEEVD, CHBEV, CHBEVX, CHBEVD,
 CHPEV, CHPEVX, CHPEVD, and CSTEDC.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab6d2226b2f8806aa9b110c167c93bedf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget02 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET02</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET02 computes the residual for a solution of a system of linear
 equations  A*x = b  or  A'*x = b:
    RESID = norm(B - A*X) / ( norm(A) * norm(X) * EPS ),
 where EPS is the machine epsilon.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANS</td><td><pre class="fragment">          TRANS is CHARACTER*1
          Specifies the form of the system of equations:
          = 'N':  A *x = b
          = 'T':  A^T*x = b, where A^T is the transpose of A
          = 'C':  A^H*x = b, where A^H is the conjugate transpose of A</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of columns of B, the matrix of right hand sides.
          NRHS &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The original M x N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension (LDX,NRHS)
          The computed solution vectors for the system of linear
          equations.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX &gt;= max(1,N); if TRANS = 'T' or 'C', LDX &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,NRHS)
          On entry, the right hand side vectors for the system of
          linear equations.
          On exit, B is overwritten with the difference B - A*X.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  IF TRANS = 'N',
          LDB &gt;= max(1,M); if TRANS = 'T' or 'C', LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is REAL
          The maximum over the number of right hand sides of
          norm(B - A*X) / ( norm(A) * norm(X) * EPS ).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dbf4135e14f662ed4f3486c218d7132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget10 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET10</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET10 compares two matrices A and B and computes the ratio
 RESULT = norm( A - B ) / ( norm(A) * M * EPS )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrices A and B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The m by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,N)
          The m by n matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is COMPLEX array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL
          RESULT = norm( A - B ) / ( norm(A) * M * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaba7f4c1d3cb97e0b5812937d39270e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget22 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANSE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANSW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( <a class="el" href="dblat3_8f.html#a6fd3ddbe863b9e8e6e79ebf9c8594174">lde</a>, * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET22</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET22 does an eigenvector check.

 The basic test is:

    RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )

 using the 1-norm.  It also tests the normalization of E:

    RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )
                 j

 where E(j) is the j-th eigenvector, and m-norm is the max-norm of a
 vector.  The max-norm of a complex n-vector x in this case is the
 maximum of |re(x(i)| + |im(x(i)| over i = 1, ..., n.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANSA</td><td><pre class="fragment">          TRANSA is CHARACTER*1
          Specifies whether or not A is transposed.
          = 'N':  No transpose
          = 'T':  Transpose
          = 'C':  Conjugate transpose</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANSE</td><td><pre class="fragment">          TRANSE is CHARACTER*1
          Specifies whether or not E is transposed.
          = 'N':  No transpose, eigenvectors are in columns of E
          = 'T':  Transpose, eigenvectors are in rows of E
          = 'C':  Conjugate transpose, eigenvectors are in rows of E</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANSW</td><td><pre class="fragment">          TRANSW is CHARACTER*1
          Specifies whether or not W is transposed.
          = 'N':  No transpose
          = 'T':  Transpose, same as TRANSW = 'N'
          = 'C':  Conjugate transpose, use -WI(j) instead of WI(j)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The matrix whose eigenvectors are in E.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is COMPLEX array, dimension (LDE,N)
          The matrix of eigenvectors. If TRANSE = 'N', the eigenvectors
          are stored in the columns of E, if TRANSE = 'T' or 'C', the
          eigenvectors are stored in the rows of E.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDE</td><td><pre class="fragment">          LDE is INTEGER
          The leading dimension of the array E.  LDE &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX array, dimension (N)
          The eigenvalues of A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (N*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )
          RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga348eb5544a2d2680f42ba665fcd5b81c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget23 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>COMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ISRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>BALANC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>JTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldlre, * )&#160;</td>
          <td class="paramname"><em>LRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDLRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDVIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDEIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 11 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET23</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CGET23  checks the nonsymmetric eigenvalue problem driver CGEEVX.
    If COMP = .FALSE., the first 8 of the following tests will be
    performed on the input matrix A, and also test 9 if LWORK is
    sufficiently large.
    if COMP is .TRUE. all 11 tests will be performed.

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a diagonal matrix with diagonal entries W(j).

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     0 if W(full) = W(partial), 1/ulp otherwise

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     0 if VR(full) = VR(partial), 1/ulp otherwise

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     0 if VL(full) = VL(partial), 1/ulp otherwise

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     0 if RCONDV(full) = RCONDV(partial), 1/ulp otherwise

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

   (10)     |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by CGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)     |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by CGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">COMP</td><td><pre class="fragment">          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISRT</td><td><pre class="fragment">          ISRT is INTEGER
          If COMP = .TRUE., ISRT indicates in how the eigenvalues
          corresponding to values in RCDVIN and RCDEIN are ordered:
            = 0 means the eigenvalues are sorted by
                increasing real part
            = 1 means the eigenvalues are sorted by
                increasing imaginary part
          If COMP = .FALSE., ISRT is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BALANC</td><td><pre class="fragment">          BALANC is CHARACTER
          Describes the balancing option to be tested.
            = 'N' for no permuting or diagonal scaling
            = 'P' for permuting but no diagonal scaling
            = 'S' for no permuting but diagonal scaling
            = 'B' for permuting and diagonal scaling</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JTYPE</td><td><pre class="fragment">          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of A. N must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          Used to hold the matrix whose eigenvalues are to be
          computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDA,N)
          Another copy of the test matrix A, modified by CGEEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX array, dimension (N)
          Contains the eigenvalues of A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W1</td><td><pre class="fragment">          W1 is COMPLEX array, dimension (N)
          Like W, this array contains the eigenvalues of A,
          but those computed when CGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is COMPLEX array, dimension (LDVL,N)
          VL holds the computed left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is COMPLEX array, dimension (LDVR,N)
          VR holds the computed right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LRE</td><td><pre class="fragment">          LRE is COMPLEX array, dimension (LDLRE,N)
          LRE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDLRE</td><td><pre class="fragment">          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDV</td><td><pre class="fragment">          RCONDV is REAL array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDV1</td><td><pre class="fragment">          RCNDV1 is REAL array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDVIN</td><td><pre class="fragment">          RCDVIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDE</td><td><pre class="fragment">          RCONDE is REAL array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDE1</td><td><pre class="fragment">          RCNDE1 is REAL array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDEIN</td><td><pre class="fragment">          RCDEIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is REAL array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE1</td><td><pre class="fragment">          SCALE1 is REAL array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (11)
          The values computed by the 11 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          2*N, and 2*N+N**2 if tests 9, 10 or 11 are to be performed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (2*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  successful exit.
          If &lt;0, input parameter -INFO had an incorrect value.
          If &gt;0, CGEEVX returned an error code, the absolute
                 value of which is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gafb74cf216cc7b889b8b724e1917e0cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget24 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>COMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>JTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>HT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WTMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RCDEIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RCDVIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSLCT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISLCT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ISRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 17 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET24</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    CGET24 checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver CGEESX.

    If COMP = .FALSE., the first 13 of the following tests will be
    be performed on the input matrix A, and also tests 14 and 15
    if LWORK is sufficiently large.
    If COMP = .TRUE., all 17 test will be performed.

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if W are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if W are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare W with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    (16)  |RCONDE - RCDEIN| / cond(RCONDE)

       RCONDE is the reciprocal average eigenvalue condition number
       computed by CGEESX and RCDEIN (the precomputed true value)
       is supplied as input.  cond(RCONDE) is the condition number
       of RCONDE, and takes errors in computing RCONDE into account,
       so that the resulting quantity should be O(ULP). cond(RCONDE)
       is essentially given by norm(A)/RCONDV.

    (17)  |RCONDV - RCDVIN| / cond(RCONDV)

       RCONDV is the reciprocal right invariant subspace condition
       number computed by CGEESX and RCDVIN (the precomputed true
       value) is supplied as input. cond(RCONDV) is the condition
       number of RCONDV, and takes errors in computing RCONDV into
       account, so that the resulting quantity should be O(ULP).
       cond(RCONDV) is essentially given by norm(A)/RCONDE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">COMP</td><td><pre class="fragment">          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JTYPE</td><td><pre class="fragment">          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of A. N must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          Used to hold the matrix whose eigenvalues are to be
          computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDA, N)
          Another copy of the test matrix A, modified by CGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HT</td><td><pre class="fragment">          HT is COMPLEX array, dimension (LDA, N)
          Yet another copy of the test matrix A, modified by CGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX array, dimension (N)
          The computed eigenvalues of A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WT</td><td><pre class="fragment">          WT is COMPLEX array, dimension (N)
          Like W, this array contains the eigenvalues of A,
          but those computed when CGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WTMP</td><td><pre class="fragment">          WTMP is COMPLEX array, dimension (N)
          Like W, this array contains the eigenvalues of A,
          but sorted by increasing real or imaginary part.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS</td><td><pre class="fragment">          VS is COMPLEX array, dimension (LDVS, N)
          VS holds the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVS</td><td><pre class="fragment">          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1, N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS1</td><td><pre class="fragment">          VS1 is COMPLEX array, dimension (LDVS, N)
          VS1 holds another copy of the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDEIN</td><td><pre class="fragment">          RCDEIN is REAL
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition number for the average of selected eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDVIN</td><td><pre class="fragment">          RCDVIN is REAL
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition number for the selected right invariant subspace.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NSLCT</td><td><pre class="fragment">          NSLCT is INTEGER
          When COMP = .TRUE. the number of selected eigenvalues
          corresponding to the precomputed values RCDEIN and RCDVIN.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISLCT</td><td><pre class="fragment">          ISLCT is INTEGER array, dimension (NSLCT)
          When COMP = .TRUE. ISLCT selects the eigenvalues of the
          input matrix corresponding to the precomputed values RCDEIN
          and RCDVIN. For I=1, ... ,NSLCT, if ISLCT(I) = J, then the
          eigenvalue with the J-th largest real or imaginary part is
          selected. The real part is used if ISRT = 0, and the
          imaginary part if ISRT = 1.
          Not referenced if COMP = .FALSE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISRT</td><td><pre class="fragment">          ISRT is INTEGER
          When COMP = .TRUE., ISRT describes how ISLCT is used to
          choose a subset of the spectrum.
          Not referenced if COMP = .FALSE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (2*N*N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK to be passed to CGEESX. This
          must be at least 2*N, and N*(N+1)/2 if tests 14--16 are to
          be performed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  successful exit.
          If &lt;0, input parameter -INFO had an incorrect value.
          If &gt;0, CGEESX returned an error code, the absolute
                 value of which is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga749fac66036c4311ca3a1fc5f29bc4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget35 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET35</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET35 tests CTRSYL, a routine for solving the Sylvester matrix
 equation

    op(A)*X + ISGN*X*op(B) = scale*C,

 A and B are assumed to be in Schur canonical form, op() represents an
 optional transpose, and ISGN can be -1 or +1.  Scale is an output
 less than or equal to 1, chosen to avoid overflow in X.

 The test code verifies that the following residual is order 1:

    norm(op(A)*X + ISGN*X*op(B) - scale*C) /
        (EPS*max(norm(A),norm(B))*norm(X))</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is REAL
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER
          Number of examples where INFO is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          Input logical unit number.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf911ed8696d5b150c4d44077b2132b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget36 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET36</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET36 tests CTREXC, a routine for reordering diagonal entries of a
 matrix in complex Schur form. Thus, CLAEXC computes a unitary matrix
 Q such that

    Q' * T1 * Q  = T2

 and where one of the diagonal blocks of T1 (the one at row IFST) has
 been moved to position ILST.

 The test code verifies that the residual Q'*T1*Q-T2 is small, that T2
 is in Schur form, and that the final position of the IFST block is
 ILST.

 The test matrices are read from a file with logical unit number NIN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is REAL
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER
          Number of examples where INFO is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          Input logical unit number.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga70075f042e15dc8f5bc26c15d38759ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget37 </td>
          <td>(</td>
          <td class="paramtype">real, dimension( 3 )&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET37</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET37 tests CTRSNA, a routine for estimating condition numbers of
 eigenvalues and/or right eigenvectors of a matrix.

 The test matrices are read from a file with logical unit number NIN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is REAL array, dimension (3)
          Value of the largest test ratio.
          RMAX(1) = largest ratio comparing different calls to CTRSNA
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If CGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If CHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If CTRSNA returns INFO nonzero on example i, LMAX(3)=i</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times CGEHRD returned INFO nonzero
          NINFO(2) = No. of times CHSEQR returned INFO nonzero
          NINFO(3) = No. of times CTRSNA returned INFO nonzero</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          Input logical unit number</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga31605f4f439bba3ee9ce9c1c24df2e7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget38 </td>
          <td>(</td>
          <td class="paramtype">real, dimension( 3 )&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET38</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET38 tests CTRSEN, a routine for estimating condition numbers of a
 cluster of eigenvalues and/or its associated right invariant subspace

 The test matrices are read from a file with logical unit number NIN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is REAL array, dimension (3)
          Values of the largest test ratios.
          RMAX(1) = largest residuals from CHST01 or comparing
                    different calls to CTRSEN
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If CGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If CHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If CTRSEN returns INFO nonzero on example i, LMAX(3)=i</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times CGEHRD returned INFO nonzero
          NINFO(2) = No. of times CHSEQR returned INFO nonzero
          NINFO(3) = No. of times CTRSEN returned INFO nonzero</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          Input logical unit number.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab476cc3251f71c95e0a4a42bcd6d7885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget51 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET51</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      CGET51  generally checks a decomposition of the form

              A = U B VC&gt;
      where * means conjugate transpose and U and V are unitary.

      Specifically, if ITYPE=1

              RESULT = | A - U B V* | / ( |A| n ulp )

      If ITYPE=2, then:

              RESULT = | A - B | / ( |A| n ulp )

      If ITYPE=3, then:

              RESULT = | I - UU* | / ( n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          =1: RESULT = | A - U B V* | / ( |A| n ulp )
          =2: RESULT = | A - B | / ( |A| n ulp )
          =3: RESULT = | I - UU* | / ( n ulp )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, CGET51 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          The original (unfactored) matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB, N)
          The factored matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, N)
          The unitary matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension (LDV, N)
          The unitary matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (2*N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL
          The values computed by the test specified by ITYPE.  The
          value is currently limited to 1/ulp, to avoid overflow.
          Errors are flagged by RESULT=10/ulp.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaad38988d8cb0400e6a532510a3819e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget52 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>LEFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( <a class="el" href="dblat3_8f.html#a6fd3ddbe863b9e8e6e79ebf9c8594174">lde</a>, * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET52</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET52  does an eigenvector check for the generalized eigenvalue
 problem.

 The basic test for right eigenvectors is:

                           | b(i) A E(i) -  a(i) B E(i) |
         RESULT(1) = max   -------------------------------
                      i    n ulp max( |b(i) A|, |a(i) B| )

 using the 1-norm.  Here, a(i)/b(i) = w is the i-th generalized
 eigenvalue of A - w B, or, equivalently, b(i)/a(i) = m is the i-th
 generalized eigenvalue of m A - B.

                         H   H  _      _
 For left eigenvectors, A , B , a, and b  are used.

 CGET52 also tests the normalization of E.  Each eigenvector is
 supposed to be normalized so that the maximum "absolute value"
 of its elements is 1, where in this case, "absolute value"
 of a complex value x is  |Re(x)| + |Im(x)| ; let us call this
 maximum "absolute value" norm of a vector v  M(v).  
 if a(i)=b(i)=0, then the eigenvector is set to be the jth coordinate
 vector. The normalization test is:

         RESULT(2) =      max       | M(v(i)) - 1 | / ( n ulp )
                    eigenvectors v(i)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LEFT</td><td><pre class="fragment">          LEFT is LOGICAL
          =.TRUE.:  The eigenvectors in the columns of E are assumed
                    to be *left* eigenvectors.
          =.FALSE.: The eigenvectors in the columns of E are assumed
                    to be *right* eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrices.  If it is zero, CGET52 does
          nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          The matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB, N)
          The matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is COMPLEX array, dimension (LDE, N)
          The matrix of eigenvectors.  It must be O( 1 ).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDE</td><td><pre class="fragment">          LDE is INTEGER
          The leading dimension of E.  It must be at least 1 and at
          least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX array, dimension (N)
          The values a(i) as described above, which, along with b(i),
          define the generalized eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX array, dimension (N)
          The values b(i) as described above, which, along with a(i),
          define the generalized eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The values computed by the test described above.  If A E or
          B E is likely to overflow, then RESULT(1:2) is set to
          10 / ulp.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gafbfe7ec0c6aeaf712ca2c79001146e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cget54 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lds, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldt, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGET54</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGET54 checks a generalized decomposition of the form

          A = U*S*V'  and B = U*T* V'

 where ' means conjugate transpose and U and V are unitary.

 Specifically,

   RESULT = ||( A - U*S*V', B - U*T*V' )|| / (||( A, B )||*n*ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, SGET54 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          The original (unfactored) matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB, N)
          The original (unfactored) matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is COMPLEX array, dimension (LDS, N)
          The factored matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDS</td><td><pre class="fragment">          LDS is INTEGER
          The leading dimension of S.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td><pre class="fragment">          T is COMPLEX array, dimension (LDT, N)
          The factored matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDT</td><td><pre class="fragment">          LDT is INTEGER
          The leading dimension of T.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension (LDV, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (3*N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL
          The value RESULT, It is currently limited to 1/ulp, to
          avoid overflow. Errors are flagged by RESULT=10/ulp.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4283cb04f906b24363d97745e2ce10bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cglmts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGLMTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGLMTS tests CGGGLM - a subroutine for solving the generalized
 linear model problem.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of rows of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of columns of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of columns of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,M)
          The N-by-M matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (LDA,M)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF. LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,P)
          The N-by-P matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (LDB,P)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF. LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array, dimension( N )
          On input, the left hand side of the GLM.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DF</td><td><pre class="fragment">          DF is COMPLEX array, dimension( N )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension( M )
          solution vector X in the GLM problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension( P )
          solution vector U in the GLM problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL
          The test ratio:
                           norm( d - A*x - B*u )
            RESULT = -----------------------------------------
                     (norm(A)+norm(B))*(norm(x)+norm(u))*EPS</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga28909ffc04948989e0c6bf3dedaed598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cgqrts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BWK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 4 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGQRTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGQRTS tests CGGQRF, which computes the GQR factorization of an
 N-by-M matrix A and a N-by-P matrix B: A = Q*R and B = Q*T*Z.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of rows of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of columns of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of columns of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,M)
          The N-by-M matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (LDA,N)
          Details of the GQR factorization of A and B, as returned
          by CGGQRF, see CGGQRF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDA,N)
          The M-by-M unitary matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is COMPLEX array, dimension (LDA,MAX(M,N))</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUA</td><td><pre class="fragment">          TAUA is COMPLEX array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by CGGQRF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,P)
          On entry, the N-by-P matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by CGGQRF, see CGGQRF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension (LDB,P)
          The P-by-P unitary matrix Z.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is COMPLEX array, dimension (LDB,max(P,N))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWK</td><td><pre class="fragment">          BWK is COMPLEX array, dimension (LDB,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUB</td><td><pre class="fragment">          TAUB is COMPLEX array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by SGGRQF.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK, LWORK &gt;= max(N,M,P)**2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (max(N,M,P))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - Q'*A ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Z - Q'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( M*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gabe5f303c97976c8ca2871a3a253e2113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cgrqts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BWK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 4 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGRQTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGRQTS tests CGGRQF, which computes the GRQ factorization of an
 M-by-N matrix A and a P-by-N matrix B: A = R*Q and B = Z*T*Q.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The M-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (LDA,N)
          Details of the GRQ factorization of A and B, as returned
          by CGGRQF, see CGGRQF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDA,N)
          The N-by-N unitary matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is COMPLEX array, dimension (LDA,MAX(M,N))</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUA</td><td><pre class="fragment">          TAUA is COMPLEX array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by SGGQRC.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,N)
          On entry, the P-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by CGGRQF, see CGGRQF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension (LDB,P)
          The P-by-P unitary matrix Z.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is COMPLEX array, dimension (LDB,max(P,N))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWK</td><td><pre class="fragment">          BWK is COMPLEX array, dimension (LDB,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUB</td><td><pre class="fragment">          TAUB is COMPLEX array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by SGGRQF.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK, LWORK &gt;= max(M,P,N)**2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - A*Q' ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Q - Z'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( N*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d7553f6e0d22cd4f061e493c45d2ff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cgsvts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldr, * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 6 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CGSVTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGSVTS tests CGGSVD, which computes the GSVD of an M-by-N matrix A
 and a P-by-N matrix B:
              U'*A*Q = D1*R and V'*B*Q = D2*R.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,M)
          The M-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (LDA,N)
          Details of the GSVD of A and B, as returned by CGGSVD,
          see CGGSVD for further details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A and AF.
          LDA &gt;= max( 1,M ).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,P)
          On entry, the P-by-N matrix B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (LDB,N)
          Details of the GSVD of A and B, as returned by CGGSVD,
          see CGGSVD for further details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B and BF.
          LDB &gt;= max(1,P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension(LDU,M)
          The M by M unitary matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U. LDU &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension(LDV,M)
          The P by P unitary matrix V.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of the array V. LDV &gt;= max(1,P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension(LDQ,N)
          The N by N unitary matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q. LDQ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL array, dimension (N)

          The generalized singular value pairs of A and B, the
          ``diagonal'' matrices D1 and D2 are constructed from
          ALPHA and BETA, see subroutine CGGSVD for details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is COMPLEX array, dimension(LDQ,N)
          The upper triangular matrix R.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDR</td><td><pre class="fragment">          LDR is INTEGER
          The leading dimension of the array R. LDR &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK,
          LWORK &gt;= max(M,P,N)*max(M,P,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (max(M,P,N))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (5)
          The test ratios:
          RESULT(1) = norm( U'*A*Q - D1*R ) / ( MAX(M,N)*norm(A)*ULP)
          RESULT(2) = norm( V'*B*Q - D2*R ) / ( MAX(P,N)*norm(B)*ULP)
          RESULT(3) = norm( I - U'*U ) / ( M*ULP )
          RESULT(4) = norm( I - V'*V ) / ( P*ULP )
          RESULT(5) = norm( I - Q'*Q ) / ( N*ULP )
          RESULT(6) = 0        if ALPHA is in decreasing order;
                    = ULPINV   otherwise.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga96644c54365d8da1b272d9ad4412d38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine chbt21 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CHBT21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CHBT21  generally checks a decomposition of the form

         A = U S UC&gt;
 where * means conjugate transpose, A is hermitian banded, U is
 unitary, and S is diagonal (if KS=0) or symmetric
 tridiagonal (if KS=1).

 Specifically:

         RESULT(1) = | A - U S U* | / ( |A| n ulp ) *andC&gt;         RESULT(2) = | I - UU* | / ( n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, CHBT21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KA</td><td><pre class="fragment">          KA is INTEGER
          The bandwidth of the matrix A.  It must be at least zero.  If
          it is larger than N-1, then max( 0, N-1 ) will be used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KS</td><td><pre class="fragment">          KS is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          hermitian, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least min( KA, N-1 ).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KS=0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, N)
          The unitary matrix in the decomposition, expressed as a
          dense matrix (i.e., not as a product of Householder
          transformations, Givens transformations, etc.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga25f6db849fd0d68eaa2e68917e36a38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine chet21 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CHET21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CHET21 generally checks a decomposition of the form

    A = U S UC&gt;
 where * means conjugate transpose, A is hermitian, U is unitary, and
 S is diagonal (if KBAND=0) or (real) symmetric tridiagonal (if
 KBAND=1).

 If ITYPE=1, then U is represented as a dense matrix; otherwise U is
 expressed as a product of Householder transformations, whose vectors
 are stored in the array "V" and whose scaling constants are in "TAU".
 We shall use the letter "V" to refer to the product of Householder
 transformations (which should be equal to U).

 Specifically, if ITYPE=1, then:

    RESULT(1) = | A - U S U* | / ( |A| n ulp ) *andC&gt;    RESULT(2) = | I - UU* | / ( n ulp )

 If ITYPE=2, then:

    RESULT(1) = | A - V S V* | / ( |A| n ulp )

 If ITYPE=3, then:

    RESULT(1) = | I - UV* | / ( n ulp )

 For ITYPE &gt; 1, the transformation U is expressed as a product
 V = H(1)...H(n-2),  where H(j) = I  -  tau(j) v(j) v(j)C&gt; and each
 vector v(j) has its first j elements 0 and the remaining n-j elements
 stored in V(j+1:n,j).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense unitary matrix:
             RESULT(1) = | A - U S U* | / ( |A| n ulp )   *andC&gt;             RESULT(2) = | I - UU* | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V* | / ( |A| n ulp )

          3: U expressed both as a dense unitary matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - UV* | / ( n ulp )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, CHET21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          hermitian, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the unitary matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension (LDV, N)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the unitary matrix
          in the decomposition.  If UPLO='L', then the vectors are in
          the lower triangle, if UPLO='U', then in the upper
          triangle.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is COMPLEX array, dimension (N)
          If ITYPE &gt;= 2, then TAU(j) is the scalar factor of
          v(j) v(j)* in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE &lt; 2, then TAU is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (2*N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d76f9028abf55ff509d2fb0a58ed763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine chet22 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CHET22</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      CHET22  generally checks a decomposition of the form

              A U = U S

      where A is complex Hermitian, the columns of U are orthonormal,
      and S is diagonal (if KBAND=0) or symmetric tridiagonal (if
      KBAND=1).  If ITYPE=1, then U is represented as a dense matrix,
      otherwise the U is expressed as a product of Householder
      transformations, whose vectors are stored in the array "V" and
      whose scaling constants are in "TAU"; we shall use the letter
      "V" to refer to the product of Householder transformations
      (which should be equal to U).

      Specifically, if ITYPE=1, then:

              RESULT(1) = | U' A U - S | / ( |A| m ulp ) *andC&gt;              RESULT(2) = | I - U'U | / ( m ulp )</pre> <pre class="fragment">  ITYPE   INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC&gt;             RESULT(2) = | I - UU' | / ( n ulp )

  UPLO    CHARACTER
          If UPLO='U', the upper triangle of A will be used and the
          (strictly) lower triangle will not be referenced.  If
          UPLO='L', the lower triangle of A will be used and the
          (strictly) upper triangle will not be referenced.
          Not modified.

  N       INTEGER
          The size of the matrix.  If it is zero, CHET22 does nothing.
          It must be at least zero.
          Not modified.

  M       INTEGER
          The number of columns of U.  If it is zero, CHET22 does
          nothing.  It must be at least zero.
          Not modified.

  KBAND   INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.
          Not modified.

  A       COMPLEX array, dimension (LDA , N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.
          Not modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.
          Not modified.

  D       REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.
          Not modified.

  E       REAL array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is ignored, E(2) is the (1,2) and (2,1) element, etc.
          Not referenced if KBAND=0.
          Not modified.

  U       COMPLEX array, dimension (LDU, N)
          If ITYPE=1, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.
          Not modified.

  LDU     INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.
          Not modified.

  V       COMPLEX array, dimension (LDV, N)
          If ITYPE=2 or 3, the lower triangle of this array contains
          the Householder vectors used to describe the orthogonal
          matrix in the decomposition.  If ITYPE=1, then it is not
          referenced.
          Not modified.

  LDV     INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.
          Not modified.

  TAU     COMPLEX array, dimension (N)
          If ITYPE &gt;= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE &lt; 2, then TAU is not referenced.
          Not modified.

  WORK    COMPLEX array, dimension (2*N**2)
          Workspace.
          Modified.

  RWORK   REAL array, dimension (N)
          Workspace.
          Modified.

  RESULT  REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if LDU is at least N.
          Modified.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0279384c87f94223fdf27a4d97f4f7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine chkxer </td>
          <td>(</td>
          <td class="paramtype">character*(*)&#160;</td>
          <td class="paramname"><em>SRNAMT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFOT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>LERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>OK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CHKXER</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> </pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa33d87ed9b63b7751f2e0111cec1eb47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine chpt21 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CHPT21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CHPT21  generally checks a decomposition of the form

         A = U S UC&gt;
 where * means conjugate transpose, A is hermitian, U is
 unitary, and S is diagonal (if KBAND=0) or (real) symmetric
 tridiagonal (if KBAND=1).  If ITYPE=1, then U is represented as
 a dense matrix, otherwise the U is expressed as a product of
 Householder transformations, whose vectors are stored in the
 array "V" and whose scaling constants are in "TAU"; we shall
 use the letter "V" to refer to the product of Householder
 transformations (which should be equal to U).

 Specifically, if ITYPE=1, then:

         RESULT(1) = | A - U S U* | / ( |A| n ulp ) *andC&gt;         RESULT(2) = | I - UU* | / ( n ulp )

 If ITYPE=2, then:

         RESULT(1) = | A - V S V* | / ( |A| n ulp )

 If ITYPE=3, then:

         RESULT(1) = | I - UV* | / ( n ulp )

 Packed storage means that, for example, if UPLO='U', then the columns
 of the upper triangle of A are stored one after another, so that
 A(1,j+1) immediately follows A(j,j) in the array AP.  Similarly, if
 UPLO='L', then the columns of the lower triangle of A are stored one
 after another in AP, so that A(j+1,j+1) immediately follows A(n,j)
 in the array AP.  This means that A(i,j) is stored in:

    AP( i + j*(j-1)/2 )                 if UPLO='U'

    AP( i + (2*n-j)*(j-1)/2 )           if UPLO='L'

 The array VP bears the same relation to the matrix V that A does to
 AP.

 For ITYPE &gt; 1, the transformation U is expressed as a product
 of Householder transformations:

    If UPLO='U', then  V = H(n-1)...H(1),  where

        H(j) = I  -  tau(j) v(j) v(j)C&gt;
    and the first j-1 elements of v(j) are stored in V(1:j-1,j+1),
    (i.e., VP( j*(j+1)/2 + 1 : j*(j+1)/2 + j-1 ) ),
    the j-th element is 1, and the last n-j elements are 0.

    If UPLO='L', then  V = H(1)...H(n-1),  where

        H(j) = I  -  tau(j) v(j) v(j)C&gt;
    and the first j elements of v(j) are 0, the (j+1)-st is 1, and the
    (j+2)-nd through n-th elements are stored in V(j+2:n,j) (i.e.,
    in VP( (2*n-j)*(j-1)/2 + j+2 : (2*n-j)*(j-1)/2 + n ) .)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense unitary matrix:
             RESULT(1) = | A - U S U* | / ( |A| n ulp )   *andC&gt;             RESULT(2) = | I - UU* | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V* | / ( |A| n ulp )

          3: U expressed both as a dense unitary matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - UV* | / ( n ulp )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, CHPT21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AP</td><td><pre class="fragment">          AP is COMPLEX array, dimension (N*(N+1)/2)
          The original (unfactored) matrix.  It is assumed to be
          hermitian, and contains the columns of just the upper
          triangle (UPLO='U') or only the lower triangle (UPLO='L'),
          packed one after another.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the unitary matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VP</td><td><pre class="fragment">          VP is REAL array, dimension (N*(N+1)/2)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the unitary matrix
          in the decomposition, as described in purpose.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is COMPLEX array, dimension (N)
          If ITYPE &gt;= 2, then TAU(j) is the scalar factor of
          v(j) v(j)* in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE &lt; 2, then TAU is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (N**2)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga30cd77400ba8f6d9e0cc2b316f549fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine chst01 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldh, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CHST01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CHST01 tests the reduction of a general matrix A to upper Hessenberg
 form:  A = Q*H*Q'.  Two test ratios are computed;

 RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
 RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )

 The matrix Q is assumed to be given explicitly as it would be
 following CGEHRD + CUNGHR.

 In this version, ILO and IHI are not used, but they could be used
 to save some work if this is desired.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILO</td><td><pre class="fragment">          ILO is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IHI</td><td><pre class="fragment">          IHI is INTEGER

          A is assumed to be upper triangular in rows and columns
          1:ILO-1 and IHI+1:N, so Q differs from the identity only in
          rows and columns ILO+1:IHI.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The original n by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX array, dimension (LDH,N)
          The upper Hessenberg matrix H from the reduction A = Q*H*Q'
          as computed by CGEHRD.  H is assumed to be zero below the
          first subdiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDH</td><td><pre class="fragment">          LDH is INTEGER
          The leading dimension of the array H.  LDH &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is COMPLEX array, dimension (LDQ,N)
          The orthogonal matrix Q from the reduction A = Q*H*Q' as
          computed by CGEHRD + CUNGHR.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  LWORK &gt;= 2*N*N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
          RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab0239c5b213ef1d200099e057195d13f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clarfy </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLARFY</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLARFY applies an elementary reflector, or Householder matrix, H,
 to an n x n Hermitian matrix C, from both the left and the right.

 H is represented in the form

    H = I - tau * v * v'

 where  tau  is a scalar and  v  is a vector.

 If  tau  is  zero, then  H  is taken to be the unit matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          Hermitian matrix C is stored.
          = 'U':  Upper triangle
          = 'L':  Lower triangle</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of rows and columns of the matrix C.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension
                  (1 + (N-1)*abs(INCV))
          The vector v as described above.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INCV</td><td><pre class="fragment">          INCV is INTEGER
          The increment between successive elements of v.  INCV must
          not be zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is COMPLEX
          The value tau as described above.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX array, dimension (LDC, N)
          On entry, the matrix C.
          On exit, C is overwritten by H * C * H'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of the array C.  LDC &gt;= max( 1, N ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (N)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga275bf58dfd5af715eea76b14ff5f6023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clarhs </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>XTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLARHS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLARHS chooses a set of NRHS random solution vectors and sets
 up the right hand sides for the linear system
    op( A ) * X = B,
 where op( A ) may be A, A**T (transpose of A), or A**H (conjugate
 transpose of A).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The type of the complex matrix A.  PATH may be given in any
          combination of upper and lower case.  Valid paths include
             xGE:  General m x n matrix
             xGB:  General banded matrix
             xPO:  Hermitian positive definite, 2-D storage
             xPP:  Hermitian positive definite packed
             xPB:  Hermitian positive definite banded
             xHE:  Hermitian indefinite, 2-D storage
             xHP:  Hermitian indefinite packed
             xHB:  Hermitian indefinite banded
             xSY:  Symmetric indefinite, 2-D storage
             xSP:  Symmetric indefinite packed
             xSB:  Symmetric indefinite banded
             xTR:  Triangular
             xTP:  Triangular packed
             xTB:  Triangular banded
             xQR:  General m x n matrix
             xLQ:  General m x n matrix
             xQL:  General m x n matrix
             xRQ:  General m x n matrix
          where the leading character indicates the precision.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">XTYPE</td><td><pre class="fragment">          XTYPE is CHARACTER*1
          Specifies how the exact solution X will be determined:
          = 'N':  New solution; generate a random X.
          = 'C':  Computed; use value of X on entry.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Used only if A is symmetric or triangular; specifies whether
          the upper or lower triangular part of the matrix A is stored.
          = 'U':  Upper triangular
          = 'L':  Lower triangular</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANS</td><td><pre class="fragment">          TRANS is CHARACTER*1
          Used only if A is nonsymmetric; specifies the operation
          applied to the matrix A.
          = 'N':  B := A    * X
          = 'T':  B := A**T * X
          = 'C':  B := A**H * X</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
          Used only if A is a band matrix; specifies the number of
          subdiagonals of A if A is a general band matrix or if A is
          symmetric or triangular and UPLO = 'L'; specifies the number
          of superdiagonals of A if A is symmetric or triangular and
          UPLO = 'U'.  0 &lt;= KL &lt;= M-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
          Used only if A is a general band matrix or if A is
          triangular.

          If PATH = xGB, specifies the number of superdiagonals of A,
          and 0 &lt;= KU &lt;= N-1.

          If PATH = xTR, xTP, or xTB, specifies whether or not the
          matrix has unit diagonal:
          = 1:  matrix has non-unit diagonal (default)
          = 2:  matrix has unit diagonal</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of right hand side vectors in the system A*X = B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The test matrix whose type is given by PATH.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.
          If PATH = xGB, LDA &gt;= KL+KU+1.
          If PATH = xPB, xSB, xHB, or xTB, LDA &gt;= KL+1.
          Otherwise, LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">X</td><td><pre class="fragment">          X is or output) COMPLEX array, dimension (LDX,NRHS)
          On entry, if XTYPE = 'C' (for 'Computed'), then X contains
          the exact solution to the system of linear equations.
          On exit, if XTYPE = 'N' (for 'New'), then X is initialized
          with random values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX &gt;= max(1,N); if TRANS = 'T', LDX &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,NRHS)
          The right hand side vector(s) for the system of equations,
          computed from B = op(A) * X, where op(A) is determined by
          TRANS.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  If TRANS = 'N',
          LDB &gt;= max(1,M); if TRANS = 'T', LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          The seed vector for the random number generator (used in
          CLATMS).  Modified on exit.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga30a0faa6bcbc4df466ebfab225b826a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clatm4 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NZ1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NZ2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>RSIGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>AMAGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RCOND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>TRIANG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLATM4</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLATM4 generates basic square matrices, which may later be
 multiplied by others in order to produce test matrices.  It is
 intended mainly to be used to test the generalized eigenvalue
 routines.

 It first generates the diagonal and (possibly) subdiagonal,
 according to the value of ITYPE, NZ1, NZ2, RSIGN, AMAGN, and RCOND.
 It then fills in the upper triangle with random numbers, if TRIANG is
 non-zero.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          The "type" of matrix on the diagonal and sub-diagonal.
          If ITYPE &lt; 0, then type abs(ITYPE) is generated and then
             swapped end for end (A(I,J) := A'(N-J,N-I).)  See also
             the description of AMAGN and RSIGN.

          Special types:
          = 0:  the zero matrix.
          = 1:  the identity.
          = 2:  a transposed Jordan block.
          = 3:  If N is odd, then a k+1 x k+1 transposed Jordan block
                followed by a k x k identity block, where k=(N-1)/2.
                If N is even, then k=(N-2)/2, and a zero diagonal entry
                is tacked onto the end.

          Diagonal types.  The diagonal consists of NZ1 zeros, then
             k=N-NZ1-NZ2 nonzeros.  The subdiagonal is zero.  ITYPE
             specifies the nonzero diagonal entries as follows:
          = 4:  1, ..., k
          = 5:  1, RCOND, ..., RCOND
          = 6:  1, ..., 1, RCOND
          = 7:  1, a, a^2, ..., a^(k-1)=RCOND
          = 8:  1, 1-d, 1-2*d, ..., 1-(k-1)*d=RCOND
          = 9:  random numbers chosen from (RCOND,1)
          = 10: random numbers with distribution IDIST (see CLARND.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NZ1</td><td><pre class="fragment">          NZ1 is INTEGER
          If abs(ITYPE) &gt; 3, then the first NZ1 diagonal entries will
          be zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NZ2</td><td><pre class="fragment">          NZ2 is INTEGER
          If abs(ITYPE) &gt; 3, then the last NZ2 diagonal entries will
          be zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RSIGN</td><td><pre class="fragment">          RSIGN is LOGICAL
          = .TRUE.:  The diagonal and subdiagonal entries will be
                     multiplied by random numbers of magnitude 1.
          = .FALSE.: The diagonal and subdiagonal entries will be
                     left as they are (usually non-negative real.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AMAGN</td><td><pre class="fragment">          AMAGN is REAL
          The diagonal and subdiagonal entries will be multiplied by
          AMAGN.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCOND</td><td><pre class="fragment">          RCOND is REAL
          If abs(ITYPE) &gt; 4, then the smallest diagonal entry will be
          RCOND.  RCOND must be between 0 and 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRIANG</td><td><pre class="fragment">          TRIANG is REAL
          The entries above the diagonal will be random numbers with
          magnitude bounded by TRIANG (i.e., random numbers multiplied
          by TRIANG.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is INTEGER
          On entry, DIST specifies the type of distribution to be used
          to generate a random matrix .
          = 1: real and imaginary parts each UNIFORM( 0, 1 )
          = 2: real and imaginary parts each UNIFORM( -1, 1 )
          = 3: real and imaginary parts each NORMAL( 0, 1 )
          = 4: complex number uniform in DISK( 0, 1 )</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator.  The values of ISEED are changed on exit, and can
          be used in the next call to CLATM4 to continue the same
          random number sequence.
          Note: ISEED(4) should be odd, for the random number generator
          used at present.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          Array to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          Leading dimension of A.  Must be at least 1 and at least N.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga90c4512d4a10ff8cc0050e0aaa112b5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> clctes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLCTES</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLCTES returns .TRUE. if the eigenvalue Z/D is to be selected
 (specifically, in this subroutine, if the real part of the
 eigenvalue is negative), and otherwise it returns .FALSE..

 It is used by the test routine CDRGES to test whether the driver
 routine CGGES succesfully sorts eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX
          The numerator part of a complex eigenvalue Z/D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX
          The denominator part of a complex eigenvalue Z/D.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2475404f498a9fc9f7146da5a6829ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> clctsx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>BETA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLCTSX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This function is used to determine what eigenvalues will be
 selected.  If this is part of the test driver CDRGSX, do not
 change the code UNLESS you are testing input examples and not
 using the built-in examples.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX

          parameters to decide whether the pair (ALPHA, BETA) is
          selected.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e6951c28a4f982e487adfaf3fc6c989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine clsets </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>CF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLSETS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLSETS tests CGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The M-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is COMPLEX array, dimension (LDA,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF, Q and R.
          LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB,N)
          The P-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is COMPLEX array, dimension (LDB,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF, V and S.
          LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX array, dimension( M )
          the vector C in the LSE problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CF</td><td><pre class="fragment">          CF is COMPLEX array, dimension( M )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array, dimension( P )
          the vector D in the LSE problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DF</td><td><pre class="fragment">          DF is COMPLEX array, dimension( P )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension( N )
          solution vector X in the LSE problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The test ratios:
            RESULT(1) = norm( A*x - c )/ norm(A)*norm(X)*EPS
            RESULT(2) = norm( B*x - d )/ norm(B)*norm(X)*EPS</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga93ee535a3f54f2c0ea6d2da4f7d8fa84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine csbmv </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSBMV</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSBMV  performs the matrix-vector  operation

    y := alpha*A*x + beta*y,

 where alpha and beta are scalars, x and y are n element vectors and
 A is an n by n symmetric band matrix, with k super-diagonals.</pre> <pre class="fragment">  UPLO   - CHARACTER*1
           On entry, UPLO specifies whether the upper or lower
           triangular part of the band matrix A is being supplied as
           follows:

              UPLO = 'U' or 'u'   The upper triangular part of A is
                                  being supplied.

              UPLO = 'L' or 'l'   The lower triangular part of A is
                                  being supplied.

           Unchanged on exit.

  N      - INTEGER
           On entry, N specifies the order of the matrix A.
           N must be at least zero.
           Unchanged on exit.

  K      - INTEGER
           On entry, K specifies the number of super-diagonals of the
           matrix A. K must satisfy  0 .le. K.
           Unchanged on exit.

  ALPHA  - COMPLEX
           On entry, ALPHA specifies the scalar alpha.
           Unchanged on exit.

  A      - COMPLEX array, dimension( LDA, N )
           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
           by n part of the array A must contain the upper triangular
           band part of the symmetric matrix, supplied column by
           column, with the leading diagonal of the matrix in row
           ( k + 1 ) of the array, the first super-diagonal starting at
           position 2 in row k, and so on. The top left k by k triangle
           of the array A is not referenced.
           The following program segment will transfer the upper
           triangular part of a symmetric band matrix from conventional
           full matrix storage to band storage:

                 DO 20, J = 1, N
                    M = K + 1 - J
                    DO 10, I = MAX( 1, J - K ), J
                       A( M + I, J ) = matrix( I, J )
              10    CONTINUE
              20 CONTINUE

           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
           by n part of the array A must contain the lower triangular
           band part of the symmetric matrix, supplied column by
           column, with the leading diagonal of the matrix in row 1 of
           the array, the first sub-diagonal starting at position 1 in
           row 2, and so on. The bottom right k by k triangle of the
           array A is not referenced.
           The following program segment will transfer the lower
           triangular part of a symmetric band matrix from conventional
           full matrix storage to band storage:

                 DO 20, J = 1, N
                    M = 1 - J
                    DO 10, I = J, MIN( N, J + K )
                       A( M + I, J ) = matrix( I, J )
              10    CONTINUE
              20 CONTINUE

           Unchanged on exit.

  LDA    - INTEGER
           On entry, LDA specifies the first dimension of A as declared
           in the calling (sub) program. LDA must be at least
           ( k + 1 ).
           Unchanged on exit.

  X      - COMPLEX array, dimension at least
           ( 1 + ( N - 1 )*abs( INCX ) ).
           Before entry, the incremented array X must contain the
           vector x.
           Unchanged on exit.

  INCX   - INTEGER
           On entry, INCX specifies the increment for the elements of
           X. INCX must not be zero.
           Unchanged on exit.

  BETA   - COMPLEX
           On entry, BETA specifies the scalar beta.
           Unchanged on exit.

  Y      - COMPLEX array, dimension at least
           ( 1 + ( N - 1 )*abs( INCY ) ).
           Before entry, the incremented array Y must contain the
           vector y. On exit, Y is overwritten by the updated vector y.

  INCY   - INTEGER
           On entry, INCY specifies the increment for the elements of
           Y. INCY must not be zero.
           Unchanged on exit.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ba73334a6847224855e1cd46190a57e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine csgt01 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSGT01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSGT01 checks a decomposition of the form

    A Z   =  B Z D or
    A B Z =  Z D or
    B A Z =  Z D

 where A is a Hermitian matrix, B is Hermitian positive definite,
 Z is unitary, and D is diagonal.

 One of the following test ratios is computed:

 ITYPE = 1:  RESULT(1) = | A Z - B Z D | / ( |A| |Z| n ulp )

 ITYPE = 2:  RESULT(1) = | A B Z - Z D | / ( |A| |Z| n ulp )

 ITYPE = 3:  RESULT(1) = | B A Z - Z D | / ( |A| |Z| n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          The form of the Hermitian generalized eigenproblem.
          = 1:  A*z = (lambda)*B*z
          = 2:  A*B*z = (lambda)*z
          = 3:  B*A*z = (lambda)*z</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          Hermitian matrices A and B is stored.
          = 'U':  Upper triangular
          = 'L':  Lower triangular</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of eigenvalues found.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, N)
          The original Hermitian matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB, N)
          The original Hermitian positive definite matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX array, dimension (LDZ, M)
          The computed eigenvectors of the generalized eigenproblem.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDZ</td><td><pre class="fragment">          LDZ is INTEGER
          The leading dimension of the array Z.  LDZ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (M)
          The computed eigenvalues of the generalized eigenproblem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (N*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (1)
          The test ratio as described above.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d9f3211db914cec239828108033783a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> cslect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSLECT</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSLECT returns .TRUE. if the eigenvalue Z is to be selected,
 otherwise it returns .FALSE.
 It is used by CCHK41 to test if CGEES succesfully sorts eigenvalues,
 and by CCHK43 to test if CGEESX succesfully sorts eigenvalues.

 The common block /SSLCT/ controls how eigenvalues are selected.
 If SELOPT = 0, then CSLECT return .TRUE. when real(Z) is less than
 zero, and .FALSE. otherwise.
 If SELOPT is at least 1, CSLECT returns SELVAL(SELOPT) and adds 1
 to SELOPT, cycling back to 1 at SELMAX.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX
          The eigenvalue Z.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bad51cd5228d6748888b32aaa29b8e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cstt21 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>AD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>AE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSTT21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSTT21  checks a decomposition of the form

    A = U S UC&gt;
 where * means conjugate transpose, A is real symmetric tridiagonal,
 U is unitary, and S is real and diagonal (if KBAND=0) or symmetric
 tridiagonal (if KBAND=1).  Two tests are performed:

    RESULT(1) = | A - U S U* | / ( |A| n ulp )

    RESULT(2) = | I - UU* | / ( n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, CSTT21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AD</td><td><pre class="fragment">          AD is REAL array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be real symmetric tridiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AE</td><td><pre class="fragment">          AE is REAL array, dimension (N-1)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be symmetric tridiagonal.  AE(1) is the (1,2)
          and (2,1) element, AE(2) is the (2,3) and (3,2) element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is REAL array, dimension (N)
          The diagonal of the real (symmetric tri-) diagonal matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is REAL array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is the
          (1,2) and (2,1) element, SE(2) is the (2,3) and (3,2)
          element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU, N)
          The unitary matrix in the decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga26e28ed198349b9824bd5809a4b72b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cstt22 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>AD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>AE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldwork, * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSTT22</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSTT22  checks a set of M eigenvalues and eigenvectors,

     A U = U S

 where A is Hermitian tridiagonal, the columns of U are unitary,
 and S is diagonal (if KBAND=0) or Hermitian tridiagonal (if KBAND=1).
 Two tests are performed:

    RESULT(1) = | U* A U - S | / ( |A| m ulp )

    RESULT(2) = | I - U*U | / ( m ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, CSTT22 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of eigenpairs to check.  If it is zero, CSTT22
          does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is Hermitian tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AD</td><td><pre class="fragment">          AD is REAL array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be Hermitian tridiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AE</td><td><pre class="fragment">          AE is REAL array, dimension (N)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be Hermitian tridiagonal.  AE(1) is ignored,
          AE(2) is the (1,2) and (2,1) element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is REAL array, dimension (N)
          The diagonal of the (Hermitian tri-) diagonal matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is REAL array, dimension (N)
          The off-diagonal of the (Hermitian tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is
          ignored, SE(2) is the (1,2) and (2,1) element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is REAL array, dimension (LDU, N)
          The unitary matrix in the decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LDWORK, M+1)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDWORK</td><td><pre class="fragment">          LDWORK is INTEGER
          The leading dimension of WORK.  LDWORK must be at least
          max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a9b6679b2002fda89e08e1a922e3aeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cunt01 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>ROWCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CUNT01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CUNT01 checks that the matrix U is unitary by computing the ratio

    RESID = norm( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = norm( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 Alternatively, if there isn't sufficient workspace to form
 I - U*U' or I - U'*U, the ratio is computed as

    RESID = abs( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = abs( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 where EPS is the machine precision.  ROWCOL is used only if m = n;
 if m &gt; n, ROWCOL is assumed to be 'C', and if m &lt; n, ROWCOL is
 assumed to be 'R'.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ROWCOL</td><td><pre class="fragment">          ROWCOL is CHARACTER
          Specifies whether the rows or columns of U should be checked
          for orthogonality.  Used only if M = N.
          = 'R':  Check for orthogonal rows of U
          = 'C':  Check for orthogonal columns of U</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU,N)
          The unitary matrix U.  U is checked for orthogonal columns
          if m &gt; n or if m = n and ROWCOL = 'C'.  U is checked for
          orthogonal rows if m &lt; n or if m = n and ROWCOL = 'R'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U.  LDU &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*N if ROWCOL = 'C' or M*M if
          ROWCOL = 'R', but the test will be done even if LWORK is 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (min(M,N))
          Used only if LWORK is large enough to use the Level 3 BLAS
          code.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is REAL
          RESID = norm( I - U * U' ) / ( n * EPS ), if ROWCOL = 'R', or
          RESID = norm( I - U' * U ) / ( m * EPS ), if ROWCOL = 'C'.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab5dc85ead2be87d8497fd4f2c4d903d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine cunt03 </td>
          <td>(</td>
          <td class="paramtype">character*( * )&#160;</td>
          <td class="paramname"><em>RC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CUNT03</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CUNT03 compares two unitary matrices U and V to see if their
 corresponding rows or columns span the same spaces.  The rows are
 checked if RC = 'R', and the columns are checked if RC = 'C'.

 RESULT is the maximum of

    | V*V' - I | / ( MV ulp ), if RC = 'R', or

    | V'*V - I | / ( MV ulp ), if RC = 'C',

 and the maximum over rows (or columns) 1 to K of

    | U(i) - S*V(i) |/ ( N ulp )

 where abs(S) = 1 (chosen to minimize the expression), U(i) is the
 i-th row (column) of U, and V(i) is the i-th row (column) of V.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RC</td><td><pre class="fragment">          RC is CHARACTER*1
          If RC = 'R' the rows of U and V are to be compared.
          If RC = 'C' the columns of U and V are to be compared.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MU</td><td><pre class="fragment">          MU is INTEGER
          The number of rows of U if RC = 'R', and the number of
          columns if RC = 'C'.  If MU = 0 CUNT03 does nothing.
          MU must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MV</td><td><pre class="fragment">          MV is INTEGER
          The number of rows of V if RC = 'R', and the number of
          columns if RC = 'C'.  If MV = 0 CUNT03 does nothing.
          MV must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          If RC = 'R', the number of columns in the matrices U and V,
          and if RC = 'C', the number of rows in U and V.  If N = 0
          CUNT03 does nothing.  N must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
          The number of rows or columns of U and V to compare.
          0 &lt;= K &lt;= max(MU,MV).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is COMPLEX array, dimension (LDU,N)
          The first matrix to compare.  If RC = 'R', U is MU by N, and
          if RC = 'C', U is N by MU.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  If RC = 'R', LDU &gt;= max(1,MU),
          and if RC = 'C', LDU &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is COMPLEX array, dimension (LDV,N)
          The second matrix to compare.  If RC = 'R', V is MV by N, and
          if RC = 'C', V is N by MV.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  If RC = 'R', LDV &gt;= max(1,MV),
          and if RC = 'C', LDV &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*N if RC = 'C' or M*M if RC = 'R', but
          the tests will be done even if LWORK is 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is REAL array, dimension (max(MV,N))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is REAL
          The value computed by the test described above.  RESULT is
          limited to 1/ulp to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          0  indicates a successful exit
          -k indicates the k-th parameter had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:25:23 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
