<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: Other Auxiliary Routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Other Auxiliary Routines<div class="ingroups"><a class="el" href="group__lapack.html">LAPACK</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga06d6aa332f6f66e062e9b96a41f40800"><td class="memItemLeft" align="right" valign="top">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga06d6aa332f6f66e062e9b96a41f40800">dlamch</a> (CMACH)</td></tr>
<tr class="memdesc:ga06d6aa332f6f66e062e9b96a41f40800"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAMCH</b>  <a href="#ga06d6aa332f6f66e062e9b96a41f40800">More...</a><br /></td></tr>
<tr class="separator:ga06d6aa332f6f66e062e9b96a41f40800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae762ae5fb996f7b2970c522d10fa22f2"><td class="memItemLeft" align="right" valign="top">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gae762ae5fb996f7b2970c522d10fa22f2">dlamc3</a> (<a class="el" href="classA.html">A</a>, B)</td></tr>
<tr class="memdesc:gae762ae5fb996f7b2970c522d10fa22f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAMC3</b>  <a href="#gae762ae5fb996f7b2970c522d10fa22f2">More...</a><br /></td></tr>
<tr class="separator:gae762ae5fb996f7b2970c522d10fa22f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48732e43b3051e58aee28857c75ce270"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga48732e43b3051e58aee28857c75ce270">dlamc1</a> (BETA, T, RND, IEEE1)</td></tr>
<tr class="memdesc:ga48732e43b3051e58aee28857c75ce270"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAMC1</b>  <a href="#ga48732e43b3051e58aee28857c75ce270">More...</a><br /></td></tr>
<tr class="separator:ga48732e43b3051e58aee28857c75ce270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dce45f915606712ff791e280ddad827"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga0dce45f915606712ff791e280ddad827">dlamc2</a> (BETA, T, RND, <a class="el" href="tukey_8c.html#a6ebf6899d6c1c8b7b9d09be872c05aae">EPS</a>, EMIN, RMIN, EMAX, RMAX)</td></tr>
<tr class="memdesc:ga0dce45f915606712ff791e280ddad827"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAMC2</b>  <a href="#ga0dce45f915606712ff791e280ddad827">More...</a><br /></td></tr>
<tr class="separator:ga0dce45f915606712ff791e280ddad827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbf236050aae6e38c07d118c3611f96"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gafdbf236050aae6e38c07d118c3611f96">__dlamchtst.f__</a></td></tr>
<tr class="memdesc:gafdbf236050aae6e38c07d118c3611f96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAMCHTST</b>  <a href="#gafdbf236050aae6e38c07d118c3611f96">More...</a><br /></td></tr>
<tr class="separator:gafdbf236050aae6e38c07d118c3611f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe21a6b76340ac0afd7f0f84326e7918"><td class="memItemLeft" align="right" valign="top">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gafe21a6b76340ac0afd7f0f84326e7918">dsecnd</a> ()</td></tr>
<tr class="memdesc:gafe21a6b76340ac0afd7f0f84326e7918"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSECND</b> Using ETIME  <a href="#gafe21a6b76340ac0afd7f0f84326e7918">More...</a><br /></td></tr>
<tr class="separator:gafe21a6b76340ac0afd7f0f84326e7918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e549b45eabbe138df540cf0f954ec6"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga00e549b45eabbe138df540cf0f954ec6">__dsecndtst.f__</a></td></tr>
<tr class="memdesc:ga00e549b45eabbe138df540cf0f954ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSECNDTST</b>  <a href="#ga00e549b45eabbe138df540cf0f954ec6">More...</a><br /></td></tr>
<tr class="separator:ga00e549b45eabbe138df540cf0f954ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0eea943fa875e927d0b8b6614c9763"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gace0eea943fa875e927d0b8b6614c9763">ilaver</a> (VERS_MAJOR, VERS_MINOR, VERS_PATCH)</td></tr>
<tr class="memdesc:gace0eea943fa875e927d0b8b6614c9763"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ILAVER</b> returns the LAPACK version.  <a href="#gace0eea943fa875e927d0b8b6614c9763">More...</a><br /></td></tr>
<tr class="separator:gace0eea943fa875e927d0b8b6614c9763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9662e1df88fb8f65d7f42edcc6f4dda"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gab9662e1df88fb8f65d7f42edcc6f4dda">__lapack_version.f__</a></td></tr>
<tr class="memdesc:gab9662e1df88fb8f65d7f42edcc6f4dda"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>LAPACK_VERSION</b>  <a href="#gab9662e1df88fb8f65d7f42edcc6f4dda">More...</a><br /></td></tr>
<tr class="separator:gab9662e1df88fb8f65d7f42edcc6f4dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada799b40a93f1fd2c6d1a86a95f21631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gada799b40a93f1fd2c6d1a86a95f21631">lsame</a> (CA, CB)</td></tr>
<tr class="memdesc:gada799b40a93f1fd2c6d1a86a95f21631"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>LSAME</b>  <a href="#gada799b40a93f1fd2c6d1a86a95f21631">More...</a><br /></td></tr>
<tr class="separator:gada799b40a93f1fd2c6d1a86a95f21631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14a642d1c4ae2713896577ae288bb58"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac14a642d1c4ae2713896577ae288bb58">__lsametst.f__</a></td></tr>
<tr class="memdesc:gac14a642d1c4ae2713896577ae288bb58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>LSAMETST</b>  <a href="#gac14a642d1c4ae2713896577ae288bb58">More...</a><br /></td></tr>
<tr class="separator:gac14a642d1c4ae2713896577ae288bb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f971a8b343bd2fcb85c3b16da97f10"><td class="memItemLeft" align="right" valign="top">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gae9f971a8b343bd2fcb85c3b16da97f10">second</a> ()</td></tr>
<tr class="memdesc:gae9f971a8b343bd2fcb85c3b16da97f10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SECOND</b> Using ETIME  <a href="#gae9f971a8b343bd2fcb85c3b16da97f10">More...</a><br /></td></tr>
<tr class="separator:gae9f971a8b343bd2fcb85c3b16da97f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279f9f1e475af3a6e6101fbfd874f955"><td class="memItemLeft" align="right" valign="top">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga279f9f1e475af3a6e6101fbfd874f955">slamch</a> (CMACH)</td></tr>
<tr class="memdesc:ga279f9f1e475af3a6e6101fbfd874f955"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAMCH</b>  <a href="#ga279f9f1e475af3a6e6101fbfd874f955">More...</a><br /></td></tr>
<tr class="separator:ga279f9f1e475af3a6e6101fbfd874f955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063f886475dbe005f58b9c37ced98b65"><td class="memItemLeft" align="right" valign="top">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga063f886475dbe005f58b9c37ced98b65">slamc3</a> (<a class="el" href="classA.html">A</a>, B)</td></tr>
<tr class="memdesc:ga063f886475dbe005f58b9c37ced98b65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAMC3</b>  <a href="#ga063f886475dbe005f58b9c37ced98b65">More...</a><br /></td></tr>
<tr class="separator:ga063f886475dbe005f58b9c37ced98b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0259f906df485fc6fba360cb3ebef320"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga0259f906df485fc6fba360cb3ebef320">slamc1</a> (BETA, T, RND, IEEE1)</td></tr>
<tr class="memdesc:ga0259f906df485fc6fba360cb3ebef320"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAMC1</b>  <a href="#ga0259f906df485fc6fba360cb3ebef320">More...</a><br /></td></tr>
<tr class="separator:ga0259f906df485fc6fba360cb3ebef320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e67de62733142ac7f456696018d1ef"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga72e67de62733142ac7f456696018d1ef">slamc2</a> (BETA, T, RND, <a class="el" href="tukey_8c.html#a6ebf6899d6c1c8b7b9d09be872c05aae">EPS</a>, EMIN, RMIN, EMAX, RMAX)</td></tr>
<tr class="memdesc:ga72e67de62733142ac7f456696018d1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAMC2</b>  <a href="#ga72e67de62733142ac7f456696018d1ef">More...</a><br /></td></tr>
<tr class="separator:ga72e67de62733142ac7f456696018d1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e158139ad16abc79a0dce7ae8ad8c9"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac9e158139ad16abc79a0dce7ae8ad8c9">tstiee</a></td></tr>
<tr class="memdesc:gac9e158139ad16abc79a0dce7ae8ad8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>TSTIEE</b>  <a href="#gac9e158139ad16abc79a0dce7ae8ad8c9">More...</a><br /></td></tr>
<tr class="separator:gac9e158139ad16abc79a0dce7ae8ad8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230d4e1886896853b11e44e541b2c6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga230d4e1886896853b11e44e541b2c6a3">disnan</a> (DIN)</td></tr>
<tr class="memdesc:ga230d4e1886896853b11e44e541b2c6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DISNAN</b> tests input for NaN.  <a href="#ga230d4e1886896853b11e44e541b2c6a3">More...</a><br /></td></tr>
<tr class="separator:ga230d4e1886896853b11e44e541b2c6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ac7409aedb2a380d5d0e625ffbeb7a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga57ac7409aedb2a380d5d0e625ffbeb7a">dlabad</a> (SMALL, LARGE)</td></tr>
<tr class="memdesc:ga57ac7409aedb2a380d5d0e625ffbeb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLABAD</b>  <a href="#ga57ac7409aedb2a380d5d0e625ffbeb7a">More...</a><br /></td></tr>
<tr class="separator:ga57ac7409aedb2a380d5d0e625ffbeb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb8731ffab2734378157c40964bf788"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga7eb8731ffab2734378157c40964bf788">dlacpy</a> (UPLO, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>)</td></tr>
<tr class="memdesc:ga7eb8731ffab2734378157c40964bf788"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLACPY</b> copies all or part of one two-dimensional array to another.  <a href="#ga7eb8731ffab2734378157c40964bf788">More...</a><br /></td></tr>
<tr class="separator:ga7eb8731ffab2734378157c40964bf788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c0279ec29e8ac222f1e319f4144fcb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gad1c0279ec29e8ac222f1e319f4144fcb">dladiv</a> (<a class="el" href="classA.html">A</a>, B, C, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, P, Q)</td></tr>
<tr class="memdesc:gad1c0279ec29e8ac222f1e319f4144fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.  <a href="#gad1c0279ec29e8ac222f1e319f4144fcb">More...</a><br /></td></tr>
<tr class="separator:gad1c0279ec29e8ac222f1e319f4144fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a36d905c1c66d345f791b91254da0ae"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga8a36d905c1c66d345f791b91254da0ae">dlae2</a> (<a class="el" href="classA.html">A</a>, B, C, RT1, RT2)</td></tr>
<tr class="memdesc:ga8a36d905c1c66d345f791b91254da0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAE2</b> computes the eigenvalues of a 2-by-2 symmetric matrix.  <a href="#ga8a36d905c1c66d345f791b91254da0ae">More...</a><br /></td></tr>
<tr class="separator:ga8a36d905c1c66d345f791b91254da0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79da86f5a84d0038788717338eef245d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga79da86f5a84d0038788717338eef245d">dlaebz</a> (IJOB, NITMAX, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, MMAX, MINP, NBMIN, ABSTOL, RELTOL, PIVMIN, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, NVAL, AB, C, MOUT, NAB, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga79da86f5a84d0038788717338eef245d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAEBZ</b> computes the number of eigenvalues of a real symmetric tridiagonal matrix which are less than or equal to a given value, and performs other tasks required by the routine sstebz.  <a href="#ga79da86f5a84d0038788717338eef245d">More...</a><br /></td></tr>
<tr class="separator:ga79da86f5a84d0038788717338eef245d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404759a75990a78660c741b3448b27e8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga404759a75990a78660c741b3448b27e8">dlaev2</a> (<a class="el" href="classA.html">A</a>, B, C, RT1, RT2, CS1, SN1)</td></tr>
<tr class="memdesc:ga404759a75990a78660c741b3448b27e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAEV2</b> computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix.  <a href="#ga404759a75990a78660c741b3448b27e8">More...</a><br /></td></tr>
<tr class="separator:ga404759a75990a78660c741b3448b27e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbc9a87ffa4a60adadcb4fc511c2556"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga0fbc9a87ffa4a60adadcb4fc511c2556">dlagts</a> (JOB, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, B, C, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, IN, Y, TOL, INFO)</td></tr>
<tr class="memdesc:ga0fbc9a87ffa4a60adadcb4fc511c2556"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAGTS</b> solves the system of equations (T-λI)x = y or (T-λI)Tx = y,where T is a general tridiagonal matrix and λ a scalar, using the LU factorization computed by slagtf.  <a href="#ga0fbc9a87ffa4a60adadcb4fc511c2556">More...</a><br /></td></tr>
<tr class="separator:ga0fbc9a87ffa4a60adadcb4fc511c2556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga341ec834c6fc14a17fead550ff486022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga341ec834c6fc14a17fead550ff486022">dlaisnan</a> (DIN1, DIN2)</td></tr>
<tr class="memdesc:ga341ec834c6fc14a17fead550ff486022"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAISNAN</b> tests input for NaN by comparing two arguments for inequality.  <a href="#ga341ec834c6fc14a17fead550ff486022">More...</a><br /></td></tr>
<tr class="separator:ga341ec834c6fc14a17fead550ff486022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4932b5966e6a63f7d7b9f0a189003b6e"><td class="memItemLeft" align="right" valign="top">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga4932b5966e6a63f7d7b9f0a189003b6e">dlaneg</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, LLD, SIGMA, PIVMIN, R)</td></tr>
<tr class="memdesc:ga4932b5966e6a63f7d7b9f0a189003b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLANEG</b> computes the Sturm count.  <a href="#ga4932b5966e6a63f7d7b9f0a189003b6e">More...</a><br /></td></tr>
<tr class="separator:ga4932b5966e6a63f7d7b9f0a189003b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d199841a9ffcf46d31e13e326d195dc"><td class="memItemLeft" align="right" valign="top">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga2d199841a9ffcf46d31e13e326d195dc">dlanst</a> (NORM, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E)</td></tr>
<tr class="memdesc:ga2d199841a9ffcf46d31e13e326d195dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLANST</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric tridiagonal matrix.  <a href="#ga2d199841a9ffcf46d31e13e326d195dc">More...</a><br /></td></tr>
<tr class="separator:ga2d199841a9ffcf46d31e13e326d195dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf4c47c2f593fb3a4e842bca6df1240b"><td class="memItemLeft" align="right" valign="top">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gacf4c47c2f593fb3a4e842bca6df1240b">dlapy2</a> (X, Y)</td></tr>
<tr class="memdesc:gacf4c47c2f593fb3a4e842bca6df1240b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAPY2</b> returns sqrt(x2+y2).  <a href="#gacf4c47c2f593fb3a4e842bca6df1240b">More...</a><br /></td></tr>
<tr class="separator:gacf4c47c2f593fb3a4e842bca6df1240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad929930f6e7780e8a1d73b2515ddd42b"><td class="memItemLeft" align="right" valign="top">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gad929930f6e7780e8a1d73b2515ddd42b">dlapy3</a> (X, Y, Z)</td></tr>
<tr class="memdesc:gad929930f6e7780e8a1d73b2515ddd42b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAPY3</b> returns sqrt(x2+y2+z2).  <a href="#gad929930f6e7780e8a1d73b2515ddd42b">More...</a><br /></td></tr>
<tr class="separator:gad929930f6e7780e8a1d73b2515ddd42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e05a87ced667cbdb502aa87c72d056"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga77e05a87ced667cbdb502aa87c72d056">dlarnv</a> (IDIST, ISEED, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, X)</td></tr>
<tr class="memdesc:ga77e05a87ced667cbdb502aa87c72d056"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARNV</b> returns a vector of random numbers from a uniform or normal distribution.  <a href="#ga77e05a87ced667cbdb502aa87c72d056">More...</a><br /></td></tr>
<tr class="separator:ga77e05a87ced667cbdb502aa87c72d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5719c25a81a95270cd36178e283166"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga0b5719c25a81a95270cd36178e283166">dlarra</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, SPLTOL, TNRM, NSPLIT, ISPLIT, INFO)</td></tr>
<tr class="memdesc:ga0b5719c25a81a95270cd36178e283166"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRA</b> computes the splitting points with the specified threshold.  <a href="#ga0b5719c25a81a95270cd36178e283166">More...</a><br /></td></tr>
<tr class="separator:ga0b5719c25a81a95270cd36178e283166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3446b2d3189e23e5b95f18ea97b0a22"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gab3446b2d3189e23e5b95f18ea97b0a22">dlarrb</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, LLD, IFIRST, ILAST, RTOL1, RTOL2, OFFSET, W, WGAP, WERR, WORK, IWORK, PIVMIN, SPDIAM, TWIST, INFO)</td></tr>
<tr class="memdesc:gab3446b2d3189e23e5b95f18ea97b0a22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRB</b> provides limited bisection to locate eigenvalues for more accuracy.  <a href="#gab3446b2d3189e23e5b95f18ea97b0a22">More...</a><br /></td></tr>
<tr class="separator:gab3446b2d3189e23e5b95f18ea97b0a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a65096bc8be9a4dc881a96147075ea"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac6a65096bc8be9a4dc881a96147075ea">dlarrc</a> (JOBT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, VL, VU, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, PIVMIN, EIGCNT, LCNT, RCNT, INFO)</td></tr>
<tr class="memdesc:gac6a65096bc8be9a4dc881a96147075ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRC</b> computes the number of eigenvalues of the symmetric tridiagonal matrix.  <a href="#gac6a65096bc8be9a4dc881a96147075ea">More...</a><br /></td></tr>
<tr class="separator:gac6a65096bc8be9a4dc881a96147075ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9fa3671522ed0e21695769fd85982c7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaa9fa3671522ed0e21695769fd85982c7">dlarrd</a> (RANGE, ORDER, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, VL, VU, IL, IU, GERS, RELTOL, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, PIVMIN, NSPLIT, ISPLIT, M, W, WERR, WL, WU, IBLOCK, INDEXW, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:gaa9fa3671522ed0e21695769fd85982c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRD</b> computes the eigenvalues of a symmetric tridiagonal matrix to suitable accuracy.  <a href="#gaa9fa3671522ed0e21695769fd85982c7">More...</a><br /></td></tr>
<tr class="separator:gaa9fa3671522ed0e21695769fd85982c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8358ae1847bb9cfb96b56b6f3ef6386"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gae8358ae1847bb9cfb96b56b6f3ef6386">dlarre</a> (RANGE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, VL, VU, IL, IU, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, RTOL1, RTOL2, SPLTOL, NSPLIT, ISPLIT, M, W, WERR, WGAP, IBLOCK, INDEXW, GERS, PIVMIN, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:gae8358ae1847bb9cfb96b56b6f3ef6386"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRE</b> given the tridiagonal matrix T, sets small off-diagonal elements to zero and for each unreduced block Ti, finds base representations and eigenvalues.  <a href="#gae8358ae1847bb9cfb96b56b6f3ef6386">More...</a><br /></td></tr>
<tr class="separator:gae8358ae1847bb9cfb96b56b6f3ef6386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa2f60646088821e40fbe04a41aa7b1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga6fa2f60646088821e40fbe04a41aa7b1">dlarrf</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, L, LD, CLSTRT, CLEND, W, WGAP, WERR, SPDIAM, CLGAPL, CLGAPR, PIVMIN, SIGMA, DPLUS, LPLUS, WORK, INFO)</td></tr>
<tr class="memdesc:ga6fa2f60646088821e40fbe04a41aa7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRF</b> finds a new relatively robust representation such that at least one of the eigenvalues is relatively isolated.  <a href="#ga6fa2f60646088821e40fbe04a41aa7b1">More...</a><br /></td></tr>
<tr class="separator:ga6fa2f60646088821e40fbe04a41aa7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdb25c9766674132d73bcbba824ab31"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga7cdb25c9766674132d73bcbba824ab31">dlarrj</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E2, IFIRST, ILAST, RTOL, OFFSET, W, WERR, WORK, IWORK, PIVMIN, SPDIAM, INFO)</td></tr>
<tr class="memdesc:ga7cdb25c9766674132d73bcbba824ab31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRJ</b> performs refinement of the initial estimates of the eigenvalues of the matrix T.  <a href="#ga7cdb25c9766674132d73bcbba824ab31">More...</a><br /></td></tr>
<tr class="separator:ga7cdb25c9766674132d73bcbba824ab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad321b234af8d1ac9fbb18ca95a1c13f2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gad321b234af8d1ac9fbb18ca95a1c13f2">dlarrk</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, IW, GL, GU, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E2, PIVMIN, RELTOL, W, WERR, INFO)</td></tr>
<tr class="memdesc:gad321b234af8d1ac9fbb18ca95a1c13f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRK</b> computes one eigenvalue of a symmetric tridiagonal matrix T to suitable accuracy.  <a href="#gad321b234af8d1ac9fbb18ca95a1c13f2">More...</a><br /></td></tr>
<tr class="separator:gad321b234af8d1ac9fbb18ca95a1c13f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe58120dedcb8d85c7a689c2d822f4a6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gafe58120dedcb8d85c7a689c2d822f4a6">dlarrr</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, INFO)</td></tr>
<tr class="memdesc:gafe58120dedcb8d85c7a689c2d822f4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARRR</b> performs tests to decide whether the symmetric tridiagonal matrix T warrants expensive computations which guarantee high relative accuracy in the eigenvalues.  <a href="#gafe58120dedcb8d85c7a689c2d822f4a6">More...</a><br /></td></tr>
<tr class="separator:gafe58120dedcb8d85c7a689c2d822f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73cdfda601476bb0fdd86047dee1d357"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga73cdfda601476bb0fdd86047dee1d357">dlartg</a> (F, G, CS, SN, R)</td></tr>
<tr class="memdesc:ga73cdfda601476bb0fdd86047dee1d357"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARTG</b> generates a plane rotation with real cosine and real sine.  <a href="#ga73cdfda601476bb0fdd86047dee1d357">More...</a><br /></td></tr>
<tr class="separator:ga73cdfda601476bb0fdd86047dee1d357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac216c77dadbc793b5f0697555af0775b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac216c77dadbc793b5f0697555af0775b">dlartgp</a> (F, G, CS, SN, R)</td></tr>
<tr class="memdesc:gac216c77dadbc793b5f0697555af0775b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARTGP</b> generates a plane rotation so that the diagonal is nonnegative.  <a href="#gac216c77dadbc793b5f0697555af0775b">More...</a><br /></td></tr>
<tr class="separator:gac216c77dadbc793b5f0697555af0775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e7c02e398f2c6365c956d272836a89"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga55e7c02e398f2c6365c956d272836a89">dlaruv</a> (ISEED, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, X)</td></tr>
<tr class="memdesc:ga55e7c02e398f2c6365c956d272836a89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARUV</b> returns a vector of n random real numbers from a uniform distribution.  <a href="#ga55e7c02e398f2c6365c956d272836a89">More...</a><br /></td></tr>
<tr class="separator:ga55e7c02e398f2c6365c956d272836a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307400bc17cbe31b5b8827a2802efae4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga307400bc17cbe31b5b8827a2802efae4">dlas2</a> (F, G, H, SSMIN, SSMAX)</td></tr>
<tr class="memdesc:ga307400bc17cbe31b5b8827a2802efae4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAS2</b> computes singular values of a 2-by-2 triangular matrix.  <a href="#ga307400bc17cbe31b5b8827a2802efae4">More...</a><br /></td></tr>
<tr class="separator:ga307400bc17cbe31b5b8827a2802efae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bce4c35ec5a86ee0bfdd15c476d99c8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga7bce4c35ec5a86ee0bfdd15c476d99c8">dlascl</a> (TYPE, KL, KU, CFROM, CTO, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, INFO)</td></tr>
<tr class="memdesc:ga7bce4c35ec5a86ee0bfdd15c476d99c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASCL</b> multiplies a general rectangular matrix by a real scalar defined as cto/cfrom.  <a href="#ga7bce4c35ec5a86ee0bfdd15c476d99c8">More...</a><br /></td></tr>
<tr class="separator:ga7bce4c35ec5a86ee0bfdd15c476d99c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17e31eb66deb0c5111275edbd302758"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gae17e31eb66deb0c5111275edbd302758">dlasd0</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, VT, LDVT, SMLSIZ, IWORK, WORK, INFO)</td></tr>
<tr class="memdesc:gae17e31eb66deb0c5111275edbd302758"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD0</b> computes the singular values of a real upper bidiagonal n-by-m matrix B with diagonal d and off-diagonal e. Used by sbdsdc.  <a href="#gae17e31eb66deb0c5111275edbd302758">More...</a><br /></td></tr>
<tr class="separator:gae17e31eb66deb0c5111275edbd302758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73e96812a1bfc42d43c9697971c82a6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gae73e96812a1bfc42d43c9697971c82a6">dlasd1</a> (NL, NR, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, ALPHA, BETA, U, LDU, VT, LDVT, IDXQ, IWORK, WORK, INFO)</td></tr>
<tr class="memdesc:gae73e96812a1bfc42d43c9697971c82a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD1</b> computes the SVD of an upper bidiagonal matrix B of the specified size. Used by sbdsdc.  <a href="#gae73e96812a1bfc42d43c9697971c82a6">More...</a><br /></td></tr>
<tr class="separator:gae73e96812a1bfc42d43c9697971c82a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32db876aadda88c12c75db105fe4f21c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga32db876aadda88c12c75db105fe4f21c">dlasd2</a> (NL, NR, SQRE, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, ALPHA, BETA, U, LDU, VT, LDVT, DSIGMA, U2, LDU2, VT2, LDVT2, IDXP, IDX, IDXC, IDXQ, COLTYP, INFO)</td></tr>
<tr class="memdesc:ga32db876aadda88c12c75db105fe4f21c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD2</b> merges the two sets of singular values together into a single sorted set. Used by sbdsdc.  <a href="#ga32db876aadda88c12c75db105fe4f21c">More...</a><br /></td></tr>
<tr class="separator:ga32db876aadda88c12c75db105fe4f21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791d0eee86fc85a3e132e613c55d1d56"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga791d0eee86fc85a3e132e613c55d1d56">dlasd3</a> (NL, NR, SQRE, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Q, LDQ, DSIGMA, U, LDU, U2, LDU2, VT, LDVT, VT2, LDVT2, IDXC, CTOT, Z, INFO)</td></tr>
<tr class="memdesc:ga791d0eee86fc85a3e132e613c55d1d56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD3</b> finds all square roots of the roots of the secular equation, as defined by the values in D and Z, and then updates the singular vectors by matrix multiplication. Used by sbdsdc.  <a href="#ga791d0eee86fc85a3e132e613c55d1d56">More...</a><br /></td></tr>
<tr class="separator:ga791d0eee86fc85a3e132e613c55d1d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ba74a3731059f524f3bdb703fd6fb4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaf0ba74a3731059f524f3bdb703fd6fb4">dlasd4</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, I, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, DELTA, RHO, SIGMA, WORK, INFO)</td></tr>
<tr class="memdesc:gaf0ba74a3731059f524f3bdb703fd6fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD4</b> computes the square root of the i-th updated eigenvalue of a positive symmetric rank-one modification to a positive diagonal matrix. Used by dbdsdc.  <a href="#gaf0ba74a3731059f524f3bdb703fd6fb4">More...</a><br /></td></tr>
<tr class="separator:gaf0ba74a3731059f524f3bdb703fd6fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac354f735ef3e53f9ca32242d2db96f74"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac354f735ef3e53f9ca32242d2db96f74">dlasd5</a> (I, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, DELTA, RHO, DSIGMA, WORK)</td></tr>
<tr class="memdesc:gac354f735ef3e53f9ca32242d2db96f74"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD5</b> computes the square root of the i-th eigenvalue of a positive symmetric rank-one modification of a 2-by-2 diagonal matrix. Used by sbdsdc.  <a href="#gac354f735ef3e53f9ca32242d2db96f74">More...</a><br /></td></tr>
<tr class="separator:gac354f735ef3e53f9ca32242d2db96f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e070b3e60c4a799927b934a17031fba"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga0e070b3e60c4a799927b934a17031fba">dlasd6</a> (ICOMPQ, NL, NR, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, VF, VL, ALPHA, BETA, IDXQ, PERM, GIVPTR, GIVCOL, LDGCOL, GIVNUM, LDGNUM, POLES, DIFL, DIFR, Z, K, C, S, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga0e070b3e60c4a799927b934a17031fba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD6</b> computes the SVD of an updated upper bidiagonal matrix obtained by merging two smaller ones by appending a row. Used by sbdsdc.  <a href="#ga0e070b3e60c4a799927b934a17031fba">More...</a><br /></td></tr>
<tr class="separator:ga0e070b3e60c4a799927b934a17031fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec18a9b77aca48cfc490ad5022eeafe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga5ec18a9b77aca48cfc490ad5022eeafe">dlasd7</a> (ICOMPQ, NL, NR, SQRE, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, ZW, VF, VFW, VL, VLW, ALPHA, BETA, DSIGMA, IDX, IDXP, IDXQ, PERM, GIVPTR, GIVCOL, LDGCOL, GIVNUM, LDGNUM, C, S, INFO)</td></tr>
<tr class="memdesc:ga5ec18a9b77aca48cfc490ad5022eeafe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD7</b> merges the two sets of singular values together into a single sorted set. Then it tries to deflate the size of the problem. Used by sbdsdc.  <a href="#ga5ec18a9b77aca48cfc490ad5022eeafe">More...</a><br /></td></tr>
<tr class="separator:ga5ec18a9b77aca48cfc490ad5022eeafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab80712d01afa9bb687bf87f10d0d2147"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gab80712d01afa9bb687bf87f10d0d2147">dlasd8</a> (ICOMPQ, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, VF, VL, DIFL, DIFR, LDDIFR, DSIGMA, WORK, INFO)</td></tr>
<tr class="memdesc:gab80712d01afa9bb687bf87f10d0d2147"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASD8</b> finds the square roots of the roots of the secular equation, and stores, for each element in D, the distance to its two nearest poles. Used by sbdsdc.  <a href="#gab80712d01afa9bb687bf87f10d0d2147">More...</a><br /></td></tr>
<tr class="separator:gab80712d01afa9bb687bf87f10d0d2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8abcba620b2d5a1321889fd86cb3f12"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaf8abcba620b2d5a1321889fd86cb3f12">dlasda</a> (ICOMPQ, SMLSIZ, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, VT, K, DIFL, DIFR, Z, POLES, GIVPTR, GIVCOL, LDGCOL, PERM, GIVNUM, C, S, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:gaf8abcba620b2d5a1321889fd86cb3f12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASDA</b> computes the singular value decomposition (SVD) of a real upper bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc.  <a href="#gaf8abcba620b2d5a1321889fd86cb3f12">More...</a><br /></td></tr>
<tr class="separator:gaf8abcba620b2d5a1321889fd86cb3f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8e49b5fff31027da26e1856f8a9b25"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gafc8e49b5fff31027da26e1856f8a9b25">dlasdq</a> (UPLO, SQRE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, NCVT, NRU, NCC, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, VT, LDVT, U, LDU, C, LDC, WORK, INFO)</td></tr>
<tr class="memdesc:gafc8e49b5fff31027da26e1856f8a9b25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASDQ</b> computes the SVD of a real bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc.  <a href="#gafc8e49b5fff31027da26e1856f8a9b25">More...</a><br /></td></tr>
<tr class="separator:gafc8e49b5fff31027da26e1856f8a9b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d5a1edccc56fb53970dd9607fcd5ee"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gab7d5a1edccc56fb53970dd9607fcd5ee">dlasdt</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, LVL, ND, INODE, NDIML, NDIMR, MSUB)</td></tr>
<tr class="memdesc:gab7d5a1edccc56fb53970dd9607fcd5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASDT</b> creates a tree of subproblems for bidiagonal divide and conquer. Used by sbdsdc.  <a href="#gab7d5a1edccc56fb53970dd9607fcd5ee">More...</a><br /></td></tr>
<tr class="separator:gab7d5a1edccc56fb53970dd9607fcd5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e332374c7cd87e5db54bfe21550bc3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga89e332374c7cd87e5db54bfe21550bc3">dlaset</a> (UPLO, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, ALPHA, BETA, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:ga89e332374c7cd87e5db54bfe21550bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASET</b> initializes the off-diagonal elements and the diagonal elements of a matrix to given values.  <a href="#ga89e332374c7cd87e5db54bfe21550bc3">More...</a><br /></td></tr>
<tr class="separator:ga89e332374c7cd87e5db54bfe21550bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a984d2062d62286a7a78ed3ba06fda"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaa0a984d2062d62286a7a78ed3ba06fda">dlasr</a> (SIDE, PIVOT, DIRECT, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, C, S, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:gaa0a984d2062d62286a7a78ed3ba06fda"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASR</b> applies a sequence of plane rotations to a general rectangular matrix.  <a href="#gaa0a984d2062d62286a7a78ed3ba06fda">More...</a><br /></td></tr>
<tr class="separator:gaa0a984d2062d62286a7a78ed3ba06fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c824016058563e3b7189801d1de6d58"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga9c824016058563e3b7189801d1de6d58">dlassq</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, X, INCX, SCALE, SUMSQ)</td></tr>
<tr class="memdesc:ga9c824016058563e3b7189801d1de6d58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASSQ</b> updates a sum of squares represented in scaled form.  <a href="#ga9c824016058563e3b7189801d1de6d58">More...</a><br /></td></tr>
<tr class="separator:ga9c824016058563e3b7189801d1de6d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8e05a707783a9fba5d213093453543"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaee8e05a707783a9fba5d213093453543">dlasv2</a> (F, G, H, SSMIN, SSMAX, SNR, CSR, SNL, CSL)</td></tr>
<tr class="memdesc:gaee8e05a707783a9fba5d213093453543"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASV2</b> computes the singular value decomposition of a 2-by-2 triangular matrix.  <a href="#gaee8e05a707783a9fba5d213093453543">More...</a><br /></td></tr>
<tr class="separator:gaee8e05a707783a9fba5d213093453543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97715c995b884378afbbff7915d884c5"><td class="memItemLeft" align="right" valign="top">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga97715c995b884378afbbff7915d884c5">ieeeck</a> (ISPEC, ZERO, ONE)</td></tr>
<tr class="memdesc:ga97715c995b884378afbbff7915d884c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>IEEECK</b>  <a href="#ga97715c995b884378afbbff7915d884c5">More...</a><br /></td></tr>
<tr class="separator:ga97715c995b884378afbbff7915d884c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b3783390380038c9d26de61d7aefb4"><td class="memItemLeft" align="right" valign="top">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gab8b3783390380038c9d26de61d7aefb4">iladlc</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:gab8b3783390380038c9d26de61d7aefb4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ILADLC</b> scans a matrix for its last non-zero column.  <a href="#gab8b3783390380038c9d26de61d7aefb4">More...</a><br /></td></tr>
<tr class="separator:gab8b3783390380038c9d26de61d7aefb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0eeaff271e43cd10d066ef1cceb5f3b"><td class="memItemLeft" align="right" valign="top">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac0eeaff271e43cd10d066ef1cceb5f3b">iladlr</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:gac0eeaff271e43cd10d066ef1cceb5f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ILADLR</b> scans a matrix for its last non-zero row.  <a href="#gac0eeaff271e43cd10d066ef1cceb5f3b">More...</a><br /></td></tr>
<tr class="separator:gac0eeaff271e43cd10d066ef1cceb5f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f37bde76d31aee91a09bb2f8e87ce6"><td class="memItemLeft" align="right" valign="top">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gab1f37bde76d31aee91a09bb2f8e87ce6">ilaenv</a> (ISPEC, NAME, OPTS, N1, N2, N3, N4)</td></tr>
<tr class="memdesc:gab1f37bde76d31aee91a09bb2f8e87ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ILAENV</b>  <a href="#gab1f37bde76d31aee91a09bb2f8e87ce6">More...</a><br /></td></tr>
<tr class="separator:gab1f37bde76d31aee91a09bb2f8e87ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e703cb600283f4bcb1b340cfd8ad3d9"><td class="memItemLeft" align="right" valign="top">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga6e703cb600283f4bcb1b340cfd8ad3d9">iparmq</a> (ISPEC, NAME, OPTS, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, ILO, IHI, LWORK)</td></tr>
<tr class="memdesc:ga6e703cb600283f4bcb1b340cfd8ad3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>IPARMQ</b>  <a href="#ga6e703cb600283f4bcb1b340cfd8ad3d9">More...</a><br /></td></tr>
<tr class="separator:ga6e703cb600283f4bcb1b340cfd8ad3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b496168bf04278e5e57050403c150aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga0b496168bf04278e5e57050403c150aa">lsamen</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, CA, CB)</td></tr>
<tr class="memdesc:ga0b496168bf04278e5e57050403c150aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>LSAMEN</b>  <a href="#ga0b496168bf04278e5e57050403c150aa">More...</a><br /></td></tr>
<tr class="separator:ga0b496168bf04278e5e57050403c150aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca6bb0411af000e3c883ee744184991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaeca6bb0411af000e3c883ee744184991">sisnan</a> (SIN)</td></tr>
<tr class="memdesc:gaeca6bb0411af000e3c883ee744184991"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SISNAN</b> tests input for NaN.  <a href="#gaeca6bb0411af000e3c883ee744184991">More...</a><br /></td></tr>
<tr class="separator:gaeca6bb0411af000e3c883ee744184991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117e4564430a16335ad47054c447cb79"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga117e4564430a16335ad47054c447cb79">slabad</a> (SMALL, LARGE)</td></tr>
<tr class="memdesc:ga117e4564430a16335ad47054c447cb79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLABAD</b>  <a href="#ga117e4564430a16335ad47054c447cb79">More...</a><br /></td></tr>
<tr class="separator:ga117e4564430a16335ad47054c447cb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7780c991533ce8dd1f2c22ae2d563f08"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga7780c991533ce8dd1f2c22ae2d563f08">slacpy</a> (UPLO, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>)</td></tr>
<tr class="memdesc:ga7780c991533ce8dd1f2c22ae2d563f08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLACPY</b> copies all or part of one two-dimensional array to another.  <a href="#ga7780c991533ce8dd1f2c22ae2d563f08">More...</a><br /></td></tr>
<tr class="separator:ga7780c991533ce8dd1f2c22ae2d563f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774ef9659ab6074d1fd66eefc222085e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga774ef9659ab6074d1fd66eefc222085e">sladiv</a> (<a class="el" href="classA.html">A</a>, B, C, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, P, Q)</td></tr>
<tr class="memdesc:ga774ef9659ab6074d1fd66eefc222085e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.  <a href="#ga774ef9659ab6074d1fd66eefc222085e">More...</a><br /></td></tr>
<tr class="separator:ga774ef9659ab6074d1fd66eefc222085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec32dea47a14590934b8970b078b58fd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaec32dea47a14590934b8970b078b58fd">slae2</a> (<a class="el" href="classA.html">A</a>, B, C, RT1, RT2)</td></tr>
<tr class="memdesc:gaec32dea47a14590934b8970b078b58fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAE2</b> computes the eigenvalues of a 2-by-2 symmetric matrix.  <a href="#gaec32dea47a14590934b8970b078b58fd">More...</a><br /></td></tr>
<tr class="separator:gaec32dea47a14590934b8970b078b58fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5045e3ec268a759d36fec562d6e481"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga4f5045e3ec268a759d36fec562d6e481">slaebz</a> (IJOB, NITMAX, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, MMAX, MINP, NBMIN, ABSTOL, RELTOL, PIVMIN, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, NVAL, AB, C, MOUT, NAB, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga4f5045e3ec268a759d36fec562d6e481"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAEBZ</b> computes the number of eigenvalues of a real symmetric tridiagonal matrix which are less than or equal to a given value, and performs other tasks required by the routine sstebz.  <a href="#ga4f5045e3ec268a759d36fec562d6e481">More...</a><br /></td></tr>
<tr class="separator:ga4f5045e3ec268a759d36fec562d6e481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79f0bb1a07a9d96b827eba946ec79fa"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaf79f0bb1a07a9d96b827eba946ec79fa">slaev2</a> (<a class="el" href="classA.html">A</a>, B, C, RT1, RT2, CS1, SN1)</td></tr>
<tr class="memdesc:gaf79f0bb1a07a9d96b827eba946ec79fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAEV2</b> computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix.  <a href="#gaf79f0bb1a07a9d96b827eba946ec79fa">More...</a><br /></td></tr>
<tr class="separator:gaf79f0bb1a07a9d96b827eba946ec79fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ea5cb7fd597f6b5ae9cade02d122b3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac8ea5cb7fd597f6b5ae9cade02d122b3">slag2d</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, SA, LDSA, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, INFO)</td></tr>
<tr class="memdesc:gac8ea5cb7fd597f6b5ae9cade02d122b3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAG2D</b> converts a single precision matrix to a double precision matrix.  <a href="#gac8ea5cb7fd597f6b5ae9cade02d122b3">More...</a><br /></td></tr>
<tr class="separator:gac8ea5cb7fd597f6b5ae9cade02d122b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b431608960457e61e885f3a2e2b18e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gae4b431608960457e61e885f3a2e2b18e">slagts</a> (JOB, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, B, C, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, IN, Y, TOL, INFO)</td></tr>
<tr class="memdesc:gae4b431608960457e61e885f3a2e2b18e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAGTS</b> solves the system of equations (T-λI)x = y or (T-λI)Tx = y,where T is a general tridiagonal matrix and λ a scalar, using the LU factorization computed by slagtf.  <a href="#gae4b431608960457e61e885f3a2e2b18e">More...</a><br /></td></tr>
<tr class="separator:gae4b431608960457e61e885f3a2e2b18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b6a1036554ed9b7196c641174d6a6da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga9b6a1036554ed9b7196c641174d6a6da">slaisnan</a> (SIN1, SIN2)</td></tr>
<tr class="memdesc:ga9b6a1036554ed9b7196c641174d6a6da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAISNAN</b> tests input for NaN by comparing two arguments for inequality.  <a href="#ga9b6a1036554ed9b7196c641174d6a6da">More...</a><br /></td></tr>
<tr class="separator:ga9b6a1036554ed9b7196c641174d6a6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea5fb550bbab683a539b551e3496bcc"><td class="memItemLeft" align="right" valign="top">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga7ea5fb550bbab683a539b551e3496bcc">slaneg</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, LLD, SIGMA, PIVMIN, R)</td></tr>
<tr class="memdesc:ga7ea5fb550bbab683a539b551e3496bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLANEG</b> computes the Sturm count.  <a href="#ga7ea5fb550bbab683a539b551e3496bcc">More...</a><br /></td></tr>
<tr class="separator:ga7ea5fb550bbab683a539b551e3496bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f856bc9099be84550d6c98ed9a3c810"><td class="memItemLeft" align="right" valign="top">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga3f856bc9099be84550d6c98ed9a3c810">slanst</a> (NORM, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E)</td></tr>
<tr class="memdesc:ga3f856bc9099be84550d6c98ed9a3c810"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLANST</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric tridiagonal matrix.  <a href="#ga3f856bc9099be84550d6c98ed9a3c810">More...</a><br /></td></tr>
<tr class="separator:ga3f856bc9099be84550d6c98ed9a3c810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcdad5f1d5d0193f7285e018824aa66"><td class="memItemLeft" align="right" valign="top">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gabfcdad5f1d5d0193f7285e018824aa66">slapy2</a> (X, Y)</td></tr>
<tr class="memdesc:gabfcdad5f1d5d0193f7285e018824aa66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAPY2</b> returns sqrt(x2+y2).  <a href="#gabfcdad5f1d5d0193f7285e018824aa66">More...</a><br /></td></tr>
<tr class="separator:gabfcdad5f1d5d0193f7285e018824aa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab147cb12ea8d677598a5aad10f7e4c"><td class="memItemLeft" align="right" valign="top">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gadab147cb12ea8d677598a5aad10f7e4c">slapy3</a> (X, Y, Z)</td></tr>
<tr class="memdesc:gadab147cb12ea8d677598a5aad10f7e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAPY3</b> returns sqrt(x2+y2+z2).  <a href="#gadab147cb12ea8d677598a5aad10f7e4c">More...</a><br /></td></tr>
<tr class="separator:gadab147cb12ea8d677598a5aad10f7e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379b09e3d4e7635db614d3b3973db5e7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga379b09e3d4e7635db614d3b3973db5e7">slarnv</a> (IDIST, ISEED, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, X)</td></tr>
<tr class="memdesc:ga379b09e3d4e7635db614d3b3973db5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARNV</b> returns a vector of random numbers from a uniform or normal distribution.  <a href="#ga379b09e3d4e7635db614d3b3973db5e7">More...</a><br /></td></tr>
<tr class="separator:ga379b09e3d4e7635db614d3b3973db5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f440e7139c504926241c9f7f71332d2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga4f440e7139c504926241c9f7f71332d2">slarra</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, SPLTOL, TNRM, NSPLIT, ISPLIT, INFO)</td></tr>
<tr class="memdesc:ga4f440e7139c504926241c9f7f71332d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRA</b> computes the splitting points with the specified threshold.  <a href="#ga4f440e7139c504926241c9f7f71332d2">More...</a><br /></td></tr>
<tr class="separator:ga4f440e7139c504926241c9f7f71332d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29562cff63b75a1f3f40e7f83aea2b7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gad29562cff63b75a1f3f40e7f83aea2b7">slarrb</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, LLD, IFIRST, ILAST, RTOL1, RTOL2, OFFSET, W, WGAP, WERR, WORK, IWORK, PIVMIN, SPDIAM, TWIST, INFO)</td></tr>
<tr class="memdesc:gad29562cff63b75a1f3f40e7f83aea2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRB</b> provides limited bisection to locate eigenvalues for more accuracy.  <a href="#gad29562cff63b75a1f3f40e7f83aea2b7">More...</a><br /></td></tr>
<tr class="separator:gad29562cff63b75a1f3f40e7f83aea2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3895a010b624d4185e3c0c60b3cf1196"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga3895a010b624d4185e3c0c60b3cf1196">slarrc</a> (JOBT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, VL, VU, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, PIVMIN, EIGCNT, LCNT, RCNT, INFO)</td></tr>
<tr class="memdesc:ga3895a010b624d4185e3c0c60b3cf1196"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRC</b> computes the number of eigenvalues of the symmetric tridiagonal matrix.  <a href="#ga3895a010b624d4185e3c0c60b3cf1196">More...</a><br /></td></tr>
<tr class="separator:ga3895a010b624d4185e3c0c60b3cf1196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137b773fc78098f8177b09e7d6dc3c91"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga137b773fc78098f8177b09e7d6dc3c91">slarrd</a> (RANGE, ORDER, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, VL, VU, IL, IU, GERS, RELTOL, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, PIVMIN, NSPLIT, ISPLIT, M, W, WERR, WL, WU, IBLOCK, INDEXW, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga137b773fc78098f8177b09e7d6dc3c91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRD</b> computes the eigenvalues of a symmetric tridiagonal matrix to suitable accuracy.  <a href="#ga137b773fc78098f8177b09e7d6dc3c91">More...</a><br /></td></tr>
<tr class="separator:ga137b773fc78098f8177b09e7d6dc3c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2b9dcf8e9c8f368fb6d39506781f46"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga4a2b9dcf8e9c8f368fb6d39506781f46">slarre</a> (RANGE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, VL, VU, IL, IU, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, E2, RTOL1, RTOL2, SPLTOL, NSPLIT, ISPLIT, M, W, WERR, WGAP, IBLOCK, INDEXW, GERS, PIVMIN, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga4a2b9dcf8e9c8f368fb6d39506781f46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRE</b> given the tridiagonal matrix T, sets small off-diagonal elements to zero and for each unreduced block Ti, finds base representations and eigenvalues.  <a href="#ga4a2b9dcf8e9c8f368fb6d39506781f46">More...</a><br /></td></tr>
<tr class="separator:ga4a2b9dcf8e9c8f368fb6d39506781f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf557670fb7f0616fb74b6af8cae353b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaaf557670fb7f0616fb74b6af8cae353b">slarrf</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, L, LD, CLSTRT, CLEND, W, WGAP, WERR, SPDIAM, CLGAPL, CLGAPR, PIVMIN, SIGMA, DPLUS, LPLUS, WORK, INFO)</td></tr>
<tr class="memdesc:gaaf557670fb7f0616fb74b6af8cae353b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRF</b> finds a new relatively robust representation such that at least one of the eigenvalues is relatively isolated.  <a href="#gaaf557670fb7f0616fb74b6af8cae353b">More...</a><br /></td></tr>
<tr class="separator:gaaf557670fb7f0616fb74b6af8cae353b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d0ea9b6f2d76876a8f0c0e1a12868c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga86d0ea9b6f2d76876a8f0c0e1a12868c">slarrj</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E2, IFIRST, ILAST, RTOL, OFFSET, W, WERR, WORK, IWORK, PIVMIN, SPDIAM, INFO)</td></tr>
<tr class="memdesc:ga86d0ea9b6f2d76876a8f0c0e1a12868c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRJ</b> performs refinement of the initial estimates of the eigenvalues of the matrix T.  <a href="#ga86d0ea9b6f2d76876a8f0c0e1a12868c">More...</a><br /></td></tr>
<tr class="separator:ga86d0ea9b6f2d76876a8f0c0e1a12868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34836aa49da0ba1ef397af5a5590e22"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac34836aa49da0ba1ef397af5a5590e22">slarrk</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, IW, GL, GU, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E2, PIVMIN, RELTOL, W, WERR, INFO)</td></tr>
<tr class="memdesc:gac34836aa49da0ba1ef397af5a5590e22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRK</b> computes one eigenvalue of a symmetric tridiagonal matrix T to suitable accuracy.  <a href="#gac34836aa49da0ba1ef397af5a5590e22">More...</a><br /></td></tr>
<tr class="separator:gac34836aa49da0ba1ef397af5a5590e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c1c1075019c75d8975e952a09516d5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga37c1c1075019c75d8975e952a09516d5">slarrr</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, INFO)</td></tr>
<tr class="memdesc:ga37c1c1075019c75d8975e952a09516d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARRR</b> performs tests to decide whether the symmetric tridiagonal matrix T warrants expensive computations which guarantee high relative accuracy in the eigenvalues.  <a href="#ga37c1c1075019c75d8975e952a09516d5">More...</a><br /></td></tr>
<tr class="separator:ga37c1c1075019c75d8975e952a09516d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee6602fc79f90ffd7113154b87088302"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaee6602fc79f90ffd7113154b87088302">slartg</a> (F, G, CS, SN, R)</td></tr>
<tr class="memdesc:gaee6602fc79f90ffd7113154b87088302"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARTG</b> generates a plane rotation with real cosine and real sine.  <a href="#gaee6602fc79f90ffd7113154b87088302">More...</a><br /></td></tr>
<tr class="separator:gaee6602fc79f90ffd7113154b87088302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf196d96b7826d09326521d4a30b4bca4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaf196d96b7826d09326521d4a30b4bca4">slartgp</a> (F, G, CS, SN, R)</td></tr>
<tr class="memdesc:gaf196d96b7826d09326521d4a30b4bca4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARTGP</b> generates a plane rotation so that the diagonal is nonnegative.  <a href="#gaf196d96b7826d09326521d4a30b4bca4">More...</a><br /></td></tr>
<tr class="separator:gaf196d96b7826d09326521d4a30b4bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ca61f3556928fc2698683460395d96c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga5ca61f3556928fc2698683460395d96c">slaruv</a> (ISEED, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, X)</td></tr>
<tr class="memdesc:ga5ca61f3556928fc2698683460395d96c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLARUV</b> returns a vector of n random real numbers from a uniform distribution.  <a href="#ga5ca61f3556928fc2698683460395d96c">More...</a><br /></td></tr>
<tr class="separator:ga5ca61f3556928fc2698683460395d96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7047efd8096db5f0724f79cad80e4127"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga7047efd8096db5f0724f79cad80e4127">slas2</a> (F, G, H, SSMIN, SSMAX)</td></tr>
<tr class="memdesc:ga7047efd8096db5f0724f79cad80e4127"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLAS2</b> computes singular values of a 2-by-2 triangular matrix.  <a href="#ga7047efd8096db5f0724f79cad80e4127">More...</a><br /></td></tr>
<tr class="separator:ga7047efd8096db5f0724f79cad80e4127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e6ce67ce97ca5b0a3a7bc5645a09d9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga11e6ce67ce97ca5b0a3a7bc5645a09d9">slascl</a> (TYPE, KL, KU, CFROM, CTO, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, INFO)</td></tr>
<tr class="memdesc:ga11e6ce67ce97ca5b0a3a7bc5645a09d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASCL</b> multiplies a general rectangular matrix by a real scalar defined as cto/cfrom.  <a href="#ga11e6ce67ce97ca5b0a3a7bc5645a09d9">More...</a><br /></td></tr>
<tr class="separator:ga11e6ce67ce97ca5b0a3a7bc5645a09d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8da896f51f0ce43896b61efa3d0381"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga7a8da896f51f0ce43896b61efa3d0381">slasd0</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, VT, LDVT, SMLSIZ, IWORK, WORK, INFO)</td></tr>
<tr class="memdesc:ga7a8da896f51f0ce43896b61efa3d0381"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD0</b> computes the singular values of a real upper bidiagonal n-by-m matrix B with diagonal d and off-diagonal e. Used by sbdsdc.  <a href="#ga7a8da896f51f0ce43896b61efa3d0381">More...</a><br /></td></tr>
<tr class="separator:ga7a8da896f51f0ce43896b61efa3d0381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882db55a5643e6b13ebbf68635f3946c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga882db55a5643e6b13ebbf68635f3946c">slasd1</a> (NL, NR, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, ALPHA, BETA, U, LDU, VT, LDVT, IDXQ, IWORK, WORK, INFO)</td></tr>
<tr class="memdesc:ga882db55a5643e6b13ebbf68635f3946c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD1</b> computes the SVD of an upper bidiagonal matrix B of the specified size. Used by sbdsdc.  <a href="#ga882db55a5643e6b13ebbf68635f3946c">More...</a><br /></td></tr>
<tr class="separator:ga882db55a5643e6b13ebbf68635f3946c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ea099005fc608ad8a5b79662e02b84"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga33ea099005fc608ad8a5b79662e02b84">slasd2</a> (NL, NR, SQRE, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, ALPHA, BETA, U, LDU, VT, LDVT, DSIGMA, U2, LDU2, VT2, LDVT2, IDXP, IDX, IDXC, IDXQ, COLTYP, INFO)</td></tr>
<tr class="memdesc:ga33ea099005fc608ad8a5b79662e02b84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD2</b> merges the two sets of singular values together into a single sorted set. Used by sbdsdc.  <a href="#ga33ea099005fc608ad8a5b79662e02b84">More...</a><br /></td></tr>
<tr class="separator:ga33ea099005fc608ad8a5b79662e02b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4359e33241fa45b40ca5b25e6bee9054"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga4359e33241fa45b40ca5b25e6bee9054">slasd3</a> (NL, NR, SQRE, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Q, LDQ, DSIGMA, U, LDU, U2, LDU2, VT, LDVT, VT2, LDVT2, IDXC, CTOT, Z, INFO)</td></tr>
<tr class="memdesc:ga4359e33241fa45b40ca5b25e6bee9054"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD3</b> finds all square roots of the roots of the secular equation, as defined by the values in D and Z, and then updates the singular vectors by matrix multiplication. Used by sbdsdc.  <a href="#ga4359e33241fa45b40ca5b25e6bee9054">More...</a><br /></td></tr>
<tr class="separator:ga4359e33241fa45b40ca5b25e6bee9054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6680aa4ad62702cd9a00d7530c8ab53a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga6680aa4ad62702cd9a00d7530c8ab53a">slasd4</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, I, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, DELTA, RHO, SIGMA, WORK, INFO)</td></tr>
<tr class="memdesc:ga6680aa4ad62702cd9a00d7530c8ab53a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD4</b> computes the square root of the i-th updated eigenvalue of a positive symmetric rank-one modification to a positive diagonal matrix. Used by sbdsdc.  <a href="#ga6680aa4ad62702cd9a00d7530c8ab53a">More...</a><br /></td></tr>
<tr class="separator:ga6680aa4ad62702cd9a00d7530c8ab53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19de62ad22e8492c93ac450198557d05"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga19de62ad22e8492c93ac450198557d05">slasd5</a> (I, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, DELTA, RHO, DSIGMA, WORK)</td></tr>
<tr class="memdesc:ga19de62ad22e8492c93ac450198557d05"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD5</b> computes the square root of the i-th eigenvalue of a positive symmetric rank-one modification of a 2-by-2 diagonal matrix. Used by sbdsdc.  <a href="#ga19de62ad22e8492c93ac450198557d05">More...</a><br /></td></tr>
<tr class="separator:ga19de62ad22e8492c93ac450198557d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49655eb79b1745feabd7e9069f05e485"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga49655eb79b1745feabd7e9069f05e485">slasd6</a> (ICOMPQ, NL, NR, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, VF, VL, ALPHA, BETA, IDXQ, PERM, GIVPTR, GIVCOL, LDGCOL, GIVNUM, LDGNUM, POLES, DIFL, DIFR, Z, K, C, S, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga49655eb79b1745feabd7e9069f05e485"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD6</b> computes the SVD of an updated upper bidiagonal matrix obtained by merging two smaller ones by appending a row. Used by sbdsdc.  <a href="#ga49655eb79b1745feabd7e9069f05e485">More...</a><br /></td></tr>
<tr class="separator:ga49655eb79b1745feabd7e9069f05e485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506889eb5029bb8325b9b2ac02a62bce"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga506889eb5029bb8325b9b2ac02a62bce">slasd7</a> (ICOMPQ, NL, NR, SQRE, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, ZW, VF, VFW, VL, VLW, ALPHA, BETA, DSIGMA, IDX, IDXP, IDXQ, PERM, GIVPTR, GIVCOL, LDGCOL, GIVNUM, LDGNUM, C, S, INFO)</td></tr>
<tr class="memdesc:ga506889eb5029bb8325b9b2ac02a62bce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD7</b> merges the two sets of singular values together into a single sorted set. Then it tries to deflate the size of the problem. Used by sbdsdc.  <a href="#ga506889eb5029bb8325b9b2ac02a62bce">More...</a><br /></td></tr>
<tr class="separator:ga506889eb5029bb8325b9b2ac02a62bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e0b8da65a5d9493e17f46cd010e6cc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gac4e0b8da65a5d9493e17f46cd010e6cc">slasd8</a> (ICOMPQ, K, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, VF, VL, DIFL, DIFR, LDDIFR, DSIGMA, WORK, INFO)</td></tr>
<tr class="memdesc:gac4e0b8da65a5d9493e17f46cd010e6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASD8</b> finds the square roots of the roots of the secular equation, and stores, for each element in D, the distance to its two nearest poles. Used by sbdsdc.  <a href="#gac4e0b8da65a5d9493e17f46cd010e6cc">More...</a><br /></td></tr>
<tr class="separator:gac4e0b8da65a5d9493e17f46cd010e6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe52aa918bfa2a863f122f39ae9e6404"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gafe52aa918bfa2a863f122f39ae9e6404">slasda</a> (ICOMPQ, SMLSIZ, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, SQRE, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, VT, K, DIFL, DIFR, Z, POLES, GIVPTR, GIVCOL, LDGCOL, PERM, GIVNUM, C, S, WORK, IWORK, INFO)</td></tr>
<tr class="memdesc:gafe52aa918bfa2a863f122f39ae9e6404"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASDA</b> computes the singular value decomposition (SVD) of a real upper bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc.  <a href="#gafe52aa918bfa2a863f122f39ae9e6404">More...</a><br /></td></tr>
<tr class="separator:gafe52aa918bfa2a863f122f39ae9e6404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4a455a53f317631c56b07d4828eb28"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gabb4a455a53f317631c56b07d4828eb28">slasdq</a> (UPLO, SQRE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, NCVT, NRU, NCC, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, VT, LDVT, U, LDU, C, LDC, WORK, INFO)</td></tr>
<tr class="memdesc:gabb4a455a53f317631c56b07d4828eb28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASDQ</b> computes the SVD of a real bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc.  <a href="#gabb4a455a53f317631c56b07d4828eb28">More...</a><br /></td></tr>
<tr class="separator:gabb4a455a53f317631c56b07d4828eb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae747f83ac11f2283d1d3f8b09d7a1138"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gae747f83ac11f2283d1d3f8b09d7a1138">slasdt</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, LVL, ND, INODE, NDIML, NDIMR, MSUB)</td></tr>
<tr class="memdesc:gae747f83ac11f2283d1d3f8b09d7a1138"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASDT</b> creates a tree of subproblems for bidiagonal divide and conquer. Used by sbdsdc.  <a href="#gae747f83ac11f2283d1d3f8b09d7a1138">More...</a><br /></td></tr>
<tr class="separator:gae747f83ac11f2283d1d3f8b09d7a1138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6174184453f17ad7cc3488044325d5ac"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga6174184453f17ad7cc3488044325d5ac">slaset</a> (UPLO, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, ALPHA, BETA, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:ga6174184453f17ad7cc3488044325d5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASET</b> initializes the off-diagonal elements and the diagonal elements of a matrix to given values.  <a href="#ga6174184453f17ad7cc3488044325d5ac">More...</a><br /></td></tr>
<tr class="separator:ga6174184453f17ad7cc3488044325d5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f6d566e3a36c43835b0ff3055879dc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga60f6d566e3a36c43835b0ff3055879dc">slasr</a> (SIDE, PIVOT, DIRECT, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, C, S, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:ga60f6d566e3a36c43835b0ff3055879dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASR</b> applies a sequence of plane rotations to a general rectangular matrix.  <a href="#ga60f6d566e3a36c43835b0ff3055879dc">More...</a><br /></td></tr>
<tr class="separator:ga60f6d566e3a36c43835b0ff3055879dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf079526ad6de4de7424528ec61b52629"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#gaf079526ad6de4de7424528ec61b52629">slassq</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, X, INCX, SCALE, SUMSQ)</td></tr>
<tr class="memdesc:gaf079526ad6de4de7424528ec61b52629"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASSQ</b> updates a sum of squares represented in scaled form.  <a href="#gaf079526ad6de4de7424528ec61b52629">More...</a><br /></td></tr>
<tr class="separator:gaf079526ad6de4de7424528ec61b52629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8783434fbc24d465134e5604c5737565"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga8783434fbc24d465134e5604c5737565">slasv2</a> (F, G, H, SSMIN, SSMAX, SNR, CSR, SNL, CSL)</td></tr>
<tr class="memdesc:ga8783434fbc24d465134e5604c5737565"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SLASV2</b> computes the singular value decomposition of a 2-by-2 triangular matrix.  <a href="#ga8783434fbc24d465134e5604c5737565">More...</a><br /></td></tr>
<tr class="separator:ga8783434fbc24d465134e5604c5737565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga377ee61015baf8dea7770b3a404b1c07"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga377ee61015baf8dea7770b3a404b1c07">xerbla</a> (SRNAME, INFO)</td></tr>
<tr class="memdesc:ga377ee61015baf8dea7770b3a404b1c07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>XERBLA</b>  <a href="#ga377ee61015baf8dea7770b3a404b1c07">More...</a><br /></td></tr>
<tr class="separator:ga377ee61015baf8dea7770b3a404b1c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1b23f68dd586f20299b80d1c9288d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__auxOTHERauxiliary.html#ga45f1b23f68dd586f20299b80d1c9288d">xerbla_array</a> (SRNAME_ARRAY, SRNAME_LEN, INFO)</td></tr>
<tr class="memdesc:ga45f1b23f68dd586f20299b80d1c9288d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>XERBLA_ARRAY</b>  <a href="#ga45f1b23f68dd586f20299b80d1c9288d">More...</a><br /></td></tr>
<tr class="separator:ga45f1b23f68dd586f20299b80d1c9288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is the group of Other Auxiliary routines </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafdbf236050aae6e38c07d118c3611f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program __dlamchtst.f__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAMCHTST</b> </p>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga00e549b45eabbe138df540cf0f954ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program __dsecndtst.f__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSECNDTST</b> </p>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab9662e1df88fb8f65d7f42edcc6f4dda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program __lapack_version.f__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>LAPACK_VERSION</b> </p>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gac14a642d1c4ae2713896577ae288bb58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program __lsametst.f__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>LSAMETST</b> </p>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga230d4e1886896853b11e44e541b2c6a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> disnan </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>DIN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DISNAN</b> tests input for NaN. </p>
<p> 
 Download DISNAN + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/disnan.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/disnan.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/disnan.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DISNAN returns .TRUE. if its argument is NaN, and .FALSE.
 otherwise.  To be replaced by the Fortran 2003 intrinsic in the
 future.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DIN</td><td><pre class="fragment">          DIN is DOUBLE PRECISION
          Input to test for NaN.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga57ac7409aedb2a380d5d0e625ffbeb7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlabad </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SMALL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>LARGE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLABAD</b> </p>
<p> 
 Download DLABAD + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlabad.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlabad.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlabad.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLABAD takes as input the values computed by DLAMCH for underflow and
 overflow, and returns the square root of each of these values if the
 log of LARGE is sufficiently large.  This subroutine is intended to
 identify machines with a large exponent range, such as the Crays, and
 redefine the underflow and overflow limits to be the square roots of
 the values computed by DLAMCH.  This subroutine is needed because
 DLAMCH does not compensate for poor arithmetic in the upper half of
 the exponent range, as is found on a Cray.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SMALL</td><td><pre class="fragment">          SMALL is DOUBLE PRECISION
          On entry, the underflow threshold as computed by DLAMCH.
          On exit, if LOG10(LARGE) is sufficiently large, the square
          root of SMALL, otherwise unchanged.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">LARGE</td><td><pre class="fragment">          LARGE is DOUBLE PRECISION
          On entry, the overflow threshold as computed by DLAMCH.
          On exit, if LOG10(LARGE) is sufficiently large, the square
          root of LARGE, otherwise unchanged.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7eb8731ffab2734378157c40964bf788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlacpy </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLACPY</b> copies all or part of one two-dimensional array to another. </p>
<p> 
 Download DLACPY + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlacpy.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlacpy.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlacpy.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies the part of the matrix A to be copied to B.
          = 'U':      Upper triangular part
          = 'L':      Lower triangular part
          Otherwise:  All of the matrix A</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The m by n matrix A.  If UPLO = 'U', only the upper triangle
          or trapezoid is accessed; if UPLO = 'L', only the lower
          triangle or trapezoid is accessed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,N)
          On exit, B = A in the locations specified by UPLO.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gad1c0279ec29e8ac222f1e319f4144fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dladiv </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow. </p>
<p> 
 Download DLADIV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dladiv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dladiv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dladiv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLADIV performs complex division in  real arithmetic

                       a + i*b
            p + i*q = ---------
                       c + i*d

 The algorithm is due to Michael Baudin and Robert L. Smith
 and can be found in the paper
 "A Robust Complex Division in Scilab"</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION
          The scalars a, b, c, and d in the above expression.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td><pre class="fragment">          P is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION
          The scalars p and q in the above expression.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a36d905c1c66d345f791b91254da0ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlae2 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RT2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAE2</b> computes the eigenvalues of a 2-by-2 symmetric matrix. </p>
<p> 
 Download DLAE2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlae2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlae2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlae2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
    [  A   B  ]
    [  B   C  ].
 On return, RT1 is the eigenvalue of larger absolute value, and RT2
 is the eigenvalue of smaller absolute value.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION
          The (1,2) and (2,1) elements of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT1</td><td><pre class="fragment">          RT1 is DOUBLE PRECISION
          The eigenvalue of larger absolute value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT2</td><td><pre class="fragment">          RT2 is DOUBLE PRECISION
          The eigenvalue of smaller absolute value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  RT1 is accurate to a few ulps barring over/underflow.

  RT2 may be inaccurate if there is massive cancellation in the
  determinant A*C-B*B; higher precision or correctly rounded or
  correctly truncated arithmetic would be needed to compute RT2
  accurately in all cases.

  Overflow is possible only if RT1 is within a factor of 5 of overflow.
  Underflow is harmless if the input data is 0 or exceeds
     underflow_threshold / macheps.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga79da86f5a84d0038788717338eef245d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlaebz </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IJOB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NITMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MINP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NBMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ABSTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RELTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( mmax, * )&#160;</td>
          <td class="paramname"><em>AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( mmax, * )&#160;</td>
          <td class="paramname"><em>NAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAEBZ</b> computes the number of eigenvalues of a real symmetric tridiagonal matrix which are less than or equal to a given value, and performs other tasks required by the routine sstebz. </p>
<p> 
 Download DLAEBZ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlaebz.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlaebz.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaebz.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAEBZ contains the iteration loops which compute and use the
 function N(w), which is the count of eigenvalues of a symmetric
 tridiagonal matrix T less than or equal to its argument  w.  It
 performs a choice of two types of loops:

 IJOB=1, followed by
 IJOB=2: It takes as input a list of intervals and returns a list of
         sufficiently small intervals whose union contains the same
         eigenvalues as the union of the original intervals.
         The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
         The output interval (AB(j,1),AB(j,2)] will contain
         eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 &lt;= j &lt;= MOUT.

 IJOB=3: It performs a binary search in each input interval
         (AB(j,1),AB(j,2)] for a point  w(j)  such that
         N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
         the search.  If such a w(j) is found, then on output
         AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
         (AB(j,1),AB(j,2)] will be a small interval containing the
         point where N(w) jumps through NVAL(j), unless that point
         lies outside the initial interval.

 Note that the intervals are in all cases half-open intervals,
 i.e., of the form  (a,b] , which includes  b  but not  a .

 To avoid underflow, the matrix should be scaled so that its largest
 element is no greater than  overflow**(1/2) * underflow**(1/4)
 in absolute value.  To assure the most accurate computation
 of small eigenvalues, the matrix should be scaled to be
 not much smaller than that, either.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966

 Note: the arguments are, in general, *not* checked for unreasonable
 values.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IJOB</td><td><pre class="fragment">          IJOB is INTEGER
          Specifies what is to be done:
          = 1:  Compute NAB for the initial intervals.
          = 2:  Perform bisection iteration to find eigenvalues of T.
          = 3:  Perform bisection iteration to invert N(w), i.e.,
                to find a point which has a specified number of
                eigenvalues of T to its left.
          Other values will cause DLAEBZ to return with INFO=-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NITMAX</td><td><pre class="fragment">          NITMAX is INTEGER
          The maximum number of "levels" of bisection to be
          performed, i.e., an interval of width W will not be made
          smaller than 2^(-NITMAX) * W.  If not all intervals
          have converged after NITMAX iterations, then INFO is set
          to the number of non-converged intervals.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension n of the tridiagonal matrix T.  It must be at
          least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MMAX</td><td><pre class="fragment">          MMAX is INTEGER
          The maximum number of intervals.  If more than MMAX intervals
          are generated, then DLAEBZ will quit with INFO=MMAX+1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MINP</td><td><pre class="fragment">          MINP is INTEGER
          The initial number of intervals.  It may not be greater than
          MMAX.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NBMIN</td><td><pre class="fragment">          NBMIN is INTEGER
          The smallest number of intervals that should be processed
          using a vector loop.  If zero, then only the scalar loop
          will be used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ABSTOL</td><td><pre class="fragment">          ABSTOL is DOUBLE PRECISION
          The minimum (absolute) width of an interval.  When an
          interval is narrower than ABSTOL, or than RELTOL times the
          larger (in magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  This must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RELTOL</td><td><pre class="fragment">          RELTOL is DOUBLE PRECISION
          The minimum relative width of an interval.  When an interval
          is narrower than ABSTOL, or than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum absolute value of a "pivot" in the Sturm
          sequence loop.
          This must be at least  max |e(j)**2|*safe_min  and at
          least safe_min, where safe_min is at least
          the smallest number that can divide one without overflow.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N)
          The offdiagonal elements of the tridiagonal matrix T in
          positions 1 through N-1.  E(N) is arbitrary.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is DOUBLE PRECISION array, dimension (N)
          The squares of the offdiagonal elements of the tridiagonal
          matrix T.  E2(N) is ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (MINP)
          If IJOB=1 or 2, not referenced.
          If IJOB=3, the desired values of N(w).  The elements of NVAL
          will be reordered to correspond with the intervals in AB.
          Thus, NVAL(j) on output will not, in general be the same as
          NVAL(j) on input, but it will correspond with the interval
          (AB(j,1),AB(j,2)] on output.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AB</td><td><pre class="fragment">          AB is DOUBLE PRECISION array, dimension (MMAX,2)
          The endpoints of the intervals.  AB(j,1) is  a(j), the left
          endpoint of the j-th interval, and AB(j,2) is b(j), the
          right endpoint of the j-th interval.  The input intervals
          will, in general, be modified, split, and reordered by the
          calculation.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension (MMAX)
          If IJOB=1, ignored.
          If IJOB=2, workspace.
          If IJOB=3, then on input C(j) should be initialized to the
          first search point in the binary search.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MOUT</td><td><pre class="fragment">          MOUT is INTEGER
          If IJOB=1, the number of eigenvalues in the intervals.
          If IJOB=2 or 3, the number of intervals output.
          If IJOB=3, MOUT will equal MINP.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">NAB</td><td><pre class="fragment">          NAB is INTEGER array, dimension (MMAX,2)
          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j)).
          If IJOB=2, then on input, NAB(i,j) should be set.  It must
             satisfy the condition:
             N(AB(i,1)) &lt;= NAB(i,1) &lt;= NAB(i,2) &lt;= N(AB(i,2)),
             which means that in interval i only eigenvalues
             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,
             NAB(i,j)=N(AB(i,j)), from a previous call to DLAEBZ with
             IJOB=1.
             On output, NAB(i,j) will contain
             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
             the input interval that the output interval
             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the
             the input values of NAB(k,1) and NAB(k,2).
          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),
             unless N(w) &gt; NVAL(i) for all search points  w , in which
             case NAB(i,1) will not be modified, i.e., the output
             value will be the same as the input value (modulo
             reorderings -- see NVAL and AB), or unless N(w) &lt; NVAL(i)
             for all search points  w , in which case NAB(i,2) will
             not be modified.  Normally, NAB should be set to some
             distinctive value(s) before DLAEBZ is called.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (MMAX)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (MMAX)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:       All intervals converged.
          = 1--MMAX: The last INFO intervals did not converge.
          = MMAX+1:  More than MMAX intervals were generated.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">      This routine is intended to be called only by other LAPACK
  routines, thus the interface is less user-friendly.  It is intended
  for two purposes:

  (a) finding eigenvalues.  In this case, DLAEBZ should have one or
      more initial intervals set up in AB, and DLAEBZ should be called
      with IJOB=1.  This sets up NAB, and also counts the eigenvalues.
      Intervals with no eigenvalues would usually be thrown out at
      this point.  Also, if not all the eigenvalues in an interval i
      are desired, NAB(i,1) can be increased or NAB(i,2) decreased.
      For example, set NAB(i,1)=NAB(i,2)-1 to get the largest
      eigenvalue.  DLAEBZ is then called with IJOB=2 and MMAX
      no smaller than the value of MOUT returned by the call with
      IJOB=1.  After this (IJOB=2) call, eigenvalues NAB(i,1)+1
      through NAB(i,2) are approximately AB(i,1) (or AB(i,2)) to the
      tolerance specified by ABSTOL and RELTOL.

  (b) finding an interval (a',b'] containing eigenvalues w(f),...,w(l).
      In this case, start with a Gershgorin interval  (a,b).  Set up
      AB to contain 2 search intervals, both initially (a,b).  One
      NVAL element should contain  f-1  and the other should contain  l
      , while C should contain a and b, resp.  NAB(i,1) should be -1
      and NAB(i,2) should be N+1, to flag an error if the desired
      interval does not lie in (a,b).  DLAEBZ is then called with
      IJOB=3.  On exit, if w(f-1) &lt; w(f), then one of the intervals --
      j -- will have AB(j,1)=AB(j,2) and NAB(j,1)=NAB(j,2)=f-1, while
      if, to the specified tolerance, w(f-k)=...=w(f+r), k &gt; 0 and r
      &gt;= 0, then the interval will have  N(AB(j,1))=NAB(j,1)=f-k and
      N(AB(j,2))=NAB(j,2)=f+r.  The cases w(l) &lt; w(l+1) and
      w(l-r)=...=w(l+k) are handled similarly.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga404759a75990a78660c741b3448b27e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlaev2 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SN1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAEV2</b> computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix. </p>
<p> 
 Download DLAEV2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlaev2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlaev2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaev2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
    [  A   B  ]
    [  B   C  ].
 On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
 eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
 eigenvector for RT1, giving the decomposition

    [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
    [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION
          The (1,2) element and the conjugate of the (2,1) element of
          the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT1</td><td><pre class="fragment">          RT1 is DOUBLE PRECISION
          The eigenvalue of larger absolute value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT2</td><td><pre class="fragment">          RT2 is DOUBLE PRECISION
          The eigenvalue of smaller absolute value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS1</td><td><pre class="fragment">          CS1 is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SN1</td><td><pre class="fragment">          SN1 is DOUBLE PRECISION
          The vector (CS1, SN1) is a unit right eigenvector for RT1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  RT1 is accurate to a few ulps barring over/underflow.

  RT2 may be inaccurate if there is massive cancellation in the
  determinant A*C-B*B; higher precision or correctly rounded or
  correctly truncated arithmetic would be needed to compute RT2
  accurately in all cases.

  CS1 and SN1 are accurate to a few ulps barring over/underflow.

  Overflow is possible only if RT1 is within a factor of 5 of overflow.
  Underflow is harmless if the input data is 0 or exceeds
     underflow_threshold / macheps.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fbc9a87ffa4a60adadcb4fc511c2556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlagts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>JOB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAGTS</b> solves the system of equations (T-λI)x = y or (T-λI)Tx = y,where T is a general tridiagonal matrix and λ a scalar, using the LU factorization computed by slagtf. </p>
<p> 
 Download DLAGTS + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlagts.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlagts.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlagts.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAGTS may be used to solve one of the systems of equations

    (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,

 where T is an n by n tridiagonal matrix, for x, following the
 factorization of (T - lambda*I) as

    (T - lambda*I) = P*L*U ,

 by routine DLAGTF. The choice of equation to be solved is
 controlled by the argument JOB, and in each case there is an option
 to perturb zero or very small diagonal elements of U, this option
 being intended for use in applications such as inverse iteration.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOB</td><td><pre class="fragment">          JOB is INTEGER
          Specifies the job to be performed by DLAGTS as follows:
          =  1: The equations  (T - lambda*I)x = y  are to be solved,
                but diagonal elements of U are not to be perturbed.
          = -1: The equations  (T - lambda*I)x = y  are to be solved
                and, if overflow would otherwise occur, the diagonal
                elements of U are to be perturbed. See argument TOL
                below.
          =  2: The equations  (T - lambda*I)**Tx = y  are to be solved,
                but diagonal elements of U are not to be perturbed.
          = -2: The equations  (T - lambda*I)**Tx = y  are to be solved
                and, if overflow would otherwise occur, the diagonal
                elements of U are to be perturbed. See argument TOL
                below.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (N)
          On entry, A must contain the diagonal elements of U as
          returned from DLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (N-1)
          On entry, B must contain the first super-diagonal elements of
          U as returned from DLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension (N-1)
          On entry, C must contain the sub-diagonal elements of L as
          returned from DLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N-2)
          On entry, D must contain the second super-diagonal elements
          of U as returned from DLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IN</td><td><pre class="fragment">          IN is INTEGER array, dimension (N)
          On entry, IN must contain details of the matrix P as returned
          from DLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is DOUBLE PRECISION array, dimension (N)
          On entry, the right hand side vector y.
          On exit, Y is overwritten by the solution vector x.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">TOL</td><td><pre class="fragment">          TOL is DOUBLE PRECISION
          On entry, with  JOB .lt. 0, TOL should be the minimum
          perturbation to be made to very small diagonal elements of U.
          TOL should normally be chosen as about eps*norm(U), where eps
          is the relative machine precision, but if TOL is supplied as
          non-positive, then it is reset to eps*max( abs( u(i,j) ) ).
          If  JOB .gt. 0  then TOL is not referenced.

          On exit, TOL is changed as described above, only if TOL is
          non-positive on entry. Otherwise TOL is unchanged.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0   : successful exit
          .lt. 0: if INFO = -i, the i-th argument had an illegal value
          .gt. 0: overflow would occur when computing the INFO(th)
                  element of the solution vector x. This can only occur
                  when JOB is supplied as positive and either means
                  that a diagonal element of U is very small, or that
                  the elements of the right-hand side vector y are very
                  large.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga341ec834c6fc14a17fead550ff486022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlaisnan </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>DIN1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>DIN2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAISNAN</b> tests input for NaN by comparing two arguments for inequality. </p>
<p> 
 Download DLAISNAN + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlaisnan.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlaisnan.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaisnan.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This routine is not for general use.  It exists solely to avoid
 over-optimization in DISNAN.

 DLAISNAN checks for NaNs by comparing its two arguments for
 inequality.  NaN is the only floating-point value where NaN != NaN
 returns .TRUE.  To check for NaNs, pass the same variable as both
 arguments.

 A compiler must assume that the two arguments are
 not the same variable, and the test will not be optimized away.
 Interprocedural or whole-program optimization may delete this
 test.  The ISNAN functions will be replaced by the correct
 Fortran 03 intrinsic once the intrinsic is widely available.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DIN1</td><td><pre class="fragment">          DIN1 is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIN2</td><td><pre class="fragment">          DIN2 is DOUBLE PRECISION
          Two numbers to compare for inequality.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga48732e43b3051e58aee28857c75ce270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlamc1 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>RND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>IEEE1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAMC1</b> </p>
<p><b>Purpose:</b> </p><pre class="fragment"> DLAMC1 determines the machine parameters given by BETA, T, RND, and
 IEEE1.</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          The base of the machine.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          The number of ( BETA ) digits in the mantissa.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RND</td><td><pre class="fragment">          Specifies whether proper rounding  ( RND = .TRUE. )  or
          chopping  ( RND = .FALSE. )  occurs in addition. This may not
          be a reliable guide to the way in which the machine performs
          its arithmetic.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IEEE1</td><td><pre class="fragment">          Specifies whether rounding appears to be done in the IEEE
          'round to nearest' style.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012</dd></dl>
<p><b>Further</b> <b>Details</b> </p><pre class="fragment">  The routine is based on the routine  ENVRON  by Malcolm and
  incorporates suggestions by Gentleman and Marovich. See

     Malcolm M. A. (1972) Algorithms to reveal properties of
        floating-point arithmetic. Comms. of the ACM, 15, 949-951.

     Gentleman W. M. and Marovich S. B. (1974) More on algorithms
        that reveal properties of floating point arithmetic units.
        Comms. of the ACM, 17, 276-277.</pre> 
</div>
</div>
<a class="anchor" id="ga0dce45f915606712ff791e280ddad827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlamc2 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>RND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>EPS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>EMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>EMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAMC2</b> </p>
<p><b>Purpose:</b> </p><pre class="fragment"> DLAMC2 determines the machine parameters specified in its argument
 list.</pre> <dl class="section author"><dt>Author</dt><dd>LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          The base of the machine.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          The number of ( BETA ) digits in the mantissa.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RND</td><td><pre class="fragment">          Specifies whether proper rounding  ( RND = .TRUE. )  or
          chopping  ( RND = .FALSE. )  occurs in addition. This may not
          be a reliable guide to the way in which the machine performs
          its arithmetic.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EPS</td><td><pre class="fragment">          The smallest positive number such that
             fl( 1.0 - EPS ) .LT. 1.0,
          where fl denotes the computed value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMIN</td><td><pre class="fragment">          The minimum exponent before (gradual) underflow occurs.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RMIN</td><td><pre class="fragment">          The smallest normalized number for the machine, given by
          BASE**( EMIN - 1 ), where  BASE  is the floating point value
          of BETA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAX</td><td><pre class="fragment">          The maximum exponent before overflow occurs.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          The largest positive number for the machine, given by
          BASE**EMAX * ( 1 - EPS ), where  BASE  is the floating point
          value of BETA.</pre></td></tr>
  </table>
  </dd>
</dl>
<p><b>Further</b> <b>Details</b> </p><pre class="fragment">  The computation of  EPS  is based on a routine PARANOIA by
  W. Kahan of the University of California at Berkeley.</pre> 
</div>
</div>
<a class="anchor" id="gae762ae5fb996f7b2970c522d10fa22f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlamc3 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAMC3</b> </p>
<p><b>Purpose:</b> </p><pre class="fragment"> DLAMC3  is intended to force  A  and  B  to be stored prior to doing
 the addition of  A  and  B ,  for use in situations where optimizers
 might hold one of these in a register.</pre> <dl class="section author"><dt>Author</dt><dd>LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is a DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is a DOUBLE PRECISION
          The values A and B.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06d6aa332f6f66e062e9b96a41f40800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlamch </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>CMACH</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAMCH</b> </p>
<p><b>DLAMCHF77</b> deprecated</p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAMCH determines double precision machine parameters.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CMACH</td><td><pre class="fragment">          Specifies the value to be returned by DLAMCH:
          = 'E' or 'e',   DLAMCH := eps
          = 'S' or 's ,   DLAMCH := sfmin
          = 'B' or 'b',   DLAMCH := base
          = 'P' or 'p',   DLAMCH := eps*base
          = 'N' or 'n',   DLAMCH := t
          = 'R' or 'r',   DLAMCH := rnd
          = 'M' or 'm',   DLAMCH := emin
          = 'U' or 'u',   DLAMCH := rmin
          = 'L' or 'l',   DLAMCH := emax
          = 'O' or 'o',   DLAMCH := rmax
          where
          eps   = relative machine precision
          sfmin = safe minimum, such that 1/sfmin does not overflow
          base  = base of the machine
          prec  = eps*base
          t     = number of (base) digits in the mantissa
          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
          emin  = minimum exponent before (gradual) underflow
          rmin  = underflow threshold - base**(emin-1)
          emax  = largest exponent before overflow
          rmax  = overflow threshold  - (base**emax)*(1-eps)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAMCHF77 determines double precision machine parameters.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CMACH</td><td><pre class="fragment">          Specifies the value to be returned by DLAMCH:
          = 'E' or 'e',   DLAMCH := eps
          = 'S' or 's ,   DLAMCH := sfmin
          = 'B' or 'b',   DLAMCH := base
          = 'P' or 'p',   DLAMCH := eps*base
          = 'N' or 'n',   DLAMCH := t
          = 'R' or 'r',   DLAMCH := rnd
          = 'M' or 'm',   DLAMCH := emin
          = 'U' or 'u',   DLAMCH := rmin
          = 'L' or 'l',   DLAMCH := emax
          = 'O' or 'o',   DLAMCH := rmax
          where
          eps   = relative machine precision
          sfmin = safe minimum, such that 1/sfmin does not overflow
          base  = base of the machine
          prec  = eps*base
          t     = number of (base) digits in the mantissa
          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
          emin  = minimum exponent before (gradual) underflow
          rmin  = underflow threshold - base**(emin-1)
          emax  = largest exponent before overflow
          rmax  = overflow threshold  - (base**emax)*(1-eps)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4932b5966e6a63f7d7b9f0a189003b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlaneg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>LLD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLANEG</b> computes the Sturm count. </p>
<p> 
 Download DLANEG + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlaneg.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlaneg.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaneg.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLANEG computes the Sturm count, the number of negative pivots
 encountered while factoring tridiagonal T - sigma I = L D L^T.
 This implementation works directly on the factors without forming
 the tridiagonal matrix T.  The Sturm count is also the number of
 eigenvalues of T less than sigma.

 This routine is called from DLARRB.

 The current routine does not use the PIVMIN parameter but rather
 requires IEEE-754 propagation of Infinities and NaNs.  This
 routine also has no input range restrictions but does require
 default exception handling such that x/0 produces Inf when x is
 non-zero, and Inf/Inf produces NaN.  For more information, see:

   Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
   Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on
   Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624
   (Tech report version in LAWN 172 with the same title.)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LLD</td><td><pre class="fragment">          LLD is DOUBLE PRECISION array, dimension (N-1)
          The (N-1) elements L(i)*L(i)*D(i).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SIGMA</td><td><pre class="fragment">          SIGMA is DOUBLE PRECISION
          Shift amount in T - sigma I = L D L^T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot in the Sturm sequence.  May be used
          when zero pivots are encountered on non-IEEE-754
          architectures.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td><pre class="fragment">          R is INTEGER
          The twist index for the twisted factorization that is used
          for the negcount.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA <br />
 Jason Riedy, University of California, Berkeley, USA <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2d199841a9ffcf46d31e13e326d195dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlanst </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>NORM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLANST</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric tridiagonal matrix. </p>
<p> 
 Download DLANST + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlanst.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlanst.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlanst.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLANST  returns the value of the one norm,  or the Frobenius norm, or
 the  infinity norm,  or the  element of  largest absolute value  of a
 real symmetric tridiagonal matrix A.</pre></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DLANST <pre class="fragment">    DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

 where  norm1  denotes the  one norm of a matrix (maximum column sum),
 normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
 normF  denotes the  Frobenius norm of a matrix (square root of sum of
 squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NORM</td><td><pre class="fragment">          NORM is CHARACTER*1
          Specifies the value to be returned in DLANST as described
          above.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.  When N = 0, DLANST is
          set to zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The diagonal elements of A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N-1)
          The (n-1) sub-diagonal or super-diagonal elements of A.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gacf4c47c2f593fb3a4e842bca6df1240b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlapy2 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAPY2</b> returns sqrt(x2+y2). </p>
<p> 
 Download DLAPY2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlapy2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlapy2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlapy2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 overflow.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is DOUBLE PRECISION
          X and Y specify the values x and y.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gad929930f6e7780e8a1d73b2515ddd42b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlapy3 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAPY3</b> returns sqrt(x2+y2+z2). </p>
<p> 
 Download DLAPY3 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlapy3.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlapy3.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlapy3.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 unnecessary overflow.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION
          X, Y and Z specify the values x, y and z.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga77e05a87ced667cbdb502aa87c72d056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarnv </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARNV</b> returns a vector of random numbers from a uniform or normal distribution. </p>
<p> 
 Download DLARNV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarnv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarnv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarnv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARNV returns a vector of n random real numbers from a uniform or
 normal distribution.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is INTEGER
          Specifies the distribution of the random numbers:
          = 1:  uniform (0,1)
          = 2:  uniform (-1,1)
          = 3:  normal (0,1)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of random numbers to be generated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (N)
          The generated random numbers.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  This routine calls the auxiliary routine DLARUV to generate random
  real numbers from a uniform (0,1) distribution, in batches of up to
  128 using vectorisable code. The Box-Muller method is used to
  transform numbers from a uniform to a normal distribution.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b5719c25a81a95270cd36178e283166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarra </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SPLTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>TNRM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRA</b> computes the splitting points with the specified threshold. </p>
<p> 
 Download DLARRA + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarra.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarra.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarra.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Compute the splitting points with threshold SPLTOL.
 DLARRA sets any "small" off-diagonal elements to zero.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          On entry, the N diagonal elements of the tridiagonal
          matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N)
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) need not be set.
          On exit, the entries E( ISPLIT( I ) ), 1 &lt;= I &lt;= NSPLIT,
          are set to zero, the other entries of E are untouched.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is DOUBLE PRECISION array, dimension (N)
          On entry, the first (N-1) entries contain the SQUARES of the
          subdiagonal elements of the tridiagonal matrix T;
          E2(N) need not be set.
          On exit, the entries E2( ISPLIT( I ) ),
          1 &lt;= I &lt;= NSPLIT, have been set to zero</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPLTOL</td><td><pre class="fragment">          SPLTOL is DOUBLE PRECISION
          The threshold for splitting. Two criteria can be used:
          SPLTOL&lt;0 : criterion based on absolute off-diagonal value
          SPLTOL&gt;0 : criterion that preserves relative accuracy</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TNRM</td><td><pre class="fragment">          TNRM is DOUBLE PRECISION
          The norm of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NSPLIT</td><td><pre class="fragment">          NSPLIT is INTEGER
          The number of blocks T splits into. 1 &lt;= NSPLIT &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ISPLIT</td><td><pre class="fragment">          ISPLIT is INTEGER array, dimension (N)
          The splitting points, at which T breaks up into blocks.
          The first block consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gab3446b2d3189e23e5b95f18ea97b0a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarrb </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>LLD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IFIRST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILAST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RTOL1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RTOL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>OFFSET</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WGAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SPDIAM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>TWIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRB</b> provides limited bisection to locate eigenvalues for more accuracy. </p>
<p> 
 Download DLARRB + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrb.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrb.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrb.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Given the relatively robust representation(RRR) L D L^T, DLARRB
 does "limited" bisection to refine the eigenvalues of L D L^T,
 W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
 guesses for these eigenvalues are input in W, the corresponding estimate
 of the error in these guesses and their gaps are input in WERR
 and WGAP, respectively. During bisection, intervals
 [left, right] are maintained by storing their mid-points and
 semi-widths in the arrays W and WERR respectively.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LLD</td><td><pre class="fragment">          LLD is DOUBLE PRECISION array, dimension (N-1)
          The (N-1) elements L(i)*L(i)*D(i).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IFIRST</td><td><pre class="fragment">          IFIRST is INTEGER
          The index of the first eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILAST</td><td><pre class="fragment">          ILAST is INTEGER
          The index of the last eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL1</td><td><pre class="fragment">          RTOL1 is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL2</td><td><pre class="fragment">          RTOL2 is DOUBLE PRECISION
          Tolerance for the convergence of the bisection intervals.
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT.LT.MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )
          where GAP is the (estimated) distance to the nearest
          eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OFFSET</td><td><pre class="fragment">          OFFSET is INTEGER
          Offset for the arrays W, WGAP and WERR, i.e., the IFIRST-OFFSET
          through ILAST-OFFSET elements of these arrays are to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">W</td><td><pre class="fragment">          W is DOUBLE PRECISION array, dimension (N)
          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are
          estimates of the eigenvalues of L D L^T indexed IFIRST throug
          ILAST.
          On output, these estimates are refined.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WGAP</td><td><pre class="fragment">          WGAP is DOUBLE PRECISION array, dimension (N-1)
          On input, the (estimated) gaps between consecutive
          eigenvalues of L D L^T, i.e., WGAP(I-OFFSET) is the gap between
          eigenvalues I and I+1. Note that if IFIRST.EQ.ILAST
          then WGAP(IFIRST-OFFSET) must be set to ZERO.
          On output, these gaps are refined.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is DOUBLE PRECISION array, dimension (N)
          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET ) are
          the errors in the estimates of the corresponding elements in W.
          On output, these errors are refined.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot in the Sturm sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPDIAM</td><td><pre class="fragment">          SPDIAM is DOUBLE PRECISION
          The spectral diameter of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TWIST</td><td><pre class="fragment">          TWIST is INTEGER
          The twist index for the twisted factorization that is used
          for the negcount.
          TWIST = N: Compute negcount from L D L^T - LAMBDA I = L+ D+ L+^T
          TWIST = 1: Compute negcount from L D L^T - LAMBDA I = U- D- U-^T
          TWIST = R: Compute negcount from L D L^T - LAMBDA I = N(r) D(r) N(r)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          Error flag.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gac6a65096bc8be9a4dc881a96147075ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarrc </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>EIGCNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LCNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>RCNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRC</b> computes the number of eigenvalues of the symmetric tridiagonal matrix. </p>
<p> 
 Download DLARRC + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrc.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrc.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrc.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Find the number of eigenvalues of the symmetric tridiagonal matrix T
 that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
 if JOBT = 'L'.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBT</td><td><pre class="fragment">          JOBT is CHARACTER*1
          = 'T':  Compute Sturm count for matrix T.
          = 'L':  Compute Sturm count for matrix L D L^T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is DOUBLE PRECISION
          The lower and upper bounds for the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          JOBT = 'T': The N diagonal elements of the tridiagonal matrix T.
          JOBT = 'L': The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N)
          JOBT = 'T': The N-1 offdiagonal elements of the matrix T.
          JOBT = 'L': The N-1 offdiagonal elements of the matrix L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EIGCNT</td><td><pre class="fragment">          EIGCNT is INTEGER
          The number of eigenvalues of the symmetric tridiagonal matrix T
          that are in the interval (VL,VU]</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LCNT</td><td><pre class="fragment">          LCNT is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNT</td><td><pre class="fragment">          RCNT is INTEGER
          The left and right negcounts of the interval.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9fa3671522ed0e21695769fd85982c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarrd </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RANGE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>ORDER</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>GERS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RELTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>WL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>WU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IBLOCK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>INDEXW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRD</b> computes the eigenvalues of a symmetric tridiagonal matrix to suitable accuracy. </p>
<p> 
 Download DLARRD + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrd.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrd.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrd.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARRD computes the eigenvalues of a symmetric tridiagonal
 matrix T to suitable accuracy. This is an auxiliary code to be
 called from DSTEMR.
 The user may ask for all eigenvalues, all eigenvalues
 in the half-open interval (VL, VU], or the IL-th through IU-th
 eigenvalues.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RANGE</td><td><pre class="fragment">          RANGE is CHARACTER*1
          = 'A': ("All")   all eigenvalues will be found.
          = 'V': ("Value") all eigenvalues in the half-open interval
                           (VL, VU] will be found.
          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                           entire matrix) will be found.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ORDER</td><td><pre class="fragment">          ORDER is CHARACTER*1
          = 'B': ("By Block") the eigenvalues will be grouped by
                              split-off block (see IBLOCK, ISPLIT) and
                              ordered from smallest to largest within
                              the block.
          = 'E': ("Entire matrix")
                              the eigenvalues for the entire matrix
                              will be ordered from smallest to
                              largest.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the tridiagonal matrix T.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is DOUBLE PRECISION
          If RANGE='V', the lower and upper bounds of the interval to
          be searched for eigenvalues.  Eigenvalues less than or equal
          to VL, or greater than VU, will not be returned.  VL &lt; VU.
          Not referenced if RANGE = 'A' or 'I'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IL</td><td><pre class="fragment">          IL is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IU</td><td><pre class="fragment">          IU is INTEGER
          If RANGE='I', the indices (in ascending order) of the
          smallest and largest eigenvalues to be returned.
          1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GERS</td><td><pre class="fragment">          GERS is DOUBLE PRECISION array, dimension (2*N)
          The N Gerschgorin intervals (the i-th Gerschgorin interval
          is (GERS(2*i-1), GERS(2*i)).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RELTOL</td><td><pre class="fragment">          RELTOL is DOUBLE PRECISION
          The minimum relative width of an interval.  When an interval
          is narrower than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The n diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N-1)
          The (n-1) off-diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is DOUBLE PRECISION array, dimension (N-1)
          The (n-1) squared off-diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot allowed in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NSPLIT</td><td><pre class="fragment">          NSPLIT is INTEGER
          The number of diagonal blocks in the matrix T.
          1 &lt;= NSPLIT &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISPLIT</td><td><pre class="fragment">          ISPLIT is INTEGER array, dimension (N)
          The splitting points, at which T breaks up into submatrices.
          The first submatrix consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
          (Only the first NSPLIT elements will actually be used, but
          since the user cannot know a priori what value NSPLIT will
          have, N words must be reserved for ISPLIT.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The actual number of eigenvalues found. 0 &lt;= M &lt;= N.
          (See also the description of INFO=2,3.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is DOUBLE PRECISION array, dimension (N)
          On exit, the first M elements of W will contain the
          eigenvalue approximations. DLARRD computes an interval
          I_j = (a_j, b_j] that includes eigenvalue j. The eigenvalue
          approximation is given as the interval midpoint
          W(j)= ( a_j + b_j)/2. The corresponding error is bounded by
          WERR(j) = abs( a_j - b_j)/2</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is DOUBLE PRECISION array, dimension (N)
          The error bound on the corresponding eigenvalue approximation
          in W.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WL</td><td><pre class="fragment">          WL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WU</td><td><pre class="fragment">          WU is DOUBLE PRECISION
          The interval (WL, WU] contains all the wanted eigenvalues.
          If RANGE='V', then WL=VL and WU=VU.
          If RANGE='A', then WL and WU are the global Gerschgorin bounds
                        on the spectrum.
          If RANGE='I', then WL and WU are computed by DLAEBZ from the
                        index range specified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IBLOCK</td><td><pre class="fragment">          IBLOCK is INTEGER array, dimension (N)
          At each row/column j where E(j) is zero or small, the
          matrix T is considered to split into a block diagonal
          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
          block (from 1 to the number of blocks) the eigenvalue W(i)
          belongs.  (DLARRD may use the remaining N-M elements as
          workspace.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INDEXW</td><td><pre class="fragment">          INDEXW is INTEGER array, dimension (N)
          The indices of the eigenvalues within each block (submatrix);
          for example, INDEXW(i)= j and IBLOCK(i)=k imply that the
          i-th eigenvalue W(i) is the j-th eigenvalue in block k.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (4*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (3*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  some or all of the eigenvalues failed to converge or
                were not computed:
                =1 or 3: Bisection failed to converge for some
                        eigenvalues; these eigenvalues are flagged by a
                        negative block number.  The effect is that the
                        eigenvalues may not be as accurate as the
                        absolute and relative tolerances.  This is
                        generally caused by unexpectedly inaccurate
                        arithmetic.
                =2 or 3: RANGE='I' only: Not all of the eigenvalues
                        IL:IU were found.
                        Effect: M &lt; IU+1-IL
                        Cause:  non-monotonic arithmetic, causing the
                                Sturm sequence to be non-monotonic.
                        Cure:   recalculate, using RANGE='A', and pick
                                out eigenvalues IL:IU.  In some cases,
                                increasing the PARAMETER "FUDGE" may
                                make things work.
                = 4:    RANGE='I', and the Gershgorin interval
                        initially used was too small.  No eigenvalues
                        were computed.
                        Probable cause: your machine has sloppy
                                        floating-point arithmetic.
                        Cure: Increase the PARAMETER "FUDGE",
                              recompile, and try again.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Internal Parameters: </dt><dd><pre class="fragment">  FUDGE   DOUBLE PRECISION, default = 2
          A "fudge factor" to widen the Gershgorin intervals.  Ideally,
          a value of 1 should work, but on machines with sloppy
          arithmetic, this needs to be larger.  The default for
          publicly released versions should be large enough to handle
          the worst machine around.  Note that this has no effect
          on accuracy of the solution.</pre></dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>W. Kahan, University of California, Berkeley, USA <br />
 Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA <br />
 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gae8358ae1847bb9cfb96b56b6f3ef6386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarre </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RANGE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RTOL1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RTOL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SPLTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WGAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IBLOCK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>INDEXW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>GERS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRE</b> given the tridiagonal matrix T, sets small off-diagonal elements to zero and for each unreduced block Ti, finds base representations and eigenvalues. </p>
<p> 
 Download DLARRE + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarre.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarre.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarre.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> To find the desired eigenvalues of a given real symmetric
 tridiagonal matrix T, DLARRE sets any "small" off-diagonal
 elements to zero, and for each unreduced block T_i, it finds
 (a) a suitable shift at one end of the block's spectrum,
 (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
 (c) eigenvalues of each L_i D_i L_i^T.
 The representations and eigenvalues found are then used by
 DSTEMR to compute the eigenvectors of T.
 The accuracy varies depending on whether bisection is used to
 find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to
 conpute all and then discard any unwanted one.
 As an added benefit, DLARRE also outputs the n
 Gerschgorin intervals for the matrices L_i D_i L_i^T.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RANGE</td><td><pre class="fragment">          RANGE is CHARACTER*1
          = 'A': ("All")   all eigenvalues will be found.
          = 'V': ("Value") all eigenvalues in the half-open interval
                           (VL, VU] will be found.
          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                           entire matrix) will be found.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is DOUBLE PRECISION
          If RANGE='V', the lower and upper bounds for the eigenvalues.
          Eigenvalues less than or equal to VL, or greater than VU,
          will not be returned.  VL &lt; VU.
          If RANGE='I' or ='A', DLARRE computes bounds on the desired
          part of the spectrum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IL</td><td><pre class="fragment">          IL is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IU</td><td><pre class="fragment">          IU is INTEGER
          If RANGE='I', the indices (in ascending order) of the
          smallest and largest eigenvalues to be returned.
          1 &lt;= IL &lt;= IU &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          On entry, the N diagonal elements of the tridiagonal
          matrix T.
          On exit, the N diagonal elements of the diagonal
          matrices D_i.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N)
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) need not be set.
          On exit, E contains the subdiagonal elements of the unit
          bidiagonal matrices L_i. The entries E( ISPLIT( I ) ),
          1 &lt;= I &lt;= NSPLIT, contain the base points sigma_i on output.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is DOUBLE PRECISION array, dimension (N)
          On entry, the first (N-1) entries contain the SQUARES of the
          subdiagonal elements of the tridiagonal matrix T;
          E2(N) need not be set.
          On exit, the entries E2( ISPLIT( I ) ),
          1 &lt;= I &lt;= NSPLIT, have been set to zero</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL1</td><td><pre class="fragment">          RTOL1 is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL2</td><td><pre class="fragment">          RTOL2 is DOUBLE PRECISION
           Parameters for bisection.
           An interval [LEFT,RIGHT] has converged if
           RIGHT-LEFT.LT.MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPLTOL</td><td><pre class="fragment">          SPLTOL is DOUBLE PRECISION
          The threshold for splitting.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NSPLIT</td><td><pre class="fragment">          NSPLIT is INTEGER
          The number of blocks T splits into. 1 &lt;= NSPLIT &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ISPLIT</td><td><pre class="fragment">          ISPLIT is INTEGER array, dimension (N)
          The splitting points, at which T breaks up into blocks.
          The first block consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The total number of eigenvalues (of all L_i D_i L_i^T)
          found.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is DOUBLE PRECISION array, dimension (N)
          The first M elements contain the eigenvalues. The
          eigenvalues of each of the blocks, L_i D_i L_i^T, are
          sorted in ascending order ( DLARRE may use the
          remaining N-M elements as workspace).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is DOUBLE PRECISION array, dimension (N)
          The error bound on the corresponding eigenvalue in W.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WGAP</td><td><pre class="fragment">          WGAP is DOUBLE PRECISION array, dimension (N)
          The separation from the right neighbor eigenvalue in W.
          The gap is only with respect to the eigenvalues of the same block
          as each block has its own representation tree.
          Exception: at the right end of a block we store the left gap</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IBLOCK</td><td><pre class="fragment">          IBLOCK is INTEGER array, dimension (N)
          The indices of the blocks (submatrices) associated with the
          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue
          W(i) belongs to the first block from the top, =2 if W(i)
          belongs to the second block, etc.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INDEXW</td><td><pre class="fragment">          INDEXW is INTEGER array, dimension (N)
          The indices of the eigenvalues within each block (submatrix);
          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the
          i-th eigenvalue W(i) is the 10-th eigenvalue in block 2</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GERS</td><td><pre class="fragment">          GERS is DOUBLE PRECISION array, dimension (2*N)
          The N Gerschgorin intervals (the i-th Gerschgorin interval
          is (GERS(2*i-1), GERS(2*i)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (6*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (5*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &gt; 0:  A problem occured in DLARRE.
          &lt; 0:  One of the called subroutines signaled an internal problem.
                Needs inspection of the corresponding parameter IINFO
                for further information.

          =-1:  Problem in DLARRD.
          = 2:  No base representation could be found in MAXTRY iterations.
                Increasing MAXTRY and recompilation might be a remedy.
          =-3:  Problem in DLARRB when computing the refined root
                representation for DLASQ2.
          =-4:  Problem in DLARRB when preforming bisection on the
                desired part of the spectrum.
          =-5:  Problem in DLASQ2.
          =-6:  Problem in DLASQ2.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  The base representations are required to suffer very little
  element growth and consequently define all their eigenvalues to
  high relative accuracy.</pre> </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6fa2f60646088821e40fbe04a41aa7b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarrf </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>LD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>CLSTRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>CLEND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WGAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SPDIAM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CLGAPL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CLGAPR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DPLUS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>LPLUS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRF</b> finds a new relatively robust representation such that at least one of the eigenvalues is relatively isolated. </p>
<p> 
 Download DLARRF + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrf.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrf.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrf.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Given the initial representation L D L^T and its cluster of close
 eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
 W( CLEND ), DLARRF finds a new relatively robust representation
 L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
 eigenvalues of L(+) D(+) L(+)^T is relatively isolated.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix (subblock, if the matrix splitted).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td><pre class="fragment">          L is DOUBLE PRECISION array, dimension (N-1)
          The (N-1) subdiagonal elements of the unit bidiagonal
          matrix L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LD</td><td><pre class="fragment">          LD is DOUBLE PRECISION array, dimension (N-1)
          The (N-1) elements L(i)*D(i).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLSTRT</td><td><pre class="fragment">          CLSTRT is INTEGER
          The index of the first eigenvalue in the cluster.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLEND</td><td><pre class="fragment">          CLEND is INTEGER
          The index of the last eigenvalue in the cluster.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td><pre class="fragment">          W is DOUBLE PRECISION array, dimension
          dimension is &gt;=  (CLEND-CLSTRT+1)
          The eigenvalue APPROXIMATIONS of L D L^T in ascending order.
          W( CLSTRT ) through W( CLEND ) form the cluster of relatively
          close eigenalues.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WGAP</td><td><pre class="fragment">          WGAP is DOUBLE PRECISION array, dimension
          dimension is &gt;=  (CLEND-CLSTRT+1)
          The separation from the right neighbor eigenvalue in W.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is DOUBLE PRECISION array, dimension
          dimension is  &gt;=  (CLEND-CLSTRT+1)
          WERR contain the semiwidth of the uncertainty
          interval of the corresponding eigenvalue APPROXIMATION in W</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPDIAM</td><td><pre class="fragment">          SPDIAM is DOUBLE PRECISION
          estimate of the spectral diameter obtained from the
          Gerschgorin intervals</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLGAPL</td><td><pre class="fragment">          CLGAPL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLGAPR</td><td><pre class="fragment">          CLGAPR is DOUBLE PRECISION
          absolute gap on each end of the cluster.
          Set by the calling routine to protect against shifts too close
          to eigenvalues outside the cluster.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot allowed in the Sturm sequence.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SIGMA</td><td><pre class="fragment">          SIGMA is DOUBLE PRECISION
          The shift used to form L(+) D(+) L(+)^T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DPLUS</td><td><pre class="fragment">          DPLUS is DOUBLE PRECISION array, dimension (N)
          The N diagonal elements of the diagonal matrix D(+).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LPLUS</td><td><pre class="fragment">          LPLUS is DOUBLE PRECISION array, dimension (N-1)
          The first (N-1) elements of LPLUS contain the subdiagonal
          elements of the unit bidiagonal matrix L(+).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          Signals processing OK (=0) or failure (=1)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cdb25c9766674132d73bcbba824ab31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarrj </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IFIRST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILAST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>OFFSET</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SPDIAM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRJ</b> performs refinement of the initial estimates of the eigenvalues of the matrix T. </p>
<p> 
 Download DLARRJ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrj.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrj.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrj.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Given the initial eigenvalue approximations of T, DLARRJ
 does  bisection to refine the eigenvalues of T,
 W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
 guesses for these eigenvalues are input in W, the corresponding estimate
 of the error in these guesses in WERR. During bisection, intervals
 [left, right] are maintained by storing their mid-points and
 semi-widths in the arrays W and WERR respectively.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The N diagonal elements of T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is DOUBLE PRECISION array, dimension (N-1)
          The Squares of the (N-1) subdiagonal elements of T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IFIRST</td><td><pre class="fragment">          IFIRST is INTEGER
          The index of the first eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILAST</td><td><pre class="fragment">          ILAST is INTEGER
          The index of the last eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL</td><td><pre class="fragment">          RTOL is DOUBLE PRECISION
          Tolerance for the convergence of the bisection intervals.
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT.LT.RTOL*MAX(|LEFT|,|RIGHT|).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OFFSET</td><td><pre class="fragment">          OFFSET is INTEGER
          Offset for the arrays W and WERR, i.e., the IFIRST-OFFSET
          through ILAST-OFFSET elements of these arrays are to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">W</td><td><pre class="fragment">          W is DOUBLE PRECISION array, dimension (N)
          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are
          estimates of the eigenvalues of L D L^T indexed IFIRST through
          ILAST.
          On output, these estimates are refined.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is DOUBLE PRECISION array, dimension (N)
          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET ) are
          the errors in the estimates of the corresponding elements in W.
          On output, these errors are refined.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPDIAM</td><td><pre class="fragment">          SPDIAM is DOUBLE PRECISION
          The spectral diameter of T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          Error flag.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gad321b234af8d1ac9fbb18ca95a1c13f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarrk </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>GL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>GU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RELTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRK</b> computes one eigenvalue of a symmetric tridiagonal matrix T to suitable accuracy. </p>
<p> 
 Download DLARRK + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrk.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrk.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrk.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARRK computes one eigenvalue of a symmetric tridiagonal
 matrix T to suitable accuracy. This is an auxiliary code to be
 called from DSTEMR.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the tridiagonal matrix T.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IW</td><td><pre class="fragment">          IW is INTEGER
          The index of the eigenvalues to be returned.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GL</td><td><pre class="fragment">          GL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GU</td><td><pre class="fragment">          GU is DOUBLE PRECISION
          An upper and a lower bound on the eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The n diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is DOUBLE PRECISION array, dimension (N-1)
          The (n-1) squared off-diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is DOUBLE PRECISION
          The minimum pivot allowed in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RELTOL</td><td><pre class="fragment">          RELTOL is DOUBLE PRECISION
          The minimum relative width of an interval.  When an interval
          is narrower than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is DOUBLE PRECISION
          The error bound on the corresponding eigenvalue approximation
          in W.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:       Eigenvalue converged
          = -1:      Eigenvalue did NOT converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Internal Parameters: </dt><dd><pre class="fragment">  FUDGE   DOUBLE PRECISION, default = 2
          A "fudge factor" to widen the Gershgorin intervals.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gafe58120dedcb8d85c7a689c2d822f4a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarrr </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARRR</b> performs tests to decide whether the symmetric tridiagonal matrix T warrants expensive computations which guarantee high relative accuracy in the eigenvalues. </p>
<p> 
 Download DLARRR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlarrr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlarrr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlarrr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Perform tests to decide whether the symmetric tridiagonal matrix T
 warrants expensive computations which guarantee high relative accuracy
 in the eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The N diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N)
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) is set to ZERO.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          INFO = 0(default) : the matrix warrants computations preserving
                              relative accuracy.
          INFO = 1          : the matrix warrants computations guaranteeing
                              only absolute accuracy.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga73cdfda601476bb0fdd86047dee1d357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlartg </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARTG</b> generates a plane rotation with real cosine and real sine. </p>
<p> 
 Download DLARTG + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlartg.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlartg.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlartg.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARTG generate a plane rotation so that

    [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
    [ -SN  CS  ]     [ G ]     [ 0 ]

 This is a slower, more accurate version of the BLAS1 routine DROTG,
 with the following other differences:
    F and G are unchanged on return.
    If G=0, then CS=1 and SN=0.
    If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
       floating point operations (saves work in DBDSQR when
       there are zeros on the diagonal).

 If F exceeds G in magnitude, CS will be positive.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is DOUBLE PRECISION
          The first component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is DOUBLE PRECISION
          The second component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS</td><td><pre class="fragment">          CS is DOUBLE PRECISION
          The cosine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SN</td><td><pre class="fragment">          SN is DOUBLE PRECISION
          The sine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is DOUBLE PRECISION
          The nonzero component of the rotated vector.

  This version has a few statements commented out for thread safety
  (machine parameters are computed on each entry). 10 feb 03, SJH.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gac216c77dadbc793b5f0697555af0775b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlartgp </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARTGP</b> generates a plane rotation so that the diagonal is nonnegative. </p>
<p> 
 Download DLARTGP + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlartgp.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlartgp.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlartgp.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARTGP generates a plane rotation so that

    [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
    [ -SN  CS  ]     [ G ]     [ 0 ]

 This is a slower, more accurate version of the Level 1 BLAS routine DROTG,
 with the following other differences:
    F and G are unchanged on return.
    If G=0, then CS=(+/-)1 and SN=0.
    If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

 The sign is chosen so that R &gt;= 0.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is DOUBLE PRECISION
          The first component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is DOUBLE PRECISION
          The second component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS</td><td><pre class="fragment">          CS is DOUBLE PRECISION
          The cosine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SN</td><td><pre class="fragment">          SN is DOUBLE PRECISION
          The sine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is DOUBLE PRECISION
          The nonzero component of the rotated vector.

  This version has a few statements commented out for thread safety
  (machine parameters are computed on each entry). 10 feb 03, SJH.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga55e7c02e398f2c6365c956d272836a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlaruv </td>
          <td>(</td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( <a class="el" href="indexexpr_8h.html#ab427e2e2b4d6cec55fa088ea2a692ace">n</a> )&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARUV</b> returns a vector of n random real numbers from a uniform distribution. </p>
<p> 
 Download DLARUV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlaruv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlaruv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaruv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARUV returns a vector of n random real numbers from a uniform (0,1)
 distribution (n &lt;= 128).

 This is an auxiliary routine called by DLARNV and ZLARNV.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of random numbers to be generated. N &lt;= 128.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (N)
          The generated random numbers.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  This routine uses a multiplicative congruential method with modulus
  2**48 and multiplier 33952834046453 (see G.S.Fishman,
  'Multiplicative congruential random number generators with modulus
  2**b: an exhaustive analysis for b = 32 and a partial analysis for
  b = 48', Math. Comp. 189, pp 331-344, 1990).

  48-bit integers are stored in 4 integer array elements with 12 bits
  per element. Hence the routine is portable across machines with
  integers of 32 bits or more.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga307400bc17cbe31b5b8827a2802efae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlas2 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SSMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SSMAX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAS2</b> computes singular values of a 2-by-2 triangular matrix. </p>
<p> 
 Download DLAS2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlas2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlas2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlas2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAS2  computes the singular values of the 2-by-2 matrix
    [  F   G  ]
    [  0   H  ].
 On return, SSMIN is the smaller singular value and SSMAX is the
 larger singular value.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is DOUBLE PRECISION
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is DOUBLE PRECISION
          The (1,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMIN</td><td><pre class="fragment">          SSMIN is DOUBLE PRECISION
          The smaller singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMAX</td><td><pre class="fragment">          SSMAX is DOUBLE PRECISION
          The larger singular value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  Barring over/underflow, all output quantities are correct to within
  a few units in the last place (ulps), even in the absence of a guard
  digit in addition/subtraction.

  In IEEE arithmetic, the code works correctly if one matrix element is
  infinite.

  Overflow will not occur unless the largest singular value itself
  overflows, or is within a few ulps of overflow. (On machines with
  partial overflow, like the Cray, overflow may occur if the largest
  singular value is within a factor of 2 of overflow.)

  Underflow is harmless if underflow is gradual. Otherwise, results
  may correspond to a matrix modified by perturbations of size near
  the underflow threshold.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bce4c35ec5a86ee0bfdd15c476d99c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlascl </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CFROM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CTO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASCL</b> multiplies a general rectangular matrix by a real scalar defined as cto/cfrom. </p>
<p> 
 Download DLASCL + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlascl.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlascl.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlascl.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASCL multiplies the M by N real matrix A by the real scalar
 CTO/CFROM.  This is done without over/underflow as long as the final
 result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
 A may be full, upper triangular, lower triangular, upper Hessenberg,
 or banded.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TYPE</td><td><pre class="fragment">          TYPE is CHARACTER*1
          TYPE indices the storage type of the input matrix.
          = 'G':  A is a full matrix.
          = 'L':  A is a lower triangular matrix.
          = 'U':  A is an upper triangular matrix.
          = 'H':  A is an upper Hessenberg matrix.
          = 'B':  A is a symmetric band matrix with lower bandwidth KL
                  and upper bandwidth KU and with the only the lower
                  half stored.
          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                  and upper bandwidth KU and with the only the upper
                  half stored.
          = 'Z':  A is a band matrix with lower bandwidth KL and upper
                  bandwidth KU. See DGBTRF for storage details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
          The lower bandwidth of A.  Referenced only if TYPE = 'B',
          'Q' or 'Z'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
          The upper bandwidth of A.  Referenced only if TYPE = 'B',
          'Q' or 'Z'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CFROM</td><td><pre class="fragment">          CFROM is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CTO</td><td><pre class="fragment">          CTO is DOUBLE PRECISION

          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
          without over/underflow if the final result CTO*A(I,J)/CFROM
          can be represented without over/underflow.  CFROM must be
          nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
          storage type.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          0  - successful exit
          &lt;0 - if INFO = -i, the i-th argument had an illegal value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gae17e31eb66deb0c5111275edbd302758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd0 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SMLSIZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD0</b> computes the singular values of a real upper bidiagonal n-by-m matrix B with diagonal d and off-diagonal e. Used by sbdsdc. </p>
<p> 
 Download DLASD0 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd0.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd0.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd0.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Using a divide and conquer approach, DLASD0 computes the singular
 value decomposition (SVD) of a real upper bidiagonal N-by-M
 matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
 The algorithm computes orthogonal matrices U and VT such that
 B = U * S * VT. The singular values S are overwritten on D.

 A related subroutine, DLASDA, computes only the singular values,
 and optionally, the singular vectors in compact form.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
         On entry, the row dimension of the upper bidiagonal matrix.
         This is also the dimension of the main diagonal array D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         Specifies the column dimension of the bidiagonal matrix.
         = 0: The bidiagonal matrix has column dimension M = N;
         = 1: The bidiagonal matrix has column dimension M = N+1;</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
         On entry D contains the main diagonal of the bidiagonal
         matrix.
         On exit D, if INFO = 0, contains its singular values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (M-1)
         Contains the subdiagonal entries of the bidiagonal matrix.
         On exit, E has been destroyed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension at least (LDQ, N)
         On exit, U contains the left singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         On entry, leading dimension of U.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension at least (LDVT, M)
         On exit, VT**T contains the right singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         On entry, leading dimension of VT.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SMLSIZ</td><td><pre class="fragment">          SMLSIZ is INTEGER
         On entry, maximum size of the subproblems at the
         bottom of the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER work array.
         Dimension must be at least (8 * N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION work array.
         Dimension must be at least (3 * M**2 + 2 * M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gae73e96812a1bfc42d43c9697971c82a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd1 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD1</b> computes the SVD of an upper bidiagonal matrix B of the specified size. Used by sbdsdc. </p>
<p> 
 Download DLASD1 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd1.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd1.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd1.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
 where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.

 A related subroutine DLASD7 handles the case in which the singular
 values (and the singular vectors in factored form) are desired.

 DLASD1 computes the SVD as follows:

               ( D1(in)    0    0       0 )
   B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
               (   0       0   D2(in)   0 )

     = U(out) * ( D(out) 0) * VT(out)

 where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
 with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
 elsewhere; and the entry b is empty if SQRE = 0.

 The left singular vectors of the original matrix are stored in U, and
 the transpose of the right singular vectors are stored in VT, and the
 singular values are in D.  The algorithm consists of three stages:

    The first stage consists of deflating the size of the problem
    when there are multiple singular values or when there are zeros in
    the Z vector.  For each such occurence the dimension of the
    secular equation problem is reduced by one.  This stage is
    performed by the routine DLASD2.

    The second stage consists of calculating the updated
    singular values. This is done by finding the square roots of the
    roots of the secular equation via the routine DLASD4 (as called
    by DLASD3). This routine also calculates the singular vectors of
    the current problem.

    The final stage consists of computing the updated singular vectors
    directly using the updated singular values.  The singular vectors
    for the current problem are multiplied with the singular vectors
    from the overall problem.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has row dimension N = NL + NR + 1,
         and column dimension M = N + SQRE.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array,
                        dimension (N = NL+NR+1).
         On entry D(1:NL,1:NL) contains the singular values of the
         upper block; and D(NL+2:N) contains the singular values of
         the lower block. On exit D(1:N) contains the singular values
         of the modified matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is DOUBLE PRECISION
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension(LDU,N)
         On entry U(1:NL, 1:NL) contains the left singular vectors of
         the upper block; U(NL+2:N, NL+2:N) contains the left singular
         vectors of the lower block. On exit U contains the left
         singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         The leading dimension of the array U.  LDU &gt;= max( 1, N ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension(LDVT,M)
         where M = N + SQRE.
         On entry VT(1:NL+1, 1:NL+1)**T contains the right singular
         vectors of the upper block; VT(NL+2:M, NL+2:M)**T contains
         the right singular vectors of the lower block. On exit
         VT**T contains the right singular vectors of the
         bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         The leading dimension of the array VT.  LDVT &gt;= max( 1, M ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array, dimension(N)
         This contains the permutation which will reintegrate the
         subproblem just solved back into sorted order, i.e.
         D( IDXQ( I = 1, N ) ) will be in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension( 4 * N )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension( 3*M**2 + 2*M )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga32db876aadda88c12c75db105fe4f21c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd2 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu2, * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt2, * )&#160;</td>
          <td class="paramname"><em>VT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>COLTYP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD2</b> merges the two sets of singular values together into a single sorted set. Used by sbdsdc. </p>
<p> 
 Download DLASD2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASD2 merges the two sets of singular values together into a single
 sorted set.  Then it tries to deflate the size of the problem.
 There are two ways in which deflation can occur:  when two or more
 singular values are close together or if there is a tiny entry in the
 Z vector.  For each such occurrence the order of the related secular
 equation problem is reduced by one.

 DLASD2 is called from DLASD1.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has N = NL + NR + 1 rows and
         M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         Contains the dimension of the non-deflated matrix,
         This is the order of the related secular equation. 1 &lt;= K &lt;=N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension(N)
         On entry D contains the singular values of the two submatrices
         to be combined.  On exit D contains the trailing (N-K) updated
         singular values (those which were deflated) sorted into
         increasing order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension(N)
         On exit Z contains the updating row vector in the secular
         equation.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is DOUBLE PRECISION
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension(LDU,N)
         On entry U contains the left singular vectors of two
         submatrices in the two square blocks with corners at (1,1),
         (NL, NL), and (NL+2, NL+2), (N,N).
         On exit U contains the trailing (N-K) updated left singular
         vectors (those which were deflated) in its last N-K columns.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         The leading dimension of the array U.  LDU &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension(LDVT,M)
         On entry VT**T contains the right singular vectors of two
         submatrices in the two square blocks with corners at (1,1),
         (NL+1, NL+1), and (NL+2, NL+2), (M,M).
         On exit VT**T contains the trailing (N-K) updated right singular
         vectors (those which were deflated) in its last N-K columns.
         In case SQRE =1, the last row of VT spans the right null
         space.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         The leading dimension of the array VT.  LDVT &gt;= M.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is DOUBLE PRECISION array, dimension (N)
         Contains a copy of the diagonal elements (K-1 singular values
         and one zero) in the secular equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is DOUBLE PRECISION array, dimension(LDU2,N)
         Contains a copy of the first K-1 left singular vectors which
         will be used by DLASD3 in a matrix multiply (DGEMM) to solve
         for the new left singular vectors. U2 is arranged into four
         blocks. The first block contains a column with 1 at NL+1 and
         zero everywhere else; the second block contains non-zero
         entries only at and above NL; the third contains non-zero
         entries only below NL+1; and the fourth is dense.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU2</td><td><pre class="fragment">          LDU2 is INTEGER
         The leading dimension of the array U2.  LDU2 &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT2</td><td><pre class="fragment">          VT2 is DOUBLE PRECISION array, dimension(LDVT2,N)
         VT2**T contains a copy of the first K right singular vectors
         which will be used by DLASD3 in a matrix multiply (DGEMM) to
         solve for the new right singular vectors. VT2 is arranged into
         three blocks. The first block contains a row that corresponds
         to the special 0 diagonal element in SIGMA; the second block
         contains non-zeros only at and before NL +1; the third block
         contains non-zeros only at and after  NL +2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT2</td><td><pre class="fragment">          LDVT2 is INTEGER
         The leading dimension of the array VT2.  LDVT2 &gt;= M.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXP</td><td><pre class="fragment">          IDXP is INTEGER array dimension(N)
         This will contain the permutation used to place deflated
         values of D at the end of the array. On output IDXP(2:K)
         points to the nondeflated D-values and IDXP(K+1:N)
         points to the deflated singular values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDX</td><td><pre class="fragment">          IDX is INTEGER array dimension(N)
         This will contain the permutation used to sort the contents of
         D into ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXC</td><td><pre class="fragment">          IDXC is INTEGER array dimension(N)
         This will contain the permutation used to arrange the columns
         of the deflated U matrix into three groups:  the first group
         contains non-zero entries only at and above NL, the second
         contains non-zero entries only below NL+2, and the third is
         dense.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array dimension(N)
         This contains the permutation which separately sorts the two
         sub-problems in D into ascending order.  Note that entries in
         the first hlaf of this permutation must first be moved one
         position backward; and entries in the second half
         must first have NL+1 added to their values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">COLTYP</td><td><pre class="fragment">          COLTYP is INTEGER array dimension(N)
         As workspace, this will contain a label which will indicate
         which of the following types a column in the U2 matrix or a
         row in the VT2 matrix is:
         1 : non-zero in the upper half only
         2 : non-zero in the lower half only
         3 : dense
         4 : deflated

         On exit, it is an array of dimension 4, with COLTYP(I) being
         the dimension of the I-th type columns.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga791d0eee86fc85a3e132e613c55d1d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd3 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu2, * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt2, * )&#160;</td>
          <td class="paramname"><em>VT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>CTOT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD3</b> finds all square roots of the roots of the secular equation, as defined by the values in D and Z, and then updates the singular vectors by matrix multiplication. Used by sbdsdc. </p>
<p> 
 Download DLASD3 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd3.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd3.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd3.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASD3 finds all the square roots of the roots of the secular
 equation, as defined by the values in D and Z.  It makes the
 appropriate calls to DLASD4 and then updates the singular
 vectors by matrix multiplication.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 DLASD3 is called from DLASD1.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has N = NL + NR + 1 rows and
         M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         The size of the secular equation, 1 =&lt; K = &lt; N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension(K)
         On exit the square roots of the roots of the secular equation,
         in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array,
                     dimension at least (LDQ,K).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
         The leading dimension of the array Q.  LDQ &gt;= K.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is DOUBLE PRECISION array, dimension(K)
         The first K elements of this array contain the old roots
         of the deflated updating problem.  These are the poles
         of the secular equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
         The last N - K columns of this matrix contain the deflated
         left singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         The leading dimension of the array U.  LDU &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is DOUBLE PRECISION array, dimension (LDU2, N)
         The first K columns of this matrix contain the non-deflated
         left singular vectors for the split problem.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU2</td><td><pre class="fragment">          LDU2 is INTEGER
         The leading dimension of the array U2.  LDU2 &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension (LDVT, M)
         The last M - K columns of VT**T contain the deflated
         right singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         The leading dimension of the array VT.  LDVT &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT2</td><td><pre class="fragment">          VT2 is DOUBLE PRECISION array, dimension (LDVT2, N)
         The first K columns of VT2**T contain the non-deflated
         right singular vectors for the split problem.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT2</td><td><pre class="fragment">          LDVT2 is INTEGER
         The leading dimension of the array VT2.  LDVT2 &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDXC</td><td><pre class="fragment">          IDXC is INTEGER array, dimension ( N )
         The permutation used to arrange the columns of U (and rows of
         VT) into three groups:  the first group contains non-zero
         entries only at and above (or before) NL +1; the second
         contains non-zero entries only at and below (or after) NL+2;
         and the third is dense. The first column of U and the row of
         VT are treated separately, however.

         The rows of the singular vectors found by DLASD4
         must be likewise permuted before the matrix multiplies can
         take place.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CTOT</td><td><pre class="fragment">          CTOT is INTEGER array, dimension ( 4 )
         A count of the total number of the various types of columns
         in U (or rows in VT), as described in IDXC. The fourth column
         type is any column which has been deflated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension (K)
         The first K elements of this array contain the components
         of the deflation-adjusted updating row vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
         = 0:  successful exit.
         &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
         &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0ba74a3731059f524f3bdb703fd6fb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd4 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DELTA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RHO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD4</b> computes the square root of the i-th updated eigenvalue of a positive symmetric rank-one modification to a positive diagonal matrix. Used by dbdsdc. </p>
<p> 
 Download DLASD4 + dependencies
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd4.f">
 [TGZ]</a>
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd4.f">
 [ZIP]</a>
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd4.f">
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This subroutine computes the square root of the I-th updated
 eigenvalue of a positive symmetric rank-one modification to
 a positive diagonal matrix whose entries are given as the squares
 of the corresponding entries in the array d, and that

        0 &lt;= D(i) &lt; D(j)  for  i &lt; j

 and that RHO &gt; 0. This is arranged by the calling routine, and is
 no loss in generality.  The rank-one modified system is thus

        diag( D ) * diag( D ) +  RHO * Z * Z_transpose.

 where we assume the Euclidean norm of Z is 1.

 The method consists of approximating the rational functions in the
 secular equation by simpler interpolating rational functions.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
         The length of all arrays.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">          I is INTEGER
         The index of the eigenvalue to be computed.  1 &lt;= I &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension ( N )
         The original eigenvalues.  It is assumed that they are in
         order, 0 &lt;= D(I) &lt; D(J)  for I &lt; J.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension ( N )
         The components of the updating vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DELTA</td><td><pre class="fragment">          DELTA is DOUBLE PRECISION array, dimension ( N )
         If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
         component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
         contains the information necessary to construct the
         (singular) eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RHO</td><td><pre class="fragment">          RHO is DOUBLE PRECISION
         The scalar in the symmetric updating formula.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SIGMA</td><td><pre class="fragment">          SIGMA is DOUBLE PRECISION
         The computed sigma_I, the I-th updated eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension ( N )
         If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
         component.  If N = 1, then WORK( 1 ) = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
         = 0:  successful exit
         &gt; 0:  if INFO = 1, the updating process failed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Internal Parameters: </dt><dd><pre class="fragment">  Logical variable ORGATI (origin-at-i?) is used for distinguishing
  whether D(i) or D(i+1) is treated as the origin.

            ORGATI = .true.    origin at i
            ORGATI = .false.   origin at i+1

  Logical variable SWTCH3 (switch-for-3-poles?) is for noting
  if we are working with THREE poles!

  MAXIT is the maximum number of iterations allowed for each
  eigenvalue.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gac354f735ef3e53f9ca32242d2db96f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd5 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>DELTA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RHO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>WORK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD5</b> computes the square root of the i-th eigenvalue of a positive symmetric rank-one modification of a 2-by-2 diagonal matrix. Used by sbdsdc. </p>
<p> 
 Download DLASD5 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd5.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd5.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd5.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This subroutine computes the square root of the I-th eigenvalue
 of a positive symmetric rank-one modification of a 2-by-2 diagonal
 matrix

            diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .

 The diagonal entries in the array D are assumed to satisfy

            0 &lt;= D(i) &lt; D(j)  for  i &lt; j .

 We also assume RHO &gt; 0 and that the Euclidean norm of the vector
 Z is one.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">          I is INTEGER
         The index of the eigenvalue to be computed.  I = 1 or I = 2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension ( 2 )
         The original eigenvalues.  We assume 0 &lt;= D(1) &lt; D(2).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension ( 2 )
         The components of the updating vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DELTA</td><td><pre class="fragment">          DELTA is DOUBLE PRECISION array, dimension ( 2 )
         Contains (D(j) - sigma_I) in its  j-th component.
         The vector DELTA contains the information necessary
         to construct the eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RHO</td><td><pre class="fragment">          RHO is DOUBLE PRECISION
         The scalar in the symmetric updating formula.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is DOUBLE PRECISION
         The computed sigma_I, the I-th updated eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension ( 2 )
         WORK contains (D(j) + sigma_I) in its  j-th component.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e070b3e60c4a799927b934a17031fba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd6 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PERM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>GIVPTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>GIVCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldgnum, * )&#160;</td>
          <td class="paramname"><em>GIVNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldgnum, * )&#160;</td>
          <td class="paramname"><em>POLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD6</b> computes the SVD of an updated upper bidiagonal matrix obtained by merging two smaller ones by appending a row. Used by sbdsdc. </p>
<p> 
 Download DLASD6 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd6.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd6.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd6.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASD6 computes the SVD of an updated upper bidiagonal matrix B
 obtained by merging two smaller ones by appending a row. This
 routine is used only for the problem which requires all singular
 values and optionally singular vector matrices in factored form.
 B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
 A related subroutine, DLASD1, handles the case in which all singular
 values and singular vectors of the bidiagonal matrix are desired.

 DLASD6 computes the SVD as follows:

               ( D1(in)    0    0       0 )
   B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
               (   0       0   D2(in)   0 )

     = U(out) * ( D(out) 0) * VT(out)

 where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
 with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
 elsewhere; and the entry b is empty if SQRE = 0.

 The singular values of B can be computed using D1, D2, the first
 components of all the right singular vectors of the lower block, and
 the last components of all the right singular vectors of the upper
 block. These components are stored and updated in VF and VL,
 respectively, in DLASD6. Hence U and VT are not explicitly
 referenced.

 The singular values are stored in D. The algorithm consists of two
 stages:

       The first stage consists of deflating the size of the problem
       when there are multiple singular values or if there is a zero
       in the Z vector. For each such occurence the dimension of the
       secular equation problem is reduced by one. This stage is
       performed by the routine DLASD7.

       The second stage consists of calculating the updated
       singular values. This is done by finding the roots of the
       secular equation via the routine DLASD4 (as called by DLASD8).
       This routine also updates VF and VL and computes the distances
       between the updated singular values and the old singular
       values.

 DLASD6 is called from DLASDA.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
         Specifies whether singular vectors are to be computed in
         factored form:
         = 0: Compute singular values only.
         = 1: Compute singular vectors in factored form as well.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has row dimension N = NL + NR + 1,
         and column dimension M = N + SQRE.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension ( NL+NR+1 ).
         On entry D(1:NL,1:NL) contains the singular values of the
         upper block, and D(NL+2:N) contains the singular values
         of the lower block. On exit D(1:N) contains the singular
         values of the modified matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VF</td><td><pre class="fragment">          VF is DOUBLE PRECISION array, dimension ( M )
         On entry, VF(1:NL+1) contains the first components of all
         right singular vectors of the upper block; and VF(NL+2:M)
         contains the first components of all right singular vectors
         of the lower block. On exit, VF contains the first components
         of all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension ( M )
         On entry, VL(1:NL+1) contains the  last components of all
         right singular vectors of the upper block; and VL(NL+2:M)
         contains the last components of all right singular vectors of
         the lower block. On exit, VL contains the last components of
         all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is DOUBLE PRECISION
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array, dimension ( N )
         This contains the permutation which will reintegrate the
         subproblem just solved back into sorted order, i.e.
         D( IDXQ( I = 1, N ) ) will be in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PERM</td><td><pre class="fragment">          PERM is INTEGER array, dimension ( N )
         The permutations (from deflation and sorting) to be applied
         to each block. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVPTR</td><td><pre class="fragment">          GIVPTR is INTEGER
         The number of Givens rotations which took place in this
         subproblem. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVCOL</td><td><pre class="fragment">          GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
         Each pair of numbers indicates a pair of columns to take place
         in a Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGCOL</td><td><pre class="fragment">          LDGCOL is INTEGER
         leading dimension of GIVCOL, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVNUM</td><td><pre class="fragment">          GIVNUM is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
         Each number indicates the C or S value to be used in the
         corresponding Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGNUM</td><td><pre class="fragment">          LDGNUM is INTEGER
         The leading dimension of GIVNUM and POLES, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">POLES</td><td><pre class="fragment">          POLES is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
         On exit, POLES(1,*) is an array containing the new singular
         values obtained from solving the secular equation, and
         POLES(2,*) is an array containing the poles in the secular
         equation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFL</td><td><pre class="fragment">          DIFL is DOUBLE PRECISION array, dimension ( N )
         On exit, DIFL(I) is the distance between I-th updated
         (undeflated) singular value and the I-th (undeflated) old
         singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFR</td><td><pre class="fragment">          DIFR is DOUBLE PRECISION array,
                  dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
                  dimension ( N ) if ICOMPQ = 0.
         On exit, DIFR(I, 1) is the distance between I-th updated
         (undeflated) singular value and the I+1-th (undeflated) old
         singular value.

         If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
         normalizing factors for the right singular vector matrix.

         See DLASD8 for details on DIFL and DIFR.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension ( M )
         The first elements of this array contain the components
         of the deflation-adjusted updating row vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         Contains the dimension of the non-deflated matrix,
         This is the order of the related secular equation. 1 &lt;= K &lt;=N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION
         C contains garbage if SQRE =0 and the C-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION
         S contains garbage if SQRE =0 and the S-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension ( 4 * M )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension ( 3 * N )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ec18a9b77aca48cfc490ad5022eeafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd7 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ZW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VFW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VLW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PERM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>GIVPTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>GIVCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldgnum, * )&#160;</td>
          <td class="paramname"><em>GIVNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD7</b> merges the two sets of singular values together into a single sorted set. Then it tries to deflate the size of the problem. Used by sbdsdc. </p>
<p> 
 Download DLASD7 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd7.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd7.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd7.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASD7 merges the two sets of singular values together into a single
 sorted set. Then it tries to deflate the size of the problem. There
 are two ways in which deflation can occur:  when two or more singular
 values are close together or if there is a tiny entry in the Z
 vector. For each such occurrence the order of the related
 secular equation problem is reduced by one.

 DLASD7 is called from DLASD6.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
          Specifies whether singular vectors are to be computed
          in compact form, as follows:
          = 0: Compute singular values only.
          = 1: Compute singular vectors of upper
               bidiagonal matrix in compact form.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block. NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block. NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has
         N = NL + NR + 1 rows and
         M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         Contains the dimension of the non-deflated matrix, this is
         the order of the related secular equation. 1 &lt;= K &lt;=N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension ( N )
         On entry D contains the singular values of the two submatrices
         to be combined. On exit D contains the trailing (N-K) updated
         singular values (those which were deflated) sorted into
         increasing order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension ( M )
         On exit Z contains the updating row vector in the secular
         equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ZW</td><td><pre class="fragment">          ZW is DOUBLE PRECISION array, dimension ( M )
         Workspace for Z.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VF</td><td><pre class="fragment">          VF is DOUBLE PRECISION array, dimension ( M )
         On entry, VF(1:NL+1) contains the first components of all
         right singular vectors of the upper block; and VF(NL+2:M)
         contains the first components of all right singular vectors
         of the lower block. On exit, VF contains the first components
         of all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VFW</td><td><pre class="fragment">          VFW is DOUBLE PRECISION array, dimension ( M )
         Workspace for VF.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension ( M )
         On entry, VL(1:NL+1) contains the  last components of all
         right singular vectors of the upper block; and VL(NL+2:M)
         contains the last components of all right singular vectors
         of the lower block. On exit, VL contains the last components
         of all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VLW</td><td><pre class="fragment">          VLW is DOUBLE PRECISION array, dimension ( M )
         Workspace for VL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is DOUBLE PRECISION
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is DOUBLE PRECISION array, dimension ( N )
         Contains a copy of the diagonal elements (K-1 singular values
         and one zero) in the secular equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDX</td><td><pre class="fragment">          IDX is INTEGER array, dimension ( N )
         This will contain the permutation used to sort the contents of
         D into ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXP</td><td><pre class="fragment">          IDXP is INTEGER array, dimension ( N )
         This will contain the permutation used to place deflated
         values of D at the end of the array. On output IDXP(2:K)
         points to the nondeflated D-values and IDXP(K+1:N)
         points to the deflated singular values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array, dimension ( N )
         This contains the permutation which separately sorts the two
         sub-problems in D into ascending order.  Note that entries in
         the first half of this permutation must first be moved one
         position backward; and entries in the second half
         must first have NL+1 added to their values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PERM</td><td><pre class="fragment">          PERM is INTEGER array, dimension ( N )
         The permutations (from deflation and sorting) to be applied
         to each singular block. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVPTR</td><td><pre class="fragment">          GIVPTR is INTEGER
         The number of Givens rotations which took place in this
         subproblem. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVCOL</td><td><pre class="fragment">          GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
         Each pair of numbers indicates a pair of columns to take place
         in a Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGCOL</td><td><pre class="fragment">          LDGCOL is INTEGER
         The leading dimension of GIVCOL, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVNUM</td><td><pre class="fragment">          GIVNUM is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
         Each number indicates the C or S value to be used in the
         corresponding Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGNUM</td><td><pre class="fragment">          LDGNUM is INTEGER
         The leading dimension of GIVNUM, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION
         C contains garbage if SQRE =0 and the C-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION
         S contains garbage if SQRE =0 and the S-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
         = 0:  successful exit.
         &lt; 0:  if INFO = -i, the i-th argument had an illegal value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gab80712d01afa9bb687bf87f10d0d2147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasd8 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lddifr, * )&#160;</td>
          <td class="paramname"><em>DIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDDIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASD8</b> finds the square roots of the roots of the secular equation, and stores, for each element in D, the distance to its two nearest poles. Used by sbdsdc. </p>
<p> 
 Download DLASD8 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasd8.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasd8.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasd8.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASD8 finds the square roots of the roots of the secular equation,
 as defined by the values in DSIGMA and Z. It makes the appropriate
 calls to DLASD4, and stores, for each  element in D, the distance
 to its two nearest poles (elements in DSIGMA). It also updates
 the arrays VF and VL, the first and last components of all the
 right singular vectors of the original bidiagonal matrix.

 DLASD8 is called from DLASD6.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
          Specifies whether singular vectors are to be computed in
          factored form in the calling routine:
          = 0: Compute singular values only.
          = 1: Compute singular vectors in factored form as well.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
          The number of terms in the rational function to be solved
          by DLASD4.  K &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension ( K )
          On output, D contains the updated singular values.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension ( K )
          On entry, the first K elements of this array contain the
          components of the deflation-adjusted updating row vector.
          On exit, Z is updated.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VF</td><td><pre class="fragment">          VF is DOUBLE PRECISION array, dimension ( K )
          On entry, VF contains  information passed through DBEDE8.
          On exit, VF contains the first K components of the first
          components of all right singular vectors of the bidiagonal
          matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension ( K )
          On entry, VL contains  information passed through DBEDE8.
          On exit, VL contains the first K components of the last
          components of all right singular vectors of the bidiagonal
          matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFL</td><td><pre class="fragment">          DIFL is DOUBLE PRECISION array, dimension ( K )
          On exit, DIFL(I) = D(I) - DSIGMA(I).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFR</td><td><pre class="fragment">          DIFR is DOUBLE PRECISION array,
                   dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
                   dimension ( K ) if ICOMPQ = 0.
          On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
          defined and will not be referenced.

          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
          normalizing factors for the right singular vector matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDIFR</td><td><pre class="fragment">          LDDIFR is INTEGER
          The leading dimension of DIFR, must be at least K.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is DOUBLE PRECISION array, dimension ( K )
          On entry, the first K elements of this array contain the old
          roots of the deflated updating problem.  These are the poles
          of the secular equation.
          On exit, the elements of DSIGMA may be very slightly altered
          in value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension at least 3 * K</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8abcba620b2d5a1321889fd86cb3f12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasda </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SMLSIZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>DIFL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>DIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>POLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>GIVPTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>GIVCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>PERM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>GIVNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASDA</b> computes the singular value decomposition (SVD) of a real upper bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc. </p>
<p> 
 Download DLASDA + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasda.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasda.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasda.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Using a divide and conquer approach, DLASDA computes the singular
 value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
 B with diagonal D and offdiagonal E, where M = N + SQRE. The
 algorithm computes the singular values in the SVD B = U * S * VT.
 The orthogonal matrices U and VT are optionally computed in
 compact form.

 A related subroutine, DLASD0, computes the singular values and
 the singular vectors in explicit form.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
         Specifies whether singular vectors are to be computed
         in compact form, as follows
         = 0: Compute singular values only.
         = 1: Compute singular vectors of upper bidiagonal
              matrix in compact form.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SMLSIZ</td><td><pre class="fragment">          SMLSIZ is INTEGER
         The maximum size of the subproblems at the bottom of the
         computation tree.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
         The row dimension of the upper bidiagonal matrix. This is
         also the dimension of the main diagonal array D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         Specifies the column dimension of the bidiagonal matrix.
         = 0: The bidiagonal matrix has column dimension M = N;
         = 1: The bidiagonal matrix has column dimension M = N + 1.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension ( N )
         On entry D contains the main diagonal of the bidiagonal
         matrix. On exit D, if INFO = 0, contains its singular values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension ( M-1 )
         Contains the subdiagonal entries of the bidiagonal matrix.
         On exit, E has been destroyed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array,
         dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
         singular vector matrices of all subproblems at the bottom
         level.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER, LDU = &gt; N.
         The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
         GIVNUM, and Z.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array,
         dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT**T contains the right
         singular vector matrices of all subproblems at the bottom
         level.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER array,
         dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
         If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
         secular equation on the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFL</td><td><pre class="fragment">          DIFL is DOUBLE PRECISION array, dimension ( LDU, NLVL ),
         where NLVL = floor(log_2 (N/SMLSIZ))).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFR</td><td><pre class="fragment">          DIFR is DOUBLE PRECISION array,
                  dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
                  dimension ( N ) if ICOMPQ = 0.
         If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
         record distances between singular values on the I-th
         level and singular values on the (I -1)-th level, and
         DIFR(1:N, 2 * I ) contains the normalizing factors for
         the right singular vector matrix. See DLASD8 for details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array,
                  dimension ( LDU, NLVL ) if ICOMPQ = 1 and
                  dimension ( N ) if ICOMPQ = 0.
         The first K elements of Z(1, I) contain the components of
         the deflation-adjusted updating row vector for subproblems
         on the I-th level.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">POLES</td><td><pre class="fragment">          POLES is DOUBLE PRECISION array,
         dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
         POLES(1, 2*I) contain  the new and old singular values
         involved in the secular equations on the I-th level.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVPTR</td><td><pre class="fragment">          GIVPTR is INTEGER array,
         dimension ( N ) if ICOMPQ = 1, and not referenced if
         ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
         the number of Givens rotations performed on the I-th
         problem on the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVCOL</td><td><pre class="fragment">          GIVCOL is INTEGER array,
         dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
         GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
         of Givens rotations performed on the I-th level on the
         computation tree.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGCOL</td><td><pre class="fragment">          LDGCOL is INTEGER, LDGCOL = &gt; N.
         The leading dimension of arrays GIVCOL and PERM.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PERM</td><td><pre class="fragment">          PERM is INTEGER array,
         dimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
         permutations done on the I-th level of the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVNUM</td><td><pre class="fragment">          GIVNUM is DOUBLE PRECISION array,
         dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
         GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
         values of Givens rotations performed on the I-th level on
         the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array,
         dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
         If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
         C( I ) contains the C-value of a Givens rotation related to
         the right null space of the I-th subproblem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension ( N ) if
         ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
         and the I-th subproblem is not square, on exit, S( I )
         contains the S-value of a Givens rotation related to
         the right null space of the I-th subproblem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension
         (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array.
         Dimension must be at least (7 * N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gafc8e49b5fff31027da26e1856f8a9b25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasdq </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NCVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NCC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASDQ</b> computes the SVD of a real bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc. </p>
<p> 
 Download DLASDQ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasdq.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasdq.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasdq.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASDQ computes the singular value decomposition (SVD) of a real
 (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
 E, accumulating the transformations if desired. Letting B denote
 the input bidiagonal matrix, the algorithm computes orthogonal
 matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
 of P). The singular values S are overwritten on D.

 The input matrix U  is changed to U  * Q  if desired.
 The input matrix VT is changed to P**T * VT if desired.
 The input matrix C  is changed to Q**T * C  if desired.

 See "Computing  Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3, for a detailed description of the algorithm.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
        On entry, UPLO specifies whether the input bidiagonal matrix
        is upper or lower bidiagonal, and wether it is square are
        not.
           UPLO = 'U' or 'u'   B is upper bidiagonal.
           UPLO = 'L' or 'l'   B is lower bidiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
        = 0: then the input matrix is N-by-N.
        = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
             (N+1)-by-N if UPLU = 'L'.

        The bidiagonal matrix has
        N = NL + NR + 1 rows and
        M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
        On entry, N specifies the number of rows and columns
        in the matrix. N must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NCVT</td><td><pre class="fragment">          NCVT is INTEGER
        On entry, NCVT specifies the number of columns of
        the matrix VT. NCVT must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRU</td><td><pre class="fragment">          NRU is INTEGER
        On entry, NRU specifies the number of rows of
        the matrix U. NRU must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NCC</td><td><pre class="fragment">          NCC is INTEGER
        On entry, NCC specifies the number of columns of
        the matrix C. NCC must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
        On entry, D contains the diagonal entries of the
        bidiagonal matrix whose SVD is desired. On normal exit,
        D contains the singular values in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array.
        dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
        On entry, the entries of E contain the offdiagonal entries
        of the bidiagonal matrix whose SVD is desired. On normal
        exit, E will contain 0. If the algorithm does not converge,
        D and E will contain the diagonal and superdiagonal entries
        of a bidiagonal matrix orthogonally equivalent to the one
        given as input.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension (LDVT, NCVT)
        On entry, contains a matrix which on exit has been
        premultiplied by P**T, dimension N-by-NCVT if SQRE = 0
        and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
        On entry, LDVT specifies the leading dimension of VT as
        declared in the calling (sub) program. LDVT must be at
        least 1. If NCVT is nonzero LDVT must also be at least N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
        On entry, contains a  matrix which on exit has been
        postmultiplied by Q, dimension NRU-by-N if SQRE = 0
        and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
        On entry, LDU  specifies the leading dimension of U as
        declared in the calling (sub) program. LDU must be at
        least max( 1, NRU ) .</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension (LDC, NCC)
        On entry, contains an N-by-NCC matrix which on exit
        has been premultiplied by Q**T  dimension N-by-NCC if SQRE = 0
        and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
        On entry, LDC  specifies the leading dimension of C as
        declared in the calling (sub) program. LDC must be at
        least 1. If NCC is nonzero, LDC must also be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (4*N)
        Workspace. Only referenced if one of NCVT, NRU, or NCC is
        nonzero, and if N is at least 2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
        On exit, a value of 0 indicates a successful exit.
        If INFO &lt; 0, argument number -INFO is illegal.
        If INFO &gt; 0, the algorithm did not converge, and INFO
        specifies how many superdiagonals did not converge.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gab7d5a1edccc56fb53970dd9607fcd5ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasdt </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>INODE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NDIML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NDIMR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MSUB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASDT</b> creates a tree of subproblems for bidiagonal divide and conquer. Used by sbdsdc. </p>
<p> 
 Download DLASDT + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasdt.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasdt.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasdt.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASDT creates a tree of subproblems for bidiagonal divide and
 conquer.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          On entry, the number of diagonal elements of the
          bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LVL</td><td><pre class="fragment">          LVL is INTEGER
          On exit, the number of levels on the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ND</td><td><pre class="fragment">          ND is INTEGER
          On exit, the number of nodes on the tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INODE</td><td><pre class="fragment">          INODE is INTEGER array, dimension ( N )
          On exit, centers of subproblems.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NDIML</td><td><pre class="fragment">          NDIML is INTEGER array, dimension ( N )
          On exit, row dimensions of left children.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NDIMR</td><td><pre class="fragment">          NDIMR is INTEGER array, dimension ( N )
          On exit, row dimensions of right children.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSUB</td><td><pre class="fragment">          MSUB is INTEGER
          On entry, the maximum row dimension each subproblem at the
          bottom of the tree can be of.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga89e332374c7cd87e5db54bfe21550bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlaset </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASET</b> initializes the off-diagonal elements and the diagonal elements of a matrix to given values. </p>
<p> 
 Download DLASET + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlaset.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlaset.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlaset.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASET initializes an m-by-n matrix A to BETA on the diagonal and
 ALPHA on the offdiagonals.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies the part of the matrix A to be set.
          = 'U':      Upper triangular part is set; the strictly lower
                      triangular part of A is not changed.
          = 'L':      Lower triangular part is set; the strictly upper
                      triangular part of A is not changed.
          Otherwise:  All of the matrix A is set.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is DOUBLE PRECISION
          The constant to which the offdiagonal elements are to be set.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION
          The constant to which the diagonal elements are to be set.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          On exit, the leading m-by-n submatrix of A is set as follows:

          if UPLO = 'U', A(i,j) = ALPHA, 1&lt;=i&lt;=j-1, 1&lt;=j&lt;=n,
          if UPLO = 'L', A(i,j) = ALPHA, j+1&lt;=i&lt;=m, 1&lt;=j&lt;=n,
          otherwise,     A(i,j) = ALPHA, 1&lt;=i&lt;=m, 1&lt;=j&lt;=n, i.ne.j,

          and, for all UPLO, A(i,i) = BETA, 1&lt;=i&lt;=min(m,n).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0a984d2062d62286a7a78ed3ba06fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasr </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SIDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>PIVOT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DIRECT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASR</b> applies a sequence of plane rotations to a general rectangular matrix. </p>
<p> 
 Download DLASR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASR applies a sequence of plane rotations to a real matrix A,
 from either the left or the right.
 
 When SIDE = 'L', the transformation takes the form
 
    A := P*A
 
 and when SIDE = 'R', the transformation takes the form
 
    A := A*P**T
 
 where P is an orthogonal matrix consisting of a sequence of z plane
 rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
 and P**T is the transpose of P.
 
 When DIRECT = 'F' (Forward sequence), then
 
    P = P(z-1) * ... * P(2) * P(1)
 
 and when DIRECT = 'B' (Backward sequence), then
 
    P = P(1) * P(2) * ... * P(z-1)
 
 where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
 
    R(k) = (  c(k)  s(k) )
         = ( -s(k)  c(k) ).
 
 When PIVOT = 'V' (Variable pivot), the rotation is performed
 for the plane (k,k+1), i.e., P(k) has the form
 
    P(k) = (  1                                            )
           (       ...                                     )
           (              1                                )
           (                   c(k)  s(k)                  )
           (                  -s(k)  c(k)                  )
           (                                1              )
           (                                     ...       )
           (                                            1  )
 
 where R(k) appears as a rank-2 modification to the identity matrix in
 rows and columns k and k+1.
 
 When PIVOT = 'T' (Top pivot), the rotation is performed for the
 plane (1,k+1), so P(k) has the form
 
    P(k) = (  c(k)                    s(k)                 )
           (         1                                     )
           (              ...                              )
           (                     1                         )
           ( -s(k)                    c(k)                 )
           (                                 1             )
           (                                      ...      )
           (                                             1 )
 
 where R(k) appears in rows and columns 1 and k+1.
 
 Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
 performed for the plane (k,z), giving P(k) the form
 
    P(k) = ( 1                                             )
           (      ...                                      )
           (             1                                 )
           (                  c(k)                    s(k) )
           (                         1                     )
           (                              ...              )
           (                                     1         )
           (                 -s(k)                    c(k) )
 
 where R(k) appears in rows and columns k and z.  The rotations are
 performed without ever forming P(k) explicitly.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SIDE</td><td><pre class="fragment">          SIDE is CHARACTER*1
          Specifies whether the plane rotation matrix P is applied to
          A on the left or the right.
          = 'L':  Left, compute A := P*A
          = 'R':  Right, compute A:= A*P**T</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVOT</td><td><pre class="fragment">          PIVOT is CHARACTER*1
          Specifies the plane for which P(k) is a plane rotation
          matrix.
          = 'V':  Variable pivot, the plane (k,k+1)
          = 'T':  Top pivot, the plane (1,k+1)
          = 'B':  Bottom pivot, the plane (k,z)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIRECT</td><td><pre class="fragment">          DIRECT is CHARACTER*1
          Specifies whether P is a forward or backward sequence of
          plane rotations.
          = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
          = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  If m &lt;= 1, an immediate
          return is effected.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  If n &lt;= 1, an
          immediate return is effected.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension
                  (M-1) if SIDE = 'L'
                  (N-1) if SIDE = 'R'
          The cosines c(k) of the plane rotations.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension
                  (M-1) if SIDE = 'L'
                  (N-1) if SIDE = 'R'
          The sines s(k) of the plane rotations.  The 2-by-2 plane
          rotation part of the matrix P(k), R(k), has the form
          R(k) = (  c(k)  s(k) )
                 ( -s(k)  c(k) ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The M-by-N matrix A.  On exit, A is overwritten by P*A if
          SIDE = 'R' or by A*P**T if SIDE = 'L'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9c824016058563e3b7189801d1de6d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlassq </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SUMSQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASSQ</b> updates a sum of squares represented in scaled form. </p>
<p> 
 Download DLASSQ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlassq.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlassq.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlassq.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASSQ  returns the values  scl  and  smsq  such that

    ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

 where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
 assumed to be non-negative and  scl  returns the value

    scl = max( scale, abs( x( i ) ) ).

 scale and sumsq must be supplied in SCALE and SUMSQ and
 scl and smsq are overwritten on SCALE and SUMSQ respectively.

 The routine makes only one pass through the vector x.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of elements to be used from the vector X.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (N)
          The vector for which a scaled sum of squares is computed.
             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 &lt;= i &lt;= n.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INCX</td><td><pre class="fragment">          INCX is INTEGER
          The increment between successive values of the vector X.
          INCX &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is DOUBLE PRECISION
          On entry, the value  scale  in the equation above.
          On exit, SCALE is overwritten with  scl , the scaling factor
          for the sum of squares.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SUMSQ</td><td><pre class="fragment">          SUMSQ is DOUBLE PRECISION
          On entry, the value  sumsq  in the equation above.
          On exit, SUMSQ is overwritten with  smsq , the basic sum of
          squares from which  scl  has been factored out.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gaee8e05a707783a9fba5d213093453543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasv2 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SSMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SSMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SNR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SNL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CSL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASV2</b> computes the singular value decomposition of a 2-by-2 triangular matrix. </p>
<p> 
 Download DLASV2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlasv2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlasv2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlasv2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASV2 computes the singular value decomposition of a 2-by-2
 triangular matrix
    [  F   G  ]
    [  0   H  ].
 On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
 smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
 right singular vectors for abs(SSMAX), giving the decomposition

    [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
    [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is DOUBLE PRECISION
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is DOUBLE PRECISION
          The (1,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMIN</td><td><pre class="fragment">          SSMIN is DOUBLE PRECISION
          abs(SSMIN) is the smaller singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMAX</td><td><pre class="fragment">          SSMAX is DOUBLE PRECISION
          abs(SSMAX) is the larger singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SNL</td><td><pre class="fragment">          SNL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CSL</td><td><pre class="fragment">          CSL is DOUBLE PRECISION
          The vector (CSL, SNL) is a unit left singular vector for the
          singular value abs(SSMAX).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SNR</td><td><pre class="fragment">          SNR is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CSR</td><td><pre class="fragment">          CSR is DOUBLE PRECISION
          The vector (CSR, SNR) is a unit right singular vector for the
          singular value abs(SSMAX).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  Any input parameter may be aliased with any output parameter.

  Barring over/underflow and assuming a guard digit in subtraction, all
  output quantities are correct to within a few units in the last
  place (ulps).

  In IEEE arithmetic, the code works correctly if one matrix element is
  infinite.

  Overflow will not occur unless the largest singular value itself
  overflows or is within a few ulps of overflow. (On machines with
  partial overflow, like the Cray, overflow may occur if the largest
  singular value is within a factor of 2 of overflow.)

  Underflow is harmless if underflow is gradual. Otherwise, results
  may correspond to a matrix modified by perturbations of size near
  the underflow threshold.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gafe21a6b76340ac0afd7f0f84326e7918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dsecnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSECND</b> Using ETIME </p>
<p><b>DSECND</b> returns nothing</p>
<p><b>DSECND</b> Using the INTERNAL function ETIME.</p>
<p><b>DSECND</b> Using INTERNAL function CPU_TIME.</p>
<p><b>DSECND</b> Using ETIME_</p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  DSECND returns the user time for a process in seconds.
  This version gets the time from the EXTERNAL system function ETIME.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  DSECND returns the user time for a process in seconds.
  This version gets the time from the system function ETIME_.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  DSECND returns the user time for a process in seconds.
  This version gets the time from the INTERNAL function CPU_TIME.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  DSECND returns the user time for a process in seconds.
  This version gets the time from the INTERNAL function ETIME.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  DSECND returns nothing instead of returning the user time for a process in seconds.
  If you are using that routine, it means that neither EXTERNAL ETIME,
  EXTERNAL ETIME_, INTERNAL ETIME, INTERNAL CPU_TIME is available  on
  your machine.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga97715c995b884378afbbff7915d884c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> ieeeck </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ISPEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ZERO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ONE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>IEEECK</b> </p>
<p> 
 Download IEEECK + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ieeeck.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ieeeck.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ieeeck.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> IEEECK is called from the ILAENV to verify that Infinity and
 possibly NaN arithmetic is safe (i.e. will not trap).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ISPEC</td><td><pre class="fragment">          ISPEC is INTEGER
          Specifies whether to test just for inifinity arithmetic
          or whether to test for infinity and NaN arithmetic.
          = 0: Verify infinity arithmetic only.
          = 1: Verify infinity and NaN arithmetic.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZERO</td><td><pre class="fragment">          ZERO is REAL
          Must contain the value 0.0
          This is passed to prevent the compiler from optimizing
          away this code.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ONE</td><td><pre class="fragment">          ONE is REAL
          Must contain the value 1.0
          This is passed to prevent the compiler from optimizing
          away this code.

  RETURN VALUE:  INTEGER
          = 0:  Arithmetic failed to produce the correct answers
          = 1:  Arithmetic produced the correct answers</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab8b3783390380038c9d26de61d7aefb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> iladlc </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ILADLC</b> scans a matrix for its last non-zero column. </p>
<p> 
 Download ILADLC + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/iladlc.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/iladlc.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/iladlc.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> ILADLC scans A for its last non-zero column.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The m by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A. LDA &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gac0eeaff271e43cd10d066ef1cceb5f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> iladlr </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ILADLR</b> scans a matrix for its last non-zero row. </p>
<p> 
 Download ILADLR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/iladlr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/iladlr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/iladlr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> ILADLR scans A for its last non-zero row.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The m by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A. LDA &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gab1f37bde76d31aee91a09bb2f8e87ce6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> ilaenv </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ISPEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character*( * )&#160;</td>
          <td class="paramname"><em>NAME</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character*( * )&#160;</td>
          <td class="paramname"><em>OPTS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ILAENV</b> </p>
<p> 
 Download ILAENV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ilaenv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ilaenv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaenv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> ILAENV is called from the LAPACK routines to choose problem-dependent
 parameters for the local environment.  See ISPEC for a description of
 the parameters.

 ILAENV returns an INTEGER
 if ILAENV &gt;= 0: ILAENV returns the value of the parameter specified by ISPEC
 if ILAENV &lt; 0:  if ILAENV = -k, the k-th argument had an illegal value.

 This version provides a set of parameters which should give good,
 but not optimal, performance on many of the currently available
 computers.  Users are encouraged to modify this subroutine to set
 the tuning parameters for their particular machine using the option
 and problem size information in the arguments.

 This routine will not function correctly if it is converted to all
 lower case.  Converting it to all upper case is allowed.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ISPEC</td><td><pre class="fragment">          ISPEC is INTEGER
          Specifies the parameter to be returned as the value of
          ILAENV.
          = 1: the optimal blocksize; if this value is 1, an unblocked
               algorithm will give the best performance.
          = 2: the minimum block size for which the block routine
               should be used; if the usable block size is less than
               this value, an unblocked routine should be used.
          = 3: the crossover point (in a block routine, for N less
               than this value, an unblocked routine should be used)
          = 4: the number of shifts, used in the nonsymmetric
               eigenvalue routines (DEPRECATED)
          = 5: the minimum column dimension for blocking to be used;
               rectangular blocks must have dimension at least k by m,
               where k is given by ILAENV(2,...) and m by ILAENV(5,...)
          = 6: the crossover point for the SVD (when reducing an m by n
               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
               this value, a QR factorization is used first to reduce
               the matrix to a triangular form.)
          = 7: the number of processors
          = 8: the crossover point for the multishift QR method
               for nonsymmetric eigenvalue problems (DEPRECATED)
          = 9: maximum size of the subproblems at the bottom of the
               computation tree in the divide-and-conquer algorithm
               (used by xGELSD and xGESDD)
          =10: ieee NaN arithmetic can be trusted not to trap
          =11: infinity arithmetic can be trusted not to trap
          12 &lt;= ISPEC &lt;= 16:
               xHSEQR or one of its subroutines,
               see IPARMQ for detailed explanation</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NAME</td><td><pre class="fragment">          NAME is CHARACTER*(*)
          The name of the calling subroutine, in either upper case or
          lower case.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OPTS</td><td><pre class="fragment">          OPTS is CHARACTER*(*)
          The character options to the subroutine NAME, concatenated
          into a single character string.  For example, UPLO = 'U',
          TRANS = 'T', and DIAG = 'N' for a triangular routine would
          be specified as OPTS = 'UTN'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N1</td><td><pre class="fragment">          N1 is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N2</td><td><pre class="fragment">          N2 is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N3</td><td><pre class="fragment">          N3 is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N4</td><td><pre class="fragment">          N4 is INTEGER
          Problem dimensions for the subroutine NAME; these may not all
          be required.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  The following conventions have been used when calling ILAENV from the
  LAPACK routines:
  1)  OPTS is a concatenation of all of the character options to
      subroutine NAME, in the same order that they appear in the
      argument list for NAME, even if they are not used in determining
      the value of the parameter specified by ISPEC.
  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
      that they appear in the argument list for NAME.  N1 is used
      first, N2 second, and so on, and unused problem dimensions are
      passed a value of -1.
  3)  The parameter value returned by ILAENV is checked for validity in
      the calling subroutine.  For example, ILAENV is used to retrieve
      the optimal blocksize for STRTRI as follows:

      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
      IF( NB.LE.1 ) NB = MAX( 1, N )</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gace0eea943fa875e927d0b8b6614c9763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ilaver </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>VERS_MAJOR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>VERS_MINOR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>VERS_PATCH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ILAVER</b> returns the LAPACK version. </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  This subroutine returns the LAPACK version.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">VERS_MAJOR</td><td>return the lapack major version</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VERS_MINOR</td><td>return the lapack minor version from the major version</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VERS_PATCH</td><td>return the lapack patch version from the minor version </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  This subroutine returns the LAPACK version.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">VERS_MAJOR</td><td>return the lapack major version</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VERS_MINOR</td><td>return the lapack minor version from the major version</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VERS_PATCH</td><td>return the lapack patch version from the minor version </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e703cb600283f4bcb1b340cfd8ad3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> iparmq </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ISPEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character, dimension( * )&#160;</td>
          <td class="paramname"><em>NAME</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character, dimension( * )&#160;</td>
          <td class="paramname"><em>OPTS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>IPARMQ</b> </p>
<p> 
 Download IPARMQ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/iparmq.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/iparmq.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/iparmq.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      This program sets problem and machine dependent parameters
      useful for xHSEQR and its subroutines. It is called whenever 
      ILAENV is called with 12 &lt;= ISPEC &lt;= 16</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ISPEC</td><td><pre class="fragment">          ISPEC is integer scalar
              ISPEC specifies which tunable parameter IPARMQ should
              return.

              ISPEC=12: (INMIN)  Matrices of order nmin or less
                        are sent directly to xLAHQR, the implicit
                        double shift QR algorithm.  NMIN must be
                        at least 11.

              ISPEC=13: (INWIN)  Size of the deflation window.
                        This is best set greater than or equal to
                        the number of simultaneous shifts NS.
                        Larger matrices benefit from larger deflation
                        windows.

              ISPEC=14: (INIBL) Determines when to stop nibbling and
                        invest in an (expensive) multi-shift QR sweep.
                        If the aggressive early deflation subroutine
                        finds LD converged eigenvalues from an order
                        NW deflation window and LD.GT.(NW*NIBBLE)/100,
                        then the next QR sweep is skipped and early
                        deflation is applied immediately to the
                        remaining active diagonal block.  Setting
                        IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a
                        multi-shift QR sweep whenever early deflation
                        finds a converged eigenvalue.  Setting
                        IPARMQ(ISPEC=14) greater than or equal to 100
                        prevents TTQRE from skipping a multi-shift
                        QR sweep.

              ISPEC=15: (NSHFTS) The number of simultaneous shifts in
                        a multi-shift QR iteration.

              ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the
                        following meanings.
                        0:  During the multi-shift QR sweep,
                            xLAQR5 does not accumulate reflections and
                            does not use matrix-matrix multiply to
                            update the far-from-diagonal matrix
                            entries.
                        1:  During the multi-shift QR sweep,
                            xLAQR5 and/or xLAQRaccumulates reflections and uses
                            matrix-matrix multiply to update the
                            far-from-diagonal matrix entries.
                        2:  During the multi-shift QR sweep.
                            xLAQR5 accumulates reflections and takes
                            advantage of 2-by-2 block structure during
                            matrix-matrix multiplies.
                        (If xTRMM is slower than xGEMM, then
                        IPARMQ(ISPEC=16)=1 may be more efficient than
                        IPARMQ(ISPEC=16)=2 despite the greater level of
                        arithmetic work implied by the latter choice.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NAME</td><td><pre class="fragment">          NAME is character string
               Name of the calling subroutine</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OPTS</td><td><pre class="fragment">          OPTS is character string
               This is a concatenation of the string arguments to
               TTQRE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is integer scalar
               N is the order of the Hessenberg matrix H.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILO</td><td><pre class="fragment">          ILO is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IHI</td><td><pre class="fragment">          IHI is INTEGER
               It is assumed that H is already upper triangular
               in rows and columns 1:ILO-1 and IHI+1:N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is integer scalar
               The amount of workspace available.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">       Little is known about how best to choose these parameters.
       It is possible to use different values of the parameters
       for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR.

       It is probably best to choose different parameters for
       different matrices and different parameters at different
       times during the iteration, but this has not been
       implemented --- yet.


       The best choices of most of the parameters depend
       in an ill-understood way on the relative execution
       rate of xLAQR3 and xLAQR5 and on the nature of each
       particular eigenvalue problem.  Experiment may be the
       only practical way to determine which choices are most
       effective.

       Following is a list of default values supplied by IPARMQ.
       These defaults may be adjusted in order to attain better
       performance in any particular computational environment.

       IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point.
                        Default: 75. (Must be at least 11.)

       IPARMQ(ISPEC=13) Recommended deflation window size.
                        This depends on ILO, IHI and NS, the
                        number of simultaneous shifts returned
                        by IPARMQ(ISPEC=15).  The default for
                        (IHI-ILO+1).LE.500 is NS.  The default
                        for (IHI-ILO+1).GT.500 is 3*NS/2.

       IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14.

       IPARMQ(ISPEC=15) Number of simultaneous shifts, NS.
                        a multi-shift QR iteration.

                        If IHI-ILO+1 is ...

                        greater than      ...but less    ... the
                        or equal to ...      than        default is

                                0               30       NS =   2+
                               30               60       NS =   4+
                               60              150       NS =  10
                              150              590       NS =  **
                              590             3000       NS =  64
                             3000             6000       NS = 128
                             6000             infinity   NS = 256

                    (+)  By default matrices of this order are
                         passed to the implicit double shift routine
                         xLAHQR.  See IPARMQ(ISPEC=12) above.   These
                         values of NS are used only in case of a rare
                         xLAHQR failure.

                    (**) The asterisks (**) indicate an ad-hoc
                         function increasing from 10 to 64.

       IPARMQ(ISPEC=16) Select structured matrix multiply.
                        (See ISPEC=16 above for details.)
                        Default: 3.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gada799b40a93f1fd2c6d1a86a95f21631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> lsame </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>CA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>CB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>LSAME</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> LSAME returns .TRUE. if CA is the same letter as CB regardless of
 case.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CA</td><td><pre class="fragment"> </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CB</td><td><pre class="fragment">          CA and CB specify the single characters to be compared.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b496168bf04278e5e57050403c150aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> lsamen </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character*( * )&#160;</td>
          <td class="paramname"><em>CA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character*( * )&#160;</td>
          <td class="paramname"><em>CB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>LSAMEN</b> </p>
<p> 
 Download LSAMEN + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/lsamen.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/lsamen.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/lsamen.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> LSAMEN  tests if the first N letters of CA are the same as the
 first N letters of CB, regardless of case.
 LSAMEN returns .TRUE. if CA and CB are equivalent except for case
 and .FALSE. otherwise.  LSAMEN also returns .FALSE. if LEN( CA )
 or LEN( CB ) is less than N.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of characters in CA and CB to be compared.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CA</td><td><pre class="fragment">          CA is CHARACTER*(*)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CB</td><td><pre class="fragment">          CB is CHARACTER*(*)
          CA and CB specify two character strings of length at least N.
          Only the first N characters of each string will be accessed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gae9f971a8b343bd2fcb85c3b16da97f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> second </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SECOND</b> Using ETIME </p>
<p><b>SECOND</b> returns nothing</p>
<p><b>SECOND</b> Using the INTERNAL function ETIME.</p>
<p><b>SECOND</b> Using INTERNAL function CPU_TIME.</p>
<p><b>SECOND</b> Using ETIME_</p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  SECOND returns the user time for a process in seconds.
  This version gets the time from the EXTERNAL system function ETIME.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  SECOND returns the user time for a process in seconds.
  This version gets the time from the system function ETIME_.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  SECOND returns the user time for a process in seconds.
  This version gets the time from the INTERNAL function CPU_TIME.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  SECOND returns the user time for a process in seconds.
  This version gets the time from the INTERNAL function ETIME.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">  SECOND returns nothing instead of returning the user time for a process in seconds.
  If you are using that routine, it means that neither EXTERNAL ETIME,
  EXTERNAL ETIME_, INTERNAL ETIME, INTERNAL CPU_TIME is available  on
  your machine.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaeca6bb0411af000e3c883ee744184991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> sisnan </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SIN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SISNAN</b> tests input for NaN. </p>
<p> 
 Download SISNAN + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sisnan.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sisnan.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sisnan.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SISNAN returns .TRUE. if its argument is NaN, and .FALSE.
 otherwise.  To be replaced by the Fortran 2003 intrinsic in the
 future.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SIN</td><td><pre class="fragment">          SIN is REAL
          Input to test for NaN.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga117e4564430a16335ad47054c447cb79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slabad </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SMALL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>LARGE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLABAD</b> </p>
<p> 
 Download SLABAD + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slabad.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slabad.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slabad.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLABAD takes as input the values computed by SLAMCH for underflow and
 overflow, and returns the square root of each of these values if the
 log of LARGE is sufficiently large.  This subroutine is intended to
 identify machines with a large exponent range, such as the Crays, and
 redefine the underflow and overflow limits to be the square roots of
 the values computed by SLAMCH.  This subroutine is needed because
 SLAMCH does not compensate for poor arithmetic in the upper half of
 the exponent range, as is found on a Cray.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SMALL</td><td><pre class="fragment">          SMALL is REAL
          On entry, the underflow threshold as computed by SLAMCH.
          On exit, if LOG10(LARGE) is sufficiently large, the square
          root of SMALL, otherwise unchanged.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">LARGE</td><td><pre class="fragment">          LARGE is REAL
          On entry, the overflow threshold as computed by SLAMCH.
          On exit, if LOG10(LARGE) is sufficiently large, the square
          root of LARGE, otherwise unchanged.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7780c991533ce8dd1f2c22ae2d563f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slacpy </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLACPY</b> copies all or part of one two-dimensional array to another. </p>
<p> 
 Download SLACPY + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slacpy.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slacpy.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slacpy.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLACPY copies all or part of a two-dimensional matrix A to another
 matrix B.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies the part of the matrix A to be copied to B.
          = 'U':      Upper triangular part
          = 'L':      Lower triangular part
          Otherwise:  All of the matrix A</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA,N)
          The m by n matrix A.  If UPLO = 'U', only the upper triangle
          or trapezoid is accessed; if UPLO = 'L', only the lower
          triangle or trapezoid is accessed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL array, dimension (LDB,N)
          On exit, B = A in the locations specified by UPLO.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga774ef9659ab6074d1fd66eefc222085e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine sladiv </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow. </p>
<p> 
 Download SLADIV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sladiv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sladiv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sladiv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLADIV performs complex division in  real arithmetic

                       a + i*b
            p + i*q = ---------
                       c + i*d

 The algorithm is due to Michael Baudin and Robert L. Smith
 and can be found in the paper
 "A Robust Complex Division in Scilab"</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL
          The scalars a, b, c, and d in the above expression.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td><pre class="fragment">          P is REAL</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is REAL
          The scalars p and q in the above expression.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>January 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="gaec32dea47a14590934b8970b078b58fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slae2 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RT2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAE2</b> computes the eigenvalues of a 2-by-2 symmetric matrix. </p>
<p> 
 Download SLAE2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slae2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slae2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slae2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
    [  A   B  ]
    [  B   C  ].
 On return, RT1 is the eigenvalue of larger absolute value, and RT2
 is the eigenvalue of smaller absolute value.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL
          The (1,2) and (2,1) elements of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT1</td><td><pre class="fragment">          RT1 is REAL
          The eigenvalue of larger absolute value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT2</td><td><pre class="fragment">          RT2 is REAL
          The eigenvalue of smaller absolute value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  RT1 is accurate to a few ulps barring over/underflow.

  RT2 may be inaccurate if there is massive cancellation in the
  determinant A*C-B*B; higher precision or correctly rounded or
  correctly truncated arithmetic would be needed to compute RT2
  accurately in all cases.

  Overflow is possible only if RT1 is within a factor of 5 of overflow.
  Underflow is harmless if the input data is 0 or exceeds
     underflow_threshold / macheps.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f5045e3ec268a759d36fec562d6e481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slaebz </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IJOB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NITMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MINP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NBMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ABSTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RELTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( mmax, * )&#160;</td>
          <td class="paramname"><em>AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( mmax, * )&#160;</td>
          <td class="paramname"><em>NAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAEBZ</b> computes the number of eigenvalues of a real symmetric tridiagonal matrix which are less than or equal to a given value, and performs other tasks required by the routine sstebz. </p>
<p> 
 Download SLAEBZ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaebz.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaebz.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaebz.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAEBZ contains the iteration loops which compute and use the
 function N(w), which is the count of eigenvalues of a symmetric
 tridiagonal matrix T less than or equal to its argument  w.  It
 performs a choice of two types of loops:

 IJOB=1, followed by
 IJOB=2: It takes as input a list of intervals and returns a list of
         sufficiently small intervals whose union contains the same
         eigenvalues as the union of the original intervals.
         The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
         The output interval (AB(j,1),AB(j,2)] will contain
         eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 &lt;= j &lt;= MOUT.

 IJOB=3: It performs a binary search in each input interval
         (AB(j,1),AB(j,2)] for a point  w(j)  such that
         N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
         the search.  If such a w(j) is found, then on output
         AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
         (AB(j,1),AB(j,2)] will be a small interval containing the
         point where N(w) jumps through NVAL(j), unless that point
         lies outside the initial interval.

 Note that the intervals are in all cases half-open intervals,
 i.e., of the form  (a,b] , which includes  b  but not  a .

 To avoid underflow, the matrix should be scaled so that its largest
 element is no greater than  overflow**(1/2) * underflow**(1/4)
 in absolute value.  To assure the most accurate computation
 of small eigenvalues, the matrix should be scaled to be
 not much smaller than that, either.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966

 Note: the arguments are, in general, *not* checked for unreasonable
 values.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IJOB</td><td><pre class="fragment">          IJOB is INTEGER
          Specifies what is to be done:
          = 1:  Compute NAB for the initial intervals.
          = 2:  Perform bisection iteration to find eigenvalues of T.
          = 3:  Perform bisection iteration to invert N(w), i.e.,
                to find a point which has a specified number of
                eigenvalues of T to its left.
          Other values will cause SLAEBZ to return with INFO=-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NITMAX</td><td><pre class="fragment">          NITMAX is INTEGER
          The maximum number of "levels" of bisection to be
          performed, i.e., an interval of width W will not be made
          smaller than 2^(-NITMAX) * W.  If not all intervals
          have converged after NITMAX iterations, then INFO is set
          to the number of non-converged intervals.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension n of the tridiagonal matrix T.  It must be at
          least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MMAX</td><td><pre class="fragment">          MMAX is INTEGER
          The maximum number of intervals.  If more than MMAX intervals
          are generated, then SLAEBZ will quit with INFO=MMAX+1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MINP</td><td><pre class="fragment">          MINP is INTEGER
          The initial number of intervals.  It may not be greater than
          MMAX.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NBMIN</td><td><pre class="fragment">          NBMIN is INTEGER
          The smallest number of intervals that should be processed
          using a vector loop.  If zero, then only the scalar loop
          will be used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ABSTOL</td><td><pre class="fragment">          ABSTOL is REAL
          The minimum (absolute) width of an interval.  When an
          interval is narrower than ABSTOL, or than RELTOL times the
          larger (in magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  This must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RELTOL</td><td><pre class="fragment">          RELTOL is REAL
          The minimum relative width of an interval.  When an interval
          is narrower than ABSTOL, or than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum absolute value of a "pivot" in the Sturm
          sequence loop.
          This must be at least  max |e(j)**2|*safe_min  and at
          least safe_min, where safe_min is at least
          the smallest number that can divide one without overflow.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N)
          The offdiagonal elements of the tridiagonal matrix T in
          positions 1 through N-1.  E(N) is arbitrary.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is REAL array, dimension (N)
          The squares of the offdiagonal elements of the tridiagonal
          matrix T.  E2(N) is ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (MINP)
          If IJOB=1 or 2, not referenced.
          If IJOB=3, the desired values of N(w).  The elements of NVAL
          will be reordered to correspond with the intervals in AB.
          Thus, NVAL(j) on output will not, in general be the same as
          NVAL(j) on input, but it will correspond with the interval
          (AB(j,1),AB(j,2)] on output.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">AB</td><td><pre class="fragment">          AB is REAL array, dimension (MMAX,2)
          The endpoints of the intervals.  AB(j,1) is  a(j), the left
          endpoint of the j-th interval, and AB(j,2) is b(j), the
          right endpoint of the j-th interval.  The input intervals
          will, in general, be modified, split, and reordered by the
          calculation.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL array, dimension (MMAX)
          If IJOB=1, ignored.
          If IJOB=2, workspace.
          If IJOB=3, then on input C(j) should be initialized to the
          first search point in the binary search.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MOUT</td><td><pre class="fragment">          MOUT is INTEGER
          If IJOB=1, the number of eigenvalues in the intervals.
          If IJOB=2 or 3, the number of intervals output.
          If IJOB=3, MOUT will equal MINP.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">NAB</td><td><pre class="fragment">          NAB is INTEGER array, dimension (MMAX,2)
          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j)).
          If IJOB=2, then on input, NAB(i,j) should be set.  It must
             satisfy the condition:
             N(AB(i,1)) &lt;= NAB(i,1) &lt;= NAB(i,2) &lt;= N(AB(i,2)),
             which means that in interval i only eigenvalues
             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,
             NAB(i,j)=N(AB(i,j)), from a previous call to SLAEBZ with
             IJOB=1.
             On output, NAB(i,j) will contain
             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
             the input interval that the output interval
             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the
             the input values of NAB(k,1) and NAB(k,2).
          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),
             unless N(w) &gt; NVAL(i) for all search points  w , in which
             case NAB(i,1) will not be modified, i.e., the output
             value will be the same as the input value (modulo
             reorderings -- see NVAL and AB), or unless N(w) &lt; NVAL(i)
             for all search points  w , in which case NAB(i,2) will
             not be modified.  Normally, NAB should be set to some
             distinctive value(s) before SLAEBZ is called.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MMAX)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (MMAX)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:       All intervals converged.
          = 1--MMAX: The last INFO intervals did not converge.
          = MMAX+1:  More than MMAX intervals were generated.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">      This routine is intended to be called only by other LAPACK
  routines, thus the interface is less user-friendly.  It is intended
  for two purposes:

  (a) finding eigenvalues.  In this case, SLAEBZ should have one or
      more initial intervals set up in AB, and SLAEBZ should be called
      with IJOB=1.  This sets up NAB, and also counts the eigenvalues.
      Intervals with no eigenvalues would usually be thrown out at
      this point.  Also, if not all the eigenvalues in an interval i
      are desired, NAB(i,1) can be increased or NAB(i,2) decreased.
      For example, set NAB(i,1)=NAB(i,2)-1 to get the largest
      eigenvalue.  SLAEBZ is then called with IJOB=2 and MMAX
      no smaller than the value of MOUT returned by the call with
      IJOB=1.  After this (IJOB=2) call, eigenvalues NAB(i,1)+1
      through NAB(i,2) are approximately AB(i,1) (or AB(i,2)) to the
      tolerance specified by ABSTOL and RELTOL.

  (b) finding an interval (a',b'] containing eigenvalues w(f),...,w(l).
      In this case, start with a Gershgorin interval  (a,b).  Set up
      AB to contain 2 search intervals, both initially (a,b).  One
      NVAL element should contain  f-1  and the other should contain  l
      , while C should contain a and b, resp.  NAB(i,1) should be -1
      and NAB(i,2) should be N+1, to flag an error if the desired
      interval does not lie in (a,b).  SLAEBZ is then called with
      IJOB=3.  On exit, if w(f-1) &lt; w(f), then one of the intervals --
      j -- will have AB(j,1)=AB(j,2) and NAB(j,1)=NAB(j,2)=f-1, while
      if, to the specified tolerance, w(f-k)=...=w(f+r), k &gt; 0 and r
      &gt;= 0, then the interval will have  N(AB(j,1))=NAB(j,1)=f-k and
      N(AB(j,2))=NAB(j,2)=f+r.  The cases w(l) &lt; w(l+1) and
      w(l-r)=...=w(l+k) are handled similarly.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf79f0bb1a07a9d96b827eba946ec79fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slaev2 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SN1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAEV2</b> computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix. </p>
<p> 
 Download SLAEV2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaev2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaev2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaev2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
    [  A   B  ]
    [  B   C  ].
 On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
 eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
 eigenvector for RT1, giving the decomposition

    [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
    [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL
          The (1,2) element and the conjugate of the (2,1) element of
          the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT1</td><td><pre class="fragment">          RT1 is REAL
          The eigenvalue of larger absolute value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT2</td><td><pre class="fragment">          RT2 is REAL
          The eigenvalue of smaller absolute value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS1</td><td><pre class="fragment">          CS1 is REAL</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SN1</td><td><pre class="fragment">          SN1 is REAL
          The vector (CS1, SN1) is a unit right eigenvector for RT1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  RT1 is accurate to a few ulps barring over/underflow.

  RT2 may be inaccurate if there is massive cancellation in the
  determinant A*C-B*B; higher precision or correctly rounded or
  correctly truncated arithmetic would be needed to compute RT2
  accurately in all cases.

  CS1 and SN1 are accurate to a few ulps barring over/underflow.

  Overflow is possible only if RT1 is within a factor of 5 of overflow.
  Underflow is harmless if the input data is 0 or exceeds
     underflow_threshold / macheps.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gac8ea5cb7fd597f6b5ae9cade02d122b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slag2d </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldsa, * )&#160;</td>
          <td class="paramname"><em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAG2D</b> converts a single precision matrix to a double precision matrix. </p>
<p> 
 Download SLAG2D + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slag2d.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slag2d.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slag2d.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAG2D converts a SINGLE PRECISION matrix, SA, to a DOUBLE
 PRECISION matrix, A.

 Note that while it is possible to overflow while converting
 from double to single, it is not possible to overflow when
 converting from single to double.

 This is an auxiliary routine so there is no argument checking.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of lines of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SA</td><td><pre class="fragment">          SA is REAL array, dimension (LDSA,N)
          On entry, the M-by-N coefficient matrix SA.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDSA</td><td><pre class="fragment">          LDSA is INTEGER
          The leading dimension of the array SA.  LDSA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          On exit, the M-by-N coefficient matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gae4b431608960457e61e885f3a2e2b18e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slagts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>JOB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAGTS</b> solves the system of equations (T-λI)x = y or (T-λI)Tx = y,where T is a general tridiagonal matrix and λ a scalar, using the LU factorization computed by slagtf. </p>
<p> 
 Download SLAGTS + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slagts.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slagts.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slagts.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAGTS may be used to solve one of the systems of equations

    (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,

 where T is an n by n tridiagonal matrix, for x, following the
 factorization of (T - lambda*I) as

    (T - lambda*I) = P*L*U ,

 by routine SLAGTF. The choice of equation to be solved is
 controlled by the argument JOB, and in each case there is an option
 to perturb zero or very small diagonal elements of U, this option
 being intended for use in applications such as inverse iteration.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOB</td><td><pre class="fragment">          JOB is INTEGER
          Specifies the job to be performed by SLAGTS as follows:
          =  1: The equations  (T - lambda*I)x = y  are to be solved,
                but diagonal elements of U are not to be perturbed.
          = -1: The equations  (T - lambda*I)x = y  are to be solved
                and, if overflow would otherwise occur, the diagonal
                elements of U are to be perturbed. See argument TOL
                below.
          =  2: The equations  (T - lambda*I)**Tx = y  are to be solved,
                but diagonal elements of U are not to be perturbed.
          = -2: The equations  (T - lambda*I)**Tx = y  are to be solved
                and, if overflow would otherwise occur, the diagonal
                elements of U are to be perturbed. See argument TOL
                below.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (N)
          On entry, A must contain the diagonal elements of U as
          returned from SLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL array, dimension (N-1)
          On entry, B must contain the first super-diagonal elements of
          U as returned from SLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL array, dimension (N-1)
          On entry, C must contain the sub-diagonal elements of L as
          returned from SLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N-2)
          On entry, D must contain the second super-diagonal elements
          of U as returned from SLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IN</td><td><pre class="fragment">          IN is INTEGER array, dimension (N)
          On entry, IN must contain details of the matrix P as returned
          from SLAGTF.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is REAL array, dimension (N)
          On entry, the right hand side vector y.
          On exit, Y is overwritten by the solution vector x.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">TOL</td><td><pre class="fragment">          TOL is REAL
          On entry, with  JOB .lt. 0, TOL should be the minimum
          perturbation to be made to very small diagonal elements of U.
          TOL should normally be chosen as about eps*norm(U), where eps
          is the relative machine precision, but if TOL is supplied as
          non-positive, then it is reset to eps*max( abs( u(i,j) ) ).
          If  JOB .gt. 0  then TOL is not referenced.

          On exit, TOL is changed as described above, only if TOL is
          non-positive on entry. Otherwise TOL is unchanged.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0   : successful exit
          .lt. 0: if INFO = -i, the i-th argument had an illegal value
          .gt. 0: overflow would occur when computing the INFO(th)
                  element of the solution vector x. This can only occur
                  when JOB is supplied as positive and either means
                  that a diagonal element of U is very small, or that
                  the elements of the right-hand side vector y are very
                  large.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b6a1036554ed9b7196c641174d6a6da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> slaisnan </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SIN1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SIN2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAISNAN</b> tests input for NaN by comparing two arguments for inequality. </p>
<p> 
 Download SLAISNAN + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaisnan.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaisnan.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaisnan.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This routine is not for general use.  It exists solely to avoid
 over-optimization in SISNAN.

 SLAISNAN checks for NaNs by comparing its two arguments for
 inequality.  NaN is the only floating-point value where NaN != NaN
 returns .TRUE.  To check for NaNs, pass the same variable as both
 arguments.

 A compiler must assume that the two arguments are
 not the same variable, and the test will not be optimized away.
 Interprocedural or whole-program optimization may delete this
 test.  The ISNAN functions will be replaced by the correct
 Fortran 03 intrinsic once the intrinsic is widely available.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SIN1</td><td><pre class="fragment">          SIN1 is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SIN2</td><td><pre class="fragment">          SIN2 is REAL
          Two numbers to compare for inequality.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0259f906df485fc6fba360cb3ebef320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slamc1 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>RND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>IEEE1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAMC1</b> </p>
<p><b>Purpose:</b> </p><pre class="fragment"> SLAMC1 determines the machine parameters given by BETA, T, RND, and
 IEEE1.</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          The base of the machine.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          The number of ( BETA ) digits in the mantissa.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RND</td><td><pre class="fragment">          Specifies whether proper rounding  ( RND = .TRUE. )  or
          chopping  ( RND = .FALSE. )  occurs in addition. This may not
          be a reliable guide to the way in which the machine performs
          its arithmetic.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IEEE1</td><td><pre class="fragment">          Specifies whether rounding appears to be done in the IEEE
          'round to nearest' style.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012</dd></dl>
<p><b>Further</b> <b>Details</b> </p><pre class="fragment">  The routine is based on the routine  ENVRON  by Malcolm and
  incorporates suggestions by Gentleman and Marovich. See

     Malcolm M. A. (1972) Algorithms to reveal properties of
        floating-point arithmetic. Comms. of the ACM, 15, 949-951.

     Gentleman W. M. and Marovich S. B. (1974) More on algorithms
        that reveal properties of floating point arithmetic units.
        Comms. of the ACM, 17, 276-277.</pre> 
</div>
</div>
<a class="anchor" id="ga72e67de62733142ac7f456696018d1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slamc2 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>RND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>EPS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>EMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>EMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RMAX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAMC2</b> </p>
<p><b>Purpose:</b> </p><pre class="fragment"> SLAMC2 determines the machine parameters specified in its argument
 list.</pre> <dl class="section author"><dt>Author</dt><dd>LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          The base of the machine.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          The number of ( BETA ) digits in the mantissa.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RND</td><td><pre class="fragment">          Specifies whether proper rounding  ( RND = .TRUE. )  or
          chopping  ( RND = .FALSE. )  occurs in addition. This may not
          be a reliable guide to the way in which the machine performs
          its arithmetic.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EPS</td><td><pre class="fragment">          The smallest positive number such that
             fl( 1.0 - EPS ) .LT. 1.0,
          where fl denotes the computed value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMIN</td><td><pre class="fragment">          The minimum exponent before (gradual) underflow occurs.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RMIN</td><td><pre class="fragment">          The smallest normalized number for the machine, given by
          BASE**( EMIN - 1 ), where  BASE  is the floating point value
          of BETA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAX</td><td><pre class="fragment">          The maximum exponent before overflow occurs.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          The largest positive number for the machine, given by
          BASE**EMAX * ( 1 - EPS ), where  BASE  is the floating point
          value of BETA.</pre></td></tr>
  </table>
  </dd>
</dl>
<p><b>Further</b> <b>Details</b> </p><pre class="fragment">  The computation of  EPS  is based on a routine PARANOIA by
  W. Kahan of the University of California at Berkeley.</pre> 
</div>
</div>
<a class="anchor" id="ga063f886475dbe005f58b9c37ced98b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> slamc3 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAMC3</b> </p>
<p><b>Purpose:</b> </p><pre class="fragment"> SLAMC3  is intended to force  A  and  B  to be stored prior to doing
 the addition of  A  and  B ,  for use in situations where optimizers
 might hold one of these in a register.</pre> <dl class="section author"><dt>Author</dt><dd>LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment"> </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          The values A and B.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga279f9f1e475af3a6e6101fbfd874f955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> slamch </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>CMACH</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAMCH</b> </p>
<p><b>SLAMCHF77</b> deprecated</p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAMCH determines single precision machine parameters.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CMACH</td><td><pre class="fragment">          Specifies the value to be returned by SLAMCH:
          = 'E' or 'e',   SLAMCH := eps
          = 'S' or 's ,   SLAMCH := sfmin
          = 'B' or 'b',   SLAMCH := base
          = 'P' or 'p',   SLAMCH := eps*base
          = 'N' or 'n',   SLAMCH := t
          = 'R' or 'r',   SLAMCH := rnd
          = 'M' or 'm',   SLAMCH := emin
          = 'U' or 'u',   SLAMCH := rmin
          = 'L' or 'l',   SLAMCH := emax
          = 'O' or 'o',   SLAMCH := rmax
          where
          eps   = relative machine precision
          sfmin = safe minimum, such that 1/sfmin does not overflow
          base  = base of the machine
          prec  = eps*base
          t     = number of (base) digits in the mantissa
          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
          emin  = minimum exponent before (gradual) underflow
          rmin  = underflow threshold - base**(emin-1)
          emax  = largest exponent before overflow
          rmax  = overflow threshold  - (base**emax)*(1-eps)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011</dd></dl>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAMCH determines single precision machine parameters.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CMACH</td><td><pre class="fragment">          Specifies the value to be returned by SLAMCH:
          = 'E' or 'e',   SLAMCH := eps
          = 'S' or 's ,   SLAMCH := sfmin
          = 'B' or 'b',   SLAMCH := base
          = 'P' or 'p',   SLAMCH := eps*base
          = 'N' or 'n',   SLAMCH := t
          = 'R' or 'r',   SLAMCH := rnd
          = 'M' or 'm',   SLAMCH := emin
          = 'U' or 'u',   SLAMCH := rmin
          = 'L' or 'l',   SLAMCH := emax
          = 'O' or 'o',   SLAMCH := rmax
          where
          eps   = relative machine precision
          sfmin = safe minimum, such that 1/sfmin does not overflow
          base  = base of the machine
          prec  = eps*base
          t     = number of (base) digits in the mantissa
          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
          emin  = minimum exponent before (gradual) underflow
          rmin  = underflow threshold - base**(emin-1)
          emax  = largest exponent before overflow
          rmax  = overflow threshold  - (base**emax)*(1-eps)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ea5fb550bbab683a539b551e3496bcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> slaneg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>LLD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLANEG</b> computes the Sturm count. </p>
<p> 
 Download SLANEG + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaneg.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaneg.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaneg.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLANEG computes the Sturm count, the number of negative pivots
 encountered while factoring tridiagonal T - sigma I = L D L^T.
 This implementation works directly on the factors without forming
 the tridiagonal matrix T.  The Sturm count is also the number of
 eigenvalues of T less than sigma.

 This routine is called from SLARRB.

 The current routine does not use the PIVMIN parameter but rather
 requires IEEE-754 propagation of Infinities and NaNs.  This
 routine also has no input range restrictions but does require
 default exception handling such that x/0 produces Inf when x is
 non-zero, and Inf/Inf produces NaN.  For more information, see:

   Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
   Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on
   Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624
   (Tech report version in LAWN 172 with the same title.)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LLD</td><td><pre class="fragment">          LLD is REAL array, dimension (N-1)
          The (N-1) elements L(i)*L(i)*D(i).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SIGMA</td><td><pre class="fragment">          SIGMA is REAL
          Shift amount in T - sigma I = L D L^T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot in the Sturm sequence.  May be used
          when zero pivots are encountered on non-IEEE-754
          architectures.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td><pre class="fragment">          R is INTEGER
          The twist index for the twisted factorization that is used
          for the negcount.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA <br />
 Jason Riedy, University of California, Berkeley, USA <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3f856bc9099be84550d6c98ed9a3c810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> slanst </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>NORM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLANST</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric tridiagonal matrix. </p>
<p> 
 Download SLANST + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slanst.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slanst.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slanst.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLANST  returns the value of the one norm,  or the Frobenius norm, or
 the  infinity norm,  or the  element of  largest absolute value  of a
 real symmetric tridiagonal matrix A.</pre></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SLANST <pre class="fragment">    SLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

 where  norm1  denotes the  one norm of a matrix (maximum column sum),
 normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
 normF  denotes the  Frobenius norm of a matrix (square root of sum of
 squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NORM</td><td><pre class="fragment">          NORM is CHARACTER*1
          Specifies the value to be returned in SLANST as described
          above.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.  When N = 0, SLANST is
          set to zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The diagonal elements of A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N-1)
          The (n-1) sub-diagonal or super-diagonal elements of A.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gabfcdad5f1d5d0193f7285e018824aa66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> slapy2 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAPY2</b> returns sqrt(x2+y2). </p>
<p> 
 Download SLAPY2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slapy2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slapy2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapy2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 overflow.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is REAL
          X and Y specify the values x and y.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gadab147cb12ea8d677598a5aad10f7e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> slapy3 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAPY3</b> returns sqrt(x2+y2+z2). </p>
<p> 
 Download SLAPY3 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slapy3.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slapy3.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapy3.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 unnecessary overflow.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL
          X, Y and Z specify the values x, y and z.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga379b09e3d4e7635db614d3b3973db5e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarnv </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARNV</b> returns a vector of random numbers from a uniform or normal distribution. </p>
<p> 
 Download SLARNV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarnv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarnv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarnv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLARNV returns a vector of n random real numbers from a uniform or
 normal distribution.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is INTEGER
          Specifies the distribution of the random numbers:
          = 1:  uniform (0,1)
          = 2:  uniform (-1,1)
          = 3:  normal (0,1)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of random numbers to be generated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is REAL array, dimension (N)
          The generated random numbers.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  This routine calls the auxiliary routine SLARUV to generate random
  real numbers from a uniform (0,1) distribution, in batches of up to
  128 using vectorisable code. The Box-Muller method is used to
  transform numbers from a uniform to a normal distribution.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f440e7139c504926241c9f7f71332d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarra </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPLTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>TNRM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRA</b> computes the splitting points with the specified threshold. </p>
<p> 
 Download SLARRA + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarra.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarra.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarra.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Compute the splitting points with threshold SPLTOL.
 SLARRA sets any "small" off-diagonal elements to zero.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          On entry, the N diagonal elements of the tridiagonal
          matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N)
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) need not be set.
          On exit, the entries E( ISPLIT( I ) ), 1 &lt;= I &lt;= NSPLIT,
          are set to zero, the other entries of E are untouched.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is REAL array, dimension (N)
          On entry, the first (N-1) entries contain the SQUARES of the
          subdiagonal elements of the tridiagonal matrix T;
          E2(N) need not be set.
          On exit, the entries E2( ISPLIT( I ) ),
          1 &lt;= I &lt;= NSPLIT, have been set to zero</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPLTOL</td><td><pre class="fragment">          SPLTOL is REAL
          The threshold for splitting. Two criteria can be used:
          SPLTOL&lt;0 : criterion based on absolute off-diagonal value
          SPLTOL&gt;0 : criterion that preserves relative accuracy</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TNRM</td><td><pre class="fragment">          TNRM is REAL
          The norm of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NSPLIT</td><td><pre class="fragment">          NSPLIT is INTEGER
          The number of blocks T splits into. 1 &lt;= NSPLIT &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ISPLIT</td><td><pre class="fragment">          ISPLIT is INTEGER array, dimension (N)
          The splitting points, at which T breaks up into blocks.
          The first block consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gad29562cff63b75a1f3f40e7f83aea2b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarrb </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>LLD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IFIRST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILAST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RTOL1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RTOL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>OFFSET</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WGAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPDIAM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>TWIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRB</b> provides limited bisection to locate eigenvalues for more accuracy. </p>
<p> 
 Download SLARRB + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrb.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrb.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrb.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Given the relatively robust representation(RRR) L D L^T, SLARRB
 does "limited" bisection to refine the eigenvalues of L D L^T,
 W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
 guesses for these eigenvalues are input in W, the corresponding estimate
 of the error in these guesses and their gaps are input in WERR
 and WGAP, respectively. During bisection, intervals
 [left, right] are maintained by storing their mid-points and
 semi-widths in the arrays W and WERR respectively.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LLD</td><td><pre class="fragment">          LLD is REAL array, dimension (N-1)
          The (N-1) elements L(i)*L(i)*D(i).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IFIRST</td><td><pre class="fragment">          IFIRST is INTEGER
          The index of the first eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILAST</td><td><pre class="fragment">          ILAST is INTEGER
          The index of the last eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL1</td><td><pre class="fragment">          RTOL1 is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL2</td><td><pre class="fragment">          RTOL2 is REAL
          Tolerance for the convergence of the bisection intervals.
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT.LT.MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )
          where GAP is the (estimated) distance to the nearest
          eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OFFSET</td><td><pre class="fragment">          OFFSET is INTEGER
          Offset for the arrays W, WGAP and WERR, i.e., the IFIRST-OFFSET
          through ILAST-OFFSET elements of these arrays are to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are
          estimates of the eigenvalues of L D L^T indexed IFIRST throug
          ILAST.
          On output, these estimates are refined.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WGAP</td><td><pre class="fragment">          WGAP is REAL array, dimension (N-1)
          On input, the (estimated) gaps between consecutive
          eigenvalues of L D L^T, i.e., WGAP(I-OFFSET) is the gap between
          eigenvalues I and I+1. Note that if IFIRST.EQ.ILAST
          then WGAP(IFIRST-OFFSET) must be set to ZERO.
          On output, these gaps are refined.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is REAL array, dimension (N)
          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET ) are
          the errors in the estimates of the corresponding elements in W.
          On output, these errors are refined.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot in the Sturm sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPDIAM</td><td><pre class="fragment">          SPDIAM is REAL
          The spectral diameter of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TWIST</td><td><pre class="fragment">          TWIST is INTEGER
          The twist index for the twisted factorization that is used
          for the negcount.
          TWIST = N: Compute negcount from L D L^T - LAMBDA I = L+ D+ L+^T
          TWIST = 1: Compute negcount from L D L^T - LAMBDA I = U- D- U-^T
          TWIST = R: Compute negcount from L D L^T - LAMBDA I = N(r) D(r) N(r)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          Error flag.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga3895a010b624d4185e3c0c60b3cf1196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarrc </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>EIGCNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LCNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>RCNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRC</b> computes the number of eigenvalues of the symmetric tridiagonal matrix. </p>
<p> 
 Download SLARRC + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrc.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrc.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrc.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Find the number of eigenvalues of the symmetric tridiagonal matrix T
 that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
 if JOBT = 'L'.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBT</td><td><pre class="fragment">          JOBT is CHARACTER*1
          = 'T':  Compute Sturm count for matrix T.
          = 'L':  Compute Sturm count for matrix L D L^T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is DOUBLE PRECISION
          The lower and upper bounds for the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          JOBT = 'T': The N diagonal elements of the tridiagonal matrix T.
          JOBT = 'L': The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N)
          JOBT = 'T': The N-1 offdiagonal elements of the matrix T.
          JOBT = 'L': The N-1 offdiagonal elements of the matrix L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EIGCNT</td><td><pre class="fragment">          EIGCNT is INTEGER
          The number of eigenvalues of the symmetric tridiagonal matrix T
          that are in the interval (VL,VU]</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LCNT</td><td><pre class="fragment">          LCNT is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNT</td><td><pre class="fragment">          RCNT is INTEGER
          The left and right negcounts of the interval.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga137b773fc78098f8177b09e7d6dc3c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarrd </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RANGE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>ORDER</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>GERS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RELTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>WL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>WU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IBLOCK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>INDEXW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRD</b> computes the eigenvalues of a symmetric tridiagonal matrix to suitable accuracy. </p>
<p> 
 Download SLARRD + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrd.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrd.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrd.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLARRD computes the eigenvalues of a symmetric tridiagonal
 matrix T to suitable accuracy. This is an auxiliary code to be
 called from SSTEMR.
 The user may ask for all eigenvalues, all eigenvalues
 in the half-open interval (VL, VU], or the IL-th through IU-th
 eigenvalues.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RANGE</td><td><pre class="fragment">          RANGE is CHARACTER*1
          = 'A': ("All")   all eigenvalues will be found.
          = 'V': ("Value") all eigenvalues in the half-open interval
                           (VL, VU] will be found.
          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                           entire matrix) will be found.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ORDER</td><td><pre class="fragment">          ORDER is CHARACTER*1
          = 'B': ("By Block") the eigenvalues will be grouped by
                              split-off block (see IBLOCK, ISPLIT) and
                              ordered from smallest to largest within
                              the block.
          = 'E': ("Entire matrix")
                              the eigenvalues for the entire matrix
                              will be ordered from smallest to
                              largest.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the tridiagonal matrix T.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is REAL
          If RANGE='V', the lower and upper bounds of the interval to
          be searched for eigenvalues.  Eigenvalues less than or equal
          to VL, or greater than VU, will not be returned.  VL &lt; VU.
          Not referenced if RANGE = 'A' or 'I'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IL</td><td><pre class="fragment">          IL is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IU</td><td><pre class="fragment">          IU is INTEGER
          If RANGE='I', the indices (in ascending order) of the
          smallest and largest eigenvalues to be returned.
          1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GERS</td><td><pre class="fragment">          GERS is REAL array, dimension (2*N)
          The N Gerschgorin intervals (the i-th Gerschgorin interval
          is (GERS(2*i-1), GERS(2*i)).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RELTOL</td><td><pre class="fragment">          RELTOL is REAL
          The minimum relative width of an interval.  When an interval
          is narrower than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The n diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N-1)
          The (n-1) off-diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is REAL array, dimension (N-1)
          The (n-1) squared off-diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot allowed in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NSPLIT</td><td><pre class="fragment">          NSPLIT is INTEGER
          The number of diagonal blocks in the matrix T.
          1 &lt;= NSPLIT &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISPLIT</td><td><pre class="fragment">          ISPLIT is INTEGER array, dimension (N)
          The splitting points, at which T breaks up into submatrices.
          The first submatrix consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
          (Only the first NSPLIT elements will actually be used, but
          since the user cannot know a priori what value NSPLIT will
          have, N words must be reserved for ISPLIT.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The actual number of eigenvalues found. 0 &lt;= M &lt;= N.
          (See also the description of INFO=2,3.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          On exit, the first M elements of W will contain the
          eigenvalue approximations. SLARRD computes an interval
          I_j = (a_j, b_j] that includes eigenvalue j. The eigenvalue
          approximation is given as the interval midpoint
          W(j)= ( a_j + b_j)/2. The corresponding error is bounded by
          WERR(j) = abs( a_j - b_j)/2</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is REAL array, dimension (N)
          The error bound on the corresponding eigenvalue approximation
          in W.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WL</td><td><pre class="fragment">          WL is REAL</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WU</td><td><pre class="fragment">          WU is REAL
          The interval (WL, WU] contains all the wanted eigenvalues.
          If RANGE='V', then WL=VL and WU=VU.
          If RANGE='A', then WL and WU are the global Gerschgorin bounds
                        on the spectrum.
          If RANGE='I', then WL and WU are computed by SLAEBZ from the
                        index range specified.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IBLOCK</td><td><pre class="fragment">          IBLOCK is INTEGER array, dimension (N)
          At each row/column j where E(j) is zero or small, the
          matrix T is considered to split into a block diagonal
          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
          block (from 1 to the number of blocks) the eigenvalue W(i)
          belongs.  (SLARRD may use the remaining N-M elements as
          workspace.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INDEXW</td><td><pre class="fragment">          INDEXW is INTEGER array, dimension (N)
          The indices of the eigenvalues within each block (submatrix);
          for example, INDEXW(i)= j and IBLOCK(i)=k imply that the
          i-th eigenvalue W(i) is the j-th eigenvalue in block k.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (4*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (3*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  some or all of the eigenvalues failed to converge or
                were not computed:
                =1 or 3: Bisection failed to converge for some
                        eigenvalues; these eigenvalues are flagged by a
                        negative block number.  The effect is that the
                        eigenvalues may not be as accurate as the
                        absolute and relative tolerances.  This is
                        generally caused by unexpectedly inaccurate
                        arithmetic.
                =2 or 3: RANGE='I' only: Not all of the eigenvalues
                        IL:IU were found.
                        Effect: M &lt; IU+1-IL
                        Cause:  non-monotonic arithmetic, causing the
                                Sturm sequence to be non-monotonic.
                        Cure:   recalculate, using RANGE='A', and pick
                                out eigenvalues IL:IU.  In some cases,
                                increasing the PARAMETER "FUDGE" may
                                make things work.
                = 4:    RANGE='I', and the Gershgorin interval
                        initially used was too small.  No eigenvalues
                        were computed.
                        Probable cause: your machine has sloppy
                                        floating-point arithmetic.
                        Cure: Increase the PARAMETER "FUDGE",
                              recompile, and try again.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Internal Parameters: </dt><dd><pre class="fragment">  FUDGE   REAL, default = 2
          A "fudge factor" to widen the Gershgorin intervals.  Ideally,
          a value of 1 should work, but on machines with sloppy
          arithmetic, this needs to be larger.  The default for
          publicly released versions should be large enough to handle
          the worst machine around.  Note that this has no effect
          on accuracy of the solution.</pre></dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>W. Kahan, University of California, Berkeley, USA <br />
 Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA <br />
 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a2b9dcf8e9c8f368fb6d39506781f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarre </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RANGE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RTOL1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RTOL2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPLTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISPLIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WGAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IBLOCK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>INDEXW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>GERS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRE</b> given the tridiagonal matrix T, sets small off-diagonal elements to zero and for each unreduced block Ti, finds base representations and eigenvalues. </p>
<p> 
 Download SLARRE + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarre.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarre.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarre.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> To find the desired eigenvalues of a given real symmetric
 tridiagonal matrix T, SLARRE sets any "small" off-diagonal
 elements to zero, and for each unreduced block T_i, it finds
 (a) a suitable shift at one end of the block's spectrum,
 (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
 (c) eigenvalues of each L_i D_i L_i^T.
 The representations and eigenvalues found are then used by
 SSTEMR to compute the eigenvectors of T.
 The accuracy varies depending on whether bisection is used to
 find a few eigenvalues or the dqds algorithm (subroutine SLASQ2) to
 conpute all and then discard any unwanted one.
 As an added benefit, SLARRE also outputs the n
 Gerschgorin intervals for the matrices L_i D_i L_i^T.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RANGE</td><td><pre class="fragment">          RANGE is CHARACTER*1
          = 'A': ("All")   all eigenvalues will be found.
          = 'V': ("Value") all eigenvalues in the half-open interval
                           (VL, VU] will be found.
          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                           entire matrix) will be found.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is REAL
          If RANGE='V', the lower and upper bounds for the eigenvalues.
          Eigenvalues less than or equal to VL, or greater than VU,
          will not be returned.  VL &lt; VU.
          If RANGE='I' or ='A', SLARRE computes bounds on the desired
          part of the spectrum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IL</td><td><pre class="fragment">          IL is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IU</td><td><pre class="fragment">          IU is INTEGER
          If RANGE='I', the indices (in ascending order) of the
          smallest and largest eigenvalues to be returned.
          1 &lt;= IL &lt;= IU &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          On entry, the N diagonal elements of the tridiagonal
          matrix T.
          On exit, the N diagonal elements of the diagonal
          matrices D_i.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N)
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) need not be set.
          On exit, E contains the subdiagonal elements of the unit
          bidiagonal matrices L_i. The entries E( ISPLIT( I ) ),
          1 &lt;= I &lt;= NSPLIT, contain the base points sigma_i on output.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is REAL array, dimension (N)
          On entry, the first (N-1) entries contain the SQUARES of the
          subdiagonal elements of the tridiagonal matrix T;
          E2(N) need not be set.
          On exit, the entries E2( ISPLIT( I ) ),
          1 &lt;= I &lt;= NSPLIT, have been set to zero</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL1</td><td><pre class="fragment">          RTOL1 is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL2</td><td><pre class="fragment">          RTOL2 is REAL
           Parameters for bisection.
           An interval [LEFT,RIGHT] has converged if
           RIGHT-LEFT.LT.MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPLTOL</td><td><pre class="fragment">          SPLTOL is REAL
          The threshold for splitting.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NSPLIT</td><td><pre class="fragment">          NSPLIT is INTEGER
          The number of blocks T splits into. 1 &lt;= NSPLIT &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ISPLIT</td><td><pre class="fragment">          ISPLIT is INTEGER array, dimension (N)
          The splitting points, at which T breaks up into blocks.
          The first block consists of rows/columns 1 to ISPLIT(1),
          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
          etc., and the NSPLIT-th consists of rows/columns
          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The total number of eigenvalues (of all L_i D_i L_i^T)
          found.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          The first M elements contain the eigenvalues. The
          eigenvalues of each of the blocks, L_i D_i L_i^T, are
          sorted in ascending order ( SLARRE may use the
          remaining N-M elements as workspace).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is REAL array, dimension (N)
          The error bound on the corresponding eigenvalue in W.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WGAP</td><td><pre class="fragment">          WGAP is REAL array, dimension (N)
          The separation from the right neighbor eigenvalue in W.
          The gap is only with respect to the eigenvalues of the same block
          as each block has its own representation tree.
          Exception: at the right end of a block we store the left gap</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IBLOCK</td><td><pre class="fragment">          IBLOCK is INTEGER array, dimension (N)
          The indices of the blocks (submatrices) associated with the
          corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue
          W(i) belongs to the first block from the top, =2 if W(i)
          belongs to the second block, etc.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INDEXW</td><td><pre class="fragment">          INDEXW is INTEGER array, dimension (N)
          The indices of the eigenvalues within each block (submatrix);
          for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the
          i-th eigenvalue W(i) is the 10-th eigenvalue in block 2</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GERS</td><td><pre class="fragment">          GERS is REAL array, dimension (2*N)
          The N Gerschgorin intervals (the i-th Gerschgorin interval
          is (GERS(2*i-1), GERS(2*i)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (6*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (5*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &gt; 0:  A problem occured in SLARRE.
          &lt; 0:  One of the called subroutines signaled an internal problem.
                Needs inspection of the corresponding parameter IINFO
                for further information.

          =-1:  Problem in SLARRD.
          = 2:  No base representation could be found in MAXTRY iterations.
                Increasing MAXTRY and recompilation might be a remedy.
          =-3:  Problem in SLARRB when computing the refined root
                representation for SLASQ2.
          =-4:  Problem in SLARRB when preforming bisection on the
                desired part of the spectrum.
          =-5:  Problem in SLASQ2.
          =-6:  Problem in SLASQ2.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  The base representations are required to suffer very little
  element growth and consequently define all their eigenvalues to
  high relative accuracy.</pre> </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaf557670fb7f0616fb74b6af8cae353b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarrf </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>LD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>CLSTRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>CLEND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WGAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPDIAM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CLGAPL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CLGAPR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DPLUS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>LPLUS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRF</b> finds a new relatively robust representation such that at least one of the eigenvalues is relatively isolated. </p>
<p> 
 Download SLARRF + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrf.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrf.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrf.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Given the initial representation L D L^T and its cluster of close
 eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
 W( CLEND ), SLARRF finds a new relatively robust representation
 L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
 eigenvalues of L(+) D(+) L(+)^T is relatively isolated.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix (subblock, if the matrix splitted).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The N diagonal elements of the diagonal matrix D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td><pre class="fragment">          L is REAL array, dimension (N-1)
          The (N-1) subdiagonal elements of the unit bidiagonal
          matrix L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LD</td><td><pre class="fragment">          LD is REAL array, dimension (N-1)
          The (N-1) elements L(i)*D(i).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLSTRT</td><td><pre class="fragment">          CLSTRT is INTEGER
          The index of the first eigenvalue in the cluster.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLEND</td><td><pre class="fragment">          CLEND is INTEGER
          The index of the last eigenvalue in the cluster.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension
          dimension is &gt;=  (CLEND-CLSTRT+1)
          The eigenvalue APPROXIMATIONS of L D L^T in ascending order.
          W( CLSTRT ) through W( CLEND ) form the cluster of relatively
          close eigenalues.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WGAP</td><td><pre class="fragment">          WGAP is REAL array, dimension
          dimension is &gt;=  (CLEND-CLSTRT+1)
          The separation from the right neighbor eigenvalue in W.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is REAL array, dimension
          dimension is &gt;=  (CLEND-CLSTRT+1)
          WERR contain the semiwidth of the uncertainty
          interval of the corresponding eigenvalue APPROXIMATION in W</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPDIAM</td><td><pre class="fragment">          SPDIAM is REAL
          estimate of the spectral diameter obtained from the
          Gerschgorin intervals</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLGAPL</td><td><pre class="fragment">          CLGAPL is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CLGAPR</td><td><pre class="fragment">          CLGAPR is REAL
          absolute gap on each end of the cluster.
          Set by the calling routine to protect against shifts too close
          to eigenvalues outside the cluster.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot allowed in the Sturm sequence.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SIGMA</td><td><pre class="fragment">          SIGMA is REAL
          The shift used to form L(+) D(+) L(+)^T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DPLUS</td><td><pre class="fragment">          DPLUS is REAL array, dimension (N)
          The N diagonal elements of the diagonal matrix D(+).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LPLUS</td><td><pre class="fragment">          LPLUS is REAL array, dimension (N-1)
          The first (N-1) elements of LPLUS contain the subdiagonal
          elements of the unit bidiagonal matrix L(+).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          Signals processing OK (=0) or failure (=1)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga86d0ea9b6f2d76876a8f0c0e1a12868c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarrj </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IFIRST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILAST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>OFFSET</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SPDIAM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRJ</b> performs refinement of the initial estimates of the eigenvalues of the matrix T. </p>
<p> 
 Download SLARRJ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrj.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrj.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrj.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Given the initial eigenvalue approximations of T, SLARRJ
 does  bisection to refine the eigenvalues of T,
 W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
 guesses for these eigenvalues are input in W, the corresponding estimate
 of the error in these guesses in WERR. During bisection, intervals
 [left, right] are maintained by storing their mid-points and
 semi-widths in the arrays W and WERR respectively.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The N diagonal elements of T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is REAL array, dimension (N-1)
          The Squares of the (N-1) subdiagonal elements of T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IFIRST</td><td><pre class="fragment">          IFIRST is INTEGER
          The index of the first eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILAST</td><td><pre class="fragment">          ILAST is INTEGER
          The index of the last eigenvalue to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RTOL</td><td><pre class="fragment">          RTOL is REAL
          Tolerance for the convergence of the bisection intervals.
          An interval [LEFT,RIGHT] has converged if
          RIGHT-LEFT.LT.RTOL*MAX(|LEFT|,|RIGHT|).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OFFSET</td><td><pre class="fragment">          OFFSET is INTEGER
          Offset for the arrays W and WERR, i.e., the IFIRST-OFFSET
          through ILAST-OFFSET elements of these arrays are to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          On input, W( IFIRST-OFFSET ) through W( ILAST-OFFSET ) are
          estimates of the eigenvalues of L D L^T indexed IFIRST through
          ILAST.
          On output, these estimates are refined.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is REAL array, dimension (N)
          On input, WERR( IFIRST-OFFSET ) through WERR( ILAST-OFFSET ) are
          the errors in the estimates of the corresponding elements in W.
          On output, these errors are refined.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (2*N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SPDIAM</td><td><pre class="fragment">          SPDIAM is REAL
          The spectral diameter of T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          Error flag.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gac34836aa49da0ba1ef397af5a5590e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarrk </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>GL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>GU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>PIVMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RELTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>WERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRK</b> computes one eigenvalue of a symmetric tridiagonal matrix T to suitable accuracy. </p>
<p> 
 Download SLARRK + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrk.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrk.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrk.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLARRK computes one eigenvalue of a symmetric tridiagonal
 matrix T to suitable accuracy. This is an auxiliary code to be
 called from SSTEMR.

 To avoid overflow, the matrix must be scaled so that its
 largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
 accuracy, it should not be much smaller than that.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford
 University, July 21, 1966.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the tridiagonal matrix T.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IW</td><td><pre class="fragment">          IW is INTEGER
          The index of the eigenvalues to be returned.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GL</td><td><pre class="fragment">          GL is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GU</td><td><pre class="fragment">          GU is REAL
          An upper and a lower bound on the eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The n diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2</td><td><pre class="fragment">          E2 is REAL array, dimension (N-1)
          The (n-1) squared off-diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVMIN</td><td><pre class="fragment">          PIVMIN is REAL
          The minimum pivot allowed in the Sturm sequence for T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RELTOL</td><td><pre class="fragment">          RELTOL is REAL
          The minimum relative width of an interval.  When an interval
          is narrower than RELTOL times the larger (in
          magnitude) endpoint, then it is considered to be
          sufficiently small, i.e., converged.  Note: this should
          always be at least radix*machine epsilon.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WERR</td><td><pre class="fragment">          WERR is REAL
          The error bound on the corresponding eigenvalue approximation
          in W.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:       Eigenvalue converged
          = -1:      Eigenvalue did NOT converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Internal Parameters: </dt><dd><pre class="fragment">  FUDGE   REAL            , default = 2
          A "fudge factor" to widen the Gershgorin intervals.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga37c1c1075019c75d8975e952a09516d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slarrr </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARRR</b> performs tests to decide whether the symmetric tridiagonal matrix T warrants expensive computations which guarantee high relative accuracy in the eigenvalues. </p>
<p> 
 Download SLARRR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarrr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarrr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarrr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Perform tests to decide whether the symmetric tridiagonal matrix T
 warrants expensive computations which guarantee high relative accuracy
 in the eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix. N &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
          The N diagonal elements of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (N)
          On entry, the first (N-1) entries contain the subdiagonal
          elements of the tridiagonal matrix T; E(N) is set to ZERO.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          INFO = 0(default) : the matrix warrants computations preserving
                              relative accuracy.
          INFO = 1          : the matrix warrants computations guaranteeing
                              only absolute accuracy.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Beresford Parlett, University of California, Berkeley, USA <br />
 Jim Demmel, University of California, Berkeley, USA <br />
 Inderjit Dhillon, University of Texas, Austin, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Christof Voemel, University of California, Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gaee6602fc79f90ffd7113154b87088302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slartg </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARTG</b> generates a plane rotation with real cosine and real sine. </p>
<p> 
 Download SLARTG + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slartg.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slartg.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slartg.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLARTG generate a plane rotation so that

    [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
    [ -SN  CS  ]     [ G ]     [ 0 ]

 This is a slower, more accurate version of the BLAS1 routine SROTG,
 with the following other differences:
    F and G are unchanged on return.
    If G=0, then CS=1 and SN=0.
    If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
       floating point operations (saves work in SBDSQR when
       there are zeros on the diagonal).

 If F exceeds G in magnitude, CS will be positive.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is REAL
          The first component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is REAL
          The second component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS</td><td><pre class="fragment">          CS is REAL
          The cosine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SN</td><td><pre class="fragment">          SN is REAL
          The sine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is REAL
          The nonzero component of the rotated vector.

  This version has a few statements commented out for thread safety
  (machine parameters are computed on each entry). 10 feb 03, SJH.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf196d96b7826d09326521d4a30b4bca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slartgp </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARTGP</b> generates a plane rotation so that the diagonal is nonnegative. </p>
<p> 
 Download SLARTGP + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slartgp.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slartgp.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slartgp.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLARTGP generates a plane rotation so that

    [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
    [ -SN  CS  ]     [ G ]     [ 0 ]

 This is a slower, more accurate version of the Level 1 BLAS routine SROTG,
 with the following other differences:
    F and G are unchanged on return.
    If G=0, then CS=(+/-)1 and SN=0.
    If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.

 The sign is chosen so that R &gt;= 0.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is REAL
          The first component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is REAL
          The second component of vector to be rotated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS</td><td><pre class="fragment">          CS is REAL
          The cosine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SN</td><td><pre class="fragment">          SN is REAL
          The sine of the rotation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is REAL
          The nonzero component of the rotated vector.

  This version has a few statements commented out for thread safety
  (machine parameters are computed on each entry). 10 feb 03, SJH.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ca61f3556928fc2698683460395d96c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slaruv </td>
          <td>(</td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( <a class="el" href="indexexpr_8h.html#ab427e2e2b4d6cec55fa088ea2a692ace">n</a> )&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLARUV</b> returns a vector of n random real numbers from a uniform distribution. </p>
<p> 
 Download SLARUV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaruv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaruv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaruv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLARUV returns a vector of n random real numbers from a uniform (0,1)
 distribution (n &lt;= 128).

 This is an auxiliary routine called by SLARNV and CLARNV.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator; the array
          elements must be between 0 and 4095, and ISEED(4) must be
          odd.
          On exit, the seed is updated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of random numbers to be generated. N &lt;= 128.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is REAL array, dimension (N)
          The generated random numbers.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  This routine uses a multiplicative congruential method with modulus
  2**48 and multiplier 33952834046453 (see G.S.Fishman,
  'Multiplicative congruential random number generators with modulus
  2**b: an exhaustive analysis for b = 32 and a partial analysis for
  b = 48', Math. Comp. 189, pp 331-344, 1990).

  48-bit integers are stored in 4 integer array elements with 12 bits
  per element. Hence the routine is portable across machines with
  integers of 32 bits or more.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7047efd8096db5f0724f79cad80e4127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slas2 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SSMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SSMAX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLAS2</b> computes singular values of a 2-by-2 triangular matrix. </p>
<p> 
 Download SLAS2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slas2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slas2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slas2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLAS2  computes the singular values of the 2-by-2 matrix
    [  F   G  ]
    [  0   H  ].
 On return, SSMIN is the smaller singular value and SSMAX is the
 larger singular value.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is REAL
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is REAL
          The (1,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td><pre class="fragment">          H is REAL
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMIN</td><td><pre class="fragment">          SSMIN is REAL
          The smaller singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMAX</td><td><pre class="fragment">          SSMAX is REAL
          The larger singular value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  Barring over/underflow, all output quantities are correct to within
  a few units in the last place (ulps), even in the absence of a guard
  digit in addition/subtraction.

  In IEEE arithmetic, the code works correctly if one matrix element is
  infinite.

  Overflow will not occur unless the largest singular value itself
  overflows, or is within a few ulps of overflow. (On machines with
  partial overflow, like the Cray, overflow may occur if the largest
  singular value is within a factor of 2 of overflow.)

  Underflow is harmless if underflow is gradual. Otherwise, results
  may correspond to a matrix modified by perturbations of size near
  the underflow threshold.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga11e6ce67ce97ca5b0a3a7bc5645a09d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slascl </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CFROM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CTO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASCL</b> multiplies a general rectangular matrix by a real scalar defined as cto/cfrom. </p>
<p> 
 Download SLASCL + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slascl.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slascl.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slascl.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASCL multiplies the M by N real matrix A by the real scalar
 CTO/CFROM.  This is done without over/underflow as long as the final
 result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
 A may be full, upper triangular, lower triangular, upper Hessenberg,
 or banded.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TYPE</td><td><pre class="fragment">          TYPE is CHARACTER*1
          TYPE indices the storage type of the input matrix.
          = 'G':  A is a full matrix.
          = 'L':  A is a lower triangular matrix.
          = 'U':  A is an upper triangular matrix.
          = 'H':  A is an upper Hessenberg matrix.
          = 'B':  A is a symmetric band matrix with lower bandwidth KL
                  and upper bandwidth KU and with the only the lower
                  half stored.
          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                  and upper bandwidth KU and with the only the upper
                  half stored.
          = 'Z':  A is a band matrix with lower bandwidth KL and upper
                  bandwidth KU. See SGBTRF for storage details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
          The lower bandwidth of A.  Referenced only if TYPE = 'B',
          'Q' or 'Z'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
          The upper bandwidth of A.  Referenced only if TYPE = 'B',
          'Q' or 'Z'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CFROM</td><td><pre class="fragment">          CFROM is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CTO</td><td><pre class="fragment">          CTO is REAL

          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
          without over/underflow if the final result CTO*A(I,J)/CFROM
          can be represented without over/underflow.  CFROM must be
          nonzero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA,N)
          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
          storage type.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          0  - successful exit
          &lt;0 - if INFO = -i, the i-th argument had an illegal value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a8da896f51f0ce43896b61efa3d0381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd0 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SMLSIZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD0</b> computes the singular values of a real upper bidiagonal n-by-m matrix B with diagonal d and off-diagonal e. Used by sbdsdc. </p>
<p> 
 Download SLASD0 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd0.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd0.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd0.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Using a divide and conquer approach, SLASD0 computes the singular
 value decomposition (SVD) of a real upper bidiagonal N-by-M
 matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
 The algorithm computes orthogonal matrices U and VT such that
 B = U * S * VT. The singular values S are overwritten on D.

 A related subroutine, SLASDA, computes only the singular values,
 and optionally, the singular vectors in compact form.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
         On entry, the row dimension of the upper bidiagonal matrix.
         This is also the dimension of the main diagonal array D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         Specifies the column dimension of the bidiagonal matrix.
         = 0: The bidiagonal matrix has column dimension M = N;
         = 1: The bidiagonal matrix has column dimension M = N+1;</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
         On entry D contains the main diagonal of the bidiagonal
         matrix.
         On exit D, if INFO = 0, contains its singular values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension (M-1)
         Contains the subdiagonal entries of the bidiagonal matrix.
         On exit, E has been destroyed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is REAL array, dimension at least (LDQ, N)
         On exit, U contains the left singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         On entry, leading dimension of U.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is REAL array, dimension at least (LDVT, M)
         On exit, VT**T contains the right singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         On entry, leading dimension of VT.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SMLSIZ</td><td><pre class="fragment">          SMLSIZ is INTEGER
         On entry, maximum size of the subproblems at the
         bottom of the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (8*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (3*M**2+2*M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga882db55a5643e6b13ebbf68635f3946c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd1 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD1</b> computes the SVD of an upper bidiagonal matrix B of the specified size. Used by sbdsdc. </p>
<p> 
 Download SLASD1 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd1.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd1.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd1.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
 where N = NL + NR + 1 and M = N + SQRE. SLASD1 is called from SLASD0.

 A related subroutine SLASD7 handles the case in which the singular
 values (and the singular vectors in factored form) are desired.

 SLASD1 computes the SVD as follows:

               ( D1(in)    0    0       0 )
   B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
               (   0       0   D2(in)   0 )

     = U(out) * ( D(out) 0) * VT(out)

 where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
 with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
 elsewhere; and the entry b is empty if SQRE = 0.

 The left singular vectors of the original matrix are stored in U, and
 the transpose of the right singular vectors are stored in VT, and the
 singular values are in D.  The algorithm consists of three stages:

    The first stage consists of deflating the size of the problem
    when there are multiple singular values or when there are zeros in
    the Z vector.  For each such occurence the dimension of the
    secular equation problem is reduced by one.  This stage is
    performed by the routine SLASD2.

    The second stage consists of calculating the updated
    singular values. This is done by finding the square roots of the
    roots of the secular equation via the routine SLASD4 (as called
    by SLASD3). This routine also calculates the singular vectors of
    the current problem.

    The final stage consists of computing the updated singular vectors
    directly using the updated singular values.  The singular vectors
    for the current problem are multiplied with the singular vectors
    from the overall problem.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has row dimension N = NL + NR + 1,
         and column dimension M = N + SQRE.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (NL+NR+1).
         N = NL+NR+1
         On entry D(1:NL,1:NL) contains the singular values of the
         upper block; and D(NL+2:N) contains the singular values of
         the lower block. On exit D(1:N) contains the singular values
         of the modified matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td><pre class="fragment">          U is REAL array, dimension (LDU,N)
         On entry U(1:NL, 1:NL) contains the left singular vectors of
         the upper block; U(NL+2:N, NL+2:N) contains the left singular
         vectors of the lower block. On exit U contains the left
         singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         The leading dimension of the array U.  LDU &gt;= max( 1, N ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is REAL array, dimension (LDVT,M)
         where M = N + SQRE.
         On entry VT(1:NL+1, 1:NL+1)**T contains the right singular
         vectors of the upper block; VT(NL+2:M, NL+2:M)**T contains
         the right singular vectors of the lower block. On exit
         VT**T contains the right singular vectors of the
         bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         The leading dimension of the array VT.  LDVT &gt;= max( 1, M ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array, dimension (N)
         This contains the permutation which will reintegrate the
         subproblem just solved back into sorted order, i.e.
         D( IDXQ( I = 1, N ) ) will be in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (4*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (3*M**2+2*M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga33ea099005fc608ad8a5b79662e02b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd2 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu2, * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvt2, * )&#160;</td>
          <td class="paramname"><em>VT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>COLTYP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD2</b> merges the two sets of singular values together into a single sorted set. Used by sbdsdc. </p>
<p> 
 Download SLASD2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASD2 merges the two sets of singular values together into a single
 sorted set.  Then it tries to deflate the size of the problem.
 There are two ways in which deflation can occur:  when two or more
 singular values are close together or if there is a tiny entry in the
 Z vector.  For each such occurrence the order of the related secular
 equation problem is reduced by one.

 SLASD2 is called from SLASD1.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has N = NL + NR + 1 rows and
         M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         Contains the dimension of the non-deflated matrix,
         This is the order of the related secular equation. 1 &lt;= K &lt;=N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
         On entry D contains the singular values of the two submatrices
         to be combined.  On exit D contains the trailing (N-K) updated
         singular values (those which were deflated) sorted into
         increasing order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension (N)
         On exit Z contains the updating row vector in the secular
         equation.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td><pre class="fragment">          U is REAL array, dimension (LDU,N)
         On entry U contains the left singular vectors of two
         submatrices in the two square blocks with corners at (1,1),
         (NL, NL), and (NL+2, NL+2), (N,N).
         On exit U contains the trailing (N-K) updated left singular
         vectors (those which were deflated) in its last N-K columns.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         The leading dimension of the array U.  LDU &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is REAL array, dimension (LDVT,M)
         On entry VT**T contains the right singular vectors of two
         submatrices in the two square blocks with corners at (1,1),
         (NL+1, NL+1), and (NL+2, NL+2), (M,M).
         On exit VT**T contains the trailing (N-K) updated right singular
         vectors (those which were deflated) in its last N-K columns.
         In case SQRE =1, the last row of VT spans the right null
         space.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         The leading dimension of the array VT.  LDVT &gt;= M.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is REAL array, dimension (N)
         Contains a copy of the diagonal elements (K-1 singular values
         and one zero) in the secular equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is REAL array, dimension (LDU2,N)
         Contains a copy of the first K-1 left singular vectors which
         will be used by SLASD3 in a matrix multiply (SGEMM) to solve
         for the new left singular vectors. U2 is arranged into four
         blocks. The first block contains a column with 1 at NL+1 and
         zero everywhere else; the second block contains non-zero
         entries only at and above NL; the third contains non-zero
         entries only below NL+1; and the fourth is dense.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU2</td><td><pre class="fragment">          LDU2 is INTEGER
         The leading dimension of the array U2.  LDU2 &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT2</td><td><pre class="fragment">          VT2 is REAL array, dimension (LDVT2,N)
         VT2**T contains a copy of the first K right singular vectors
         which will be used by SLASD3 in a matrix multiply (SGEMM) to
         solve for the new right singular vectors. VT2 is arranged into
         three blocks. The first block contains a row that corresponds
         to the special 0 diagonal element in SIGMA; the second block
         contains non-zeros only at and before NL +1; the third block
         contains non-zeros only at and after  NL +2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT2</td><td><pre class="fragment">          LDVT2 is INTEGER
         The leading dimension of the array VT2.  LDVT2 &gt;= M.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXP</td><td><pre class="fragment">          IDXP is INTEGER array, dimension (N)
         This will contain the permutation used to place deflated
         values of D at the end of the array. On output IDXP(2:K)
         points to the nondeflated D-values and IDXP(K+1:N)
         points to the deflated singular values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDX</td><td><pre class="fragment">          IDX is INTEGER array, dimension (N)
         This will contain the permutation used to sort the contents of
         D into ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXC</td><td><pre class="fragment">          IDXC is INTEGER array, dimension (N)
         This will contain the permutation used to arrange the columns
         of the deflated U matrix into three groups:  the first group
         contains non-zero entries only at and above NL, the second
         contains non-zero entries only below NL+2, and the third is
         dense.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array, dimension (N)
         This contains the permutation which separately sorts the two
         sub-problems in D into ascending order.  Note that entries in
         the first hlaf of this permutation must first be moved one
         position backward; and entries in the second half
         must first have NL+1 added to their values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">COLTYP</td><td><pre class="fragment">          COLTYP is INTEGER array, dimension (N)
         As workspace, this will contain a label which will indicate
         which of the following types a column in the U2 matrix or a
         row in the VT2 matrix is:
         1 : non-zero in the upper half only
         2 : non-zero in the lower half only
         3 : dense
         4 : deflated

         On exit, it is an array of dimension 4, with COLTYP(I) being
         the dimension of the I-th type columns.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga4359e33241fa45b40ca5b25e6bee9054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd3 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu2, * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvt2, * )&#160;</td>
          <td class="paramname"><em>VT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>CTOT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD3</b> finds all square roots of the roots of the secular equation, as defined by the values in D and Z, and then updates the singular vectors by matrix multiplication. Used by sbdsdc. </p>
<p> 
 Download SLASD3 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd3.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd3.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd3.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASD3 finds all the square roots of the roots of the secular
 equation, as defined by the values in D and Z.  It makes the
 appropriate calls to SLASD4 and then updates the singular
 vectors by matrix multiplication.

 This code makes very mild assumptions about floating point
 arithmetic. It will work on machines with a guard digit in
 add/subtract, or on those binary machines without guard digits
 which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
 It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 SLASD3 is called from SLASD1.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has N = NL + NR + 1 rows and
         M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         The size of the secular equation, 1 =&lt; K = &lt; N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension(K)
         On exit the square roots of the roots of the secular equation,
         in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is REAL array,
                     dimension at least (LDQ,K).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
         The leading dimension of the array Q.  LDQ &gt;= K.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is REAL array, dimension(K)
         The first K elements of this array contain the old roots
         of the deflated updating problem.  These are the poles
         of the secular equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is REAL array, dimension (LDU, N)
         The last N - K columns of this matrix contain the deflated
         left singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
         The leading dimension of the array U.  LDU &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is REAL array, dimension (LDU2, N)
         The first K columns of this matrix contain the non-deflated
         left singular vectors for the split problem.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU2</td><td><pre class="fragment">          LDU2 is INTEGER
         The leading dimension of the array U2.  LDU2 &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is REAL array, dimension (LDVT, M)
         The last M - K columns of VT**T contain the deflated
         right singular vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
         The leading dimension of the array VT.  LDVT &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT2</td><td><pre class="fragment">          VT2 is REAL array, dimension (LDVT2, N)
         The first K columns of VT2**T contain the non-deflated
         right singular vectors for the split problem.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT2</td><td><pre class="fragment">          LDVT2 is INTEGER
         The leading dimension of the array VT2.  LDVT2 &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDXC</td><td><pre class="fragment">          IDXC is INTEGER array, dimension (N)
         The permutation used to arrange the columns of U (and rows of
         VT) into three groups:  the first group contains non-zero
         entries only at and above (or before) NL +1; the second
         contains non-zero entries only at and below (or after) NL+2;
         and the third is dense. The first column of U and the row of
         VT are treated separately, however.

         The rows of the singular vectors found by SLASD4
         must be likewise permuted before the matrix multiplies can
         take place.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CTOT</td><td><pre class="fragment">          CTOT is INTEGER array, dimension (4)
         A count of the total number of the various types of columns
         in U (or rows in VT), as described in IDXC. The fourth column
         type is any column which has been deflated.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension (K)
         The first K elements of this array contain the components
         of the deflation-adjusted updating row vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
         = 0:  successful exit.
         &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
         &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga6680aa4ad62702cd9a00d7530c8ab53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd4 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DELTA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RHO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD4</b> computes the square root of the i-th updated eigenvalue of a positive symmetric rank-one modification to a positive diagonal matrix. Used by sbdsdc. </p>
<p> 
 Download SLASD4 + dependencies
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd4.f">
 [TGZ]</a>
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd4.f">
 [ZIP]</a>
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd4.f">
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This subroutine computes the square root of the I-th updated
 eigenvalue of a positive symmetric rank-one modification to
 a positive diagonal matrix whose entries are given as the squares
 of the corresponding entries in the array d, and that

        0 &lt;= D(i) &lt; D(j)  for  i &lt; j

 and that RHO &gt; 0. This is arranged by the calling routine, and is
 no loss in generality.  The rank-one modified system is thus

        diag( D ) * diag( D ) +  RHO * Z * Z_transpose.

 where we assume the Euclidean norm of Z is 1.

 The method consists of approximating the rational functions in the
 secular equation by simpler interpolating rational functions.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
         The length of all arrays.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">          I is INTEGER
         The index of the eigenvalue to be computed.  1 &lt;= I &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension ( N )
         The original eigenvalues.  It is assumed that they are in
         order, 0 &lt;= D(I) &lt; D(J)  for I &lt; J.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension ( N )
         The components of the updating vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DELTA</td><td><pre class="fragment">          DELTA is REAL array, dimension ( N )
         If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
         component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
         contains the information necessary to construct the
         (singular) eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RHO</td><td><pre class="fragment">          RHO is REAL
         The scalar in the symmetric updating formula.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SIGMA</td><td><pre class="fragment">          SIGMA is REAL
         The computed sigma_I, the I-th updated eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension ( N )
         If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
         component.  If N = 1, then WORK( 1 ) = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
         = 0:  successful exit
         &gt; 0:  if INFO = 1, the updating process failed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Internal Parameters: </dt><dd><pre class="fragment">  Logical variable ORGATI (origin-at-i?) is used for distinguishing
  whether D(i) or D(i+1) is treated as the origin.

            ORGATI = .true.    origin at i
            ORGATI = .false.   origin at i+1

  Logical variable SWTCH3 (switch-for-3-poles?) is for noting
  if we are working with THREE poles!

  MAXIT is the maximum number of iterations allowed for each
  eigenvalue.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga19de62ad22e8492c93ac450198557d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd5 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>DELTA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RHO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( 2 )&#160;</td>
          <td class="paramname"><em>WORK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD5</b> computes the square root of the i-th eigenvalue of a positive symmetric rank-one modification of a 2-by-2 diagonal matrix. Used by sbdsdc. </p>
<p> 
 Download SLASD5 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd5.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd5.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd5.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This subroutine computes the square root of the I-th eigenvalue
 of a positive symmetric rank-one modification of a 2-by-2 diagonal
 matrix

            diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .

 The diagonal entries in the array D are assumed to satisfy

            0 &lt;= D(i) &lt; D(j)  for  i &lt; j .

 We also assume RHO &gt; 0 and that the Euclidean norm of the vector
 Z is one.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">          I is INTEGER
         The index of the eigenvalue to be computed.  I = 1 or I = 2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (2)
         The original eigenvalues.  We assume 0 &lt;= D(1) &lt; D(2).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension (2)
         The components of the updating vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DELTA</td><td><pre class="fragment">          DELTA is REAL array, dimension (2)
         Contains (D(j) - sigma_I) in its  j-th component.
         The vector DELTA contains the information necessary
         to construct the eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RHO</td><td><pre class="fragment">          RHO is REAL
         The scalar in the symmetric updating formula.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is REAL
         The computed sigma_I, the I-th updated eigenvalue.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (2)
         WORK contains (D(j) + sigma_I) in its  j-th component.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga49655eb79b1745feabd7e9069f05e485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd6 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PERM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>GIVPTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>GIVCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldgnum, * )&#160;</td>
          <td class="paramname"><em>GIVNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldgnum, * )&#160;</td>
          <td class="paramname"><em>POLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD6</b> computes the SVD of an updated upper bidiagonal matrix obtained by merging two smaller ones by appending a row. Used by sbdsdc. </p>
<p> 
 Download SLASD6 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd6.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd6.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd6.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASD6 computes the SVD of an updated upper bidiagonal matrix B
 obtained by merging two smaller ones by appending a row. This
 routine is used only for the problem which requires all singular
 values and optionally singular vector matrices in factored form.
 B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
 A related subroutine, SLASD1, handles the case in which all singular
 values and singular vectors of the bidiagonal matrix are desired.

 SLASD6 computes the SVD as follows:

               ( D1(in)    0    0       0 )
   B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
               (   0       0   D2(in)   0 )

     = U(out) * ( D(out) 0) * VT(out)

 where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
 with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
 elsewhere; and the entry b is empty if SQRE = 0.

 The singular values of B can be computed using D1, D2, the first
 components of all the right singular vectors of the lower block, and
 the last components of all the right singular vectors of the upper
 block. These components are stored and updated in VF and VL,
 respectively, in SLASD6. Hence U and VT are not explicitly
 referenced.

 The singular values are stored in D. The algorithm consists of two
 stages:

       The first stage consists of deflating the size of the problem
       when there are multiple singular values or if there is a zero
       in the Z vector. For each such occurence the dimension of the
       secular equation problem is reduced by one. This stage is
       performed by the routine SLASD7.

       The second stage consists of calculating the updated
       singular values. This is done by finding the roots of the
       secular equation via the routine SLASD4 (as called by SLASD8).
       This routine also updates VF and VL and computes the distances
       between the updated singular values and the old singular
       values.

 SLASD6 is called from SLASDA.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
         Specifies whether singular vectors are to be computed in
         factored form:
         = 0: Compute singular values only.
         = 1: Compute singular vectors in factored form as well.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block.  NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block.  NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has row dimension N = NL + NR + 1,
         and column dimension M = N + SQRE.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (NL+NR+1).
         On entry D(1:NL,1:NL) contains the singular values of the
         upper block, and D(NL+2:N) contains the singular values
         of the lower block. On exit D(1:N) contains the singular
         values of the modified matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VF</td><td><pre class="fragment">          VF is REAL array, dimension (M)
         On entry, VF(1:NL+1) contains the first components of all
         right singular vectors of the upper block; and VF(NL+2:M)
         contains the first components of all right singular vectors
         of the lower block. On exit, VF contains the first components
         of all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL array, dimension (M)
         On entry, VL(1:NL+1) contains the  last components of all
         right singular vectors of the upper block; and VL(NL+2:M)
         contains the last components of all right singular vectors of
         the lower block. On exit, VL contains the last components of
         all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array, dimension (N)
         This contains the permutation which will reintegrate the
         subproblem just solved back into sorted order, i.e.
         D( IDXQ( I = 1, N ) ) will be in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PERM</td><td><pre class="fragment">          PERM is INTEGER array, dimension ( N )
         The permutations (from deflation and sorting) to be applied
         to each block. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVPTR</td><td><pre class="fragment">          GIVPTR is INTEGER
         The number of Givens rotations which took place in this
         subproblem. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVCOL</td><td><pre class="fragment">          GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
         Each pair of numbers indicates a pair of columns to take place
         in a Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGCOL</td><td><pre class="fragment">          LDGCOL is INTEGER
         leading dimension of GIVCOL, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVNUM</td><td><pre class="fragment">          GIVNUM is REAL array, dimension ( LDGNUM, 2 )
         Each number indicates the C or S value to be used in the
         corresponding Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGNUM</td><td><pre class="fragment">          LDGNUM is INTEGER
         The leading dimension of GIVNUM and POLES, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">POLES</td><td><pre class="fragment">          POLES is REAL array, dimension ( LDGNUM, 2 )
         On exit, POLES(1,*) is an array containing the new singular
         values obtained from solving the secular equation, and
         POLES(2,*) is an array containing the poles in the secular
         equation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFL</td><td><pre class="fragment">          DIFL is REAL array, dimension ( N )
         On exit, DIFL(I) is the distance between I-th updated
         (undeflated) singular value and the I-th (undeflated) old
         singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFR</td><td><pre class="fragment">          DIFR is REAL array,
                  dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
                  dimension ( N ) if ICOMPQ = 0.
         On exit, DIFR(I, 1) is the distance between I-th updated
         (undeflated) singular value and the I+1-th (undeflated) old
         singular value.

         If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
         normalizing factors for the right singular vector matrix.

         See SLASD8 for details on DIFL and DIFR.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension ( M )
         The first elements of this array contain the components
         of the deflation-adjusted updating row vector.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         Contains the dimension of the non-deflated matrix,
         This is the order of the related secular equation. 1 &lt;= K &lt;=N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL
         C contains garbage if SQRE =0 and the C-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL
         S contains garbage if SQRE =0 and the S-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension ( 4 * M )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension ( 3 * N )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga506889eb5029bb8325b9b2ac02a62bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd7 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>ZW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VFW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VLW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IDXQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PERM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>GIVPTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>GIVCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldgnum, * )&#160;</td>
          <td class="paramname"><em>GIVNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD7</b> merges the two sets of singular values together into a single sorted set. Then it tries to deflate the size of the problem. Used by sbdsdc. </p>
<p> 
 Download SLASD7 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd7.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd7.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd7.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASD7 merges the two sets of singular values together into a single
 sorted set. Then it tries to deflate the size of the problem. There
 are two ways in which deflation can occur:  when two or more singular
 values are close together or if there is a tiny entry in the Z
 vector. For each such occurrence the order of the related
 secular equation problem is reduced by one.

 SLASD7 is called from SLASD6.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
          Specifies whether singular vectors are to be computed
          in compact form, as follows:
          = 0: Compute singular values only.
          = 1: Compute singular vectors of upper
               bidiagonal matrix in compact form.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NL</td><td><pre class="fragment">          NL is INTEGER
         The row dimension of the upper block. NL &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NR</td><td><pre class="fragment">          NR is INTEGER
         The row dimension of the lower block. NR &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         = 0: the lower block is an NR-by-NR square matrix.
         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

         The bidiagonal matrix has
         N = NL + NR + 1 rows and
         M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
         Contains the dimension of the non-deflated matrix, this is
         the order of the related secular equation. 1 &lt;= K &lt;=N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension ( N )
         On entry D contains the singular values of the two submatrices
         to be combined. On exit D contains the trailing (N-K) updated
         singular values (those which were deflated) sorted into
         increasing order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension ( M )
         On exit Z contains the updating row vector in the secular
         equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ZW</td><td><pre class="fragment">          ZW is REAL array, dimension ( M )
         Workspace for Z.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VF</td><td><pre class="fragment">          VF is REAL array, dimension ( M )
         On entry, VF(1:NL+1) contains the first components of all
         right singular vectors of the upper block; and VF(NL+2:M)
         contains the first components of all right singular vectors
         of the lower block. On exit, VF contains the first components
         of all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VFW</td><td><pre class="fragment">          VFW is REAL array, dimension ( M )
         Workspace for VF.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL array, dimension ( M )
         On entry, VL(1:NL+1) contains the  last components of all
         right singular vectors of the upper block; and VL(NL+2:M)
         contains the last components of all right singular vectors
         of the lower block. On exit, VL contains the last components
         of all right singular vectors of the bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VLW</td><td><pre class="fragment">          VLW is REAL array, dimension ( M )
         Workspace for VL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL
         Contains the diagonal element associated with the added row.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL
         Contains the off-diagonal element associated with the added
         row.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is REAL array, dimension ( N )
         Contains a copy of the diagonal elements (K-1 singular values
         and one zero) in the secular equation.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDX</td><td><pre class="fragment">          IDX is INTEGER array, dimension ( N )
         This will contain the permutation used to sort the contents of
         D into ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IDXP</td><td><pre class="fragment">          IDXP is INTEGER array, dimension ( N )
         This will contain the permutation used to place deflated
         values of D at the end of the array. On output IDXP(2:K)
         points to the nondeflated D-values and IDXP(K+1:N)
         points to the deflated singular values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDXQ</td><td><pre class="fragment">          IDXQ is INTEGER array, dimension ( N )
         This contains the permutation which separately sorts the two
         sub-problems in D into ascending order.  Note that entries in
         the first half of this permutation must first be moved one
         position backward; and entries in the second half
         must first have NL+1 added to their values.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PERM</td><td><pre class="fragment">          PERM is INTEGER array, dimension ( N )
         The permutations (from deflation and sorting) to be applied
         to each singular block. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVPTR</td><td><pre class="fragment">          GIVPTR is INTEGER
         The number of Givens rotations which took place in this
         subproblem. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVCOL</td><td><pre class="fragment">          GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
         Each pair of numbers indicates a pair of columns to take place
         in a Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGCOL</td><td><pre class="fragment">          LDGCOL is INTEGER
         The leading dimension of GIVCOL, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVNUM</td><td><pre class="fragment">          GIVNUM is REAL array, dimension ( LDGNUM, 2 )
         Each number indicates the C or S value to be used in the
         corresponding Givens rotation. Not referenced if ICOMPQ = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGNUM</td><td><pre class="fragment">          LDGNUM is INTEGER
         The leading dimension of GIVNUM, must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL
         C contains garbage if SQRE =0 and the C-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL
         S contains garbage if SQRE =0 and the S-value of a Givens
         rotation related to the right null space if SQRE = 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
         = 0:  successful exit.
         &lt; 0:  if INFO = -i, the i-th argument had an illegal value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gac4e0b8da65a5d9493e17f46cd010e6cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasd8 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lddifr, * )&#160;</td>
          <td class="paramname"><em>DIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDDIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>DSIGMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASD8</b> finds the square roots of the roots of the secular equation, and stores, for each element in D, the distance to its two nearest poles. Used by sbdsdc. </p>
<p> 
 Download SLASD8 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasd8.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasd8.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasd8.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASD8 finds the square roots of the roots of the secular equation,
 as defined by the values in DSIGMA and Z. It makes the appropriate
 calls to SLASD4, and stores, for each  element in D, the distance
 to its two nearest poles (elements in DSIGMA). It also updates
 the arrays VF and VL, the first and last components of all the
 right singular vectors of the original bidiagonal matrix.

 SLASD8 is called from SLASD6.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
          Specifies whether singular vectors are to be computed in
          factored form in the calling routine:
          = 0: Compute singular values only.
          = 1: Compute singular vectors in factored form as well.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
          The number of terms in the rational function to be solved
          by SLASD4.  K &gt;= 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension ( K )
          On output, D contains the updated singular values.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension ( K )
          On entry, the first K elements of this array contain the
          components of the deflation-adjusted updating row vector.
          On exit, Z is updated.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VF</td><td><pre class="fragment">          VF is REAL array, dimension ( K )
          On entry, VF contains  information passed through DBEDE8.
          On exit, VF contains the first K components of the first
          components of all right singular vectors of the bidiagonal
          matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL array, dimension ( K )
          On entry, VL contains  information passed through DBEDE8.
          On exit, VL contains the first K components of the last
          components of all right singular vectors of the bidiagonal
          matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFL</td><td><pre class="fragment">          DIFL is REAL array, dimension ( K )
          On exit, DIFL(I) = D(I) - DSIGMA(I).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFR</td><td><pre class="fragment">          DIFR is REAL array,
                   dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
                   dimension ( K ) if ICOMPQ = 0.
          On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
          defined and will not be referenced.

          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
          normalizing factors for the right singular vector matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDIFR</td><td><pre class="fragment">          LDDIFR is INTEGER
          The leading dimension of DIFR, must be at least K.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">DSIGMA</td><td><pre class="fragment">          DSIGMA is REAL array, dimension ( K )
          On entry, the first K elements of this array contain the old
          roots of the deflated updating problem.  These are the poles
          of the secular equation.
          On exit, the elements of DSIGMA may be very slightly altered
          in value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension at least 3 * K</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gafe52aa918bfa2a863f122f39ae9e6404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasda </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ICOMPQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SMLSIZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>DIFL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>DIFR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>POLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>GIVPTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>GIVCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDGCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( ldgcol, * )&#160;</td>
          <td class="paramname"><em>PERM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>GIVNUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASDA</b> computes the singular value decomposition (SVD) of a real upper bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc. </p>
<p> 
 Download SLASDA + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasda.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasda.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasda.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> Using a divide and conquer approach, SLASDA computes the singular
 value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
 B with diagonal D and offdiagonal E, where M = N + SQRE. The
 algorithm computes the singular values in the SVD B = U * S * VT.
 The orthogonal matrices U and VT are optionally computed in
 compact form.

 A related subroutine, SLASD0, computes the singular values and
 the singular vectors in explicit form.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ICOMPQ</td><td><pre class="fragment">          ICOMPQ is INTEGER
         Specifies whether singular vectors are to be computed
         in compact form, as follows
         = 0: Compute singular values only.
         = 1: Compute singular vectors of upper bidiagonal
              matrix in compact form.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SMLSIZ</td><td><pre class="fragment">          SMLSIZ is INTEGER
         The maximum size of the subproblems at the bottom of the
         computation tree.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
         The row dimension of the upper bidiagonal matrix. This is
         also the dimension of the main diagonal array D.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
         Specifies the column dimension of the bidiagonal matrix.
         = 0: The bidiagonal matrix has column dimension M = N;
         = 1: The bidiagonal matrix has column dimension M = N + 1.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension ( N )
         On entry D contains the main diagonal of the bidiagonal
         matrix. On exit D, if INFO = 0, contains its singular values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array, dimension ( M-1 )
         Contains the subdiagonal entries of the bidiagonal matrix.
         On exit, E has been destroyed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is REAL array,
         dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
         singular vector matrices of all subproblems at the bottom
         level.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER, LDU = &gt; N.
         The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
         GIVNUM, and Z.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is REAL array,
         dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT**T contains the right
         singular vector matrices of all subproblems at the bottom
         level.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER array, dimension ( N )
         if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
         If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
         secular equation on the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFL</td><td><pre class="fragment">          DIFL is REAL array, dimension ( LDU, NLVL ),
         where NLVL = floor(log_2 (N/SMLSIZ))).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFR</td><td><pre class="fragment">          DIFR is REAL array,
                  dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
                  dimension ( N ) if ICOMPQ = 0.
         If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
         record distances between singular values on the I-th
         level and singular values on the (I -1)-th level, and
         DIFR(1:N, 2 * I ) contains the normalizing factors for
         the right singular vector matrix. See SLASD8 for details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array,
                  dimension ( LDU, NLVL ) if ICOMPQ = 1 and
                  dimension ( N ) if ICOMPQ = 0.
         The first K elements of Z(1, I) contain the components of
         the deflation-adjusted updating row vector for subproblems
         on the I-th level.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">POLES</td><td><pre class="fragment">          POLES is REAL array,
         dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
         POLES(1, 2*I) contain  the new and old singular values
         involved in the secular equations on the I-th level.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVPTR</td><td><pre class="fragment">          GIVPTR is INTEGER array,
         dimension ( N ) if ICOMPQ = 1, and not referenced if
         ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
         the number of Givens rotations performed on the I-th
         problem on the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVCOL</td><td><pre class="fragment">          GIVCOL is INTEGER array,
         dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
         GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
         of Givens rotations performed on the I-th level on the
         computation tree.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDGCOL</td><td><pre class="fragment">          LDGCOL is INTEGER, LDGCOL = &gt; N.
         The leading dimension of arrays GIVCOL and PERM.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PERM</td><td><pre class="fragment">          PERM is INTEGER array, dimension ( LDGCOL, NLVL )
         if ICOMPQ = 1, and not referenced
         if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
         permutations done on the I-th level of the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GIVNUM</td><td><pre class="fragment">          GIVNUM is REAL array,
         dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
         referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
         GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
         values of Givens rotations performed on the I-th level on
         the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL array,
         dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
         If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
         C( I ) contains the C-value of a Givens rotation related to
         the right null space of the I-th subproblem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL array, dimension ( N ) if
         ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
         and the I-th subproblem is not square, on exit, S( I )
         contains the S-value of a Givens rotation related to
         the right null space of the I-th subproblem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension
         (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (7*N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit.
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  if INFO = 1, a singular value did not converge</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gabb4a455a53f317631c56b07d4828eb28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasdq </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SQRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NCVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NCC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASDQ</b> computes the SVD of a real bidiagonal matrix with diagonal d and off-diagonal e. Used by sbdsdc. </p>
<p> 
 Download SLASDQ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasdq.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasdq.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasdq.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASDQ computes the singular value decomposition (SVD) of a real
 (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
 E, accumulating the transformations if desired. Letting B denote
 the input bidiagonal matrix, the algorithm computes orthogonal
 matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
 of P). The singular values S are overwritten on D.

 The input matrix U  is changed to U  * Q  if desired.
 The input matrix VT is changed to P**T * VT if desired.
 The input matrix C  is changed to Q**T * C  if desired.

 See "Computing  Small Singular Values of Bidiagonal Matrices With
 Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
 LAPACK Working Note #3, for a detailed description of the algorithm.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
        On entry, UPLO specifies whether the input bidiagonal matrix
        is upper or lower bidiagonal, and wether it is square are
        not.
           UPLO = 'U' or 'u'   B is upper bidiagonal.
           UPLO = 'L' or 'l'   B is lower bidiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SQRE</td><td><pre class="fragment">          SQRE is INTEGER
        = 0: then the input matrix is N-by-N.
        = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
             (N+1)-by-N if UPLU = 'L'.

        The bidiagonal matrix has
        N = NL + NR + 1 rows and
        M = N + SQRE &gt;= N columns.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
        On entry, N specifies the number of rows and columns
        in the matrix. N must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NCVT</td><td><pre class="fragment">          NCVT is INTEGER
        On entry, NCVT specifies the number of columns of
        the matrix VT. NCVT must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRU</td><td><pre class="fragment">          NRU is INTEGER
        On entry, NRU specifies the number of rows of
        the matrix U. NRU must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NCC</td><td><pre class="fragment">          NCC is INTEGER
        On entry, NCC specifies the number of columns of
        the matrix C. NCC must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td><pre class="fragment">          D is REAL array, dimension (N)
        On entry, D contains the diagonal entries of the
        bidiagonal matrix whose SVD is desired. On normal exit,
        D contains the singular values in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td><pre class="fragment">          E is REAL array.
        dimension is (N-1) if SQRE = 0 and N if SQRE = 1.
        On entry, the entries of E contain the offdiagonal entries
        of the bidiagonal matrix whose SVD is desired. On normal
        exit, E will contain 0. If the algorithm does not converge,
        D and E will contain the diagonal and superdiagonal entries
        of a bidiagonal matrix orthogonally equivalent to the one
        given as input.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is REAL array, dimension (LDVT, NCVT)
        On entry, contains a matrix which on exit has been
        premultiplied by P**T, dimension N-by-NCVT if SQRE = 0
        and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
        On entry, LDVT specifies the leading dimension of VT as
        declared in the calling (sub) program. LDVT must be at
        least 1. If NCVT is nonzero LDVT must also be at least N.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td><pre class="fragment">          U is REAL array, dimension (LDU, N)
        On entry, contains a  matrix which on exit has been
        postmultiplied by Q, dimension NRU-by-N if SQRE = 0
        and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
        On entry, LDU  specifies the leading dimension of U as
        declared in the calling (sub) program. LDU must be at
        least max( 1, NRU ) .</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL array, dimension (LDC, NCC)
        On entry, contains an N-by-NCC matrix which on exit
        has been premultiplied by Q**T  dimension N-by-NCC if SQRE = 0
        and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
        On entry, LDC  specifies the leading dimension of C as
        declared in the calling (sub) program. LDC must be at
        least 1. If NCC is nonzero, LDC must also be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (4*N)
        Workspace. Only referenced if one of NCVT, NRU, or NCC is
        nonzero, and if N is at least 2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
        On exit, a value of 0 indicates a successful exit.
        If INFO &lt; 0, argument number -INFO is illegal.
        If INFO &gt; 0, the algorithm did not converge, and INFO
        specifies how many superdiagonals did not converge.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="gae747f83ac11f2283d1d3f8b09d7a1138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasdt </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>INODE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NDIML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NDIMR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MSUB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASDT</b> creates a tree of subproblems for bidiagonal divide and conquer. Used by sbdsdc. </p>
<p> 
 Download SLASDT + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasdt.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasdt.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasdt.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASDT creates a tree of subproblems for bidiagonal divide and
 conquer.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          On entry, the number of diagonal elements of the
          bidiagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LVL</td><td><pre class="fragment">          LVL is INTEGER
          On exit, the number of levels on the computation tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ND</td><td><pre class="fragment">          ND is INTEGER
          On exit, the number of nodes on the tree.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INODE</td><td><pre class="fragment">          INODE is INTEGER array, dimension ( N )
          On exit, centers of subproblems.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NDIML</td><td><pre class="fragment">          NDIML is INTEGER array, dimension ( N )
          On exit, row dimensions of left children.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NDIMR</td><td><pre class="fragment">          NDIMR is INTEGER array, dimension ( N )
          On exit, row dimensions of right children.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSUB</td><td><pre class="fragment">          MSUB is INTEGER
          On entry, the maximum row dimension each subproblem at the
          bottom of the tree can be of.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga6174184453f17ad7cc3488044325d5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slaset </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASET</b> initializes the off-diagonal elements and the diagonal elements of a matrix to given values. </p>
<p> 
 Download SLASET + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaset.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaset.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaset.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASET initializes an m-by-n matrix A to BETA on the diagonal and
 ALPHA on the offdiagonals.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies the part of the matrix A to be set.
          = 'U':      Upper triangular part is set; the strictly lower
                      triangular part of A is not changed.
          = 'L':      Lower triangular part is set; the strictly upper
                      triangular part of A is not changed.
          Otherwise:  All of the matrix A is set.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is REAL
          The constant to which the offdiagonal elements are to be set.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL
          The constant to which the diagonal elements are to be set.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA,N)
          On exit, the leading m-by-n submatrix of A is set as follows:

          if UPLO = 'U', A(i,j) = ALPHA, 1&lt;=i&lt;=j-1, 1&lt;=j&lt;=n,
          if UPLO = 'L', A(i,j) = ALPHA, j+1&lt;=i&lt;=m, 1&lt;=j&lt;=n,
          otherwise,     A(i,j) = ALPHA, 1&lt;=i&lt;=m, 1&lt;=j&lt;=n, i.ne.j,

          and, for all UPLO, A(i,i) = BETA, 1&lt;=i&lt;=min(m,n).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga60f6d566e3a36c43835b0ff3055879dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasr </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SIDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>PIVOT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DIRECT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASR</b> applies a sequence of plane rotations to a general rectangular matrix. </p>
<p> 
 Download SLASR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASR applies a sequence of plane rotations to a real matrix A,
 from either the left or the right.
 
 When SIDE = 'L', the transformation takes the form
 
    A := P*A
 
 and when SIDE = 'R', the transformation takes the form
 
    A := A*P**T
 
 where P is an orthogonal matrix consisting of a sequence of z plane
 rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
 and P**T is the transpose of P.
 
 When DIRECT = 'F' (Forward sequence), then
 
    P = P(z-1) * ... * P(2) * P(1)
 
 and when DIRECT = 'B' (Backward sequence), then
 
    P = P(1) * P(2) * ... * P(z-1)
 
 where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
 
    R(k) = (  c(k)  s(k) )
         = ( -s(k)  c(k) ).
 
 When PIVOT = 'V' (Variable pivot), the rotation is performed
 for the plane (k,k+1), i.e., P(k) has the form
 
    P(k) = (  1                                            )
           (       ...                                     )
           (              1                                )
           (                   c(k)  s(k)                  )
           (                  -s(k)  c(k)                  )
           (                                1              )
           (                                     ...       )
           (                                            1  )
 
 where R(k) appears as a rank-2 modification to the identity matrix in
 rows and columns k and k+1.
 
 When PIVOT = 'T' (Top pivot), the rotation is performed for the
 plane (1,k+1), so P(k) has the form
 
    P(k) = (  c(k)                    s(k)                 )
           (         1                                     )
           (              ...                              )
           (                     1                         )
           ( -s(k)                    c(k)                 )
           (                                 1             )
           (                                      ...      )
           (                                             1 )
 
 where R(k) appears in rows and columns 1 and k+1.
 
 Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
 performed for the plane (k,z), giving P(k) the form
 
    P(k) = ( 1                                             )
           (      ...                                      )
           (             1                                 )
           (                  c(k)                    s(k) )
           (                         1                     )
           (                              ...              )
           (                                     1         )
           (                 -s(k)                    c(k) )
 
 where R(k) appears in rows and columns k and z.  The rotations are
 performed without ever forming P(k) explicitly.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SIDE</td><td><pre class="fragment">          SIDE is CHARACTER*1
          Specifies whether the plane rotation matrix P is applied to
          A on the left or the right.
          = 'L':  Left, compute A := P*A
          = 'R':  Right, compute A:= A*P**T</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PIVOT</td><td><pre class="fragment">          PIVOT is CHARACTER*1
          Specifies the plane for which P(k) is a plane rotation
          matrix.
          = 'V':  Variable pivot, the plane (k,k+1)
          = 'T':  Top pivot, the plane (1,k+1)
          = 'B':  Bottom pivot, the plane (k,z)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DIRECT</td><td><pre class="fragment">          DIRECT is CHARACTER*1
          Specifies whether P is a forward or backward sequence of
          plane rotations.
          = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
          = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  If m &lt;= 1, an immediate
          return is effected.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  If n &lt;= 1, an
          immediate return is effected.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is REAL array, dimension
                  (M-1) if SIDE = 'L'
                  (N-1) if SIDE = 'R'
          The cosines c(k) of the plane rotations.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL array, dimension
                  (M-1) if SIDE = 'L'
                  (N-1) if SIDE = 'R'
          The sines s(k) of the plane rotations.  The 2-by-2 plane
          rotation part of the matrix P(k), R(k), has the form
          R(k) = (  c(k)  s(k) )
                 ( -s(k)  c(k) ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA,N)
          The M-by-N matrix A.  On exit, A is overwritten by P*A if
          SIDE = 'R' or by A*P**T if SIDE = 'L'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf079526ad6de4de7424528ec61b52629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slassq </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SUMSQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASSQ</b> updates a sum of squares represented in scaled form. </p>
<p> 
 Download SLASSQ + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slassq.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slassq.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slassq.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASSQ  returns the values  scl  and  smsq  such that

    ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

 where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
 assumed to be non-negative and  scl  returns the value

    scl = max( scale, abs( x( i ) ) ).

 scale and sumsq must be supplied in SCALE and SUMSQ and
 scl and smsq are overwritten on SCALE and SUMSQ respectively.

 The routine makes only one pass through the vector x.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of elements to be used from the vector X.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is REAL array, dimension (N)
          The vector for which a scaled sum of squares is computed.
             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 &lt;= i &lt;= n.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INCX</td><td><pre class="fragment">          INCX is INTEGER
          The increment between successive values of the vector X.
          INCX &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is REAL
          On entry, the value  scale  in the equation above.
          On exit, SCALE is overwritten with  scl , the scaling factor
          for the sum of squares.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SUMSQ</td><td><pre class="fragment">          SUMSQ is REAL
          On entry, the value  sumsq  in the equation above.
          On exit, SUMSQ is overwritten with  smsq , the basic sum of
          squares from which  scl  has been factored out.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8783434fbc24d465134e5604c5737565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine slasv2 </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SSMIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SSMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SNR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CSR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SNL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>CSL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SLASV2</b> computes the singular value decomposition of a 2-by-2 triangular matrix. </p>
<p> 
 Download SLASV2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasv2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasv2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasv2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SLASV2 computes the singular value decomposition of a 2-by-2
 triangular matrix
    [  F   G  ]
    [  0   H  ].
 On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
 smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
 right singular vectors for abs(SSMAX), giving the decomposition

    [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
    [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td><pre class="fragment">          F is REAL
          The (1,1) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td><pre class="fragment">          G is REAL
          The (1,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td><pre class="fragment">          H is REAL
          The (2,2) element of the 2-by-2 matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMIN</td><td><pre class="fragment">          SSMIN is REAL
          abs(SSMIN) is the smaller singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSMAX</td><td><pre class="fragment">          SSMAX is REAL
          abs(SSMAX) is the larger singular value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SNL</td><td><pre class="fragment">          SNL is REAL</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CSL</td><td><pre class="fragment">          CSL is REAL
          The vector (CSL, SNL) is a unit left singular vector for the
          singular value abs(SSMAX).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SNR</td><td><pre class="fragment">          SNR is REAL</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CSR</td><td><pre class="fragment">          CSR is REAL
          The vector (CSR, SNR) is a unit right singular vector for the
          singular value abs(SSMAX).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  Any input parameter may be aliased with any output parameter.

  Barring over/underflow and assuming a guard digit in subtraction, all
  output quantities are correct to within a few units in the last
  place (ulps).

  In IEEE arithmetic, the code works correctly if one matrix element is
  infinite.

  Overflow will not occur unless the largest singular value itself
  overflows or is within a few ulps of overflow. (On machines with
  partial overflow, like the Cray, overflow may occur if the largest
  singular value is within a factor of 2 of overflow.)

  Underflow is harmless if underflow is gradual. Otherwise, results
  may correspond to a matrix modified by perturbations of size near
  the underflow threshold.</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gac9e158139ad16abc79a0dce7ae8ad8c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program tstiee </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>TSTIEE</b> </p>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga377ee61015baf8dea7770b3a404b1c07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xerbla </td>
          <td>(</td>
          <td class="paramtype">character*(*)&#160;</td>
          <td class="paramname"><em>SRNAME</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>XERBLA</b> </p>
<p> 
 Download XERBLA + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/xerbla.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/xerbla.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/xerbla.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> XERBLA  is an error handler for the LAPACK routines.
 It is called by an LAPACK routine if an input parameter has an
 invalid value.  A message is printed and execution stops.

 Installers may consider modifying the STOP statement in order to
 call system-specific exception-handling facilities.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SRNAME</td><td><pre class="fragment">          SRNAME is CHARACTER*(*)
          The name of the routine which called XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          The position of the invalid parameter in the parameter list
          of the calling routine.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga45f1b23f68dd586f20299b80d1c9288d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine xerbla_array </td>
          <td>(</td>
          <td class="paramtype">character(1), dimension(srname_len)&#160;</td>
          <td class="paramname"><em>SRNAME_ARRAY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>SRNAME_LEN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>XERBLA_ARRAY</b> </p>
<p> 
 Download XERBLA_ARRAY + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/xerbla_array.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/xerbla_array.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/xerbla_array.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK
 and BLAS error handler.  Rather than taking a Fortran string argument
 as the function's name, XERBLA_ARRAY takes an array of single
 characters along with the array's length.  XERBLA_ARRAY then copies
 up to 32 characters of that array into a Fortran string and passes
 that to XERBLA.  If called with a non-positive SRNAME_LEN,
 XERBLA_ARRAY will call XERBLA with a string of all blank characters.

 Say some macro or other device makes XERBLA_ARRAY available to C99
 by a name lapack_xerbla and with a common Fortran calling convention.
 Then a C99 program could invoke XERBLA via:
    {
      int flen = strlen(__func__);
      lapack_xerbla(__func__, &amp;flen, &amp;info);
    }

 Providing XERBLA_ARRAY is not necessary for intercepting LAPACK
 errors.  XERBLA_ARRAY calls XERBLA.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SRNAME_ARRAY</td><td><pre class="fragment">          SRNAME_ARRAY is CHARACTER(1) array, dimension (SRNAME_LEN)
          The name of the routine which called XERBLA_ARRAY.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SRNAME_LEN</td><td><pre class="fragment">          SRNAME_LEN is INTEGER
          The length of the name in SRNAME_ARRAY.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          The position of the invalid parameter in the parameter list
          of the calling routine.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:25:21 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
