<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: complex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">complex<div class="ingroups"><a class="el" href="group__lapack.html">LAPACK</a> &raquo; <a class="el" href="group__SY.html">Symmetric Matrix</a> &raquo; <a class="el" href="group__auxiliarySY.html">Auxiliary routines</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad7bdd5e02c8e280c12ff9fba3c712dd6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complexSYauxiliary.html#gad7bdd5e02c8e280c12ff9fba3c712dd6">claesy</a> (<a class="el" href="classA.html">A</a>, B, C, RT1, RT2, EVSCAL, CS1, SN1)</td></tr>
<tr class="memdesc:gad7bdd5e02c8e280c12ff9fba3c712dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAESY</b> computes the eigenvalues and eigenvectors of a 2-by-2 complex symmetric matrix.  <a href="#gad7bdd5e02c8e280c12ff9fba3c712dd6">More...</a><br /></td></tr>
<tr class="separator:gad7bdd5e02c8e280c12ff9fba3c712dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c86a28190eb12c91cda1c4faef5df7"><td class="memItemLeft" align="right" valign="top">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complexSYauxiliary.html#gad2c86a28190eb12c91cda1c4faef5df7">clansy</a> (NORM, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, WORK)</td></tr>
<tr class="memdesc:gad2c86a28190eb12c91cda1c4faef5df7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLANSY</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex symmetric matrix.  <a href="#gad2c86a28190eb12c91cda1c4faef5df7">More...</a><br /></td></tr>
<tr class="separator:gad2c86a28190eb12c91cda1c4faef5df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12daf202264e97ef334a0d8125497b8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complexSYauxiliary.html#gab12daf202264e97ef334a0d8125497b8">claqsy</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, S, SCOND, AMAX, EQUED)</td></tr>
<tr class="memdesc:gab12daf202264e97ef334a0d8125497b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CLAQSY</b> scales a symmetric/Hermitian matrix, using scaling factors computed by spoequ.  <a href="#gab12daf202264e97ef334a0d8125497b8">More...</a><br /></td></tr>
<tr class="separator:gab12daf202264e97ef334a0d8125497b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae013512af4fd2c59629f1708ca4de36a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complexSYauxiliary.html#gae013512af4fd2c59629f1708ca4de36a">csymv</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, ALPHA, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, X, INCX, BETA, Y, INCY)</td></tr>
<tr class="memdesc:gae013512af4fd2c59629f1708ca4de36a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSYMV</b> computes a matrix-vector product for a complex symmetric matrix.  <a href="#gae013512af4fd2c59629f1708ca4de36a">More...</a><br /></td></tr>
<tr class="separator:gae013512af4fd2c59629f1708ca4de36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fbaf7c4477110907f682b250b24abe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complexSYauxiliary.html#gab7fbaf7c4477110907f682b250b24abe">csyr</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, ALPHA, X, INCX, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:gab7fbaf7c4477110907f682b250b24abe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSYR</b> performs the symmetric rank-1 update of a complex symmetric matrix.  <a href="#gab7fbaf7c4477110907f682b250b24abe">More...</a><br /></td></tr>
<tr class="separator:gab7fbaf7c4477110907f682b250b24abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9a3d10086d7de0fcb0a4732c2e9b21"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complexSYauxiliary.html#ga9f9a3d10086d7de0fcb0a4732c2e9b21">csyswapr</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, I1, I2)</td></tr>
<tr class="memdesc:ga9f9a3d10086d7de0fcb0a4732c2e9b21"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CSYSWAPR</b>  <a href="#ga9f9a3d10086d7de0fcb0a4732c2e9b21">More...</a><br /></td></tr>
<tr class="separator:ga9f9a3d10086d7de0fcb0a4732c2e9b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a880920a428b8ac1203547b0e74d6b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__complexSYauxiliary.html#ga82a880920a428b8ac1203547b0e74d6b">ctgsy2</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58">TRANS</a>, IJOB, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, C, LDC, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, LDD, E, LDE, F, LDF, SCALE, RDSUM, RDSCAL, INFO)</td></tr>
<tr class="memdesc:ga82a880920a428b8ac1203547b0e74d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>CTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).  <a href="#ga82a880920a428b8ac1203547b0e74d6b">More...</a><br /></td></tr>
<tr class="separator:ga82a880920a428b8ac1203547b0e74d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is the group of complex auxiliary functions for SY matrices </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad7bdd5e02c8e280c12ff9fba3c712dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine claesy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>RT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>RT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>EVSCAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>CS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>SN1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAESY</b> computes the eigenvalues and eigenvectors of a 2-by-2 complex symmetric matrix. </p>
<p> 
 Download CLAESY + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/claesy.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/claesy.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claesy.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
    ( ( A, B );( B, C ) )
 provided the norm of the matrix of eigenvectors is larger than
 some threshold value.

 RT1 is the eigenvalue of larger absolute value, and RT2 of
 smaller absolute value.  If the eigenvectors are computed, then
 on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence

 [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
 [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX
          The ( 1, 1 ) element of input matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX
          The ( 1, 2 ) element of input matrix.  The ( 2, 1 ) element
          is also given by B, since the 2-by-2 matrix is symmetric.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX
          The ( 2, 2 ) element of input matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT1</td><td><pre class="fragment">          RT1 is COMPLEX
          The eigenvalue of larger modulus.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RT2</td><td><pre class="fragment">          RT2 is COMPLEX
          The eigenvalue of smaller modulus.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EVSCAL</td><td><pre class="fragment">          EVSCAL is COMPLEX
          The complex value by which the eigenvector matrix was scaled
          to make it orthonormal.  If EVSCAL is zero, the eigenvectors
          were not computed.  This means one of two things:  the 2-by-2
          matrix could not be diagonalized, or the norm of the matrix
          of eigenvectors before scaling was larger than the threshold
          value THRESH (set below).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS1</td><td><pre class="fragment">          CS1 is COMPLEX</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SN1</td><td><pre class="fragment">          SN1 is COMPLEX
          If EVSCAL .NE. 0,  ( CS1, SN1 ) is the unit right eigenvector
          for RT1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gad2c86a28190eb12c91cda1c4faef5df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> clansy </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>NORM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLANSY</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a complex symmetric matrix. </p>
<p> 
 Download CLANSY + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/clansy.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/clansy.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/clansy.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLANSY  returns the value of the one norm,  or the Frobenius norm, or
 the  infinity norm,  or the  element of  largest absolute value  of a
 complex symmetric matrix A.</pre></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CLANSY <pre class="fragment">    CLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
             (
             ( norm1(A),         NORM = '1', 'O' or 'o'
             (
             ( normI(A),         NORM = 'I' or 'i'
             (
             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

 where  norm1  denotes the  one norm of a matrix (maximum column sum),
 normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
 normF  denotes the  Frobenius norm of a matrix (square root of sum of
 squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NORM</td><td><pre class="fragment">          NORM is CHARACTER*1
          Specifies the value to be returned in CLANSY as described
          above.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is to be referenced.
          = 'U':  Upper triangular part of A is referenced
          = 'L':  Lower triangular part of A is referenced</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.  When N = 0, CLANSY is
          set to zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          The symmetric matrix A.  If UPLO = 'U', the leading n by n
          upper triangular part of A contains the upper triangular part
          of the matrix A, and the strictly lower triangular part of A
          is not referenced.  If UPLO = 'L', the leading n by n lower
          triangular part of A contains the lower triangular part of
          the matrix A, and the strictly upper triangular part of A is
          not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(N,1).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK)),
          where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
          WORK is not referenced.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gab12daf202264e97ef334a0d8125497b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine claqsy </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SCOND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>AMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>EQUED</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CLAQSY</b> scales a symmetric/Hermitian matrix, using scaling factors computed by spoequ. </p>
<p> 
 Download CLAQSY + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/claqsy.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/claqsy.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/claqsy.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CLAQSY equilibrates a symmetric matrix A using the scaling factors
 in the vector S.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          symmetric matrix A is stored.
          = 'U':  Upper triangular
          = 'L':  Lower triangular</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
          n by n upper triangular part of A contains the upper
          triangular part of the matrix A, and the strictly lower
          triangular part of A is not referenced.  If UPLO = 'L', the
          leading n by n lower triangular part of A contains the lower
          triangular part of the matrix A, and the strictly upper
          triangular part of A is not referenced.

          On exit, if EQUED = 'Y', the equilibrated matrix:
          diag(S) * A * diag(S).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(N,1).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is REAL array, dimension (N)
          The scale factors for A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCOND</td><td><pre class="fragment">          SCOND is REAL
          Ratio of the smallest S(i) to the largest S(i).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AMAX</td><td><pre class="fragment">          AMAX is REAL
          Absolute value of largest matrix entry.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EQUED</td><td><pre class="fragment">          EQUED is CHARACTER*1
          Specifies whether or not equilibration was done.
          = 'N':  No equilibration.
          = 'Y':  Equilibration was done, i.e., A has been replaced by
                  diag(S) * A * diag(S).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Internal Parameters: </dt><dd><pre class="fragment">  THRESH is a threshold value used to decide if scaling should be done
  based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
  scaling is done.

  LARGE and SMALL are threshold values used to decide if scaling should
  be done based on the absolute size of the largest matrix element.
  If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gae013512af4fd2c59629f1708ca4de36a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine csymv </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSYMV</b> computes a matrix-vector product for a complex symmetric matrix. </p>
<p> 
 Download CSYMV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/csymv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/csymv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csymv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSYMV  performs the matrix-vector  operation

    y := alpha*A*x + beta*y,

 where alpha and beta are scalars, x and y are n element vectors and
 A is an n by n symmetric matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
           On entry, UPLO specifies whether the upper or lower
           triangular part of the array A is to be referenced as
           follows:

              UPLO = 'U' or 'u'   Only the upper triangular part of A
                                  is to be referenced.

              UPLO = 'L' or 'l'   Only the lower triangular part of A
                                  is to be referenced.

           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           On entry, N specifies the order of the matrix A.
           N must be at least zero.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX
           On entry, ALPHA specifies the scalar alpha.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension ( LDA, N )
           Before entry, with  UPLO = 'U' or 'u', the leading n by n
           upper triangular part of the array A must contain the upper
           triangular part of the symmetric matrix and the strictly
           lower triangular part of A is not referenced.
           Before entry, with UPLO = 'L' or 'l', the leading n by n
           lower triangular part of the array A must contain the lower
           triangular part of the symmetric matrix and the strictly
           upper triangular part of A is not referenced.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
           On entry, LDA specifies the first dimension of A as declared
           in the calling (sub) program. LDA must be at least
           max( 1, N ).
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension at least
           ( 1 + ( N - 1 )*abs( INCX ) ).
           Before entry, the incremented array X must contain the N-
           element vector x.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INCX</td><td><pre class="fragment">          INCX is INTEGER
           On entry, INCX specifies the increment for the elements of
           X. INCX must not be zero.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is COMPLEX
           On entry, BETA specifies the scalar beta. When BETA is
           supplied as zero then Y need not be set on input.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is COMPLEX array, dimension at least
           ( 1 + ( N - 1 )*abs( INCY ) ).
           Before entry, the incremented array Y must contain the n
           element vector y. On exit, Y is overwritten by the updated
           vector y.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INCY</td><td><pre class="fragment">          INCY is INTEGER
           On entry, INCY specifies the increment for the elements of
           Y. INCY must not be zero.
           Unchanged on exit.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="gab7fbaf7c4477110907f682b250b24abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine csyr </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSYR</b> performs the symmetric rank-1 update of a complex symmetric matrix. </p>
<p> 
 Download CSYR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/csyr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/csyr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csyr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSYR   performs the symmetric rank 1 operation

    A := alpha*x*x**H + A,

 where alpha is a complex scalar, x is an n element vector and A is an
 n by n symmetric matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
           On entry, UPLO specifies whether the upper or lower
           triangular part of the array A is to be referenced as
           follows:

              UPLO = 'U' or 'u'   Only the upper triangular part of A
                                  is to be referenced.

              UPLO = 'L' or 'l'   Only the lower triangular part of A
                                  is to be referenced.

           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           On entry, N specifies the order of the matrix A.
           N must be at least zero.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is COMPLEX
           On entry, ALPHA specifies the scalar alpha.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is COMPLEX array, dimension at least
           ( 1 + ( N - 1 )*abs( INCX ) ).
           Before entry, the incremented array X must contain the N-
           element vector x.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INCX</td><td><pre class="fragment">          INCX is INTEGER
           On entry, INCX specifies the increment for the elements of
           X. INCX must not be zero.
           Unchanged on exit.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension ( LDA, N )
           Before entry, with  UPLO = 'U' or 'u', the leading n by n
           upper triangular part of the array A must contain the upper
           triangular part of the symmetric matrix and the strictly
           lower triangular part of A is not referenced. On exit, the
           upper triangular part of the array A is overwritten by the
           upper triangular part of the updated matrix.
           Before entry, with UPLO = 'L' or 'l', the leading n by n
           lower triangular part of the array A must contain the lower
           triangular part of the symmetric matrix and the strictly
           upper triangular part of A is not referenced. On exit, the
           lower triangular part of the array A is overwritten by the
           lower triangular part of the updated matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
           On entry, LDA specifies the first dimension of A as declared
           in the calling (sub) program. LDA must be at least
           max( 1, N ).
           Unchanged on exit.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f9a3d10086d7de0fcb0a4732c2e9b21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine csyswapr </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, <a class="el" href="indexexpr_8h.html#ab427e2e2b4d6cec55fa088ea2a692ace">n</a> )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>I2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CSYSWAPR</b> </p>
<p> 
 Download CSYSWAPR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/csyswapr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/csyswapr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/csyswapr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CSYSWAPR applies an elementary permutation on the rows and the columns of
 a symmetric matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the details of the factorization are stored
          as an upper or lower triangular matrix.
          = 'U':  Upper triangular, form is A = U*D*U**T;
          = 'L':  Lower triangular, form is A = L*D*L**T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA,N)
          On entry, the NB diagonal matrix D and the multipliers
          used to obtain the factor U or L as computed by CSYTRF.

          On exit, if INFO = 0, the (symmetric) inverse of the original
          matrix.  If UPLO = 'U', the upper triangular part of the
          inverse is formed and the part of A below the diagonal is not
          referenced; if UPLO = 'L' the lower triangular part of the
          inverse is formed and the part of A above the diagonal is
          not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I1</td><td><pre class="fragment">          I1 is INTEGER
          Index of the first row to swap</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2</td><td><pre class="fragment">          I2 is INTEGER
          Index of the second row to swap</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga82a880920a428b8ac1203547b0e74d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ctgsy2 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IJOB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldd, * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( <a class="el" href="dblat3_8f.html#a6fd3ddbe863b9e8e6e79ebf9c8594174">lde</a>, * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a>, dimension( ldf, * )&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RDSUM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>RDSCAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>CTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm). </p>
<p> 
 Download CTGSY2 + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ctgsy2.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ctgsy2.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ctgsy2.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CTGSY2 solves the generalized Sylvester equation

             A * R - L * B = scale *  C               (1)
             D * R - L * E = scale * F

 using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
 (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
 N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
 (i.e., (A,D) and (B,E) in generalized Schur form).

 The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output
 scaling factor chosen to avoid overflow.

 In matrix notation solving equation (1) corresponds to solve
 Zx = scale * b, where Z is defined as

        Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
            [ kron(In, D)  -kron(E**H, Im) ],

 Ik is the identity matrix of size k and X**H is the transpose of X.
 kron(X, Y) is the Kronecker product between the matrices X and Y.

 If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
 is solved for, which is equivalent to solve for R and L in

             A**H * R  + D**H * L   = scale * C           (3)
             R  * B**H + L  * E**H  = scale * -F

 This case is used to compute an estimate of Dif[(A, D), (B, E)] =
 = sigma_min(Z) using reverse communicaton with CLACON.

 CTGSY2 also (IJOB &gt;= 1) contributes to the computation in CTGSYL
 of an upper bound on the separation between to matrix pairs. Then
 the input (A, D), (B, E) are sub-pencils of two matrix pairs in
 CTGSYL.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANS</td><td><pre class="fragment">          TRANS is CHARACTER*1
          = 'N', solve the generalized Sylvester equation (1).
          = 'T': solve the 'transposed' system (3).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IJOB</td><td><pre class="fragment">          IJOB is INTEGER
          Specifies what kind of functionality to be performed.
          =0: solve (1) only.
          =1: A contribution from this subsystem to a Frobenius
              norm-based estimate of the separation between two matrix
              pairs is computed. (look ahead strategy is used).
          =2: A contribution from this subsystem to a Frobenius
              norm-based estimate of the separation between two matrix
              pairs is computed. (SGECON on sub-systems is used.)
          Not referenced if TRANS = 'T'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          On entry, M specifies the order of A and D, and the row
          dimension of C, F, R and L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          On entry, N specifies the order of B and E, and the column
          dimension of C, F, R and L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is COMPLEX array, dimension (LDA, M)
          On entry, A contains an upper triangular matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the matrix A. LDA &gt;= max(1, M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is COMPLEX array, dimension (LDB, N)
          On entry, B contains an upper triangular matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the matrix B. LDB &gt;= max(1, N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><pre class="fragment">          C is COMPLEX array, dimension (LDC, N)
          On entry, C contains the right-hand-side of the first matrix
          equation in (1).
          On exit, if IJOB = 0, C has been overwritten by the solution
          R.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of the matrix C. LDC &gt;= max(1, M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is COMPLEX array, dimension (LDD, M)
          On entry, D contains an upper triangular matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDD</td><td><pre class="fragment">          LDD is INTEGER
          The leading dimension of the matrix D. LDD &gt;= max(1, M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is COMPLEX array, dimension (LDE, N)
          On entry, E contains an upper triangular matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDE</td><td><pre class="fragment">          LDE is INTEGER
          The leading dimension of the matrix E. LDE &gt;= max(1, N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td><pre class="fragment">          F is COMPLEX array, dimension (LDF, N)
          On entry, F contains the right-hand-side of the second matrix
          equation in (1).
          On exit, if IJOB = 0, F has been overwritten by the solution
          L.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDF</td><td><pre class="fragment">          LDF is INTEGER
          The leading dimension of the matrix F. LDF &gt;= max(1, M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is REAL
          On exit, 0 &lt;= SCALE &lt;= 1. If 0 &lt; SCALE &lt; 1, the solutions
          R and L (C and F on entry) will hold the solutions to a
          slightly perturbed system but the input matrices A, B, D and
          E have not been changed. If SCALE = 0, R and L will hold the
          solutions to the homogeneous system with C = F = 0.
          Normally, SCALE = 1.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">RDSUM</td><td><pre class="fragment">          RDSUM is REAL
          On entry, the sum of squares of computed contributions to
          the Dif-estimate under computation by CTGSYL, where the
          scaling factor RDSCAL (see below) has been factored out.
          On exit, the corresponding sum of squares updated with the
          contributions from the current sub-system.
          If TRANS = 'T' RDSUM is not touched.
          NOTE: RDSUM only makes sense when CTGSY2 is called by
          CTGSYL.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">RDSCAL</td><td><pre class="fragment">          RDSCAL is REAL
          On entry, scaling factor used to prevent overflow in RDSUM.
          On exit, RDSCAL is updated w.r.t. the current contributions
          in RDSUM.
          If TRANS = 'T', RDSCAL is not touched.
          NOTE: RDSCAL only makes sense when CTGSY2 is called by
          CTGSYL.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          On exit, if INFO is set to
            =0: Successful exit
            &lt;0: If INFO = -i, input argument number i is illegal.
            &gt;0: The matrix pairs (A, D) and (B, E) have common or very
                close eigenvalues.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea, Sweden. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:25:21 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
