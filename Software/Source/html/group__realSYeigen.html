<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: real</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">real<div class="ingroups"><a class="el" href="group__lapack.html">LAPACK</a> &raquo; <a class="el" href="group__SY.html">Symmetric Matrix</a> &raquo; <a class="el" href="group__eigenSY.html">Eigenvalue</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga63d8d12aef8f2711d711d9e6bd833e46"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__realSYeigen.html#ga63d8d12aef8f2711d711d9e6bd833e46">ssyev</a> (JOBZ, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, W, WORK, LWORK, INFO)</td></tr>
<tr class="memdesc:ga63d8d12aef8f2711d711d9e6bd833e46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> SSYEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b>  <a href="#ga63d8d12aef8f2711d711d9e6bd833e46">More...</a><br /></td></tr>
<tr class="separator:ga63d8d12aef8f2711d711d9e6bd833e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4d01c8952350ea557b90302ef9de4d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__realSYeigen.html#ga6b4d01c8952350ea557b90302ef9de4d">ssyevd</a> (JOBZ, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, W, WORK, LWORK, IWORK, LIWORK, INFO)</td></tr>
<tr class="memdesc:ga6b4d01c8952350ea557b90302ef9de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> SSYEVD computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b>  <a href="#ga6b4d01c8952350ea557b90302ef9de4d">More...</a><br /></td></tr>
<tr class="separator:ga6b4d01c8952350ea557b90302ef9de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24155d2da67fb4a896c5f8257589b19f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__realSYeigen.html#ga24155d2da67fb4a896c5f8257589b19f">ssyevr</a> (JOBZ, RANGE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK, IWORK, LIWORK, INFO)</td></tr>
<tr class="memdesc:ga24155d2da67fb4a896c5f8257589b19f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> SSYEVR computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b>  <a href="#ga24155d2da67fb4a896c5f8257589b19f">More...</a><br /></td></tr>
<tr class="separator:ga24155d2da67fb4a896c5f8257589b19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8f413f03a84dbe4ac7a973024d0a48"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__realSYeigen.html#ga7f8f413f03a84dbe4ac7a973024d0a48">ssyevx</a> (JOBZ, RANGE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, LWORK, IWORK, IFAIL, INFO)</td></tr>
<tr class="memdesc:ga7f8f413f03a84dbe4ac7a973024d0a48"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> SSYEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b>  <a href="#ga7f8f413f03a84dbe4ac7a973024d0a48">More...</a><br /></td></tr>
<tr class="separator:ga7f8f413f03a84dbe4ac7a973024d0a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0523956327948aae43173b964188e5a2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__realSYeigen.html#ga0523956327948aae43173b964188e5a2">ssygv</a> (ITYPE, JOBZ, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, W, WORK, LWORK, INFO)</td></tr>
<tr class="memdesc:ga0523956327948aae43173b964188e5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SSYGST</b>  <a href="#ga0523956327948aae43173b964188e5a2">More...</a><br /></td></tr>
<tr class="separator:ga0523956327948aae43173b964188e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728a73f9991d8490e62135c31c2017b8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__realSYeigen.html#ga728a73f9991d8490e62135c31c2017b8">ssygvd</a> (ITYPE, JOBZ, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, W, WORK, LWORK, IWORK, LIWORK, INFO)</td></tr>
<tr class="memdesc:ga728a73f9991d8490e62135c31c2017b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SSYGST</b>  <a href="#ga728a73f9991d8490e62135c31c2017b8">More...</a><br /></td></tr>
<tr class="separator:ga728a73f9991d8490e62135c31c2017b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a3927f20cd9692c94ff14babe54ffa"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__realSYeigen.html#ga29a3927f20cd9692c94ff14babe54ffa">ssygvx</a> (ITYPE, JOBZ, RANGE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, LWORK, IWORK, IFAIL, INFO)</td></tr>
<tr class="memdesc:ga29a3927f20cd9692c94ff14babe54ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SSYGST</b>  <a href="#ga29a3927f20cd9692c94ff14babe54ffa">More...</a><br /></td></tr>
<tr class="separator:ga29a3927f20cd9692c94ff14babe54ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is the group of real eigenvalue driver functions for SY matrices </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga63d8d12aef8f2711d711d9e6bd833e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ssyev </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> SSYEV computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b> </p>
<p> 
 Download SSYEV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssyev.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssyev.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyev.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SSYEV computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBZ</td><td><pre class="fragment">          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          = 'U':  Upper triangle of A is stored;
          = 'L':  Lower triangle of A is stored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          orthonormal eigenvectors of the matrix A.
          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
          or the upper triangle (if UPLO='U') of A, including the
          diagonal, is destroyed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          If INFO = 0, the eigenvalues in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  LWORK &gt;= max(1,3*N-1).
          For optimal efficiency, LWORK &gt;= (NB+2)*N,
          where NB is the blocksize for SSYTRD returned by ILAENV.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  if INFO = i, the algorithm failed to converge; i
                off-diagonal elements of an intermediate tridiagonal
                form did not converge to zero.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b4d01c8952350ea557b90302ef9de4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ssyevd </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> SSYEVD computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b> </p>
<p> 
 Download SSYEVD + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssyevd.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssyevd.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyevd.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SSYEVD computes all eigenvalues and, optionally, eigenvectors of a
 real symmetric matrix A. If eigenvectors are desired, it uses a
 divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.

 Because of large use of BLAS of level 3, SSYEVD needs N**2 more
 workspace than SSYEVX.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBZ</td><td><pre class="fragment">          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          = 'U':  Upper triangle of A is stored;
          = 'L':  Lower triangle of A is stored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.
          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          orthonormal eigenvectors of the matrix A.
          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
          or the upper triangle (if UPLO='U') of A, including the
          diagonal, is destroyed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          If INFO = 0, the eigenvalues in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array,
                                         dimension (LWORK)
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.
          If N &lt;= 1,               LWORK must be at least 1.
          If JOBZ = 'N' and N &gt; 1, LWORK must be at least 2*N+1.
          If JOBZ = 'V' and N &gt; 1, LWORK must be at least 
                                                1 + 6*N + 2*N**2.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (MAX(1,LIWORK))
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          The dimension of the array IWORK.
          If N &lt;= 1,                LIWORK must be at least 1.
          If JOBZ  = 'N' and N &gt; 1, LIWORK must be at least 1.
          If JOBZ  = 'V' and N &gt; 1, LIWORK must be at least 3 + 5*N.

          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                to converge; i off-diagonal elements of an intermediate
                tridiagonal form did not converge to zero;
                if INFO = i and JOBZ = 'V', then the algorithm failed
                to compute an eigenvalue while working on the submatrix
                lying in rows and columns INFO/(N+1) through
                mod(INFO,N+1).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Jeff Rutter, Computer Science Division, University of California at Berkeley, USA <br />
 Modified by Francoise Tisseur, University of Tennessee <br />
 Modified description of INFO. Sven, 16 Feb 05. <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga24155d2da67fb4a896c5f8257589b19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ssyevr </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RANGE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ABSTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISUPPZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> SSYEVR computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b> </p>
<p> 
 Download SSYEVR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssyevr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssyevr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyevr.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SSYEVR computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of
 indices for the desired eigenvalues.

 SSYEVR first reduces the matrix A to tridiagonal form T with a call
 to SSYTRD.  Then, whenever possible, SSYEVR calls SSTEMR to compute
 the eigenspectrum using Relatively Robust Representations.  SSTEMR
 computes eigenvalues by the dqds algorithm, while orthogonal
 eigenvectors are computed from various "good" L D L^T representations
 (also known as Relatively Robust Representations). Gram-Schmidt
 orthogonalization is avoided as far as possible. More specifically,
 the various steps of the algorithm are as follows.

 For each unreduced block (submatrix) of T,
    (a) Compute T - sigma I  = L D L^T, so that L and D
        define all the wanted eigenvalues to high relative accuracy.
        This means that small relative changes in the entries of D and L
        cause only small relative changes in the eigenvalues and
        eigenvectors. The standard (unfactored) representation of the
        tridiagonal matrix T does not have this property in general.
    (b) Compute the eigenvalues to suitable accuracy.
        If the eigenvectors are desired, the algorithm attains full
        accuracy of the computed eigenvalues only right before
        the corresponding vectors have to be computed, see steps c) and d).
    (c) For each cluster of close eigenvalues, select a new
        shift close to the cluster, find a new factorization, and refine
        the shifted eigenvalues to suitable accuracy.
    (d) For each eigenvalue with a large enough relative separation compute
        the corresponding eigenvector by forming a rank revealing twisted
        factorization. Go back to (c) for any clusters that remain.

 The desired accuracy of the output can be specified by the input
 parameter ABSTOL.

 For more details, see SSTEMR's documentation and:
 - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
   to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
   Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
 - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
   Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
   2004.  Also LAPACK Working Note 154.
 - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
   tridiagonal eigenvalue/eigenvector problem",
   Computer Science Division Technical Report No. UCB/CSD-97-971,
   UC Berkeley, May 1997.


 Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested
 on machines which conform to the ieee-754 floating point standard.
 SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and
 when partial spectrum requests are made.

 Normal execution of SSTEMR may create NaNs and infinities and
 hence may abort due to a floating point exception in environments
 which do not handle NaNs and infinities in the ieee standard default
 manner.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBZ</td><td><pre class="fragment">          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RANGE</td><td><pre class="fragment">          RANGE is CHARACTER*1
          = 'A': all eigenvalues will be found.
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found.
          = 'I': the IL-th through IU-th eigenvalues will be found.
          For RANGE = 'V' or 'I' and IU - IL &lt; N - 1, SSTEBZ and
          SSTEIN are called</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          = 'U':  Upper triangle of A is stored;
          = 'L':  Lower triangle of A is stored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is REAL
          If RANGE='V', the lower and upper bounds of the interval to
          be searched for eigenvalues. VL &lt; VU.
          Not referenced if RANGE = 'A' or 'I'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IL</td><td><pre class="fragment">          IL is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IU</td><td><pre class="fragment">          IU is INTEGER
          If RANGE='I', the indices (in ascending order) of the
          smallest and largest eigenvalues to be returned.
          1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ABSTOL</td><td><pre class="fragment">          ABSTOL is REAL
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to

                  ABSTOL + EPS *   max( |a|,|b| ) ,

          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form.

          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3.

          If high relative accuracy is important, set ABSTOL to
          SLAMCH( 'Safe minimum' ).  Doing so will guarantee that
          eigenvalues are computed to high relative accuracy when
          possible in future releases.  The current code does not
          make any guarantees about high relative accuracy, but
          future releases will. See J. Barlow and J. Demmel,
          "Computing Accurate Eigensystems of Scaled Diagonally
          Dominant Matrices", LAPACK Working Note #7, for a discussion
          of which matrices define their eigenvalues to high relative
          accuracy.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The total number of eigenvalues found.  0 &lt;= M &lt;= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          The first M elements contain the selected eigenvalues in
          ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension (LDZ, max(1,M))
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If JOBZ = 'N', then Z is not referenced.
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used.
          Supplying N columns is always safe.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDZ</td><td><pre class="fragment">          LDZ is INTEGER
          The leading dimension of the array Z.  LDZ &gt;= 1, and if
          JOBZ = 'V', LDZ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ISUPPZ</td><td><pre class="fragment">          ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
          The support of the eigenvectors in Z, i.e., the indices
          indicating the nonzero elements in Z. The i-th eigenvector
          is nonzero only in elements ISUPPZ( 2*i-1 ) through
          ISUPPZ( 2*i ).
          Implemented only for RANGE = 'A' or 'I' and IU - IL = N - 1</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.  LWORK &gt;= max(1,26*N).
          For optimal efficiency, LWORK &gt;= (NB+6)*N,
          where NB is the max of the blocksize for SSYTRD and SORMTR
          returned by ILAENV.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (MAX(1,LIWORK))
          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          The dimension of the array IWORK.  LIWORK &gt;= max(1,10*N).

          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  Internal error</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>September 2012 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Inderjit Dhillon, IBM Almaden, USA <br />
 Osni Marques, LBNL/NERSC, USA <br />
 Ken Stanley, Computer Science Division, University of California at Berkeley, USA <br />
 Jason Riedy, Computer Science Division, University of California at Berkeley, USA <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7f8f413f03a84dbe4ac7a973024d0a48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ssyevx </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RANGE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ABSTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IFAIL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> SSYEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for SY matrices</b> </p>
<p> 
 Download SSYEVX + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssyevx.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssyevx.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssyevx.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SSYEVX computes selected eigenvalues and, optionally, eigenvectors
 of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
 selected by specifying either a range of values or a range of indices
 for the desired eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBZ</td><td><pre class="fragment">          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RANGE</td><td><pre class="fragment">          RANGE is CHARACTER*1
          = 'A': all eigenvalues will be found.
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found.
          = 'I': the IL-th through IU-th eigenvalues will be found.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          = 'U':  Upper triangle of A is stored;
          = 'L':  Lower triangle of A is stored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.
          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is REAL
          If RANGE='V', the lower and upper bounds of the interval to
          be searched for eigenvalues. VL &lt; VU.
          Not referenced if RANGE = 'A' or 'I'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IL</td><td><pre class="fragment">          IL is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IU</td><td><pre class="fragment">          IU is INTEGER
          If RANGE='I', the indices (in ascending order) of the
          smallest and largest eigenvalues to be returned.
          1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ABSTOL</td><td><pre class="fragment">          ABSTOL is REAL
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to

                  ABSTOL + EPS *   max( |a|,|b| ) ,

          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing A to tridiagonal form.

          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
          If this routine returns with INFO&gt;0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S').

          See "Computing Small Singular Values of Bidiagonal Matrices
          with Guaranteed High Relative Accuracy," by Demmel and
          Kahan, LAPACK Working Note #3.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The total number of eigenvalues found.  0 &lt;= M &lt;= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension (LDZ, max(1,M))
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL.
          If JOBZ = 'N', then Z is not referenced.
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDZ</td><td><pre class="fragment">          LDZ is INTEGER
          The leading dimension of the array Z.  LDZ &gt;= 1, and if
          JOBZ = 'V', LDZ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  LWORK &gt;= 1, when N &lt;= 1;
          otherwise 8*N.
          For optimal efficiency, LWORK &gt;= (NB+3)*N,
          where NB is the max of the blocksize for SSYTRD and SORMTR
          returned by ILAENV.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (5*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IFAIL</td><td><pre class="fragment">          IFAIL is INTEGER array, dimension (N)
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO &gt; 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge.
          If JOBZ = 'N', then IFAIL is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  if INFO = i, then i eigenvectors failed to converge.
                Their indices are stored in array IFAIL.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0523956327948aae43173b964188e5a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ssygv </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SSYGST</b> </p>
<p> 
 Download SSYGV + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssygv.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssygv.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygv.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SSYGV computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
 Here A and B are assumed to be symmetric and B is also
 positive definite.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the problem type to be solved:
          = 1:  A*x = (lambda)*B*x
          = 2:  A*B*x = (lambda)*x
          = 3:  B*A*x = (lambda)*x</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBZ</td><td><pre class="fragment">          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          = 'U':  Upper triangles of A and B are stored;
          = 'L':  Lower triangles of A and B are stored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.

          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows:
          if ITYPE = 1 or 2, Z**T*B*Z = I;
          if ITYPE = 3, Z**T*inv(B)*Z = I.
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL array, dimension (LDB, N)
          On entry, the symmetric positive definite matrix B.
          If UPLO = 'U', the leading N-by-N upper triangular part of B
          contains the upper triangular part of the matrix B.
          If UPLO = 'L', the leading N-by-N lower triangular part of B
          contains the lower triangular part of the matrix B.

          On exit, if INFO &lt;= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          If INFO = 0, the eigenvalues in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  LWORK &gt;= max(1,3*N-1).
          For optimal efficiency, LWORK &gt;= (NB+2)*N,
          where NB is the blocksize for SSYTRD returned by ILAENV.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  SPOTRF or SSYEV returned an error code:
             &lt;= N:  if INFO = i, SSYEV failed to converge;
                    i off-diagonal elements of an intermediate
                    tridiagonal form did not converge to zero;
             &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga728a73f9991d8490e62135c31c2017b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ssygvd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SSYGST</b> </p>
<p> 
 Download SSYGVD + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssygvd.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssygvd.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygvd.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SSYGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
 B are assumed to be symmetric and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the problem type to be solved:
          = 1:  A*x = (lambda)*B*x
          = 2:  A*B*x = (lambda)*x
          = 3:  B*A*x = (lambda)*x</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBZ</td><td><pre class="fragment">          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          = 'U':  Upper triangles of A and B are stored;
          = 'L':  Lower triangles of A and B are stored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.

          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows:
          if ITYPE = 1 or 2, Z**T*B*Z = I;
          if ITYPE = 3, Z**T*inv(B)*Z = I.
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL array, dimension (LDB, N)
          On entry, the symmetric matrix B.  If UPLO = 'U', the
          leading N-by-N upper triangular part of B contains the
          upper triangular part of the matrix B.  If UPLO = 'L',
          the leading N-by-N lower triangular part of B contains
          the lower triangular part of the matrix B.

          On exit, if INFO &lt;= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          If INFO = 0, the eigenvalues in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.
          If N &lt;= 1,               LWORK &gt;= 1.
          If JOBZ = 'N' and N &gt; 1, LWORK &gt;= 2*N+1.
          If JOBZ = 'V' and N &gt; 1, LWORK &gt;= 1 + 6*N + 2*N**2.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK and IWORK
          arrays, returns these values as the first entries of the WORK
          and IWORK arrays, and no error message related to LWORK or
          LIWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (MAX(1,LIWORK))
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          The dimension of the array IWORK.
          If N &lt;= 1,                LIWORK &gt;= 1.
          If JOBZ  = 'N' and N &gt; 1, LIWORK &gt;= 1.
          If JOBZ  = 'V' and N &gt; 1, LIWORK &gt;= 3 + 5*N.

          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK and
          IWORK arrays, returns these values as the first entries of
          the WORK and IWORK arrays, and no error message related to
          LWORK or LIWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  SPOTRF or SSYEVD returned an error code:
             &lt;= N:  if INFO = i and JOBZ = 'N', then the algorithm
                    failed to converge; i off-diagonal elements of an
                    intermediate tridiagonal form did not converge to
                    zero;
                    if INFO = i and JOBZ = 'V', then the algorithm
                    failed to compute an eigenvalue while working on
                    the submatrix lying in rows and columns INFO/(N+1)
                    through mod(INFO,N+1);
             &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  Modified so that no backsubstitution is performed if SSYEVD fails to
  converge (NEIG in old code could be greater than N causing out of
  bounds reference to A - reported by Ralf Meyer).  Also corrected the
  description of INFO and the test on ITYPE. Sven, 16 Feb 05.</pre> </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </dd></dl>

</div>
</div>
<a class="anchor" id="ga29a3927f20cd9692c94ff14babe54ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ssygvx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>RANGE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>VU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ABSTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IFAIL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SSYGST</b> </p>
<p> 
 Download SSYGVX + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssygvx.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssygvx.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssygvx.f"> 
 [TXT]</a>
  </p><dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SSYGVX computes selected eigenvalues, and optionally, eigenvectors
 of a real generalized symmetric-definite eigenproblem, of the form
 A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
 and B are assumed to be symmetric and B is also positive definite.
 Eigenvalues and eigenvectors can be selected by specifying either a
 range of values or a range of indices for the desired eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the problem type to be solved:
          = 1:  A*x = (lambda)*B*x
          = 2:  A*B*x = (lambda)*x
          = 3:  B*A*x = (lambda)*x</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBZ</td><td><pre class="fragment">          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RANGE</td><td><pre class="fragment">          RANGE is CHARACTER*1
          = 'A': all eigenvalues will be found.
          = 'V': all eigenvalues in the half-open interval (VL,VU]
                 will be found.
          = 'I': the IL-th through IU-th eigenvalues will be found.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          = 'U':  Upper triangle of A and B are stored;
          = 'L':  Lower triangle of A and B are stored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix pencil (A,B).  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.

          On exit, the lower triangle (if UPLO='L') or the upper
          triangle (if UPLO='U') of A, including the diagonal, is
          destroyed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL array, dimension (LDA, N)
          On entry, the symmetric matrix B.  If UPLO = 'U', the
          leading N-by-N upper triangular part of B contains the
          upper triangular part of the matrix B.  If UPLO = 'L',
          the leading N-by-N lower triangular part of B contains
          the lower triangular part of the matrix B.

          On exit, if INFO &lt;= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**T*U or B = L*L**T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VU</td><td><pre class="fragment">          VU is REAL
          If RANGE='V', the lower and upper bounds of the interval to
          be searched for eigenvalues. VL &lt; VU.
          Not referenced if RANGE = 'A' or 'I'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IL</td><td><pre class="fragment">          IL is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IU</td><td><pre class="fragment">          IU is INTEGER
          If RANGE='I', the indices (in ascending order) of the
          smallest and largest eigenvalues to be returned.
          1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
          Not referenced if RANGE = 'A' or 'V'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ABSTOL</td><td><pre class="fragment">          ABSTOL is REAL
          The absolute error tolerance for the eigenvalues.
          An approximate eigenvalue is accepted as converged
          when it is determined to lie in an interval [a,b]
          of width less than or equal to

                  ABSTOL + EPS *   max( |a|,|b| ) ,

          where EPS is the machine precision.  If ABSTOL is less than
          or equal to zero, then  EPS*|T|  will be used in its place,
          where |T| is the 1-norm of the tridiagonal matrix obtained
          by reducing C to tridiagonal form, where C is the symmetric
          matrix of the standard symmetric problem to which the
          generalized problem is transformed.

          Eigenvalues will be computed most accurately when ABSTOL is
          set to twice the underflow threshold 2*DLAMCH('S'), not zero.
          If this routine returns with INFO&gt;0, indicating that some
          eigenvectors did not converge, try setting ABSTOL to
          2*SLAMCH('S').</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The total number of eigenvalues found.  0 &lt;= M &lt;= N.
          If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is REAL array, dimension (N)
          On normal exit, the first M elements contain the selected
          eigenvalues in ascending order.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is REAL array, dimension (LDZ, max(1,M))
          If JOBZ = 'N', then Z is not referenced.
          If JOBZ = 'V', then if INFO = 0, the first M columns of Z
          contain the orthonormal eigenvectors of the matrix A
          corresponding to the selected eigenvalues, with the i-th
          column of Z holding the eigenvector associated with W(i).
          The eigenvectors are normalized as follows:
          if ITYPE = 1 or 2, Z**T*B*Z = I;
          if ITYPE = 3, Z**T*inv(B)*Z = I.

          If an eigenvector fails to converge, then that column of Z
          contains the latest approximation to the eigenvector, and the
          index of the eigenvector is returned in IFAIL.
          Note: the user must ensure that at least max(1,M) columns are
          supplied in the array Z; if RANGE = 'V', the exact value of M
          is not known in advance and an upper bound must be used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDZ</td><td><pre class="fragment">          LDZ is INTEGER
          The leading dimension of the array Z.  LDZ &gt;= 1, and if
          JOBZ = 'V', LDZ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  LWORK &gt;= max(1,8*N).
          For optimal efficiency, LWORK &gt;= (NB+3)*N,
          where NB is the blocksize for SSYTRD returned by ILAENV.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (5*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IFAIL</td><td><pre class="fragment">          IFAIL is INTEGER array, dimension (N)
          If JOBZ = 'V', then if INFO = 0, the first M elements of
          IFAIL are zero.  If INFO &gt; 0, then IFAIL contains the
          indices of the eigenvectors that failed to converge.
          If JOBZ = 'N', then IFAIL is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  SPOTRF or SSYEVX returned an error code:
             &lt;= N:  if INFO = i, SSYEVX failed to converge;
                    i eigenvectors failed to converge.  Their indices
                    are stored in array IFAIL.
             &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:25:21 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
