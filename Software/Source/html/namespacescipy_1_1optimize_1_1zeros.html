<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.optimize.zeros Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize.html">optimize</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html">zeros</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.optimize.zeros Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1zeros_1_1RootResults.html">RootResults</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeaa5e32ae93421ba62caeff5fa44380f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aeaa5e32ae93421ba62caeff5fa44380f">results_c</a></td></tr>
<tr class="separator:aeaa5e32ae93421ba62caeff5fa44380f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68360f1b4d04cd5b9b379ad9c9f83d8b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a68360f1b4d04cd5b9b379ad9c9f83d8b">newton</a></td></tr>
<tr class="separator:a68360f1b4d04cd5b9b379ad9c9f83d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83315ba9f5f00391cade4e5d4a5e3a0c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a83315ba9f5f00391cade4e5d4a5e3a0c">bisect</a></td></tr>
<tr class="separator:a83315ba9f5f00391cade4e5d4a5e3a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9f8fc893c60c2dd83d4f104525a076"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a9c9f8fc893c60c2dd83d4f104525a076">ridder</a></td></tr>
<tr class="separator:a9c9f8fc893c60c2dd83d4f104525a076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80f0ae5fa1147fe0c77cd6159380b59"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#ad80f0ae5fa1147fe0c77cd6159380b59">brentq</a></td></tr>
<tr class="separator:ad80f0ae5fa1147fe0c77cd6159380b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46554b03f9304e126d5f4330727cd131"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a46554b03f9304e126d5f4330727cd131">brenth</a></td></tr>
<tr class="separator:a46554b03f9304e126d5f4330727cd131"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaeb208fcd759004ff55061e4ece6af34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aaeb208fcd759004ff55061e4ece6af34">_iter</a> = 100</td></tr>
<tr class="separator:aaeb208fcd759004ff55061e4ece6af34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af117e07d5a2cbf80b5dd0a02ff847f77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#af117e07d5a2cbf80b5dd0a02ff847f77">_xtol</a> = 1</td></tr>
<tr class="separator:af117e07d5a2cbf80b5dd0a02ff847f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8195c6fae6fc47dcfd8b6a1de741372b"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a8195c6fae6fc47dcfd8b6a1de741372b">_rtol</a> = finfo(float)</td></tr>
<tr class="separator:a8195c6fae6fc47dcfd8b6a1de741372b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bb9fd4594454a268fa8b93df50f0d6"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a20bb9fd4594454a268fa8b93df50f0d6">__all__</a> = ['<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a68360f1b4d04cd5b9b379ad9c9f83d8b">newton</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a83315ba9f5f00391cade4e5d4a5e3a0c">bisect</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a9c9f8fc893c60c2dd83d4f104525a076">ridder</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#ad80f0ae5fa1147fe0c77cd6159380b59">brentq</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a46554b03f9304e126d5f4330727cd131">brenth</a>']</td></tr>
<tr class="separator:a20bb9fd4594454a268fa8b93df50f0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94fd9b4c3e606a658916b313bbb9c97"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#ae94fd9b4c3e606a658916b313bbb9c97">CONVERGED</a> = 'converged'</td></tr>
<tr class="separator:ae94fd9b4c3e606a658916b313bbb9c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebed2989815ce89b4efba74926c6d56"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aeebed2989815ce89b4efba74926c6d56">SIGNERR</a> = 'sign <a class="el" href="specfun_8f.html#a1606d291e8b683668654c8d4219efa20">error</a>'</td></tr>
<tr class="separator:aeebed2989815ce89b4efba74926c6d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4044a77254dd216fb958ece2ae9ded7"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aa4044a77254dd216fb958ece2ae9ded7">CONVERR</a> = 'convergence <a class="el" href="specfun_8f.html#a1606d291e8b683668654c8d4219efa20">error</a>'</td></tr>
<tr class="separator:aa4044a77254dd216fb958ece2ae9ded7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9cc0583205f6b55a4d523a6a3a02d2"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a7e9cc0583205f6b55a4d523a6a3a02d2">flag_map</a> = {0: <a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#ae94fd9b4c3e606a658916b313bbb9c97">CONVERGED</a>, -1: <a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aeebed2989815ce89b4efba74926c6d56">SIGNERR</a>, -2: <a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aa4044a77254dd216fb958ece2ae9ded7">CONVERR</a>}</td></tr>
<tr class="separator:a7e9cc0583205f6b55a4d523a6a3a02d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a83315ba9f5f00391cade4e5d4a5e3a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.optimize.zeros.bisect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>_xtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>_rtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>_iter</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find root of a function within an interval.

Basic bisection routine to find a zero of the function `f` between the
arguments `a` and `b`. `f(a)` and `f(b)` can not have the same signs.
Slow but sure.

Parameters
----------
f : function
    Python function returning a number.  `f` must be continuous, and
    f(a) and f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within `xtol` of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in `maxiter` iterations, and error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where x is the root, and r is
    a `RootResults` object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.  In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, bisect, newton
fixed_point : scalar fixed-point finder
fsolve : n-dimensional root-finding</pre> 
</div>
</div>
<a class="anchor" id="a46554b03f9304e126d5f4330727cd131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.optimize.zeros.brenth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>_xtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>_rtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>_iter</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find root of f in [a,b].

A variation on the classic Brent routine to find a zero of the function f
between the arguments a and b that uses hyperbolic extrapolation instead of
inverse quadratic extrapolation. There was a paper back in the 1980's ...
f(a) and f(b) can not have the same signs. Generally on a par with the
brent routine, but not as heavily tested.  It is a safe version of the
secant method that uses hyperbolic extrapolation. The version here is by
Chuck Harris.

Parameters
----------
f : function
    Python function returning a number.  f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within xtol of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in maxiter iterations, and error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a RootResults object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.  In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
fmin, fmin_powell, fmin_cg,
       fmin_bfgs, fmin_ncg : multivariate local optimizers

leastsq : nonlinear least squares minimizer

fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers

anneal, brute : global optimizers

fminbound, brent, golden, bracket : local scalar minimizers

fsolve : n-dimensional root-finding

brentq, brenth, ridder, bisect, newton : one-dimensional root-finding

fixed_point : scalar fixed-point finder</pre> 
</div>
</div>
<a class="anchor" id="ad80f0ae5fa1147fe0c77cd6159380b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.optimize.zeros.brentq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>_xtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>_rtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>_iter</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a root of a function in given interval.

Return float, a zero of `f` between `a` and `b`.  `f` must be a continuous
function, and [a,b] must be a sign changing interval.

Description:
Uses the classic Brent (1973) method to find a zero of the function `f` on
the sign changing interval [a , b].  Generally considered the best of the
rootfinding routines here.  It is a safe version of the secant method that
uses inverse quadratic extrapolation.  Brent's method combines root
bracketing, interval bisection, and inverse quadratic interpolation.  It is
sometimes known as the van Wijngaarden-Deker-Brent method.  Brent (1973)
claims convergence is guaranteed for functions computable within [a,b].

[Brent1973]_ provides the classic description of the algorithm.  Another
description can be found in a recent edition of Numerical Recipes, including
[PressEtal1992]_.  Another description is at
http://mathworld.wolfram.com/BrentsMethod.html.  It should be easy to
understand the algorithm just by reading our code.  Our code diverges a bit
from standard presentations: we choose a different formula for the
extrapolation step.

Parameters
----------
f : function
    Python function returning a number.  f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within xtol of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in maxiter iterations, and error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a RootResults object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.  In particular,
    ``r.converged`` is True if the routine converged.

See Also
--------
multivariate local optimizers
  `fmin`, `fmin_powell`, `fmin_cg`, `fmin_bfgs`, `fmin_ncg`
nonlinear least squares minimizer
  `leastsq`
constrained multivariate optimizers
  `fmin_l_bfgs_b`, `fmin_tnc`, `fmin_cobyla`
global optimizers
  `anneal`, `basinhopping`, `brute`
local scalar minimizers
  `fminbound`, `brent`, `golden`, `bracket`
n-dimensional root-finding
  `fsolve`
one-dimensional root-finding
  `brentq`, `brenth`, `ridder`, `bisect`, `newton`
scalar fixed-point finder
  `fixed_point`

Notes
-----
`f` must be continuous.  f(a) and f(b) must have opposite signs.


References
----------
.. [Brent1973]
   Brent, R. P.,
   *Algorithms for Minimization Without Derivatives*.
   Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.

.. [PressEtal1992]
   Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.
   *Numerical Recipes in FORTRAN: The Art of Scientific Computing*, 2nd ed.
   Cambridge, England: Cambridge University Press, pp. 352-355, 1992.
   Section 9.3:  "Van Wijngaarden-Dekker-Brent Method."</pre> 
</div>
</div>
<a class="anchor" id="a68360f1b4d04cd5b9b379ad9c9f83d8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.optimize.zeros.newton </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fprime</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1.48e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fprime2</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a zero using the Newton-Raphson or secant method.

Find a zero of the function `func` given a nearby starting point `x0`.
The Newton-Raphson method is used if the derivative `fprime` of `func`
is provided, otherwise the secant method is used.  If the second order
derivate `fprime2` of `func` is provided, parabolic Halley's method
is used.

Parameters
----------
func : function
    The function whose zero is wanted. It must be a function of a
    single variable of the form f(x,a,b,c...), where a,b,c... are extra
    arguments that can be passed in the `args` parameter.
x0 : float
    An initial estimate of the zero that should be somewhere near the
    actual zero.
fprime : function, optional
    The derivative of the function when available and convenient. If it
    is None (default), then the secant method is used.
args : tuple, optional
    Extra arguments to be used in the function call.
tol : float, optional
    The allowable error of the zero value.
maxiter : int, optional
    Maximum number of iterations.
fprime2 : function, optional
    The second order derivative of the function when available and
    convenient. If it is None (default), then the normal Newton-Raphson
    or the secant method is used. If it is given, parabolic Halley's
    method is used.

Returns
-------
zero : float
    Estimated location where function is zero.

See Also
--------
brentq, brenth, ridder, bisect
fsolve : find zeroes in n dimensions.

Notes
-----
The convergence rate of the Newton-Raphson method is quadratic,
the Halley method is cubic, and the secant method is
sub-quadratic.  This means that if the function is well behaved
the actual error in the estimated zero is approximately the square
(cube for Halley) of the requested tolerance up to roundoff
error. However, the stopping criterion used here is the step size
and there is no guarantee that a zero has been found. Consequently
the result should be verified. Safer algorithms are brentq,
brenth, ridder, and bisect, but they all require that the root
first be bracketed in an interval where the function changes
sign. The brentq algorithm is recommended for general use in one
dimensional problems when such an interval has been found.</pre> 
</div>
</div>
<a class="anchor" id="aeaa5e32ae93421ba62caeff5fa44380f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.optimize.zeros.results_c </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c9f8fc893c60c2dd83d4f104525a076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.optimize.zeros.ridder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>_xtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>_rtol</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>_iter</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a root of a function in an interval.

Parameters
----------
f : function
    Python function returning a number.  f must be continuous, and f(a) and
    f(b) must have opposite signs.
a : number
    One end of the bracketing interval [a,b].
b : number
    The other end of the bracketing interval [a,b].
xtol : number, optional
    The routine converges when a root is known to lie within xtol of the
    value return. Should be &gt;= 0.  The routine modifies this to take into
    account the relative precision of doubles.
rtol : number, optional
    The routine converges when a root is known to lie within `rtol` times
    the value returned of the value returned. Should be &gt;= 0. Defaults to
    ``np.finfo(float).eps * 2``.
maxiter : number, optional
    if convergence is not achieved in maxiter iterations, and error is
    raised.  Must be &gt;= 0.
args : tuple, optional
    containing extra arguments for the function `f`.
    `f` is called by ``apply(f, (x)+args)``.
full_output : bool, optional
    If `full_output` is False, the root is returned.  If `full_output` is
    True, the return value is ``(x, r)``, where `x` is the root, and `r` is
    a RootResults object.
disp : bool, optional
    If True, raise RuntimeError if the algorithm didn't converge.

Returns
-------
x0 : float
    Zero of `f` between `a` and `b`.
r : RootResults (present if ``full_output = True``)
    Object containing information about the convergence.
    In particular, ``r.converged`` is True if the routine converged.

See Also
--------
brentq, brenth, bisect, newton : one-dimensional root-finding
fixed_point : scalar fixed-point finder

Notes
-----
Uses [Ridders1979]_ method to find a zero of the function `f` between the
arguments `a` and `b`. Ridders' method is faster than bisection, but not
generally as fast as the Brent rountines. [Ridders1979]_ provides the
classic description and source of the algorithm. A description can also be
found in any recent edition of Numerical Recipes.

The routine used here diverges slightly from standard presentations in
order to be a bit more careful of tolerance.

References
----------
.. [Ridders1979]
   Ridders, C. F. J. "A New Algorithm for Computing a
   Single Root of a Real Continuous Function."
   IEEE Trans. Circuits Systems 26, 979-980, 1979.</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a20bb9fd4594454a268fa8b93df50f0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.optimize.zeros.__all__ = ['<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a68360f1b4d04cd5b9b379ad9c9f83d8b">newton</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a83315ba9f5f00391cade4e5d4a5e3a0c">bisect</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a9c9f8fc893c60c2dd83d4f104525a076">ridder</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#ad80f0ae5fa1147fe0c77cd6159380b59">brentq</a>', '<a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#a46554b03f9304e126d5f4330727cd131">brenth</a>']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaeb208fcd759004ff55061e4ece6af34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize.zeros._iter = 100</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8195c6fae6fc47dcfd8b6a1de741372b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.optimize.zeros._rtol = finfo(float)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af117e07d5a2cbf80b5dd0a02ff847f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scipy.optimize.zeros._xtol = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae94fd9b4c3e606a658916b313bbb9c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string scipy.optimize.zeros.CONVERGED = 'converged'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4044a77254dd216fb958ece2ae9ded7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string scipy.optimize.zeros.CONVERR = 'convergence <a class="el" href="specfun_8f.html#a1606d291e8b683668654c8d4219efa20">error</a>'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e9cc0583205f6b55a4d523a6a3a02d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.optimize.zeros.flag_map = {0: <a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#ae94fd9b4c3e606a658916b313bbb9c97">CONVERGED</a>, -1: <a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aeebed2989815ce89b4efba74926c6d56">SIGNERR</a>, -2: <a class="el" href="namespacescipy_1_1optimize_1_1zeros.html#aa4044a77254dd216fb958ece2ae9ded7">CONVERR</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeebed2989815ce89b4efba74926c6d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string scipy.optimize.zeros.SIGNERR = 'sign <a class="el" href="specfun_8f.html#a1606d291e8b683668654c8d4219efa20">error</a>'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:19 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
