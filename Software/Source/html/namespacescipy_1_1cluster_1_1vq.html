<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.cluster.vq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html">vq</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.cluster.vq Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1cluster_1_1vq_1_1ClusterError.html">ClusterError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5054f4f6a85a7626ef46afd302cf8d0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#ae5054f4f6a85a7626ef46afd302cf8d0">whiten</a></td></tr>
<tr class="separator:ae5054f4f6a85a7626ef46afd302cf8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617d8953ae056de229338f05e8c0c9ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a617d8953ae056de229338f05e8c0c9ef">vq</a></td></tr>
<tr class="separator:a617d8953ae056de229338f05e8c0c9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7d7659bff189e532c4566fac1b44bd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a9b7d7659bff189e532c4566fac1b44bd">py_vq</a></td></tr>
<tr class="separator:a9b7d7659bff189e532c4566fac1b44bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65128ab172a61aefaf65322e25e394bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a65128ab172a61aefaf65322e25e394bc">py_vq2</a></td></tr>
<tr class="separator:a65128ab172a61aefaf65322e25e394bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bfedf7fde3d48032d839db0477faa1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#af4bfedf7fde3d48032d839db0477faa1">kmeans</a></td></tr>
<tr class="separator:af4bfedf7fde3d48032d839db0477faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714311c102593f06182b0fa9f187b20f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a714311c102593f06182b0fa9f187b20f">kmeans2</a></td></tr>
<tr class="separator:a714311c102593f06182b0fa9f187b20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a269068c9eec58420eecf07db13f0e5d5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a269068c9eec58420eecf07db13f0e5d5">__docformat__</a> = 'restructuredtext'</td></tr>
<tr class="separator:a269068c9eec58420eecf07db13f0e5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e5d52c843bc7d5966796bf5abb506"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#aa44e5d52c843bc7d5966796bf5abb506">__all__</a> = ['<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#ae5054f4f6a85a7626ef46afd302cf8d0">whiten</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a617d8953ae056de229338f05e8c0c9ef">vq</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#af4bfedf7fde3d48032d839db0477faa1">kmeans</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a714311c102593f06182b0fa9f187b20f">kmeans2</a>']</td></tr>
<tr class="separator:aa44e5d52c843bc7d5966796bf5abb506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f327fb1e0d050f586f210c9e285727"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a16f327fb1e0d050f586f210c9e285727">_valid_init_meth</a> = {'random': _krandinit, 'points': _kpoints}</td></tr>
<tr class="separator:a16f327fb1e0d050f586f210c9e285727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc099b68b254c57a0c261d94f38b432"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1vq.html#abbc099b68b254c57a0c261d94f38b432">_valid_miss_meth</a> = {'<a class="el" href="eepromer_8c.html#acc421dc81e5dbb4c9cc2f0709f71b861">warn</a>': _missing_warn, 'raise': _missing_raise}</td></tr>
<tr class="separator:abbc099b68b254c57a0c261d94f38b432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">====================================================================
K-means clustering and vector quantization (:mod:`scipy.cluster.vq`)
====================================================================

Provides routines for k-means clustering, generating code books
from k-means models, and quantizing vectors by comparing them with
centroids in a code book.

.. autosummary::
   :toctree: generated/

   whiten -- Normalize a group of observations so each feature has unit variance
   vq -- Calculate code book membership of a set of observation vectors
   kmeans -- Performs k-means on a set of observation vectors forming k clusters
   kmeans2 -- A different implementation of k-means with more methods
       -- for initializing centroids

Background information
======================
The k-means algorithm takes as input the number of clusters to
generate, k, and a set of observation vectors to cluster.  It
returns a set of centroids, one for each of the k clusters.  An
observation vector is classified with the cluster number or
centroid index of the centroid closest to it.

A vector v belongs to cluster i if it is closer to centroid i than
any other centroids. If v belongs to i, we say centroid i is the
dominating centroid of v. The k-means algorithm tries to
minimize distortion, which is defined as the sum of the squared distances
between each observation vector and its dominating centroid.  Each
step of the k-means algorithm refines the choices of centroids to
reduce distortion. The change in distortion is used as a
stopping criterion: when the change is lower than a threshold, the
k-means algorithm is not making sufficient progress and
terminates. One can also define a maximum number of iterations.

Since vector quantization is a natural application for k-means,
information theory terminology is often used.  The centroid index
or cluster index is also referred to as a "code" and the table
mapping codes to centroids and vice versa is often referred as a
"code book". The result of k-means, a set of centroids, can be
used to quantize vectors. Quantization aims to find an encoding of
vectors that reduces the expected distortion.

All routines expect obs to be a M by N array where the rows are
the observation vectors. The codebook is a k by N array where the
i'th row is the centroid of code word i. The observation vectors
and centroids have the same feature dimension.

As an example, suppose we wish to compress a 24-bit color image
(each pixel is represented by one byte for red, one for blue, and
one for green) before sending it over the web.  By using a smaller
8-bit encoding, we can reduce the amount of data by two
thirds. Ideally, the colors for each of the 256 possible 8-bit
encoding values should be chosen to minimize distortion of the
color. Running k-means with k=256 generates a code book of 256
codes, which fills up all possible 8-bit sequences.  Instead of
sending a 3-byte value for each pixel, the 8-bit centroid index
(or code word) of the dominating centroid is transmitted. The code
book is also sent over the wire so each 8-bit code can be
translated back to a 24-bit pixel value representation. If the
image of interest was of an ocean, we would expect many 24-bit
blues to be represented by 8-bit codes. If it was an image of a
human face, more flesh tone colors would be represented in the
code book.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af4bfedf7fde3d48032d839db0477faa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.vq.kmeans </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k_or_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iter</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs k-means on a set of observation vectors forming k clusters.

The k-means algorithm adjusts the centroids until sufficient
progress cannot be made, i.e. the change in distortion since
the last iteration is less than some threshold. This yields
a code book mapping centroids to codes and vice versa.

Distortion is defined as the sum of the squared differences
between the observations and the corresponding centroid.

Parameters
----------
obs : ndarray
   Each row of the M by N array is an observation vector. The
   columns are the features seen during each observation.
   The features must be whitened first with the `whiten` function.

k_or_guess : int or ndarray
   The number of centroids to generate. A code is assigned to
   each centroid, which is also the row index of the centroid
   in the code_book matrix generated.

   The initial k centroids are chosen by randomly selecting
   observations from the observation matrix. Alternatively,
   passing a k by N array specifies the initial k centroids.

iter : int, optional
   The number of times to run k-means, returning the codebook
   with the lowest distortion. This argument is ignored if
   initial centroids are specified with an array for the
   ``k_or_guess`` parameter. This parameter does not represent the
   number of iterations of the k-means algorithm.

thresh : float, optional
   Terminates the k-means algorithm if the change in
   distortion since the last k-means iteration is less than
   or equal to thresh.

Returns
-------
codebook : ndarray
   A k by N array of k centroids. The i'th centroid
   codebook[i] is represented with the code i. The centroids
   and codes generated represent the lowest distortion seen,
   not necessarily the globally minimal distortion.

distortion : float
   The distortion between the observations passed and the
   centroids generated.

See Also
--------
kmeans2 : a different implementation of k-means clustering
   with more methods for generating initial centroids but without
   using a distortion change threshold as a stopping criterion.

whiten : must be called prior to passing an observation matrix
   to kmeans.

Examples
--------
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; from scipy.cluster.vq import vq, kmeans, whiten
&gt;&gt;&gt; features  = array([[ 1.9,2.3],
...                    [ 1.5,2.5],
...                    [ 0.8,0.6],
...                    [ 0.4,1.8],
...                    [ 0.1,0.1],
...                    [ 0.2,1.8],
...                    [ 2.0,0.5],
...                    [ 0.3,1.5],
...                    [ 1.0,1.0]])
&gt;&gt;&gt; whitened = whiten(features)
&gt;&gt;&gt; book = array((whitened[0],whitened[2]))
&gt;&gt;&gt; kmeans(whitened,book)
(array([[ 2.3110306 ,  2.86287398],
       [ 0.93218041,  1.24398691]]), 0.85684700941625547)

&gt;&gt;&gt; from numpy import random
&gt;&gt;&gt; random.seed((1000,2000))
&gt;&gt;&gt; codes = 3
&gt;&gt;&gt; kmeans(whitened,codes)
(array([[ 2.3110306 ,  2.86287398],
       [ 1.32544402,  0.65607529],
       [ 0.40782893,  2.02786907]]), 0.5196582527686241)</pre> 
</div>
</div>
<a class="anchor" id="a714311c102593f06182b0fa9f187b20f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.vq.kmeans2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iter</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minit</em> = <code>'random'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>missing</em> = <code>'<a class="el" href="eepromer_8c.html#acc421dc81e5dbb4c9cc2f0709f71b861">warn</a>'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Classify a set of observations into k clusters using the k-means algorithm.

The algorithm attempts to minimize the Euclidian distance between
observations and centroids. Several initialization methods are
included.

Parameters
----------
data : ndarray
    A 'M' by 'N' array of 'M' observations in 'N' dimensions or a length
    'M' array of 'M' one-dimensional observations.
k : int or ndarray
    The number of clusters to form as well as the number of
    centroids to generate. If `minit` initialization string is
    'matrix', or if a ndarray is given instead, it is
    interpreted as initial cluster to use instead.
iter : int
    Number of iterations of the k-means algrithm to run. Note
    that this differs in meaning from the iters parameter to
    the kmeans function.
thresh : float
    (not used yet)
minit : string
    Method for initialization. Available methods are 'random',
    'points', 'uniform', and 'matrix':

    'random': generate k centroids from a Gaussian with mean and
    variance estimated from the data.

    'points': choose k observations (rows) at random from data for
    the initial centroids.

    'uniform': generate k observations from the data from a uniform
    distribution defined by the data set (unsupported).

    'matrix': interpret the k parameter as a k by M (or length k
    array for one-dimensional data) array of initial centroids.

Returns
-------
centroid : ndarray
    A 'k' by 'N' array of centroids found at the last iteration of
    k-means.
label : ndarray
    label[i] is the code or index of the centroid the
    i'th observation is closest to.</pre> 
</div>
</div>
<a class="anchor" id="a9b7d7659bff189e532c4566fac1b44bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.vq.py_vq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>code_book</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Python version of vq algorithm.

The algorithm computes the euclidian distance between each
observation and every frame in the code_book.

Parameters
----------
obs : ndarray
    Expects a rank 2 array. Each row is one observation.
code_book : ndarray
    Code book to use. Same format than obs. Should have same number of
    features (eg columns) than obs.

Returns
-------
code : ndarray
    code[i] gives the label of the ith obversation, that its code is
    code_book[code[i]].
mind_dist : ndarray
    min_dist[i] gives the distance between the ith observation and its
    corresponding code.

Notes
-----
This function is slower than the C version but works for
all input types.  If the inputs have the wrong types for the
C versions of the function, this one is called as a last resort.

It is about 20 times slower than the C version.</pre> 
</div>
</div>
<a class="anchor" id="a65128ab172a61aefaf65322e25e394bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.vq.py_vq2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>code_book</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">2nd Python version of vq algorithm.

The algorithm simply computes the euclidian distance between each
observation and every frame in the code_book/

Parameters
----------
obs : ndarray
    Expect a rank 2 array. Each row is one observation.
code_book : ndarray
    Code book to use. Same format than obs. Should have same number of
    features (eg columns) than obs.

Returns
-------
code : ndarray
    code[i] gives the label of the ith obversation, that its code is
    code_book[code[i]].
mind_dist : ndarray
    min_dist[i] gives the distance between the ith observation and its
    corresponding code.

Notes
-----
This could be faster when number of codebooks is small, but it
becomes a real memory hog when codebook is large. It requires
N by M by O storage where N=number of obs, M = number of
features, and O = number of codes.</pre> 
</div>
</div>
<a class="anchor" id="a617d8953ae056de229338f05e8c0c9ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.vq.vq </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>code_book</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assign codes from a code book to observations.

Assigns a code from a code book to each observation. Each
observation vector in the 'M' by 'N' `obs` array is compared with the
centroids in the code book and assigned the code of the closest
centroid.

The features in `obs` should have unit variance, which can be
achieved by passing them through the whiten function.  The code
book can be created with the k-means algorithm or a different
encoding algorithm.

Parameters
----------
obs : ndarray
    Each row of the 'N' x 'M' array is an observation.  The columns are
    the "features" seen during each observation. The features must be
    whitened first using the whiten function or something equivalent.
code_book : ndarray
    The code book is usually generated using the k-means algorithm.
    Each row of the array holds a different code, and the columns are
    the features of the code.

     &gt;&gt;&gt; #              f0    f1    f2   f3
     &gt;&gt;&gt; code_book = [
     ...             [  1.,   2.,   3.,   4.],  #c0
     ...             [  1.,   2.,   3.,   4.],  #c1
     ...             [  1.,   2.,   3.,   4.]]) #c2

Returns
-------
code : ndarray
    A length N array holding the code book index for each observation.
dist : ndarray
    The distortion (distance) between the observation and its nearest
    code.

Notes
-----
This currently forces 32-bit math precision for speed.  Anyone know
of a situation where this undermines the accuracy of the algorithm?

Examples
--------
&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; from scipy.cluster.vq import vq
&gt;&gt;&gt; code_book = array([[1.,1.,1.],
...                    [2.,2.,2.]])
&gt;&gt;&gt; features  = array([[  1.9,2.3,1.7],
...                    [  1.5,2.5,2.2],
...                    [  0.8,0.6,1.7]])
&gt;&gt;&gt; vq(features,code_book)
(array([1, 1, 0],'i'), array([ 0.43588989,  0.73484692,  0.83066239]))</pre> 
</div>
</div>
<a class="anchor" id="ae5054f4f6a85a7626ef46afd302cf8d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.vq.whiten </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Normalize a group of observations on a per feature basis.

Before running k-means, it is beneficial to rescale each feature
dimension of the observation set with whitening. Each feature is
divided by its standard deviation across all observations to give
it unit variance.

Parameters
----------
obs : ndarray
    Each row of the array is an observation.  The
    columns are the features seen during each observation.

    &gt;&gt;&gt; #         f0    f1    f2
    &gt;&gt;&gt; obs = [[  1.,   1.,   1.],  #o0
    ...        [  2.,   2.,   2.],  #o1
    ...        [  3.,   3.,   3.],  #o2
    ...        [  4.,   4.,   4.]]) #o3

Returns
-------
result : ndarray
    Contains the values in `obs` scaled by the standard deviation
    of each column.

Examples
--------
&gt;&gt;&gt; from scipy.cluster.vq import whiten
&gt;&gt;&gt; features  = np.array([[1.9, 2.3, 1.7],
...                       [1.5, 2.5, 2.2],
...                       [0.8, 0.6, 1.7,]])
&gt;&gt;&gt; whiten(features)
array([[ 4.17944278,  2.69811351,  7.21248917],
       [ 3.29956009,  2.93273208,  9.33380951],
       [ 1.75976538,  0.7038557 ,  7.21248917]])</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aa44e5d52c843bc7d5966796bf5abb506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.cluster.vq.__all__ = ['<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#ae5054f4f6a85a7626ef46afd302cf8d0">whiten</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a617d8953ae056de229338f05e8c0c9ef">vq</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#af4bfedf7fde3d48032d839db0477faa1">kmeans</a>', '<a class="el" href="namespacescipy_1_1cluster_1_1vq.html#a714311c102593f06182b0fa9f187b20f">kmeans2</a>']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a269068c9eec58420eecf07db13f0e5d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string scipy.cluster.vq.__docformat__ = 'restructuredtext'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16f327fb1e0d050f586f210c9e285727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.cluster.vq._valid_init_meth = {'random': _krandinit, 'points': _kpoints}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbc099b68b254c57a0c261d94f38b432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.cluster.vq._valid_miss_meth = {'<a class="el" href="eepromer_8c.html#acc421dc81e5dbb4c9cc2f0709f71b861">warn</a>': _missing_warn, 'raise': _missing_raise}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:26:55 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
