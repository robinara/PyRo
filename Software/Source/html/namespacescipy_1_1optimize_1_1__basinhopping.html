<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.optimize._basinhopping Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize.html">optimize</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html">_basinhopping</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.optimize._basinhopping Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__basinhopping_1_1AdaptiveStepsize.html">AdaptiveStepsize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__basinhopping_1_1BasinHoppingRunner.html">BasinHoppingRunner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__basinhopping_1_1Metropolis.html">Metropolis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__basinhopping_1_1MinimizerWrapper.html">MinimizerWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__basinhopping_1_1RandomDisplacement.html">RandomDisplacement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1optimize_1_1__basinhopping_1_1Storage.html">Storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33599dd3a1af47882707303ea89bb036"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html#a33599dd3a1af47882707303ea89bb036">basinhopping</a></td></tr>
<tr class="separator:a33599dd3a1af47882707303ea89bb036"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a47ca6452454c4eae46b270e28300380e"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html#a47ca6452454c4eae46b270e28300380e">__all__</a> = ['<a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html#a33599dd3a1af47882707303ea89bb036">basinhopping</a>']</td></tr>
<tr class="separator:a47ca6452454c4eae46b270e28300380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1073cfc3f47000d71431e4d4f033b21"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html#af1073cfc3f47000d71431e4d4f033b21">kwargs</a> = {&quot;method&quot;: &quot;L-BFGS-B&quot;}</td></tr>
<tr class="separator:af1073cfc3f47000d71431e4d4f033b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf49b15a9ea81879b1d8991926e3c150"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html#adf49b15a9ea81879b1d8991926e3c150">x0</a> = np.array([1.0, 1.])</td></tr>
<tr class="separator:adf49b15a9ea81879b1d8991926e3c150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa266e39b61ee46db97b8c3949e6fff22"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html#aa266e39b61ee46db97b8c3949e6fff22">ret</a></td></tr>
<tr class="separator:aa266e39b61ee46db97b8c3949e6fff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">basinhopping: The basinhopping global optimization algorithm
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a33599dd3a1af47882707303ea89bb036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.optimize._basinhopping.basinhopping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>niter</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stepsize</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minimizer_kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>take_step</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accept_test</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>niter_success</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the global minimum of a function using the basin-hopping algorithm

.. versionadded:: 0.12.0

Parameters
----------
func : callable ``f(x, *args)``
    Function to be optimized.  ``args`` can be passed as an optional item
    in the dict ``minimizer_kwargs``
x0 : ndarray
    Initial guess.
niter : integer, optional
    The number of basin hopping iterations
T : float, optional
    The "temperature" parameter for the accept or reject criterion.  Higher
    "temperatures" mean that larger jumps in function value will be
    accepted.  For best results ``T`` should be comparable to the
    separation
    (in function value) between local minima.
stepsize : float, optional
    initial step size for use in the random displacement.
minimizer_kwargs : dict, optional
    Extra keyword arguments to be passed to the minimizer
    ``scipy.optimize.minimize()`` Some important options could be:
        method : str
            The minimization method (e.g. ``"L-BFGS-B"``)
        args : tuple
            Extra arguments passed to the objective function (``func``) and
            its derivatives (Jacobian, Hessian).

take_step : callable ``take_step(x)``, optional
    Replace the default step taking routine with this routine.  The default
    step taking routine is a random displacement of the coordinates, but
    other step taking algorithms may be better for some systems.
    ``take_step`` can optionally have the attribute ``take_step.stepsize``.
    If this attribute exists, then ``basinhopping`` will adjust
    ``take_step.stepsize`` in order to try to optimize the global minimum
    search.
accept_test : callable, ``accept_test(f_new=f_new, x_new=x_new, f_old=fold, x_old=x_old)``, optional
    Define a test which will be used to judge whether or not to accept the
    step.  This will be used in addition to the Metropolis test based on
    "temperature" ``T``.  The acceptable return values are True,
    False, or ``"force accept"``.  If the latter, then this will
    override any other tests in order to accept the step.  This can be
    used, for example, to forcefully escape from a local minimum that
    ``basinhopping`` is trapped in.
callback : callable, ``callback(x, f, accept)``, optional
    A callback function which will be called for all minimum found.  ``x``
    and ``f`` are the coordinates and function value of the trial minima,
    and ``accept`` is whether or not that minima was accepted.  This can be
    used, for example, to save the lowest N minima found.  Also,
    ``callback`` can be used to specify a user defined stop criterion by
    optionally returning True to stop the ``basinhopping`` routine.
interval : integer, optional
    interval for how often to update the ``stepsize``
disp : bool, optional
    Set to True to print status messages
niter_success : integer, optional
    Stop the run if the global minimum candidate remains the same for this
    number of iterations.


Returns
-------
res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.  Important
    attributes are: ``x`` the solution array, ``fun`` the value of the
    function at the solution, and ``message`` which describes the cause of
    the termination. See `OptimizeResult` for a description of other attributes.

See Also
--------
minimize :
    The local minimization function called once for each basinhopping step.
    ``minimizer_kwargs`` is passed to this routine.

Notes
-----
Basin-hopping is a stochastic algorithm which attempts to find the global
minimum of a smooth scalar function of one or more variables [1]_ [2]_ [3]_
[4]_.  The algorithm in its current form was described by David Wales and
Jonathan Doye [2]_ http://www-wales.ch.cam.ac.uk/.

The algorithm is iterative with each cycle composed of the following
features

1) random perturbation of the coordinates

2) local minimization

3) accept or reject the new coordinates based on the minimized function
   value

The acceptance test used here is the Metropolis criterion of standard Monte
Carlo algorithms, although there are many other possibilities [3]_.

This global minimization method has been shown to be extremely efficient
for a wide variety of problems in physics and chemistry.  It is
particularly useful when the function has many minima separated by large
barriers. See the Cambridge Cluster Database
http://www-wales.ch.cam.ac.uk/CCD.html for databases of molecular systems
that have been optimized primarily using basin-hopping.  This database
includes minimization problems exceeding 300 degrees of freedom.

See the free software program GMIN (http://www-wales.ch.cam.ac.uk/GMIN) for
a Fortran implementation of basin-hopping.  This implementation has many
different variations of the procedure described above, including more
advanced step taking algorithms and alternate acceptance criterion.

For stochastic global optimization there is no way to determine if the true
global minimum has actually been found. Instead, as a consistency check,
the algorithm can be run from a number of different random starting points
to ensure the lowest minimum found in each example has converged to the
global minimum.  For this reason ``basinhopping`` will by default simply
run for the number of iterations ``niter`` and return the lowest minimum
found.  It is left to the user to ensure that this is in fact the global
minimum.

Choosing ``stepsize``:  This is a crucial parameter in ``basinhopping`` and
depends on the problem being solved.  Ideally it should be comparable to
the typical separation between local minima of the function being
optimized.  ``basinhopping`` will, by default, adjust ``stepsize`` to find
an optimal value, but this may take many iterations.  You will get quicker
results if you set a sensible value for ``stepsize``.

Choosing ``T``: The parameter ``T`` is the temperature used in the
metropolis criterion.  Basinhopping steps are accepted with probability
``1`` if ``func(xnew) &lt; func(xold)``, or otherwise with probability::

    exp( -(func(xnew) - func(xold)) / T )

So, for best results, ``T`` should to be comparable to the typical
difference in function values between local minima.

References
----------
.. [1] Wales, David J. 2003, Energy Landscapes, Cambridge University Press,
    Cambridge, UK.
.. [2] Wales, D J, and Doye J P K, Global Optimization by Basin-Hopping and
    the Lowest Energy Structures of Lennard-Jones Clusters Containing up to
    110 Atoms.  Journal of Physical Chemistry A, 1997, 101, 5111.
.. [3] Li, Z. and Scheraga, H. A., Monte Carlo-minimization approach to the
    multiple-minima problem in protein folding, Proc. Natl. Acad. Sci. USA,
    1987, 84, 6611.
.. [4] Wales, D. J. and Scheraga, H. A., Global optimization of clusters,
    crystals, and biomolecules, Science, 1999, 285, 1368.

Examples
--------
The following example is a one-dimensional minimization problem,  with many
local minima superimposed on a parabola.

&gt;&gt;&gt; func = lambda x: cos(14.5 * x - 0.3) + (x + 0.2) * x
&gt;&gt;&gt; x0=[1.]

Basinhopping, internally, uses a local minimization algorithm.  We will use
the parameter ``minimizer_kwargs`` to tell basinhopping which algorithm to
use and how to set up that minimizer.  This parameter will be passed to
``scipy.optimize.minimize()``.

&gt;&gt;&gt; minimizer_kwargs = {"method": "BFGS"}
&gt;&gt;&gt; ret = basinhopping(func, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200)
&gt;&gt;&gt; print("global minimum: x = %.4f, f(x0) = %.4f" % (ret.x, ret.fun))
global minimum: x = -0.1951, f(x0) = -1.0009

Next consider a two-dimensional minimization problem. Also, this time we
will use gradient information to significantly speed up the search.

&gt;&gt;&gt; def func2d(x):
...     f = cos(14.5 * x[0] - 0.3) + (x[1] + 0.2) * x[1] + (x[0] +
...                                                         0.2) * x[0]
...     df = np.zeros(2)
...     df[0] = -14.5 * sin(14.5 * x[0] - 0.3) + 2. * x[0] + 0.2
...     df[1] = 2. * x[1] + 0.2
...     return f, df

We'll also use a different local minimization algorithm.  Also we must tell
the minimizer that our function returns both energy and gradient (jacobian)

&gt;&gt;&gt; minimizer_kwargs = {"method":"L-BFGS-B", "jac":True}
&gt;&gt;&gt; x0 = [1.0, 1.0]
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200)
&gt;&gt;&gt; print("global minimum: x = [%.4f, %.4f], f(x0) = %.4f" % (ret.x[0],
...                                                           ret.x[1],
...                                                           ret.fun))
global minimum: x = [-0.1951, -0.1000], f(x0) = -1.0109


Here is an example using a custom step taking routine.  Imagine you want
the first coordinate to take larger steps then the rest of the coordinates.
This can be implemented like so:

&gt;&gt;&gt; class MyTakeStep(object):
...    def __init__(self, stepsize=0.5):
...        self.stepsize = stepsize
...    def __call__(self, x):
...        s = self.stepsize
...        x[0] += np.random.uniform(-2.*s, 2.*s)
...        x[1:] += np.random.uniform(-s, s, x[1:].shape)
...        return x

Since ``MyTakeStep.stepsize`` exists basinhopping will adjust the magnitude
of ``stepsize`` to optimize the search.  We'll use the same 2-D function as
before

&gt;&gt;&gt; mytakestep = MyTakeStep()
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200, take_step=mytakestep)
&gt;&gt;&gt; print("global minimum: x = [%.4f, %.4f], f(x0) = %.4f" % (ret.x[0],
...                                                           ret.x[1],
...                                                           ret.fun))
global minimum: x = [-0.1951, -0.1000], f(x0) = -1.0109


Now let's do an example using a custom callback function which prints the
value of every minimum found

&gt;&gt;&gt; def print_fun(x, f, accepted):
...         print("at minima %.4f accepted %d" % (f, int(accepted)))

We'll run it for only 10 basinhopping steps this time.

&gt;&gt;&gt; np.random.seed(1)
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=10, callback=print_fun)
at minima 0.4159 accepted 1
at minima -0.9073 accepted 1
at minima -0.1021 accepted 1
at minima -0.1021 accepted 1
at minima 0.9102 accepted 1
at minima 0.9102 accepted 1
at minima 2.2945 accepted 0
at minima -0.1021 accepted 1
at minima -1.0109 accepted 1
at minima -1.0109 accepted 1


The minima at -1.0109 is actually the global minimum, found already on the
8th iteration.

Now let's implement bounds on the problem using a custom ``accept_test``:

&gt;&gt;&gt; class MyBounds(object):
...     def __init__(self, xmax=[1.1,1.1], xmin=[-1.1,-1.1] ):
...         self.xmax = np.array(xmax)
...         self.xmin = np.array(xmin)
...     def __call__(self, **kwargs):
...         x = kwargs["x_new"]
...         tmax = bool(np.all(x &lt;= self.xmax))
...         tmin = bool(np.all(x &gt;= self.xmin))
...         return tmax and tmin

&gt;&gt;&gt; mybounds = MyBounds()
&gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=10, accept_test=mybounds)</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a47ca6452454c4eae46b270e28300380e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.optimize._basinhopping.__all__ = ['<a class="el" href="namespacescipy_1_1optimize_1_1__basinhopping.html#a33599dd3a1af47882707303ea89bb036">basinhopping</a>']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1073cfc3f47000d71431e4d4f033b21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.optimize._basinhopping.kwargs = {&quot;method&quot;: &quot;L-BFGS-B&quot;}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa266e39b61ee46db97b8c3949e6fff22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.optimize._basinhopping.ret</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespacescipy_1_1optimize_1_1__basinhopping.html">    1</a></span>&#160;= <a class="code" href="namespacescipy_1_1optimize_1_1__basinhopping.html#a33599dd3a1af47882707303ea89bb036">basinhopping</a>(_test_func2d_nograd, x0, minimizer_kwargs=kwargs,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                       niter=200, disp=<span class="keyword">False</span>)</div>
<div class="ttc" id="namespacescipy_1_1optimize_1_1__basinhopping_html_a33599dd3a1af47882707303ea89bb036"><div class="ttname"><a href="namespacescipy_1_1optimize_1_1__basinhopping.html#a33599dd3a1af47882707303ea89bb036">scipy.optimize._basinhopping.basinhopping</a></div><div class="ttdeci">def basinhopping</div><div class="ttdef"><b>Definition:</b> _basinhopping.py:304</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adf49b15a9ea81879b1d8991926e3c150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.optimize._basinhopping.x0 = np.array([1.0, 1.])</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:13 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
