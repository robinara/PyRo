<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.spatial.kdtree.KDTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1spatial.html">spatial</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1spatial_1_1kdtree.html">kdtree</a></li><li class="navelem"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html">KDTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classscipy_1_1spatial_1_1kdtree_1_1KDTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">scipy.spatial.kdtree.KDTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for scipy.spatial.kdtree.KDTree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classscipy_1_1spatial_1_1kdtree_1_1KDTree.png" usemap="#scipy.spatial.kdtree.KDTree_map" alt=""/>
  <map id="scipy.spatial.kdtree.KDTree_map" name="scipy.spatial.kdtree.KDTree_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree_1_1innernode.html">innernode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree_1_1leafnode.html">leafnode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree_1_1node.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6eb2743dd105d2796b758d1fc7ec3e00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a6eb2743dd105d2796b758d1fc7ec3e00">__init__</a></td></tr>
<tr class="separator:a6eb2743dd105d2796b758d1fc7ec3e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562327e8239ae3df870296e38d15b79e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a562327e8239ae3df870296e38d15b79e">query</a></td></tr>
<tr class="separator:a562327e8239ae3df870296e38d15b79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8639d93206dce7dfef095a1fa9d421"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a4f8639d93206dce7dfef095a1fa9d421">query_ball_point</a></td></tr>
<tr class="separator:a4f8639d93206dce7dfef095a1fa9d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d6b0561287117695e24f5becfc2b32"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#ae2d6b0561287117695e24f5becfc2b32">query_ball_tree</a></td></tr>
<tr class="separator:ae2d6b0561287117695e24f5becfc2b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86033ebe09f30b5216ad45339fe4367"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#ad86033ebe09f30b5216ad45339fe4367">query_pairs</a></td></tr>
<tr class="separator:ad86033ebe09f30b5216ad45339fe4367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a91f85ae76ae364a34d4051e76fb24"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#ad6a91f85ae76ae364a34d4051e76fb24">count_neighbors</a></td></tr>
<tr class="separator:ad6a91f85ae76ae364a34d4051e76fb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b33c027a8aec40ab53c23c4b4ec24c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a29b33c027a8aec40ab53c23c4b4ec24c">sparse_distance_matrix</a></td></tr>
<tr class="separator:a29b33c027a8aec40ab53c23c4b4ec24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a89685062babd7ff12cd5f465f7e74a6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a89685062babd7ff12cd5f465f7e74a6c">data</a></td></tr>
<tr class="separator:a89685062babd7ff12cd5f465f7e74a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ba7c07dbc703fd689e82541f44b84c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a79ba7c07dbc703fd689e82541f44b84c">m</a></td></tr>
<tr class="separator:a79ba7c07dbc703fd689e82541f44b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6f34f45726bb27be32908d8345de49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#afc6f34f45726bb27be32908d8345de49">leafsize</a></td></tr>
<tr class="separator:afc6f34f45726bb27be32908d8345de49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94c9b4f7ca63474d06e6bcbdd110c9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#aa94c9b4f7ca63474d06e6bcbdd110c9a">maxes</a></td></tr>
<tr class="separator:aa94c9b4f7ca63474d06e6bcbdd110c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b8f3b2253d9f73512530535cf40fb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a87b8f3b2253d9f73512530535cf40fb4">mins</a></td></tr>
<tr class="separator:a87b8f3b2253d9f73512530535cf40fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885b7950948f0cf39887d406ffe4d456"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1spatial_1_1kdtree_1_1KDTree.html#a885b7950948f0cf39887d406ffe4d456">tree</a></td></tr>
<tr class="separator:a885b7950948f0cf39887d406ffe4d456"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">kd-tree for quick nearest-neighbor lookup

This class provides an index into a set of k-dimensional points which
can be used to rapidly look up the nearest neighbors of any point.

Parameters
----------
data : (N,K) array_like
    The data points to be indexed. This array is not copied, and
    so modifying this data will result in bogus results.
leafsize : int, optional
    The number of points at which the algorithm switches over to
    brute-force.  Has to be positive.

Raises
------
RuntimeError
    The maximum recursion limit can be exceeded for large data
    sets.  If this happens, either increase the value for the `leafsize`
    parameter or increase the recursion limit by::

        &gt;&gt;&gt; import sys
        &gt;&gt;&gt; sys.setrecursionlimit(10000)

Notes
-----
The algorithm used is described in Maneewongvatana and Mount 1999.
The general idea is that the kd-tree is a binary tree, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value.

During construction, the axis and splitting point are chosen by the
"sliding midpoint" rule, which ensures that the cells do not all
become long and thin.

The tree can be queried for the r closest neighbors of any given point
(optionally returning only those within some maximum distance of the
point). It can also be queried, with a substantial gain in efficiency,
for the r approximate closest neighbors.

For large dimensions (20 is already large) do not expect this to run
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.

The tree also supports all-neighbors queries, both with arrays of points
and with other kd-trees. These do use a reasonably efficient algorithm,
but the kd-tree is not necessarily the best data structure for this
sort of calculation.</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6eb2743dd105d2796b758d1fc7ec3e00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.spatial.kdtree.KDTree.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leafsize</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad6a91f85ae76ae364a34d4051e76fb24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.spatial.kdtree.KDTree.count_neighbors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Count how many nearby pairs can be formed.

Count the number of pairs (x1,x2) can be formed, with x1 drawn
from self and x2 drawn from `other`, and where
``distance(x1, x2, p) &lt;= r``.
This is the "two-point correlation" described in Gray and Moore 2000,
"N-body problems in statistical learning", and the code here is based
on their algorithm.

Parameters
----------
other : KDTree instance
    The other tree to draw points from.
r : float or one-dimensional array of floats
    The radius to produce a count for. Multiple radii are searched with
    a single tree traversal.
p : float, 1&lt;=p&lt;=infinity
    Which Minkowski p-norm to use

Returns
-------
result : int or 1-D array of ints
    The number of pairs. Note that this is internally stored in a numpy
    int, and so may overflow if very large (2e9).</pre> 
</div>
</div>
<a class="anchor" id="a562327e8239ae3df870296e38d15b79e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.spatial.kdtree.KDTree.query </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance_upper_bound</em> = <code>np.inf</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Query the kd-tree for nearest neighbors

Parameters
----------
x : array_like, last dimension self.m
    An array of points to query.
k : integer
    The number of nearest neighbors to return.
eps : nonnegative float
    Return approximate nearest neighbors; the kth returned value
    is guaranteed to be no further than (1+eps) times the
    distance to the real kth nearest neighbor.
p : float, 1&lt;=p&lt;=infinity
    Which Minkowski p-norm to use.
    1 is the sum-of-absolute-values "Manhattan" distance
    2 is the usual Euclidean distance
    infinity is the maximum-coordinate-difference distance
distance_upper_bound : nonnegative float
    Return only neighbors within this distance. This is used to prune
    tree searches, so if you are doing a series of nearest-neighbor
    queries, it may help to supply the distance to the nearest neighbor
    of the most recent point.

Returns
-------
d : array of floats
    The distances to the nearest neighbors.
    If x has shape tuple+(self.m,), then d has shape tuple if
    k is one, or tuple+(k,) if k is larger than one.  Missing
    neighbors are indicated with infinite distances.  If k is None,
    then d is an object array of shape tuple, containing lists
    of distances. In either case the hits are sorted by distance
    (nearest first).
i : array of integers
    The locations of the neighbors in self.data. i is the same
    shape as d.

Examples
--------
&gt;&gt;&gt; from scipy import spatial
&gt;&gt;&gt; x, y = np.mgrid[0:5, 2:8]
&gt;&gt;&gt; tree = spatial.KDTree(zip(x.ravel(), y.ravel()))
&gt;&gt;&gt; tree.data
array([[0, 2],
       [0, 3],
       [0, 4],
       [0, 5],
       [0, 6],
       [0, 7],
       [1, 2],
       [1, 3],
       [1, 4],
       [1, 5],
       [1, 6],
       [1, 7],
       [2, 2],
       [2, 3],
       [2, 4],
       [2, 5],
       [2, 6],
       [2, 7],
       [3, 2],
       [3, 3],
       [3, 4],
       [3, 5],
       [3, 6],
       [3, 7],
       [4, 2],
       [4, 3],
       [4, 4],
       [4, 5],
       [4, 6],
       [4, 7]])
&gt;&gt;&gt; pts = np.array([[0, 0], [2.1, 2.9]])
&gt;&gt;&gt; tree.query(pts)
(array([ 2.        ,  0.14142136]), array([ 0, 13]))</pre> 
</div>
</div>
<a class="anchor" id="a4f8639d93206dce7dfef095a1fa9d421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.spatial.kdtree.KDTree.query_ball_point </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all points within distance r of point(s) x.

Parameters
----------
x : array_like, shape tuple + (self.m,)
    The point or points to search for neighbors of.
r : positive float
    The radius of points to return.
p : float, optional
    Which Minkowski p-norm to use.  Should be in the range [1, inf].
eps : nonnegative float, optional
    Approximate search. Branches of the tree are not explored if their
    nearest points are further than ``r / (1 + eps)``, and branches are
    added in bulk if their furthest points are nearer than
    ``r * (1 + eps)``.

Returns
-------
results : list or array of lists
    If `x` is a single point, returns a list of the indices of the
    neighbors of `x`. If `x` is an array of points, returns an object
    array of shape tuple containing lists of neighbors.

Notes
-----
If you have many points whose neighbors you want to find, you may save
substantial amounts of time by putting them in a KDTree and using
query_ball_tree.

Examples
--------
&gt;&gt;&gt; from scipy import spatial
&gt;&gt;&gt; x, y = np.mgrid[0:4, 0:4]
&gt;&gt;&gt; points = zip(x.ravel(), y.ravel())
&gt;&gt;&gt; tree = spatial.KDTree(points)
&gt;&gt;&gt; tree.query_ball_point([2, 0], 1)
[4, 8, 9, 12]</pre> 
</div>
</div>
<a class="anchor" id="ae2d6b0561287117695e24f5becfc2b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.spatial.kdtree.KDTree.query_ball_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all pairs of points whose distance is at most r

Parameters
----------
other : KDTree instance
    The tree containing points to search against.
r : float
    The maximum distance, has to be positive.
p : float, optional
    Which Minkowski norm to use.  `p` has to meet the condition
    ``1 &lt;= p &lt;= infinity``.
eps : float, optional
    Approximate search.  Branches of the tree are not explored
    if their nearest points are further than ``r/(1+eps)``, and
    branches are added in bulk if their furthest points are nearer
    than ``r * (1+eps)``.  `eps` has to be non-negative.

Returns
-------
results : list of lists
    For each element ``self.data[i]`` of this tree, ``results[i]`` is a
    list of the indices of its neighbors in ``other.data``.</pre> 
</div>
</div>
<a class="anchor" id="ad86033ebe09f30b5216ad45339fe4367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.spatial.kdtree.KDTree.query_pairs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all pairs of points within a distance.

Parameters
----------
r : positive float
    The maximum distance.
p : float, optional
    Which Minkowski norm to use.  `p` has to meet the condition
    ``1 &lt;= p &lt;= infinity``.
eps : float, optional
    Approximate search.  Branches of the tree are not explored
    if their nearest points are further than ``r/(1+eps)``, and
    branches are added in bulk if their furthest points are nearer
    than ``r * (1+eps)``.  `eps` has to be non-negative.

Returns
-------
results : set
    Set of pairs ``(i,j)``, with ``i &lt; j``, for which the corresponding
    positions are close.</pre> 
</div>
</div>
<a class="anchor" id="a29b33c027a8aec40ab53c23c4b4ec24c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.spatial.kdtree.KDTree.sparse_distance_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a sparse distance matrix

Computes a distance matrix between two KDTrees, leaving as zero
any distance greater than max_distance.

Parameters
----------
other : KDTree

max_distance : positive float

p : float, optional

Returns
-------
result : dok_matrix
    Sparse matrix representing the results in "dictionary of keys" format.</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a89685062babd7ff12cd5f465f7e74a6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial.kdtree.KDTree.data</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc6f34f45726bb27be32908d8345de49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial.kdtree.KDTree.leafsize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a79ba7c07dbc703fd689e82541f44b84c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial.kdtree.KDTree.m</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa94c9b4f7ca63474d06e6bcbdd110c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial.kdtree.KDTree.maxes</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87b8f3b2253d9f73512530535cf40fb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial.kdtree.KDTree.mins</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a885b7950948f0cf39887d406ffe4d456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.spatial.kdtree.KDTree.tree</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packages/scipy-0.14.0/scipy/spatial/<a class="el" href="kdtree_8py.html">kdtree.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:26 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
