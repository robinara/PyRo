<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.cluster.hierarchy Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1cluster.html">cluster</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html">hierarchy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.cluster.hierarchy Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1ClusterNode.html">ClusterNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4668bd02bef75a17761dada2f952c443"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a4668bd02bef75a17761dada2f952c443">single</a></td></tr>
<tr class="separator:a4668bd02bef75a17761dada2f952c443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb689b5fca344374db75337b3b4435fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#afb689b5fca344374db75337b3b4435fc">complete</a></td></tr>
<tr class="separator:afb689b5fca344374db75337b3b4435fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ced3081d3d6da023b5c0885863d30"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ab27ced3081d3d6da023b5c0885863d30">average</a></td></tr>
<tr class="separator:ab27ced3081d3d6da023b5c0885863d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a2dff4a4334f6c1fd8d1d387513c92"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a99a2dff4a4334f6c1fd8d1d387513c92">weighted</a></td></tr>
<tr class="separator:a99a2dff4a4334f6c1fd8d1d387513c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8295ae6d011df53777d384414aa4816a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a8295ae6d011df53777d384414aa4816a">centroid</a></td></tr>
<tr class="separator:a8295ae6d011df53777d384414aa4816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6273676cba44a8b2ffb81a5157e4aadc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a6273676cba44a8b2ffb81a5157e4aadc">median</a></td></tr>
<tr class="separator:a6273676cba44a8b2ffb81a5157e4aadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b8f04f0248ca03b03444ebcfb53dd4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a46b8f04f0248ca03b03444ebcfb53dd4">ward</a></td></tr>
<tr class="separator:a46b8f04f0248ca03b03444ebcfb53dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be1f5414c9a257cc2daa617cffcf1b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a2be1f5414c9a257cc2daa617cffcf1b9">linkage</a></td></tr>
<tr class="separator:a2be1f5414c9a257cc2daa617cffcf1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b20ed2c62f072a917ecc5384e05a83"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ac7b20ed2c62f072a917ecc5384e05a83">to_tree</a></td></tr>
<tr class="separator:ac7b20ed2c62f072a917ecc5384e05a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264fa612fe9c659a0e8900a1abb6064d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a264fa612fe9c659a0e8900a1abb6064d">cophenet</a></td></tr>
<tr class="separator:a264fa612fe9c659a0e8900a1abb6064d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d6073833207315f320d397f3fa7185"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a14d6073833207315f320d397f3fa7185">inconsistent</a></td></tr>
<tr class="separator:a14d6073833207315f320d397f3fa7185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a0bbae02e3e357b28d82c14d9bc288"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a37a0bbae02e3e357b28d82c14d9bc288">from_mlab_linkage</a></td></tr>
<tr class="separator:a37a0bbae02e3e357b28d82c14d9bc288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf53c96cc6ed2e23d449c407817fbeae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#abf53c96cc6ed2e23d449c407817fbeae">to_mlab_linkage</a></td></tr>
<tr class="separator:abf53c96cc6ed2e23d449c407817fbeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ad8404948d885554a6a145aa94595f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a69ad8404948d885554a6a145aa94595f">is_monotonic</a></td></tr>
<tr class="separator:a69ad8404948d885554a6a145aa94595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2f1ac53c4b95196a145ff2a5f13c14"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a9e2f1ac53c4b95196a145ff2a5f13c14">is_valid_im</a></td></tr>
<tr class="separator:a9e2f1ac53c4b95196a145ff2a5f13c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcf98fbb74908032d81e3723a99e3d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a6bcf98fbb74908032d81e3723a99e3d4">is_valid_linkage</a></td></tr>
<tr class="separator:a6bcf98fbb74908032d81e3723a99e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19efc78f56efff7483b3d498caa73b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#ad19efc78f56efff7483b3d498caa73b0">num_obs_linkage</a></td></tr>
<tr class="separator:ad19efc78f56efff7483b3d498caa73b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbe3f6eb0f37504ba37c6fd4fa82672"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a7dbe3f6eb0f37504ba37c6fd4fa82672">correspond</a></td></tr>
<tr class="separator:a7dbe3f6eb0f37504ba37c6fd4fa82672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab69119d3ded3eea468daaa4fa49d66"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#adab69119d3ded3eea468daaa4fa49d66">fcluster</a></td></tr>
<tr class="separator:adab69119d3ded3eea468daaa4fa49d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098505df307702564c947c14783dd2b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a098505df307702564c947c14783dd2b5">fclusterdata</a></td></tr>
<tr class="separator:a098505df307702564c947c14783dd2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f956758f76e1b11a971b1fee79ea8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a955f956758f76e1b11a971b1fee79ea8">leaves_list</a></td></tr>
<tr class="separator:a955f956758f76e1b11a971b1fee79ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5f59df78e8ca0e6ed5d93317e6c90e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#afc5f59df78e8ca0e6ed5d93317e6c90e">set_link_color_palette</a></td></tr>
<tr class="separator:afc5f59df78e8ca0e6ed5d93317e6c90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2942d06d7f30b74eed25bd2c0330d15a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a2942d06d7f30b74eed25bd2c0330d15a">dendrogram</a></td></tr>
<tr class="separator:a2942d06d7f30b74eed25bd2c0330d15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeae371603f7ba0b6834fad572137ed3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#abeae371603f7ba0b6834fad572137ed3">is_isomorphic</a></td></tr>
<tr class="separator:abeae371603f7ba0b6834fad572137ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a7225fdc03418ef902fa333dcab176"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a94a7225fdc03418ef902fa333dcab176">maxdists</a></td></tr>
<tr class="separator:a94a7225fdc03418ef902fa333dcab176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc774e7e5e48fb37a71fc5195bdd6ee4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#adc774e7e5e48fb37a71fc5195bdd6ee4">maxinconsts</a></td></tr>
<tr class="separator:adc774e7e5e48fb37a71fc5195bdd6ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea12331b90b1b1220456a4e97dfcf4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a0ea12331b90b1b1220456a4e97dfcf4f">maxRstat</a></td></tr>
<tr class="separator:a0ea12331b90b1b1220456a4e97dfcf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1642f47e85e138ea1e697387dec17c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#adf1642f47e85e138ea1e697387dec17c">leaders</a></td></tr>
<tr class="separator:adf1642f47e85e138ea1e697387dec17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a08000610cd9218a42e8e775811ac3116"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a08000610cd9218a42e8e775811ac3116">_cpy_non_euclid_methods</a></td></tr>
<tr class="separator:a08000610cd9218a42e8e775811ac3116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8c8239c572cb5301150e9e3d238b0a"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#aed8c8239c572cb5301150e9e3d238b0a">_cpy_euclid_methods</a> = {'<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a8295ae6d011df53777d384414aa4816a">centroid</a>': 3, '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a6273676cba44a8b2ffb81a5157e4aadc">median</a>': 4, '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a46b8f04f0248ca03b03444ebcfb53dd4">ward</a>': 5}</td></tr>
<tr class="separator:aed8c8239c572cb5301150e9e3d238b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa669835643f735862acc3d9690855cc"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#afa669835643f735862acc3d9690855cc">_cpy_linkage_methods</a> = set(_cpy_non_euclid_methods.keys())</td></tr>
<tr class="separator:afa669835643f735862acc3d9690855cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e5f5137979cd0a60b16d1f0853b6c4"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a41e5f5137979cd0a60b16d1f0853b6c4">__all__</a></td></tr>
<tr class="separator:a41e5f5137979cd0a60b16d1f0853b6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790a0a5417c572c81331a31bfc6d2150"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a790a0a5417c572c81331a31bfc6d2150">_cnode_bare</a> = <a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1ClusterNode.html">ClusterNode</a>(0)</td></tr>
<tr class="separator:a790a0a5417c572c81331a31bfc6d2150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28abe10552adf386e64235999e2c5c05"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a28abe10552adf386e64235999e2c5c05">_cnode_type</a> = <a class="el" href="fftw__dct_8c.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a>(<a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1ClusterNode.html">ClusterNode</a>)</td></tr>
<tr class="separator:a28abe10552adf386e64235999e2c5c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c2ab570be16641c7a6c6b8c9888a01"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a70c2ab570be16641c7a6c6b8c9888a01">_dtextsizes</a> = {20: 12, 30: 10, 50: 8, 85: 6, np.inf: 5}</td></tr>
<tr class="separator:a70c2ab570be16641c7a6c6b8c9888a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc156b5164b7d8ba3654b3f0bc5a41f4"><td class="memItemLeft" align="right" valign="top">dictionary&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#adc156b5164b7d8ba3654b3f0bc5a41f4">_drotation</a> = {20: 0, 40: 45, np.inf: 90}</td></tr>
<tr class="separator:adc156b5164b7d8ba3654b3f0bc5a41f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7261f809976b2b79252f0c9119182b4f"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a7261f809976b2b79252f0c9119182b4f">_dtextsortedkeys</a> = list(_dtextsizes.keys())</td></tr>
<tr class="separator:a7261f809976b2b79252f0c9119182b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1462efdb7ea8807e2bc726e282832d1"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#af1462efdb7ea8807e2bc726e282832d1">_drotationsortedkeys</a> = list(_drotation.keys())</td></tr>
<tr class="separator:af1462efdb7ea8807e2bc726e282832d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446dcf1e49353bbdaaf45d973eef5883"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a446dcf1e49353bbdaaf45d973eef5883">_link_line_colors</a> = ['g', '<a class="el" href="indexexpr_8h.html#ac434fd11cc2493608d8d91424d60c17e">r</a>', 'c', '<a class="el" href="indexexpr_8h.html#ab72fdb4031d47b75ab26dd18a437bcdc">m</a>', 'y', '<a class="el" href="indexexpr_8h.html#abb72938a198351550846b37a84588b63">k</a>']</td></tr>
<tr class="separator:a446dcf1e49353bbdaaf45d973eef5883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">========================================================
Hierarchical clustering (:mod:`scipy.cluster.hierarchy`)
========================================================

.. currentmodule:: scipy.cluster.hierarchy

These functions cut hierarchical clusterings into flat clusterings
or find the roots of the forest formed by a cut by providing the flat
cluster ids of each observation.

.. autosummary::
   :toctree: generated/

   fcluster
   fclusterdata
   leaders

These are routines for agglomerative clustering.

.. autosummary::
   :toctree: generated/

   linkage
   single
   complete
   average
   weighted
   centroid
   median
   ward

These routines compute statistics on hierarchies.

.. autosummary::
   :toctree: generated/

   cophenet
   from_mlab_linkage
   inconsistent
   maxinconsts
   maxdists
   maxRstat
   to_mlab_linkage

Routines for visualizing flat clusters.

.. autosummary::
   :toctree: generated/

   dendrogram

These are data structures and routines for representing hierarchies as
tree objects.

.. autosummary::
   :toctree: generated/

   ClusterNode
   leaves_list
   to_tree

These are predicates for checking the validity of linkage and
inconsistency matrices as well as for checking isomorphism of two
flat cluster assignments.

.. autosummary::
   :toctree: generated/

   is_valid_im
   is_valid_linkage
   is_isomorphic
   is_monotonic
   correspond
   num_obs_linkage

Utility routines for plotting:

.. autosummary::
   :toctree: generated/

   set_link_color_palette

References
----------

.. [1] "Statistics toolbox." API Reference Documentation. The MathWorks.
   http://www.mathworks.com/access/helpdesk/help/toolbox/stats/.
   Accessed October 1, 2007.

.. [2] "Hierarchical clustering." API Reference Documentation.
   The Wolfram Research, Inc.
   http://reference.wolfram.com/mathematica/HierarchicalClustering/tutorial/
   HierarchicalClustering.html.
   Accessed October 1, 2007.

.. [3] Gower, JC and Ross, GJS. "Minimum Spanning Trees and Single Linkage
   Cluster Analysis." Applied Statistics. 18(1): pp. 54--64. 1969.

.. [4] Ward Jr, JH. "Hierarchical grouping to optimize an objective
   function." Journal of the American Statistical Association. 58(301):
   pp. 236--44. 1963.

.. [5] Johnson, SC. "Hierarchical clustering schemes." Psychometrika.
   32(2): pp. 241--54. 1966.

.. [6] Sneath, PH and Sokal, RR. "Numerical taxonomy." Nature. 193: pp.
   855--60. 1962.

.. [7] Batagelj, V. "Comparing resemblance measures." Journal of
   Classification. 12: pp. 73--90. 1995.

.. [8] Sokal, RR and Michener, CD. "A statistical method for evaluating
   systematic relationships." Scientific Bulletins. 38(22):
   pp. 1409--38. 1958.

.. [9] Edelbrock, C. "Mixture model tests of hierarchical clustering
   algorithms: the problem of classifying everybody." Multivariate
   Behavioral Research. 14: pp. 367--84. 1979.

.. [10] Jain, A., and Dubes, R., "Algorithms for Clustering Data."
   Prentice-Hall. Englewood Cliffs, NJ. 1988.

.. [11] Fisher, RA "The use of multiple measurements in taxonomic
   problems." Annals of Eugenics, 7(2): 179-188. 1936


* MATLAB and MathWorks are registered trademarks of The MathWorks, Inc.

* Mathematica is a registered trademark of The Wolfram Research, Inc.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab27ced3081d3d6da023b5c0885863d30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.average </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs average/UPGMA linkage on a condensed distance matrix

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</pre> 
</div>
</div>
<a class="anchor" id="a8295ae6d011df53777d384414aa4816a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.centroid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs centroid/UPGMC linkage.

See ``linkage`` for more information on the return structure
and algorithm.

The following are common calling conventions:

1. ``Z = centroid(y)``

   Performs centroid/UPGMC linkage on the condensed distance
   matrix ``y``.  See ``linkage`` for more information on the return
   structure and algorithm.

2. ``Z = centroid(X)``

   Performs centroid/UPGMC linkage on the observation matrix ``X``
   using Euclidean distance as the distance metric. See ``linkage``
   for more information on the return structure and algorithm.

Parameters
----------
Q : ndarray
    A condensed or redundant distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns. Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    a m by n array.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</pre> 
</div>
</div>
<a class="anchor" id="afb689b5fca344374db75337b3b4435fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs complete/max/farthest point linkage on a condensed distance matrix

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage</pre> 
</div>
</div>
<a class="anchor" id="a264fa612fe9c659a0e8900a1abb6064d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.cophenet </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates the cophenetic distances between each observation in
the hierarchical clustering defined by the linkage ``Z``.

Suppose ``p`` and ``q`` are original observations in
disjoint clusters ``s`` and ``t``, respectively and
``s`` and ``t`` are joined by a direct parent cluster
``u``. The cophenetic distance between observations
``i`` and ``j`` is simply the distance between
clusters ``s`` and ``t``.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as an array
    (see ``linkage`` function).

Y : ndarray (optional)
    Calculates the cophenetic correlation coefficient ``c`` of a
    hierarchical clustering defined by the linkage matrix `Z`
    of a set of :math:`n` observations in :math:`m`
    dimensions. `Y` is the condensed distance matrix from which
    `Z` was generated.

Returns
-------
c : ndarray
    The cophentic correlation distance (if ``y`` is passed).
d : ndarray
    The cophenetic distance matrix in condensed form. The
    :math:`ij` th entry is the cophenetic distance between
    original observations :math:`i` and :math:`j`.</pre> 
</div>
</div>
<a class="anchor" id="a7dbe3f6eb0f37504ba37c6fd4fa82672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.correspond </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks for correspondence between linkage and condensed distance matrices

They must have the same number of original observations for
the check to succeed.

This function is useful as a sanity check in algorithms that make
extensive use of linkage and distance matrices that must
correspond to the same set of original observations.

Parameters
----------
Z : array_like
    The linkage matrix to check for correspondence.
Y : array_like
    The condensed distance matrix to check for correspondence.

Returns
-------
b : bool
    A boolean indicating whether the linkage matrix and distance
    matrix could possibly correspond to one another.</pre> 
</div>
</div>
<a class="anchor" id="a2942d06d7f30b74eed25bd2c0330d15a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.dendrogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>truncate_mode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>color_threshold</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>get_leaves</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orientation</em> = <code>'top'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count_sort</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance_sort</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>show_leaf_counts</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_plot</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_labels</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>color_list</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_font_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_rotation</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaf_label_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_leaves</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>show_contracted</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>link_color_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ax</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Plots the hierarchical clustering as a dendrogram.

The dendrogram illustrates how each cluster is
composed by drawing a U-shaped link between a non-singleton
cluster and its children. The height of the top of the U-link is
the distance between its children clusters. It is also the
cophenetic distance between original observations in the two
children clusters. It is expected that the distances in Z[:,2] be
monotonic, otherwise crossings appear in the dendrogram.

Parameters
----------
Z : ndarray
    The linkage matrix encoding the hierarchical clustering to
    render as a dendrogram. See the ``linkage`` function for more
    information on the format of ``Z``.
p : int, optional
    The ``p`` parameter for ``truncate_mode``.
truncate_mode : str, optional
    The dendrogram can be hard to read when the original
    observation matrix from which the linkage is derived is
    large. Truncation is used to condense the dendrogram. There
    are several modes:

    ``None/'none'``
      No truncation is performed (Default).

    ``'lastp'``
      The last ``p`` non-singleton formed in the linkage are the only
      non-leaf nodes in the linkage; they correspond to rows
      ``Z[n-p-2:end]`` in ``Z``. All other non-singleton clusters are
      contracted into leaf nodes.

    ``'mlab'``
      This corresponds to MATLAB(TM) behavior. (not implemented yet)

    ``'level'/'mtica'``
      No more than ``p`` levels of the dendrogram tree are displayed.
      This corresponds to Mathematica(TM) behavior.

color_threshold : double, optional
    For brevity, let :math:`t` be the ``color_threshold``.
    Colors all the descendent links below a cluster node
    :math:`k` the same color if :math:`k` is the first node below
    the cut threshold :math:`t`. All links connecting nodes with
    distances greater than or equal to the threshold are colored
    blue. If :math:`t` is less than or equal to zero, all nodes
    are colored blue. If ``color_threshold`` is None or
    'default', corresponding with MATLAB(TM) behavior, the
    threshold is set to ``0.7*max(Z[:,2])``.
get_leaves : bool, optional
    Includes a list ``R['leaves']=H`` in the result
    dictionary. For each :math:`i`, ``H[i] == j``, cluster node
    ``j`` appears in position ``i`` in the left-to-right traversal
    of the leaves, where :math:`j &lt; 2n-1` and :math:`i &lt; n`.
orientation : str, optional
    The direction to plot the dendrogram, which can be any
    of the following strings:

    ``'top'``
      Plots the root at the top, and plot descendent links going downwards.
      (default).

    ``'bottom'``
      Plots the root at the bottom, and plot descendent links going
      upwards.

    ``'left'``
      Plots the root at the left, and plot descendent links going right.

    ``'right'``
      Plots the root at the right, and plot descendent links going left.

labels : ndarray, optional
    By default ``labels`` is None so the index of the original observation
    is used to label the leaf nodes.  Otherwise, this is an :math:`n`
    -sized list (or tuple). The ``labels[i]`` value is the text to put
    under the :math:`i` th leaf node only if it corresponds to an original
    observation and not a non-singleton cluster.
count_sort : str or bool, optional
    For each node n, the order (visually, from left-to-right) n's
    two descendent links are plotted is determined by this
    parameter, which can be any of the following values:

    ``False``
      Nothing is done.

    ``'ascending'`` or ``True``
      The child with the minimum number of original objects in its cluster
      is plotted first.

    ``'descendent'``
      The child with the maximum number of original objects in its cluster
      is plotted first.

    Note ``distance_sort`` and ``count_sort`` cannot both be True.
distance_sort : str or bool, optional
    For each node n, the order (visually, from left-to-right) n's
    two descendent links are plotted is determined by this
    parameter, which can be any of the following values:

    ``False``
      Nothing is done.

    ``'ascending'`` or ``True``
      The child with the minimum distance between its direct descendents is
      plotted first.

    ``'descending'``
      The child with the maximum distance between its direct descendents is
      plotted first.

    Note ``distance_sort`` and ``count_sort`` cannot both be True.
show_leaf_counts : bool, optional
     When True, leaf nodes representing :math:`k&gt;1` original
     observation are labeled with the number of observations they
     contain in parentheses.
no_plot : bool, optional
    When True, the final rendering is not performed. This is
    useful if only the data structures computed for the rendering
    are needed or if matplotlib is not available.
no_labels : bool, optional
    When True, no labels appear next to the leaf nodes in the
    rendering of the dendrogram.
leaf_label_rotation : double, optional
    Specifies the angle (in degrees) to rotate the leaf
    labels. When unspecified, the rotation based on the number of
    nodes in the dendrogram (default is 0).
leaf_font_size : int, optional
    Specifies the font size (in points) of the leaf labels. When
    unspecified, the size based on the number of nodes in the
    dendrogram.
leaf_label_func : lambda or function, optional
    When leaf_label_func is a callable function, for each
    leaf with cluster index :math:`k &lt; 2n-1`. The function
    is expected to return a string with the label for the
    leaf.

    Indices :math:`k &lt; n` correspond to original observations
    while indices :math:`k \\geq n` correspond to non-singleton
    clusters.

    For example, to label singletons with their node id and
    non-singletons with their id, count, and inconsistency
    coefficient, simply do:

    &gt;&gt;&gt; # First define the leaf label function.
    &gt;&gt;&gt; def llf(id):
    ...       if id &lt; n:
    ...           return str(id)
    ...       else:
    &gt;&gt;&gt;           return '[%d %d %1.2f]' % (id, count, R[n-id,3])
    &gt;&gt;&gt;
    &gt;&gt;&gt;  # The text for the leaf nodes is going to be big so force
    &gt;&gt;&gt;  # a rotation of 90 degrees.
    &gt;&gt;&gt;  dendrogram(Z, leaf_label_func=llf, leaf_rotation=90)

show_contracted : bool, optional
    When True the heights of non-singleton nodes contracted
    into a leaf node are plotted as crosses along the link
    connecting that leaf node.  This really is only useful when
    truncation is used (see ``truncate_mode`` parameter).
link_color_func : callable, optional
    If given, `link_color_function` is called with each non-singleton id
    corresponding to each U-shaped link it will paint. The function is
    expected to return the color to paint the link, encoded as a matplotlib
    color string code. For example:

    &gt;&gt;&gt; dendrogram(Z, link_color_func=lambda k: colors[k])

    colors the direct links below each untruncated non-singleton node
    ``k`` using ``colors[k]``.
ax : matplotlib Axes instance, optional
    If None and `no_plot` is not True, the dendrogram will be plotted
    on the current axes.  Otherwise if `no_plot` is not True the
    dendrogram will be plotted on the given ``Axes`` instance. This can be
    useful if the dendrogram is part of a more complex figure.

Returns
-------
R : dict
    A dictionary of data structures computed to render the
    dendrogram. Its has the following keys:

    ``'icoords'``
      A list of lists ``[I1, I2, ..., Ip]`` where ``Ik`` is a list of 4
      independent variable coordinates corresponding to the line that
      represents the k'th link painted.

    ``'dcoords'``
      A list of lists ``[I2, I2, ..., Ip]`` where ``Ik`` is a list of 4
      independent variable coordinates corresponding to the line that
      represents the k'th link painted.

    ``'ivl'``
      A list of labels corresponding to the leaf nodes.

    ``'leaves'``
      For each i, ``H[i] == j``, cluster node ``j`` appears in position
      ``i`` in the left-to-right traversal of the leaves, where
      :math:`j &lt; 2n-1` and :math:`i &lt; n`. If ``j`` is less than ``n``, the
      ``i``-th leaf node corresponds to an original observation.
      Otherwise, it corresponds to a non-singleton cluster.</pre> 
</div>
</div>
<a class="anchor" id="adab69119d3ded3eea468daaa4fa49d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.fcluster </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>criterion</em> = <code>'inconsistent'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>monocrit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Forms flat clusters from the hierarchical clustering defined by
the linkage matrix ``Z``.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded with the matrix returned
    by the `linkage` function.
t : float
    The threshold to apply when forming flat clusters.
criterion : str, optional
    The criterion to use in forming flat clusters. This can
    be any of the following values:

      ``inconsistent`` : If a cluster node and all its
          descendants have an inconsistent value less than or equal
          to `t` then all its leaf descendants belong to the
          same flat cluster. When no non-singleton cluster meets
          this criterion, every node is assigned to its own
          cluster. (Default)

      ``distance`` : Forms flat clusters so that the original
          observations in each flat cluster have no greater a
          cophenetic distance than `t`.

      ``maxclust`` : Finds a minimum threshold ``r`` so that
          the cophenetic distance between any two original
          observations in the same flat cluster is no more than
          ``r`` and no more than `t` flat clusters are formed.

      ``monocrit`` : Forms a flat cluster from a cluster node c
          with index i when ``monocrit[j] &lt;= t``.

          For example, to threshold on the maximum mean distance
          as computed in the inconsistency matrix R with a
          threshold of 0.8 do:

            MR = maxRstat(Z, R, 3)

            cluster(Z, t=0.8, criterion='monocrit', monocrit=MR)

      ``maxclust_monocrit`` : Forms a flat cluster from a
          non-singleton cluster node ``c`` when ``monocrit[i] &lt;=
          r`` for all cluster indices ``i`` below and including
          ``c``. ``r`` is minimized such that no more than ``t``
          flat clusters are formed. monocrit must be
          monotonic. For example, to minimize the threshold t on
          maximum inconsistency values so that no more than 3 flat
          clusters are formed, do:

            MI = maxinconsts(Z, R)

            cluster(Z, t=3, criterion='maxclust_monocrit', monocrit=MI)

depth : int, optional
    The maximum depth to perform the inconsistency calculation.
    It has no meaning for the other criteria. Default is 2.
R : ndarray, optional
    The inconsistency matrix to use for the 'inconsistent'
    criterion. This matrix is computed if not provided.
monocrit : ndarray, optional
    An array of length n-1. `monocrit[i]` is the
    statistics upon which non-singleton i is thresholded. The
    monocrit vector must be monotonic, i.e. given a node c with
    index i, for all node indices j corresponding to nodes
    below c, `monocrit[i] &gt;= monocrit[j]`.

Returns
-------
fcluster : ndarray
    An array of length n. T[i] is the flat cluster number to
    which original observation i belongs.</pre> 
</div>
</div>
<a class="anchor" id="a098505df307702564c947c14783dd2b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.fclusterdata </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>criterion</em> = <code>'inconsistent'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>'euclidean'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>depth</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'single'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cluster observation data using a given metric.

Clusters the original observations in the n-by-m data
matrix X (n observations in m dimensions), using the euclidean
distance metric to calculate distances between original observations,
performs hierarchical clustering using the single linkage algorithm,
and forms flat clusters using the inconsistency method with `t` as the
cut-off threshold.

A one-dimensional array T of length n is returned. T[i] is the index
of the flat cluster to which the original observation i belongs.

Parameters
----------
X : (N, M) ndarray
    N by M data matrix with N observations in M dimensions.
t : float
    The threshold to apply when forming flat clusters.
criterion : str, optional
    Specifies the criterion for forming flat clusters.  Valid
    values are 'inconsistent' (default), 'distance', or 'maxclust'
    cluster formation algorithms. See `fcluster` for descriptions.
metric : str, optional
    The distance metric for calculating pairwise distances. See
    `distance.pdist` for descriptions and linkage to verify
    compatibility with the linkage method.
depth : int, optional
    The maximum depth for the inconsistency calculation. See
    `inconsistent` for more information.
method : str, optional
    The linkage method to use (single, complete, average,
    weighted, median centroid, ward). See `linkage` for more
    information. Default is "single".
R : ndarray, optional
    The inconsistency matrix. It will be computed if necessary
    if it is not passed.

Returns
-------
fclusterdata : ndarray
    A vector of length n. T[i] is the flat cluster number to
    which original observation i belongs.

Notes
-----
This function is similar to the MATLAB function clusterdata.</pre> 
</div>
</div>
<a class="anchor" id="a37a0bbae02e3e357b28d82c14d9bc288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.from_mlab_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts a linkage matrix generated by MATLAB(TM) to a new
linkage matrix compatible with this module.

The conversion does two things:

 * the indices are converted from ``1..N`` to ``0..(N-1)`` form,
   and

 * a fourth column Z[:,3] is added where Z[i,3] is represents the
   number of original observations (leaves) in the non-singleton
   cluster i.

This function is useful when loading in linkages from legacy data
files generated by MATLAB.

Parameters
----------
Z : ndarray
    A linkage matrix generated by MATLAB(TM).

Returns
-------
ZS : ndarray
    A linkage matrix compatible with this library.</pre> 
</div>
</div>
<a class="anchor" id="a14d6073833207315f320d397f3fa7185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.inconsistent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculates inconsistency statistics on a linkage.

Note: This function behaves similarly to the MATLAB(TM)
inconsistent function.

Parameters
----------
Z : ndarray
    The :math:`(n-1)` by 4 matrix encoding the linkage
    (hierarchical clustering).  See ``linkage`` documentation
    for more information on its form.
d : int, optional
    The number of links up to `d` levels below each
    non-singleton cluster.

Returns
-------
R : ndarray
    A :math:`(n-1)` by 5 matrix where the ``i``'th row
    contains the link statistics for the non-singleton cluster
    ``i``. The link statistics are computed over the link
    heights for links :math:`d` levels below the cluster
    ``i``. ``R[i,0]`` and ``R[i,1]`` are the mean and standard
    deviation of the link heights, respectively; ``R[i,2]`` is
    the number of links included in the calculation; and
    ``R[i,3]`` is the inconsistency coefficient,

    .. math:: \\frac{\\mathtt{Z[i,2]}-\\mathtt{R[i,0]}} {R[i,1]}</pre> 
</div>
</div>
<a class="anchor" id="abeae371603f7ba0b6834fad572137ed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.is_isomorphic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determines if two different cluster assignments are equivalent.

Parameters
----------
T1 : array_like
    An assignment of singleton cluster ids to flat cluster ids.
T2 : array_like
    An assignment of singleton cluster ids to flat cluster ids.

Returns
-------
b : bool
    Whether the flat cluster assignments `T1` and `T2` are
    equivalent.</pre> 
</div>
</div>
<a class="anchor" id="a69ad8404948d885554a6a145aa94595f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.is_monotonic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the linkage passed is monotonic.

The linkage is monotonic if for every cluster :math:`s` and :math:`t`
joined, the distance between them is no less than the distance
between any previously joined clusters.

Parameters
----------
Z : ndarray
    The linkage matrix to check for monotonicity.

Returns
-------
b : bool
    A boolean indicating whether the linkage is monotonic.</pre> 
</div>
</div>
<a class="anchor" id="a9e2f1ac53c4b95196a145ff2a5f13c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.is_valid_im </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>warning</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>throw</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the inconsistency matrix passed is valid.

It must be a :math:`n` by 4 numpy array of doubles. The standard
deviations ``R[:,1]`` must be nonnegative. The link counts
``R[:,2]`` must be positive and no greater than :math:`n-1`.

Parameters
----------
R : ndarray
    The inconsistency matrix to check for validity.
warning : bool, optional
     When True, issues a Python warning if the linkage
     matrix passed is invalid.
throw : bool, optional
     When True, throws a Python exception if the linkage
     matrix passed is invalid.
name : str, optional
     This string refers to the variable name of the invalid
     linkage matrix.

Returns
-------
b : bool
    True if the inconsistency matrix is valid.</pre> 
</div>
</div>
<a class="anchor" id="a6bcf98fbb74908032d81e3723a99e3d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.is_valid_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>warning</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>throw</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks the validity of a linkage matrix.

A linkage matrix is valid if it is a two dimensional
ndarray (type double) with :math:`n`
rows and 4 columns.  The first two columns must contain indices
between 0 and :math:`2n-1`. For a given row ``i``,
:math:`0 \\leq \\mathtt{Z[i,0]} \\leq i+n-1`
and :math:`0 \\leq Z[i,1] \\leq i+n-1`
(i.e. a cluster cannot join another cluster unless the cluster
being joined has been generated.)

Parameters
----------
Z : array_like
    Linkage matrix.
warning : bool, optional
    When True, issues a Python warning if the linkage
    matrix passed is invalid.
throw : bool, optional
    When True, throws a Python exception if the linkage
    matrix passed is invalid.
name : str, optional
       This string refers to the variable name of the invalid
       linkage matrix.

Returns
-------
b : bool
    True iff the inconsistency matrix is valid.</pre> 
</div>
</div>
<a class="anchor" id="adf1642f47e85e138ea1e697387dec17c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.leaders </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the root nodes in a hierarchical clustering.

Returns the root nodes in a hierarchical clustering corresponding
to a cut defined by a flat cluster assignment vector ``T``. See
the ``fcluster`` function for more information on the format of ``T``.

For each flat cluster :math:`j` of the :math:`k` flat clusters
represented in the n-sized flat cluster assignment vector ``T``,
this function finds the lowest cluster node :math:`i` in the linkage
tree Z such that:

  * leaf descendents belong only to flat cluster j
    (i.e. ``T[p]==j`` for all :math:`p` in :math:`S(i)` where
    :math:`S(i)` is the set of leaf ids of leaf nodes descendent
    with cluster node :math:`i`)

  * there does not exist a leaf that is not descendent with
    :math:`i` that also belongs to cluster :math:`j`
    (i.e. ``T[q]!=j`` for all :math:`q` not in :math:`S(i)`).  If
    this condition is violated, ``T`` is not a valid cluster
    assignment vector, and an exception will be thrown.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.
T : ndarray
    The flat cluster assignment vector.

Returns
-------
L : ndarray
    The leader linkage node id's stored as a k-element 1-D array
    where ``k`` is the number of flat clusters found in ``T``.

    ``L[j]=i`` is the linkage cluster node id that is the
    leader of flat cluster with id M[j].  If ``i &lt; n``, ``i``
    corresponds to an original observation, otherwise it
    corresponds to a non-singleton cluster.

    For example: if ``L[3]=2`` and ``M[3]=8``, the flat cluster with
    id 8's leader is linkage node 2.
M : ndarray
    The leader linkage node id's stored as a k-element 1-D array where
    ``k`` is the number of flat clusters found in ``T``. This allows the
    set of flat cluster ids to be any arbitrary set of ``k`` integers.</pre> 
</div>
</div>
<a class="anchor" id="a955f956758f76e1b11a971b1fee79ea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.leaves_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of leaf node ids

The return corresponds to the observation vector index as it appears
in the tree from left to right. Z is a linkage matrix.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix.  `Z` is
    a linkage matrix.  See ``linkage`` for more information.

Returns
-------
leaves_list : ndarray
    The list of leaf node ids.</pre> 
</div>
</div>
<a class="anchor" id="a2be1f5414c9a257cc2daa617cffcf1b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'single'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>'euclidean'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs hierarchical/agglomerative clustering on the condensed
distance matrix y.

y must be a :math:`{n \\choose 2}` sized
vector where n is the number of original observations paired
in the distance matrix. The behavior of this function is very
similar to the MATLAB linkage function.

A 4 by :math:`(n-1)` matrix ``Z`` is returned. At the
:math:`i`-th iteration, clusters with indices ``Z[i, 0]`` and
``Z[i, 1]`` are combined to form cluster :math:`n + i`. A
cluster with an index less than :math:`n` corresponds to one of
the :math:`n` original observations. The distance between
clusters ``Z[i, 0]`` and ``Z[i, 1]`` is given by ``Z[i, 2]``. The
fourth value ``Z[i, 3]`` represents the number of original
observations in the newly formed cluster.

The following linkage methods are used to compute the distance
:math:`d(s, t)` between two clusters :math:`s` and
:math:`t`. The algorithm begins with a forest of clusters that
have yet to be used in the hierarchy being formed. When two
clusters :math:`s` and :math:`t` from this forest are combined
into a single cluster :math:`u`, :math:`s` and :math:`t` are
removed from the forest, and :math:`u` is added to the
forest. When only one cluster remains in the forest, the algorithm
stops, and this cluster becomes the root.

A distance matrix is maintained at each iteration. The ``d[i,j]``
entry corresponds to the distance between cluster :math:`i` and
:math:`j` in the original forest.

At each iteration, the algorithm must update the distance matrix
to reflect the distance of the newly formed cluster u with the
remaining clusters in the forest.

Suppose there are :math:`|u|` original observations
:math:`u[0], \\ldots, u[|u|-1]` in cluster :math:`u` and
:math:`|v|` original objects :math:`v[0], \\ldots, v[|v|-1]` in
cluster :math:`v`. Recall :math:`s` and :math:`t` are
combined to form cluster :math:`u`. Let :math:`v` be any
remaining cluster in the forest that is not :math:`u`.

The following are methods for calculating the distance between the
newly formed cluster :math:`u` and each :math:`v`.

  * method='single' assigns

    .. math::
       d(u,v) = \\min(dist(u[i],v[j]))

    for all points :math:`i` in cluster :math:`u` and
    :math:`j` in cluster :math:`v`. This is also known as the
    Nearest Point Algorithm.

  * method='complete' assigns

    .. math::
       d(u, v) = \\max(dist(u[i],v[j]))

    for all points :math:`i` in cluster u and :math:`j` in
    cluster :math:`v`. This is also known by the Farthest Point
    Algorithm or Voor Hees Algorithm.

  * method='average' assigns

    .. math::
       d(u,v) = \\sum_{ij} \\frac{d(u[i], v[j])}
                               {(|u|*|v|)}

    for all points :math:`i` and :math:`j` where :math:`|u|`
    and :math:`|v|` are the cardinalities of clusters :math:`u`
    and :math:`v`, respectively. This is also called the UPGMA
    algorithm. This is called UPGMA.

  * method='weighted' assigns

    .. math::
       d(u,v) = (dist(s,v) + dist(t,v))/2

    where cluster u was formed with cluster s and t and v
    is a remaining cluster in the forest. (also called WPGMA)

  * method='centroid' assigns

    .. math::
       dist(s,t) = ||c_s-c_t||_2

    where :math:`c_s` and :math:`c_t` are the centroids of
    clusters :math:`s` and :math:`t`, respectively. When two
    clusters :math:`s` and :math:`t` are combined into a new
    cluster :math:`u`, the new centroid is computed over all the
    original objects in clusters :math:`s` and :math:`t`. The
    distance then becomes the Euclidean distance between the
    centroid of :math:`u` and the centroid of a remaining cluster
    :math:`v` in the forest. This is also known as the UPGMC
    algorithm.

  * method='median' assigns math:`d(s,t)` like the ``centroid``
    method. When two clusters :math:`s` and :math:`t` are combined
    into a new cluster :math:`u`, the average of centroids s and t
    give the new centroid :math:`u`. This is also known as the
    WPGMC algorithm.

  * method='ward' uses the Ward variance minimization algorithm.
    The new entry :math:`d(u,v)` is computed as follows,

    .. math::

       d(u,v) = \\sqrt{\\frac{|v|+|s|}
                           {T}d(v,s)^2
                    + \\frac{|v|+|t|}
                           {T}d(v,t)^2
                    + \\frac{|v|}
                           {T}d(s,t)^2}

    where :math:`u` is the newly joined cluster consisting of
    clusters :math:`s` and :math:`t`, :math:`v` is an unused
    cluster in the forest, :math:`T=|v|+|s|+|t|`, and
    :math:`|*|` is the cardinality of its argument. This is also
    known as the incremental algorithm.

Warning: When the minimum distance pair in the forest is chosen, there
may be two or more pairs with the same minimum distance. This
implementation may chose a different minimum than the MATLAB
version.

Parameters
----------
y : ndarray
    A condensed or redundant distance matrix. A condensed distance matrix
    is a flat array containing the upper triangular of the distance matrix.
    This is the form that ``pdist`` returns. Alternatively, a collection of
    :math:`m` observation vectors in n dimensions may be passed as an
    :math:`m` by :math:`n` array.
method : str, optional
    The linkage algorithm to use. See the ``Linkage Methods`` section below
    for full descriptions.
metric : str, optional
    The distance metric to use. See the ``distance.pdist`` function for a
    list of valid distance metrics.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.</pre> 
</div>
</div>
<a class="anchor" id="a94a7225fdc03418ef902fa333dcab176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.maxdists </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the maximum distance between any non-singleton cluster.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.

Returns
-------
maxdists : ndarray
    A ``(n-1)`` sized numpy array of doubles; ``MD[i]`` represents
    the maximum distance between any cluster (including
    singletons) below and including the node with index i. More
    specifically, ``MD[i] = Z[Q(i)-n, 2].max()`` where ``Q(i)`` is the
    set of all node indices below and including node i.</pre> 
</div>
</div>
<a class="anchor" id="adc774e7e5e48fb37a71fc5195bdd6ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.maxinconsts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the maximum inconsistency coefficient for each
non-singleton cluster and its descendents.

Parameters
----------
Z : ndarray
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.
R : ndarray
    The inconsistency matrix.

Returns
-------
MI : ndarray
    A monotonic ``(n-1)``-sized numpy array of doubles.</pre> 
</div>
</div>
<a class="anchor" id="a0ea12331b90b1b1220456a4e97dfcf4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.maxRstat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the maximum statistic for each non-singleton cluster and
its descendents.

Parameters
----------
Z : array_like
    The hierarchical clustering encoded as a matrix. See
    ``linkage`` for more information.
R : array_like
    The inconsistency matrix.
i : int
    The column of `R` to use as the statistic.

Returns
-------
MR : ndarray
    Calculates the maximum statistic for the i'th column of the
    inconsistency matrix `R` for each non-singleton cluster
    node. ``MR[j]`` is the maximum over ``R[Q(j)-n, i]`` where
    ``Q(j)`` the set of all node ids corresponding to nodes below
    and including ``j``.</pre> 
</div>
</div>
<a class="anchor" id="a6273676cba44a8b2ffb81a5157e4aadc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.median </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs median/WPGMC linkage.

See ``linkage`` for more information on the return structure
and algorithm.

 The following are common calling conventions:

 1. ``Z = median(y)``

    Performs median/WPGMC linkage on the condensed distance matrix
    ``y``.  See ``linkage`` for more information on the return
    structure and algorithm.

 2. ``Z = median(X)``

    Performs median/WPGMC linkage on the observation matrix ``X``
    using Euclidean distance as the distance metric. See linkage
    for more information on the return structure and algorithm.

Parameters
----------
Q : ndarray
    A condensed or redundant distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns. Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    a m by n array.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</pre> 
</div>
</div>
<a class="anchor" id="ad19efc78f56efff7483b3d498caa73b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.num_obs_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of original observations of the linkage matrix
passed.

Parameters
----------
Z : ndarray
    The linkage matrix on which to perform the operation.

Returns
-------
n : int
    The number of original observations in the linkage.</pre> 
</div>
</div>
<a class="anchor" id="afc5f59df78e8ca0e6ed5d93317e6c90e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.set_link_color_palette </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>palette</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set list of matplotlib color codes for dendrogram color_threshold.

Parameters
----------
palette : list
    A list of matplotlib color codes. The order of
    the color codes is the order in which the colors are cycled
    through when color thresholding in the dendrogram.</pre> 
</div>
</div>
<a class="anchor" id="a4668bd02bef75a17761dada2f952c443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.single </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs single/min/nearest linkage on the condensed distance matrix ``y``

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    The linkage matrix.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</pre> 
</div>
</div>
<a class="anchor" id="abf53c96cc6ed2e23d449c407817fbeae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.to_mlab_linkage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts a linkage matrix to a MATLAB(TM) compatible one.

Converts a linkage matrix ``Z`` generated by the linkage function
of this module to a MATLAB(TM) compatible one. The return linkage
matrix has the last column removed and the cluster indices are
converted to ``1..N`` indexing.

Parameters
----------
Z : ndarray
    A linkage matrix generated by this library.

Returns
-------
to_mlab_linkage : ndarray
    A linkage matrix compatible with MATLAB(TM)'s hierarchical
    clustering functions.

    The return linkage matrix has the last column removed
    and the cluster indices are converted to ``1..N`` indexing.</pre> 
</div>
</div>
<a class="anchor" id="ac7b20ed2c62f072a917ecc5384e05a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.to_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rd</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts a hierarchical clustering encoded in the matrix ``Z`` (by
linkage) into an easy-to-use tree object.

The reference r to the root ClusterNode object is returned.

Each ClusterNode object has a left, right, dist, id, and count
attribute. The left and right attributes point to ClusterNode objects
that were combined to generate the cluster. If both are None then
the ClusterNode object is a leaf node, its count must be 1, and its
distance is meaningless but set to 0.

Note: This function is provided for the convenience of the library
user. ClusterNodes are not used as input to any of the functions in this
library.

Parameters
----------
Z : ndarray
    The linkage matrix in proper form (see the ``linkage``
    function documentation).

rd : bool, optional
    When False, a reference to the root ClusterNode object is
    returned.  Otherwise, a tuple (r,d) is returned. ``r`` is a
    reference to the root node while ``d`` is a dictionary
    mapping cluster ids to ClusterNode references. If a cluster id is
    less than n, then it corresponds to a singleton cluster
    (leaf node). See ``linkage`` for more information on the
    assignment of cluster ids to clusters.

Returns
-------
L : list
    The pre-order traversal.</pre> 
</div>
</div>
<a class="anchor" id="a46b8f04f0248ca03b03444ebcfb53dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.ward </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs Ward's linkage on a condensed or redundant distance matrix.

See linkage for more information on the return structure
and algorithm.

The following are common calling conventions:

1. ``Z = ward(y)``
   Performs Ward's linkage on the condensed distance matrix ``Z``. See
   linkage for more information on the return structure and
   algorithm.

2. ``Z = ward(X)``
   Performs Ward's linkage on the observation matrix ``X`` using
   Euclidean distance as the distance metric. See linkage for more
   information on the return structure and algorithm.

Parameters
----------
Q : ndarray
    A condensed or redundant distance matrix. A condensed
    distance matrix is a flat array containing the upper
    triangular of the distance matrix. This is the form that
    ``pdist`` returns. Alternatively, a collection of
    m observation vectors in n dimensions may be passed as
    a m by n array.

Returns
-------
Z : ndarray
    The hierarchical clustering encoded as a linkage matrix.

See Also
--------
linkage: for advanced creation of hierarchical clusterings.</pre> 
</div>
</div>
<a class="anchor" id="a99a2dff4a4334f6c1fd8d1d387513c92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.cluster.hierarchy.weighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Performs weighted/WPGMA linkage on the condensed distance matrix.

See ``linkage`` for more information on the return
structure and algorithm.

Parameters
----------
y : ndarray
    The upper triangular of the distance matrix. The result of
    ``pdist`` is returned in this form.

Returns
-------
Z : ndarray
    A linkage matrix containing the hierarchical clustering. See
    the ``linkage`` function documentation for more information
    on its structure.

See Also
--------
linkage : for advanced creation of hierarchical clusterings.</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a41e5f5137979cd0a60b16d1f0853b6c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.cluster.hierarchy.__all__</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespacescipy_1_1cluster_1_1hierarchy.html">    1</a></span>&#160;= [<span class="stringliteral">&#39;ClusterNode&#39;</span>, <span class="stringliteral">&#39;average&#39;</span>, <span class="stringliteral">&#39;centroid&#39;</span>, <span class="stringliteral">&#39;complete&#39;</span>, <span class="stringliteral">&#39;cophenet&#39;</span>,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;           <span class="stringliteral">&#39;correspond&#39;</span>, <span class="stringliteral">&#39;dendrogram&#39;</span>, <span class="stringliteral">&#39;fcluster&#39;</span>, <span class="stringliteral">&#39;fclusterdata&#39;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;           <span class="stringliteral">&#39;from_mlab_linkage&#39;</span>, <span class="stringliteral">&#39;inconsistent&#39;</span>, <span class="stringliteral">&#39;is_isomorphic&#39;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;           <span class="stringliteral">&#39;is_monotonic&#39;</span>, <span class="stringliteral">&#39;is_valid_im&#39;</span>, <span class="stringliteral">&#39;is_valid_linkage&#39;</span>, <span class="stringliteral">&#39;leaders&#39;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;           <span class="stringliteral">&#39;leaves_list&#39;</span>, <span class="stringliteral">&#39;linkage&#39;</span>, <span class="stringliteral">&#39;maxRstat&#39;</span>, <span class="stringliteral">&#39;maxdists&#39;</span>, <span class="stringliteral">&#39;maxinconsts&#39;</span>,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;           <span class="stringliteral">&#39;median&#39;</span>, <span class="stringliteral">&#39;num_obs_linkage&#39;</span>, <span class="stringliteral">&#39;set_link_color_palette&#39;</span>, <span class="stringliteral">&#39;single&#39;</span>,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;           <span class="stringliteral">&#39;to_mlab_linkage&#39;</span>, <span class="stringliteral">&#39;to_tree&#39;</span>, <span class="stringliteral">&#39;ward&#39;</span>, <span class="stringliteral">&#39;weighted&#39;</span>, <span class="stringliteral">&#39;distance&#39;</span>]</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a790a0a5417c572c81331a31bfc6d2150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.cluster.hierarchy._cnode_bare = <a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1ClusterNode.html">ClusterNode</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a28abe10552adf386e64235999e2c5c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.cluster.hierarchy._cnode_type = <a class="el" href="fftw__dct_8c.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a>(<a class="el" href="classscipy_1_1cluster_1_1hierarchy_1_1ClusterNode.html">ClusterNode</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aed8c8239c572cb5301150e9e3d238b0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.cluster.hierarchy._cpy_euclid_methods = {'<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a8295ae6d011df53777d384414aa4816a">centroid</a>': 3, '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a6273676cba44a8b2ffb81a5157e4aadc">median</a>': 4, '<a class="el" href="namespacescipy_1_1cluster_1_1hierarchy.html#a46b8f04f0248ca03b03444ebcfb53dd4">ward</a>': 5}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa669835643f735862acc3d9690855cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.cluster.hierarchy._cpy_linkage_methods = set(_cpy_non_euclid_methods.keys())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a08000610cd9218a42e8e775811ac3116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.cluster.hierarchy._cpy_non_euclid_methods</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespacescipy_1_1cluster_1_1hierarchy.html">    1</a></span>&#160;= {<span class="stringliteral">&#39;single&#39;</span>: 0, <span class="stringliteral">&#39;complete&#39;</span>: 1, <span class="stringliteral">&#39;average&#39;</span>: 2,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;                           <span class="stringliteral">&#39;weighted&#39;</span>: 6}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adc156b5164b7d8ba3654b3f0bc5a41f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.cluster.hierarchy._drotation = {20: 0, 40: 45, np.inf: 90}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1462efdb7ea8807e2bc726e282832d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.cluster.hierarchy._drotationsortedkeys = list(_drotation.keys())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a70c2ab570be16641c7a6c6b8c9888a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictionary scipy.cluster.hierarchy._dtextsizes = {20: 12, 30: 10, 50: 8, 85: 6, np.inf: 5}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7261f809976b2b79252f0c9119182b4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.cluster.hierarchy._dtextsortedkeys = list(_dtextsizes.keys())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a446dcf1e49353bbdaaf45d973eef5883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.cluster.hierarchy._link_line_colors = ['g', '<a class="el" href="indexexpr_8h.html#ac434fd11cc2493608d8d91424d60c17e">r</a>', 'c', '<a class="el" href="indexexpr_8h.html#ab72fdb4031d47b75ab26dd18a437bcdc">m</a>', 'y', '<a class="el" href="indexexpr_8h.html#abb72938a198351550846b37a84588b63">k</a>']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:26:55 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
