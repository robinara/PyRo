<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: double</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">double<div class="ingroups"><a class="el" href="group__testing.html">LAPACK Testing</a> &raquo; <a class="el" href="group__eig.html">Eigenvalue and Singular value</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4281d345e520762c2b713861a36db678"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga4281d345e520762c2b713861a36db678">dbdt01</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KD, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, Q, LDQ, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, PT, LDPT, WORK, RESID)</td></tr>
<tr class="memdesc:ga4281d345e520762c2b713861a36db678"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DBDT01</b>  <a href="#ga4281d345e520762c2b713861a36db678">More...</a><br /></td></tr>
<tr class="separator:ga4281d345e520762c2b713861a36db678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4300a964c1dd20239562d1c58a1c8a69"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga4300a964c1dd20239562d1c58a1c8a69">dbdt02</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, C, LDC, U, LDU, WORK, RESID)</td></tr>
<tr class="memdesc:ga4300a964c1dd20239562d1c58a1c8a69"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DBDT02</b>  <a href="#ga4300a964c1dd20239562d1c58a1c8a69">More...</a><br /></td></tr>
<tr class="separator:ga4300a964c1dd20239562d1c58a1c8a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6578f36abb99e08a2b08611468074f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga6c6578f36abb99e08a2b08611468074f">dbdt03</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KD, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, S, VT, LDVT, WORK, RESID)</td></tr>
<tr class="memdesc:ga6c6578f36abb99e08a2b08611468074f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DBDT03</b>  <a href="#ga6c6578f36abb99e08a2b08611468074f">More...</a><br /></td></tr>
<tr class="separator:ga6c6578f36abb99e08a2b08611468074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ec9fc9822df7885e553241df6b3171"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gad3ec9fc9822df7885e553241df6b3171">dchkbb</a> (NSIZES, MVAL, NVAL, NWDTHS, KK, NTYPES, DOTYPE, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, AB, LDAB, BD, BE, Q, LDQ, P, LDP, C, LDC, CC, WORK, LWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:gad3ec9fc9822df7885e553241df6b3171"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKBB</b>  <a href="#gad3ec9fc9822df7885e553241df6b3171">More...</a><br /></td></tr>
<tr class="separator:gad3ec9fc9822df7885e553241df6b3171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ab01e2495d343417e614aeec1571f1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga04ab01e2495d343417e614aeec1571f1">dchkbd</a> (NSIZES, MVAL, NVAL, NTYPES, DOTYPE, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, BD, BE, S1, S2, X, LDX, Y, Z, Q, LDQ, PT, LDPT, U, VT, WORK, LWORK, IWORK, NOUT, INFO)</td></tr>
<tr class="memdesc:ga04ab01e2495d343417e614aeec1571f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKBD</b>  <a href="#ga04ab01e2495d343417e614aeec1571f1">More...</a><br /></td></tr>
<tr class="separator:ga04ab01e2495d343417e614aeec1571f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcf76f5f33d2f4905f61284d938d3e4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga8bcf76f5f33d2f4905f61284d938d3e4">dchkbk</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:ga8bcf76f5f33d2f4905f61284d938d3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKBK</b>  <a href="#ga8bcf76f5f33d2f4905f61284d938d3e4">More...</a><br /></td></tr>
<tr class="separator:ga8bcf76f5f33d2f4905f61284d938d3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48bef9c53d7828ee7b25c9ccf56fed9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gad48bef9c53d7828ee7b25c9ccf56fed9">dchkbl</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:gad48bef9c53d7828ee7b25c9ccf56fed9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKBL</b>  <a href="#gad48bef9c53d7828ee7b25c9ccf56fed9">More...</a><br /></td></tr>
<tr class="separator:gad48bef9c53d7828ee7b25c9ccf56fed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga909f6f89527e6667b8e49034a692f7b4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga909f6f89527e6667b8e49034a692f7b4">dchkec</a> (<a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, TSTERR, NIN, NOUT)</td></tr>
<tr class="memdesc:ga909f6f89527e6667b8e49034a692f7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKEC</b>  <a href="#ga909f6f89527e6667b8e49034a692f7b4">More...</a><br /></td></tr>
<tr class="separator:ga909f6f89527e6667b8e49034a692f7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8356beeda2da8d0fef89ccb4bc414d5a"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga8356beeda2da8d0fef89ccb4bc414d5a">dchkee</a></td></tr>
<tr class="memdesc:ga8356beeda2da8d0fef89ccb4bc414d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKEE</b>  <a href="#ga8356beeda2da8d0fef89ccb4bc414d5a">More...</a><br /></td></tr>
<tr class="separator:ga8356beeda2da8d0fef89ccb4bc414d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e3a487742ba9acb39f783362b5b300"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga90e3a487742ba9acb39f783362b5b300">dchkgg</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, TSTDIF, THRSHN, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, H, T, S1, S2, P1, P2, U, LDU, V, Q, Z, ALPHR1, ALPHI1, BETA1, ALPHR3, ALPHI3, BETA3, EVECTL, EVECTR, WORK, LWORK, LLWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga90e3a487742ba9acb39f783362b5b300"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKGG</b>  <a href="#ga90e3a487742ba9acb39f783362b5b300">More...</a><br /></td></tr>
<tr class="separator:ga90e3a487742ba9acb39f783362b5b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4c10b0d7b63d96afa90ce5928d6d30"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga4c4c10b0d7b63d96afa90ce5928d6d30">dchkgk</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:ga4c4c10b0d7b63d96afa90ce5928d6d30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKGK</b>  <a href="#ga4c4c10b0d7b63d96afa90ce5928d6d30">More...</a><br /></td></tr>
<tr class="separator:ga4c4c10b0d7b63d96afa90ce5928d6d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e823485a300f7a3e836dde971d0539b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga2e823485a300f7a3e836dde971d0539b">dchkgl</a> (NIN, NOUT)</td></tr>
<tr class="memdesc:ga2e823485a300f7a3e836dde971d0539b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKGL</b>  <a href="#ga2e823485a300f7a3e836dde971d0539b">More...</a><br /></td></tr>
<tr class="separator:ga2e823485a300f7a3e836dde971d0539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7d85c04f03e5a109a04a119293910b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga1c7d85c04f03e5a109a04a119293910b">dchkhs</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, T1, T2, U, LDU, Z, UZ, WR1, WI1, WR3, WI3, EVECTL, EVECTR, EVECTY, EVECTX, UU, TAU, WORK, NWORK, IWORK, SELECT, RESULT, INFO)</td></tr>
<tr class="memdesc:ga1c7d85c04f03e5a109a04a119293910b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKHS</b>  <a href="#ga1c7d85c04f03e5a109a04a119293910b">More...</a><br /></td></tr>
<tr class="separator:ga1c7d85c04f03e5a109a04a119293910b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef9e79152c39b707e749d783f40e57b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga5ef9e79152c39b707e749d783f40e57b">dchksb</a> (NSIZES, NN, NWDTHS, KK, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, SD, SE, U, LDU, WORK, LWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga5ef9e79152c39b707e749d783f40e57b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKSB</b>  <a href="#ga5ef9e79152c39b707e749d783f40e57b">More...</a><br /></td></tr>
<tr class="separator:ga5ef9e79152c39b707e749d783f40e57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fcde518d0efadd400e7ddf07235f188"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga9fcde518d0efadd400e7ddf07235f188">dchkst</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, AP, SD, SE, D1, D2, D3, D4, D5, WA1, WA2, WA3, WR, U, LDU, V, VP, TAU, Z, WORK, LWORK, IWORK, LIWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga9fcde518d0efadd400e7ddf07235f188"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCHKST</b>  <a href="#ga9fcde518d0efadd400e7ddf07235f188">More...</a><br /></td></tr>
<tr class="separator:ga9fcde518d0efadd400e7ddf07235f188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21bc4aa635925a1753872278c38891b8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga21bc4aa635925a1753872278c38891b8">dckcsd</a> (NM, MVAL, PVAL, QVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, MMAX, X, XF, U1, U2, V1T, V2T, THETA, IWORK, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:ga21bc4aa635925a1753872278c38891b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCKCSD</b>  <a href="#ga21bc4aa635925a1753872278c38891b8">More...</a><br /></td></tr>
<tr class="separator:ga21bc4aa635925a1753872278c38891b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b8c9f14788fd8526a77c40a11e684f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaf6b8c9f14788fd8526a77c40a11e684f">dckglm</a> (NN, MVAL, PVAL, NVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, B, BF, X, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:gaf6b8c9f14788fd8526a77c40a11e684f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCKGLM</b>  <a href="#gaf6b8c9f14788fd8526a77c40a11e684f">More...</a><br /></td></tr>
<tr class="separator:gaf6b8c9f14788fd8526a77c40a11e684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d542e25f93c07e7fac6bdf79e741bac"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga2d542e25f93c07e7fac6bdf79e741bac">dckgqr</a> (NM, MVAL, NP, PVAL, NN, NVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, AQ, AR, TAUA, B, BF, BZ, BT, BWK, TAUB, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:ga2d542e25f93c07e7fac6bdf79e741bac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCKGQR</b>  <a href="#ga2d542e25f93c07e7fac6bdf79e741bac">More...</a><br /></td></tr>
<tr class="separator:ga2d542e25f93c07e7fac6bdf79e741bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc45ea9306629ad531d876544d73adf"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gafbc45ea9306629ad531d876544d73adf">dckgsv</a> (NM, MVAL, PVAL, NVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, B, BF, U, V, Q, ALPHA, BETA, R, IWORK, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:gafbc45ea9306629ad531d876544d73adf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCKGSV</b>  <a href="#gafbc45ea9306629ad531d876544d73adf">More...</a><br /></td></tr>
<tr class="separator:gafbc45ea9306629ad531d876544d73adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9cfcdec43b543507c9b770e2d4e0e3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga4d9cfcdec43b543507c9b770e2d4e0e3">dcklse</a> (NN, MVAL, PVAL, NVAL, NMATS, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NMAX, <a class="el" href="classA.html">A</a>, AF, B, BF, X, WORK, RWORK, NIN, NOUT, INFO)</td></tr>
<tr class="memdesc:ga4d9cfcdec43b543507c9b770e2d4e0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCKLSE</b>  <a href="#ga4d9cfcdec43b543507c9b770e2d4e0e3">More...</a><br /></td></tr>
<tr class="separator:ga4d9cfcdec43b543507c9b770e2d4e0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03cd3ed37d8c793d58398c431d01ea1d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga03cd3ed37d8c793d58398c431d01ea1d">dcsdts</a> (M, P, Q, X, XF, LDX, U1, LDU1, U2, LDU2, V1T, LDV1T, V2T, LDV2T, THETA, IWORK, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga03cd3ed37d8c793d58398c431d01ea1d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DCSDTS</b>  <a href="#ga03cd3ed37d8c793d58398c431d01ea1d">More...</a><br /></td></tr>
<tr class="separator:ga03cd3ed37d8c793d58398c431d01ea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc419f7585f852ef90e140e55fdfd49"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga6cc419f7585f852ef90e140e55fdfd49">ddrges</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, S, T, Q, LDQ, Z, ALPHAR, ALPHAI, BETA, WORK, LWORK, RESULT, BWORK, INFO)</td></tr>
<tr class="memdesc:ga6cc419f7585f852ef90e140e55fdfd49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRGES</b>  <a href="#ga6cc419f7585f852ef90e140e55fdfd49">More...</a><br /></td></tr>
<tr class="separator:ga6cc419f7585f852ef90e140e55fdfd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd9ec32424dde4c58b7f7b35365e879"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga5dd9ec32424dde4c58b7f7b35365e879">ddrgev</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, S, T, Q, LDQ, Z, QE, LDQE, ALPHAR, ALPHAI, BETA, ALPHR1, ALPHI1, BETA1, WORK, LWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga5dd9ec32424dde4c58b7f7b35365e879"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRGEV</b>  <a href="#ga5dd9ec32424dde4c58b7f7b35365e879">More...</a><br /></td></tr>
<tr class="separator:ga5dd9ec32424dde4c58b7f7b35365e879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5408eea13bb949e9ff502a7dfd447954"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga5408eea13bb949e9ff502a7dfd447954">ddrgsx</a> (NSIZE, NCMAX, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIN, NOUT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, AI, BI, Z, Q, ALPHAR, ALPHAI, BETA, C, LDC, S, WORK, LWORK, IWORK, LIWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:ga5408eea13bb949e9ff502a7dfd447954"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRGSX</b>  <a href="#ga5408eea13bb949e9ff502a7dfd447954">More...</a><br /></td></tr>
<tr class="separator:ga5408eea13bb949e9ff502a7dfd447954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fe443f6eebc293d99eae77fa84d9c5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga12fe443f6eebc293d99eae77fa84d9c5">ddrgvx</a> (NSIZE, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIN, NOUT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, AI, BI, ALPHAR, ALPHAI, BETA, VL, VR, ILO, IHI, LSCALE, RSCALE, S, DTRU, DIF, DIFTRU, WORK, LWORK, IWORK, LIWORK, RESULT, BWORK, INFO)</td></tr>
<tr class="memdesc:ga12fe443f6eebc293d99eae77fa84d9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRGVX</b>  <a href="#ga12fe443f6eebc293d99eae77fa84d9c5">More...</a><br /></td></tr>
<tr class="separator:ga12fe443f6eebc293d99eae77fa84d9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154b2caeffc955bb3dede4c310ca3cd6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga154b2caeffc955bb3dede4c310ca3cd6">ddrvbd</a> (NSIZES, MM, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, U, LDU, VT, LDVT, ASAV, USAV, VTSAV, S, SSAV, E, WORK, LWORK, IWORK, NOUT, INFO)</td></tr>
<tr class="memdesc:ga154b2caeffc955bb3dede4c310ca3cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVBD</b>  <a href="#ga154b2caeffc955bb3dede4c310ca3cd6">More...</a><br /></td></tr>
<tr class="separator:ga154b2caeffc955bb3dede4c310ca3cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ffc2a465b9b10ab80fc13e6197d0dc3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga8ffc2a465b9b10ab80fc13e6197d0dc3">ddrves</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, HT, WR, WI, WRT, WIT, VS, LDVS, RESULT, WORK, NWORK, IWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:ga8ffc2a465b9b10ab80fc13e6197d0dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVES</b>  <a href="#ga8ffc2a465b9b10ab80fc13e6197d0dc3">More...</a><br /></td></tr>
<tr class="separator:ga8ffc2a465b9b10ab80fc13e6197d0dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11aeae4727a8a3236db6a56d3ca220c1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga11aeae4727a8a3236db6a56d3ca220c1">ddrvev</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, WR, WI, WR1, WI1, VL, LDVL, VR, LDVR, LRE, LDLRE, RESULT, WORK, NWORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga11aeae4727a8a3236db6a56d3ca220c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVEV</b>  <a href="#ga11aeae4727a8a3236db6a56d3ca220c1">More...</a><br /></td></tr>
<tr class="separator:ga11aeae4727a8a3236db6a56d3ca220c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf88edcce9dcbf23eda454e31d1b422db"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaf88edcce9dcbf23eda454e31d1b422db">ddrvgg</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, THRSHN, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, S, T, S2, T2, Q, LDQ, Z, ALPHR1, ALPHI1, BETA1, ALPHR2, ALPHI2, BETA2, VL, VR, WORK, LWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:gaf88edcce9dcbf23eda454e31d1b422db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVGG</b>  <a href="#gaf88edcce9dcbf23eda454e31d1b422db">More...</a><br /></td></tr>
<tr class="separator:gaf88edcce9dcbf23eda454e31d1b422db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58eaea06da0e219700ba96536201242"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gac58eaea06da0e219700ba96536201242">ddrvsg</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, Z, LDZ, AB, BB, AP, BP, WORK, NWORK, IWORK, LIWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:gac58eaea06da0e219700ba96536201242"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVSG</b>  <a href="#gac58eaea06da0e219700ba96536201242">More...</a><br /></td></tr>
<tr class="separator:gac58eaea06da0e219700ba96536201242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47fc55396c12e72375ade9b3b3fefc79"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga47fc55396c12e72375ade9b3b3fefc79">ddrvst</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, D1, D2, D3, D4, EVEIGS, WA1, WA2, WA3, U, LDU, V, TAU, Z, WORK, LWORK, IWORK, LIWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:ga47fc55396c12e72375ade9b3b3fefc79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVST</b>  <a href="#ga47fc55396c12e72375ade9b3b3fefc79">More...</a><br /></td></tr>
<tr class="separator:ga47fc55396c12e72375ade9b3b3fefc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b419f2aaa6ac71abbaa387a29e5ee6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga35b419f2aaa6ac71abbaa387a29e5ee6">ddrvsx</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIUNIT, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, HT, WR, WI, WRT, WIT, WRTMP, WITMP, VS, LDVS, VS1, RESULT, WORK, LWORK, IWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:ga35b419f2aaa6ac71abbaa387a29e5ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVSX</b>  <a href="#ga35b419f2aaa6ac71abbaa387a29e5ee6">More...</a><br /></td></tr>
<tr class="separator:ga35b419f2aaa6ac71abbaa387a29e5ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db8108d75a2a49d865e766418fa0726"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga4db8108d75a2a49d865e766418fa0726">ddrvvx</a> (NSIZES, NN, NTYPES, DOTYPE, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, NIUNIT, NOUNIT, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, WR, WI, WR1, WI1, VL, LDVL, VR, LDVR, LRE, LDLRE, RCONDV, RCNDV1, RCDVIN, RCONDE, RCNDE1, RCDEIN, SCALE, SCALE1, RESULT, WORK, NWORK, IWORK, INFO)</td></tr>
<tr class="memdesc:ga4db8108d75a2a49d865e766418fa0726"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DDRVVX</b>  <a href="#ga4db8108d75a2a49d865e766418fa0726">More...</a><br /></td></tr>
<tr class="separator:ga4db8108d75a2a49d865e766418fa0726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e18a852c76f0b059ad31c83f06b8cc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gad5e18a852c76f0b059ad31c83f06b8cc">derrbd</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:gad5e18a852c76f0b059ad31c83f06b8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DERRBD</b>  <a href="#gad5e18a852c76f0b059ad31c83f06b8cc">More...</a><br /></td></tr>
<tr class="separator:gad5e18a852c76f0b059ad31c83f06b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5320e38d676febaa986dd34106f0bb2f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga5320e38d676febaa986dd34106f0bb2f">derrec</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:ga5320e38d676febaa986dd34106f0bb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DERREC</b>  <a href="#ga5320e38d676febaa986dd34106f0bb2f">More...</a><br /></td></tr>
<tr class="separator:ga5320e38d676febaa986dd34106f0bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae397fe859a9ec662321082f76fb08b8f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gae397fe859a9ec662321082f76fb08b8f">derred</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:gae397fe859a9ec662321082f76fb08b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DERRED</b>  <a href="#gae397fe859a9ec662321082f76fb08b8f">More...</a><br /></td></tr>
<tr class="separator:gae397fe859a9ec662321082f76fb08b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d9ace812b32d503ff8f053720136c7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gab1d9ace812b32d503ff8f053720136c7">derrgg</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:gab1d9ace812b32d503ff8f053720136c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DERRGG</b>  <a href="#gab1d9ace812b32d503ff8f053720136c7">More...</a><br /></td></tr>
<tr class="separator:gab1d9ace812b32d503ff8f053720136c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab764b80cbc14db00eaf61ea4d9b81b1a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gab764b80cbc14db00eaf61ea4d9b81b1a">derrhs</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:gab764b80cbc14db00eaf61ea4d9b81b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DERRHS</b>  <a href="#gab764b80cbc14db00eaf61ea4d9b81b1a">More...</a><br /></td></tr>
<tr class="separator:gab764b80cbc14db00eaf61ea4d9b81b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21a3e291e9a00ac64068628a398361f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gae21a3e291e9a00ac64068628a398361f">derrst</a> (PATH, NUNIT)</td></tr>
<tr class="memdesc:gae21a3e291e9a00ac64068628a398361f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DERRST</b>  <a href="#gae21a3e291e9a00ac64068628a398361f">More...</a><br /></td></tr>
<tr class="separator:gae21a3e291e9a00ac64068628a398361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed33a09e8bc0c43d32c67f83e1673630"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaed33a09e8bc0c43d32c67f83e1673630">dget02</a> (<a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58">TRANS</a>, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, X, LDX, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, RWORK, RESID)</td></tr>
<tr class="memdesc:gaed33a09e8bc0c43d32c67f83e1673630"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET02</b>  <a href="#gaed33a09e8bc0c43d32c67f83e1673630">More...</a><br /></td></tr>
<tr class="separator:gaed33a09e8bc0c43d32c67f83e1673630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb713f19d6762f47a227399fcfdf6f2a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gafb713f19d6762f47a227399fcfdf6f2a">dget10</a> (M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, WORK, RESULT)</td></tr>
<tr class="memdesc:gafb713f19d6762f47a227399fcfdf6f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET10</b>  <a href="#gafb713f19d6762f47a227399fcfdf6f2a">More...</a><br /></td></tr>
<tr class="separator:gafb713f19d6762f47a227399fcfdf6f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585a3526e86563a9452e9243c23ad31b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga585a3526e86563a9452e9243c23ad31b">dget22</a> (TRANSA, TRANSE, TRANSW, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, E, LDE, WR, WI, WORK, RESULT)</td></tr>
<tr class="memdesc:ga585a3526e86563a9452e9243c23ad31b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET22</b>  <a href="#ga585a3526e86563a9452e9243c23ad31b">More...</a><br /></td></tr>
<tr class="separator:ga585a3526e86563a9452e9243c23ad31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52ccc18dfdd08a5c0af32a0bb689f6c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaa52ccc18dfdd08a5c0af32a0bb689f6c">dget23</a> (COMP, BALANC, JTYPE, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, ISEED, NOUNIT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, WR, WI, WR1, WI1, VL, LDVL, VR, LDVR, LRE, LDLRE, RCONDV, RCNDV1, RCDVIN, RCONDE, RCNDE1, RCDEIN, SCALE, SCALE1, RESULT, WORK, LWORK, IWORK, INFO)</td></tr>
<tr class="memdesc:gaa52ccc18dfdd08a5c0af32a0bb689f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET23</b>  <a href="#gaa52ccc18dfdd08a5c0af32a0bb689f6c">More...</a><br /></td></tr>
<tr class="separator:gaa52ccc18dfdd08a5c0af32a0bb689f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656556219b63123ac0f9abe66299ec50"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga656556219b63123ac0f9abe66299ec50">dget24</a> (COMP, JTYPE, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, ISEED, NOUNIT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, HT, WR, WI, WRT, WIT, WRTMP, WITMP, VS, LDVS, VS1, RCDEIN, RCDVIN, NSLCT, ISLCT, RESULT, WORK, LWORK, IWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:ga656556219b63123ac0f9abe66299ec50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET24</b>  <a href="#ga656556219b63123ac0f9abe66299ec50">More...</a><br /></td></tr>
<tr class="separator:ga656556219b63123ac0f9abe66299ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec96be19f30761456f6973cfbfe302bb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaec96be19f30761456f6973cfbfe302bb">dget31</a> (RMAX, LMAX, NINFO, KNT)</td></tr>
<tr class="memdesc:gaec96be19f30761456f6973cfbfe302bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET31</b>  <a href="#gaec96be19f30761456f6973cfbfe302bb">More...</a><br /></td></tr>
<tr class="separator:gaec96be19f30761456f6973cfbfe302bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7bb9df80003ec4b42399fac9972fcdf"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaa7bb9df80003ec4b42399fac9972fcdf">dget32</a> (RMAX, LMAX, NINFO, KNT)</td></tr>
<tr class="memdesc:gaa7bb9df80003ec4b42399fac9972fcdf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET32</b>  <a href="#gaa7bb9df80003ec4b42399fac9972fcdf">More...</a><br /></td></tr>
<tr class="separator:gaa7bb9df80003ec4b42399fac9972fcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d06279a44e3ee4af0c0122fc704857a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga0d06279a44e3ee4af0c0122fc704857a">dget33</a> (RMAX, LMAX, NINFO, KNT)</td></tr>
<tr class="memdesc:ga0d06279a44e3ee4af0c0122fc704857a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET33</b>  <a href="#ga0d06279a44e3ee4af0c0122fc704857a">More...</a><br /></td></tr>
<tr class="separator:ga0d06279a44e3ee4af0c0122fc704857a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5920e80cf7499fc8cdb1c71f4e97ad3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gac5920e80cf7499fc8cdb1c71f4e97ad3">dget34</a> (RMAX, LMAX, NINFO, KNT)</td></tr>
<tr class="memdesc:gac5920e80cf7499fc8cdb1c71f4e97ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET34</b>  <a href="#gac5920e80cf7499fc8cdb1c71f4e97ad3">More...</a><br /></td></tr>
<tr class="separator:gac5920e80cf7499fc8cdb1c71f4e97ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85b2e71e578a368367a8c4043011129"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gad85b2e71e578a368367a8c4043011129">dget35</a> (RMAX, LMAX, NINFO, KNT)</td></tr>
<tr class="memdesc:gad85b2e71e578a368367a8c4043011129"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET35</b>  <a href="#gad85b2e71e578a368367a8c4043011129">More...</a><br /></td></tr>
<tr class="separator:gad85b2e71e578a368367a8c4043011129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca33e5cebfce251ead6098f633c8bc13"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaca33e5cebfce251ead6098f633c8bc13">dget36</a> (RMAX, LMAX, NINFO, KNT, NIN)</td></tr>
<tr class="memdesc:gaca33e5cebfce251ead6098f633c8bc13"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET36</b>  <a href="#gaca33e5cebfce251ead6098f633c8bc13">More...</a><br /></td></tr>
<tr class="separator:gaca33e5cebfce251ead6098f633c8bc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcacf57969bb6f47213da97e24ca706"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gabdcacf57969bb6f47213da97e24ca706">dget37</a> (RMAX, LMAX, NINFO, KNT, NIN)</td></tr>
<tr class="memdesc:gabdcacf57969bb6f47213da97e24ca706"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET37</b>  <a href="#gabdcacf57969bb6f47213da97e24ca706">More...</a><br /></td></tr>
<tr class="separator:gabdcacf57969bb6f47213da97e24ca706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6037bff69c348a29907e03c047b4ed8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gae6037bff69c348a29907e03c047b4ed8">dget38</a> (RMAX, LMAX, NINFO, KNT, NIN)</td></tr>
<tr class="memdesc:gae6037bff69c348a29907e03c047b4ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET38</b>  <a href="#gae6037bff69c348a29907e03c047b4ed8">More...</a><br /></td></tr>
<tr class="separator:gae6037bff69c348a29907e03c047b4ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa546404302fddb3545bcd1ca639b2dd8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaa546404302fddb3545bcd1ca639b2dd8">dget39</a> (RMAX, LMAX, NINFO, KNT)</td></tr>
<tr class="memdesc:gaa546404302fddb3545bcd1ca639b2dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET39</b>  <a href="#gaa546404302fddb3545bcd1ca639b2dd8">More...</a><br /></td></tr>
<tr class="separator:gaa546404302fddb3545bcd1ca639b2dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f9376de56715d7548005efd8e71a65"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaf6f9376de56715d7548005efd8e71a65">dget51</a> (ITYPE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, U, LDU, V, LDV, WORK, RESULT)</td></tr>
<tr class="memdesc:gaf6f9376de56715d7548005efd8e71a65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET51</b>  <a href="#gaf6f9376de56715d7548005efd8e71a65">More...</a><br /></td></tr>
<tr class="separator:gaf6f9376de56715d7548005efd8e71a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af5c9297a5d6bc3f84223b499442944"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga8af5c9297a5d6bc3f84223b499442944">dget52</a> (LEFT, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, E, LDE, ALPHAR, ALPHAI, BETA, WORK, RESULT)</td></tr>
<tr class="memdesc:ga8af5c9297a5d6bc3f84223b499442944"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET52</b>  <a href="#ga8af5c9297a5d6bc3f84223b499442944">More...</a><br /></td></tr>
<tr class="separator:ga8af5c9297a5d6bc3f84223b499442944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f4c00fce1f7d59566e68da4fecbf29"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga50f4c00fce1f7d59566e68da4fecbf29">dget53</a> (<a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, SCALE, WR, WI, RESULT, INFO)</td></tr>
<tr class="memdesc:ga50f4c00fce1f7d59566e68da4fecbf29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET53</b>  <a href="#ga50f4c00fce1f7d59566e68da4fecbf29">More...</a><br /></td></tr>
<tr class="separator:ga50f4c00fce1f7d59566e68da4fecbf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14537b71a6ca0def78c7edf19acfa8f4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga14537b71a6ca0def78c7edf19acfa8f4">dget54</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, S, LDS, T, LDT, U, LDU, V, LDV, WORK, RESULT)</td></tr>
<tr class="memdesc:ga14537b71a6ca0def78c7edf19acfa8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGET54</b>  <a href="#ga14537b71a6ca0def78c7edf19acfa8f4">More...</a><br /></td></tr>
<tr class="separator:ga14537b71a6ca0def78c7edf19acfa8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6ee09a4853bbafa0ad4b5f5dd26f32"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gadb6ee09a4853bbafa0ad4b5f5dd26f32">dglmts</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, P, <a class="el" href="classA.html">A</a>, AF, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, BF, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, DF, X, U, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gadb6ee09a4853bbafa0ad4b5f5dd26f32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGLMTS</b>  <a href="#gadb6ee09a4853bbafa0ad4b5f5dd26f32">More...</a><br /></td></tr>
<tr class="separator:gadb6ee09a4853bbafa0ad4b5f5dd26f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c45f96f24770b97239b6269c8d1cdd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga73c45f96f24770b97239b6269c8d1cdd">dgqrts</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, P, <a class="el" href="classA.html">A</a>, AF, Q, R, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, TAUA, B, BF, Z, T, BWK, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, TAUB, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga73c45f96f24770b97239b6269c8d1cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGQRTS</b>  <a href="#ga73c45f96f24770b97239b6269c8d1cdd">More...</a><br /></td></tr>
<tr class="separator:ga73c45f96f24770b97239b6269c8d1cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7407f6eaf402bcb6bbda3e5bd46485fa"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga7407f6eaf402bcb6bbda3e5bd46485fa">dgrqts</a> (M, P, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, AF, Q, R, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, TAUA, B, BF, Z, T, BWK, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, TAUB, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga7407f6eaf402bcb6bbda3e5bd46485fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGRQTS</b>  <a href="#ga7407f6eaf402bcb6bbda3e5bd46485fa">More...</a><br /></td></tr>
<tr class="separator:ga7407f6eaf402bcb6bbda3e5bd46485fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ad62ba253b56ff68e7007244ce988e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gae3ad62ba253b56ff68e7007244ce988e">dgsvts</a> (M, P, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, AF, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, BF, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, U, LDU, V, LDV, Q, LDQ, ALPHA, BETA, R, LDR, IWORK, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:gae3ad62ba253b56ff68e7007244ce988e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DGSVTS</b>  <a href="#gae3ad62ba253b56ff68e7007244ce988e">More...</a><br /></td></tr>
<tr class="separator:gae3ad62ba253b56ff68e7007244ce988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2bc3739bff16d2f68bcce82a72e5bb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga2c2bc3739bff16d2f68bcce82a72e5bb">dhst01</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, ILO, IHI, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, H, LDH, Q, LDQ, WORK, LWORK, RESULT)</td></tr>
<tr class="memdesc:ga2c2bc3739bff16d2f68bcce82a72e5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DHST01</b>  <a href="#ga2c2bc3739bff16d2f68bcce82a72e5bb">More...</a><br /></td></tr>
<tr class="separator:ga2c2bc3739bff16d2f68bcce82a72e5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9c26a927bb292ac5cab99adc1a357c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga6f9c26a927bb292ac5cab99adc1a357c">dlafts</a> (TYPE, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, IMAT, NTESTS, RESULT, ISEED, <a class="el" href="zlaqgs_8c.html#a0656018abfc9fa2821827415f5d5ea57">THRESH</a>, IOUNIT, IE)</td></tr>
<tr class="memdesc:ga6f9c26a927bb292ac5cab99adc1a357c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAFTS</b>  <a href="#ga6f9c26a927bb292ac5cab99adc1a357c">More...</a><br /></td></tr>
<tr class="separator:ga6f9c26a927bb292ac5cab99adc1a357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ca6e066facb65a20568f3b790f1624"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaf5ca6e066facb65a20568f3b790f1624">dlahd2</a> (IOUNIT, PATH)</td></tr>
<tr class="memdesc:gaf5ca6e066facb65a20568f3b790f1624"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLAHD2</b>  <a href="#gaf5ca6e066facb65a20568f3b790f1624">More...</a><br /></td></tr>
<tr class="separator:gaf5ca6e066facb65a20568f3b790f1624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a374be57f1611d886c1ac0a6999351d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga7a374be57f1611d886c1ac0a6999351d">dlarfy</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, V, INCV, TAU, C, LDC, WORK)</td></tr>
<tr class="memdesc:ga7a374be57f1611d886c1ac0a6999351d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARFY</b>  <a href="#ga7a374be57f1611d886c1ac0a6999351d">More...</a><br /></td></tr>
<tr class="separator:ga7a374be57f1611d886c1ac0a6999351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada4fcd971471a815d7d0bba57fdf627b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gada4fcd971471a815d7d0bba57fdf627b">dlarhs</a> (PATH, XTYPE, UPLO, <a class="el" href="superlu__enum__consts_8h.html#a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58">TRANS</a>, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KL, KU, <a class="el" href="example__user_8c.html#aa0138da002ce2a90360df2f521eb3198">NRHS</a>, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, X, LDX, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, ISEED, INFO)</td></tr>
<tr class="memdesc:gada4fcd971471a815d7d0bba57fdf627b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLARHS</b>  <a href="#gada4fcd971471a815d7d0bba57fdf627b">More...</a><br /></td></tr>
<tr class="separator:gada4fcd971471a815d7d0bba57fdf627b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fd4cb18655d3b4b20912ad7f57c6890"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga3fd4cb18655d3b4b20912ad7f57c6890">dlasum</a> (TYPE, IOUNIT, IE, NRUN)</td></tr>
<tr class="memdesc:ga3fd4cb18655d3b4b20912ad7f57c6890"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLASUM</b>  <a href="#ga3fd4cb18655d3b4b20912ad7f57c6890">More...</a><br /></td></tr>
<tr class="separator:ga3fd4cb18655d3b4b20912ad7f57c6890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab048b044b8daf142a4780aa5dd1e68ab"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gab048b044b8daf142a4780aa5dd1e68ab">dlatb9</a> (PATH, IMAT, M, P, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, TYPE, KLA, KUA, KLB, KUB, ANORM, BNORM, MODEA, MODEB, CNDNMA, CNDNMB, DISTA, DISTB)</td></tr>
<tr class="memdesc:gab048b044b8daf142a4780aa5dd1e68ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLATB9</b>  <a href="#gab048b044b8daf142a4780aa5dd1e68ab">More...</a><br /></td></tr>
<tr class="separator:gab048b044b8daf142a4780aa5dd1e68ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac7051d7e9a8e10930e4b1bcd19fe3f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga0ac7051d7e9a8e10930e4b1bcd19fe3f">dlatm4</a> (ITYPE, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, NZ1, NZ2, ISIGN, AMAGN, <a class="el" href="superlu__enum__consts_8h.html#af00a42ecad444bbda75cde1b64bd7e72a9b5c151728d8512307565994c89919d5">RCOND</a>, TRIANG, IDIST, ISEED, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>)</td></tr>
<tr class="memdesc:ga0ac7051d7e9a8e10930e4b1bcd19fe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLATM4</b>  <a href="#ga0ac7051d7e9a8e10930e4b1bcd19fe3f">More...</a><br /></td></tr>
<tr class="separator:ga0ac7051d7e9a8e10930e4b1bcd19fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9773e3d39987ec10a5a58e224ff7582b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga9773e3d39987ec10a5a58e224ff7582b">dlctes</a> (ZR, ZI, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>)</td></tr>
<tr class="memdesc:ga9773e3d39987ec10a5a58e224ff7582b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLCTES</b>  <a href="#ga9773e3d39987ec10a5a58e224ff7582b">More...</a><br /></td></tr>
<tr class="separator:ga9773e3d39987ec10a5a58e224ff7582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14489af521606715c20ff53663f535c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga14489af521606715c20ff53663f535c9">dlctsx</a> (AR, AI, BETA)</td></tr>
<tr class="memdesc:ga14489af521606715c20ff53663f535c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLCTSX</b>  <a href="#ga14489af521606715c20ff53663f535c9">More...</a><br /></td></tr>
<tr class="separator:ga14489af521606715c20ff53663f535c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7f392f14da20c2cc0d33982627b1e4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga8f7f392f14da20c2cc0d33982627b1e4">dlsets</a> (M, P, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, AF, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, BF, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, C, CF, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, DF, X, WORK, LWORK, RWORK, RESULT)</td></tr>
<tr class="memdesc:ga8f7f392f14da20c2cc0d33982627b1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DLSETS</b>  <a href="#ga8f7f392f14da20c2cc0d33982627b1e4">More...</a><br /></td></tr>
<tr class="separator:ga8f7f392f14da20c2cc0d33982627b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1a5c2792c183c95bcab211a6c8027a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga4d1a5c2792c183c95bcab211a6c8027a">dort01</a> (ROWCOL, M, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, U, LDU, WORK, LWORK, RESID)</td></tr>
<tr class="memdesc:ga4d1a5c2792c183c95bcab211a6c8027a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DORT01</b>  <a href="#ga4d1a5c2792c183c95bcab211a6c8027a">More...</a><br /></td></tr>
<tr class="separator:ga4d1a5c2792c183c95bcab211a6c8027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b5f991af6cf4cbd658c1ceb7dd70bd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gab5b5f991af6cf4cbd658c1ceb7dd70bd">dort03</a> (RC, MU, MV, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, K, U, LDU, V, LDV, WORK, LWORK, RESULT, INFO)</td></tr>
<tr class="memdesc:gab5b5f991af6cf4cbd658c1ceb7dd70bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DORT03</b>  <a href="#gab5b5f991af6cf4cbd658c1ceb7dd70bd">More...</a><br /></td></tr>
<tr class="separator:gab5b5f991af6cf4cbd658c1ceb7dd70bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9fe83560bacaba5de4d7ac54653b34"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga0b9fe83560bacaba5de4d7ac54653b34">dsbt21</a> (UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KA, KS, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, WORK, RESULT)</td></tr>
<tr class="memdesc:ga0b9fe83560bacaba5de4d7ac54653b34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSBT21</b>  <a href="#ga0b9fe83560bacaba5de4d7ac54653b34">More...</a><br /></td></tr>
<tr class="separator:ga0b9fe83560bacaba5de4d7ac54653b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga928f4bcc4b7ac39d393fd7df69b1c6dd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga928f4bcc4b7ac39d393fd7df69b1c6dd">dsgt01</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, B, <a class="el" href="example__user_8c.html#a50e90a7104df172b5a89a06c47fcca04">LDB</a>, Z, LDZ, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, WORK, RESULT)</td></tr>
<tr class="memdesc:ga928f4bcc4b7ac39d393fd7df69b1c6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSGT01</b>  <a href="#ga928f4bcc4b7ac39d393fd7df69b1c6dd">More...</a><br /></td></tr>
<tr class="separator:ga928f4bcc4b7ac39d393fd7df69b1c6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c1ed076508e5ae3b39e824e27790cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gab8c1ed076508e5ae3b39e824e27790cc">dslect</a> (ZR, ZI)</td></tr>
<tr class="memdesc:gab8c1ed076508e5ae3b39e824e27790cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSLECT</b>  <a href="#gab8c1ed076508e5ae3b39e824e27790cc">More...</a><br /></td></tr>
<tr class="separator:gab8c1ed076508e5ae3b39e824e27790cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf7333dd6afe3a4fb228534b24c1533"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaecf7333dd6afe3a4fb228534b24c1533">dspt21</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KBAND, AP, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, VP, TAU, WORK, RESULT)</td></tr>
<tr class="memdesc:gaecf7333dd6afe3a4fb228534b24c1533"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSPT21</b>  <a href="#gaecf7333dd6afe3a4fb228534b24c1533">More...</a><br /></td></tr>
<tr class="separator:gaecf7333dd6afe3a4fb228534b24c1533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee97881cc8f081baf0b4bf6bc4abfd46"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaee97881cc8f081baf0b4bf6bc4abfd46">dstech</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, B, EIG, TOL, WORK, INFO)</td></tr>
<tr class="memdesc:gaee97881cc8f081baf0b4bf6bc4abfd46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSTECH</b>  <a href="#gaee97881cc8f081baf0b4bf6bc4abfd46">More...</a><br /></td></tr>
<tr class="separator:gaee97881cc8f081baf0b4bf6bc4abfd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5467550660ec78049bd9d095d06fc25e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga5467550660ec78049bd9d095d06fc25e">dstect</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classA.html">A</a>, B, SHIFT, NUM)</td></tr>
<tr class="memdesc:ga5467550660ec78049bd9d095d06fc25e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSTECT</b>  <a href="#ga5467550660ec78049bd9d095d06fc25e">More...</a><br /></td></tr>
<tr class="separator:ga5467550660ec78049bd9d095d06fc25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc98f0ae883a4f4a2be0bb1ae45b608"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gafcc98f0ae883a4f4a2be0bb1ae45b608">dstt21</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KBAND, AD, AE, SD, SE, U, LDU, WORK, RESULT)</td></tr>
<tr class="memdesc:gafcc98f0ae883a4f4a2be0bb1ae45b608"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSTT21</b>  <a href="#gafcc98f0ae883a4f4a2be0bb1ae45b608">More...</a><br /></td></tr>
<tr class="separator:gafcc98f0ae883a4f4a2be0bb1ae45b608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffce2d056146c156467c485904cb413"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gabffce2d056146c156467c485904cb413">dstt22</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, KBAND, AD, AE, SD, SE, U, LDU, WORK, LDWORK, RESULT)</td></tr>
<tr class="memdesc:gabffce2d056146c156467c485904cb413"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSTT22</b>  <a href="#gabffce2d056146c156467c485904cb413">More...</a><br /></td></tr>
<tr class="separator:gabffce2d056146c156467c485904cb413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970e8ed2adc72fcf96d412fcb3d33226"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga970e8ed2adc72fcf96d412fcb3d33226">dsvdch</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, S, E, SVD, TOL, INFO)</td></tr>
<tr class="memdesc:ga970e8ed2adc72fcf96d412fcb3d33226"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSVDCH</b>  <a href="#ga970e8ed2adc72fcf96d412fcb3d33226">More...</a><br /></td></tr>
<tr class="separator:ga970e8ed2adc72fcf96d412fcb3d33226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc6bc302348dc1e4790a98d3bcefb67"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gacfc6bc302348dc1e4790a98d3bcefb67">dsvdct</a> (<a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, S, E, SHIFT, NUM)</td></tr>
<tr class="memdesc:gacfc6bc302348dc1e4790a98d3bcefb67"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSVDCT</b>  <a href="#gacfc6bc302348dc1e4790a98d3bcefb67">More...</a><br /></td></tr>
<tr class="separator:gacfc6bc302348dc1e4790a98d3bcefb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ddc3e6002ccca1ee7b31370e4e8b523"><td class="memItemLeft" align="right" valign="top">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#ga3ddc3e6002ccca1ee7b31370e4e8b523">dsxt1</a> (IJOB, D1, N1, D2, N2, ABSTOL, ULP, UNFL)</td></tr>
<tr class="memdesc:ga3ddc3e6002ccca1ee7b31370e4e8b523"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSXT1</b>  <a href="#ga3ddc3e6002ccca1ee7b31370e4e8b523">More...</a><br /></td></tr>
<tr class="separator:ga3ddc3e6002ccca1ee7b31370e4e8b523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ec778bf025e73e4c067632270cd5e2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaf6ec778bf025e73e4c067632270cd5e2">dsyt21</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, KBAND, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, V, LDV, TAU, WORK, RESULT)</td></tr>
<tr class="memdesc:gaf6ec778bf025e73e4c067632270cd5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSYT21</b>  <a href="#gaf6ec778bf025e73e4c067632270cd5e2">More...</a><br /></td></tr>
<tr class="separator:gaf6ec778bf025e73e4c067632270cd5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55d41534d46929dbd30b8abc36f11b6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__double__eig.html#gaa55d41534d46929dbd30b8abc36f11b6">dsyt22</a> (ITYPE, UPLO, <a class="el" href="polmisc_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, M, KBAND, <a class="el" href="classA.html">A</a>, <a class="el" href="example__user_8c.html#ae946da542ce0db94dced19b2ecefd1aa">LDA</a>, <a class="el" href="odrpack_8h.html#a7dae6ea403d00f3687f24a874e67d139">D</a>, E, U, LDU, V, LDV, TAU, WORK, RESULT)</td></tr>
<tr class="memdesc:gaa55d41534d46929dbd30b8abc36f11b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>DSYT22</b>  <a href="#gaa55d41534d46929dbd30b8abc36f11b6">More...</a><br /></td></tr>
<tr class="separator:gaa55d41534d46929dbd30b8abc36f11b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is the group of double LAPACK TESTING EIG routines. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4281d345e520762c2b713861a36db678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dbdt01 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>PT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDPT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DBDT01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DBDT01 reconstructs a general matrix A from its bidiagonal form
    A = Q * B * P'
 where Q (m by min(m,n)) and P' (min(m,n) by n) are orthogonal
 matrices and B is bidiagonal.

 The test ratio to test the reduction is
    RESID = norm( A - Q * B * PT ) / ( n * norm(A) * EPS )
 where PT = P' and EPS is the machine precision.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrices A and Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and P'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KD</td><td><pre class="fragment">          KD is INTEGER
          If KD = 0, B is diagonal and the array E is not referenced.
          If KD = 1, the reduction was performed by xGEBRD; B is upper
          bidiagonal if M &gt;= N, and lower bidiagonal if M &lt; N.
          If KD = -1, the reduction was performed by xGBBRD; B is
          always upper bidiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The m by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDQ,N)
          The m by min(m,n) orthogonal matrix Q in the reduction
          A = Q * B * P'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (min(M,N))
          The diagonal elements of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (min(M,N)-1)
          The superdiagonal elements of the bidiagonal matrix B if
          m &gt;= n, or the subdiagonal elements of B if m &lt; n.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PT</td><td><pre class="fragment">          PT is DOUBLE PRECISION array, dimension (LDPT,N)
          The min(m,n) by n orthogonal matrix P' in the reduction
          A = Q * B * P'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDPT</td><td><pre class="fragment">          LDPT is INTEGER
          The leading dimension of the array PT.
          LDPT &gt;= max(1,min(M,N)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (M+N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is DOUBLE PRECISION
          The test ratio:  norm(A - Q * B * P') / ( n * norm(A) * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4300a964c1dd20239562d1c58a1c8a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dbdt02 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DBDT02</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DBDT02 tests the change of basis C = U' * B by computing the residual

    RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),

 where B and C are M by N matrices, U is an M by M orthogonal matrix,
 and EPS is the machine precision.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrices B and C and the order of
          the matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices B and C.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,N)
          The m by n matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension (LDC,N)
          The m by n matrix C, assumed to contain U' * B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of the array C.  LDC &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU,M)
          The m by m orthogonal matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U.  LDU &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is DOUBLE PRECISION
          RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c6578f36abb99e08a2b08611468074f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dbdt03 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DBDT03</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DBDT03 reconstructs a bidiagonal matrix B from its SVD:
    S = U' * B * V
 where U and V are orthogonal matrices and S is diagonal.

 The test ratio to test the singular value decomposition is
    RESID = norm( B - U * S * VT ) / ( n * norm(B) * EPS )
 where VT = V' and EPS is the machine precision.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the matrix B is upper or lower bidiagonal.
          = 'U':  Upper bidiagonal
          = 'L':  Lower bidiagonal</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KD</td><td><pre class="fragment">          KD is INTEGER
          The bandwidth of the bidiagonal matrix B.  If KD = 1, the
          matrix B is bidiagonal, and if KD = 0, B is diagonal and E is
          not referenced.  If KD is greater than 1, it is assumed to be
          1, and if KD is less than 0, it is assumed to be 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The n diagonal elements of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N-1)
          The (n-1) superdiagonal elements of the bidiagonal matrix B
          if UPLO = 'U', or the (n-1) subdiagonal elements of B if
          UPLO = 'L'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU,N)
          The n by n orthogonal matrix U in the reduction B = U'*A*P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U.  LDU &gt;= max(1,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension (N)
          The singular values from the SVD of B, sorted in decreasing
          order.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension (LDVT,N)
          The n by n orthogonal matrix V' in the reduction
          B = U * S * V'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
          The leading dimension of the array VT.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (2*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is DOUBLE PRECISION
          The test ratio:  norm(B - U * S * V') / ( n * norm(A) * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gad3ec9fc9822df7885e553241df6b3171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkbb </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWDTHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>KK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldab, * )&#160;</td>
          <td class="paramname"><em>AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( <a class="el" href="slsqp__optmz_8f.html#ac230f990daa202f79a01fd76eb954ff4">ldp</a>, * )&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>CC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKBB</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKBB tests the reduction of a general real rectangular band
 matrix to bidiagonal form.

 DGBBRD factors a general band matrix A as  Q B P* , where * means
 transpose, B is upper bidiagonal, and Q and P are orthogonal;
 DGBBRD can also overwrite a given matrix C with Q* C .

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix C are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x M
    P:          N x N
    B:          min(M,N) x min(M,N)
    C:          M x NRHS

 For each generated matrix, 4 tests are performed:

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 (4)   | Y - Q' C | / ( |Y| max(M,NRHS) ulp ), where Y = Q' C.

 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).
          If NSIZES is zero, DCHKBB does nothing.  NSIZES must be at
          least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix column dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWDTHS</td><td><pre class="fragment">          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          DCHKBB does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KK</td><td><pre class="fragment">          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DCHKBB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of columns in the "right-hand side" matrix C.
          If NRHS = 0, then the operations on the right-hand side will
          not be tested. NRHS must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DCHKBB to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension
                            (LDA, max(NN))
          Used to hold the matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AB</td><td><pre class="fragment">          AB is DOUBLE PRECISION array, dimension (LDAB, max(NN))
          Used to hold A in band storage format.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDAB</td><td><pre class="fragment">          LDAB is INTEGER
          The leading dimension of AB.  It must be at least 2 (not 1!)
          and at least max( KK )+1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BD</td><td><pre class="fragment">          BD is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the diagonal of the bidiagonal matrix computed
          by DGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BE</td><td><pre class="fragment">          BE is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the off-diagonal of the bidiagonal matrix
          computed by DGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDQ, max(NN))
          Used to hold the orthogonal matrix Q computed by DGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td><pre class="fragment">          P is DOUBLE PRECISION array, dimension (LDP, max(NN))
          Used to hold the orthogonal matrix P computed by DGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDP</td><td><pre class="fragment">          LDP is INTEGER
          The leading dimension of P.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension (LDC, max(NN))
          Used to hold the matrix C updated by DGBBRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CC</td><td><pre class="fragment">          CC is DOUBLE PRECISION array, dimension (LDC, max(NN))
          Used to hold a copy of the matrix C.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga04ab01e2495d343417e614aeec1571f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkbd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>PT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDPT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldpt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKBD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKBD checks the singular value decomposition (SVD) routines.

 DGEBRD reduces a real general m by n matrix A to upper or lower
 bidiagonal form B by an orthogonal transformation:  Q' * A * P = B
 (or A = Q * B * P').  The matrix B is upper bidiagonal if m &gt;= n
 and lower bidiagonal if m &lt; n.

 DORGBR generates the orthogonal matrices Q and P' from DGEBRD.
 Note that Q and P are not necessarily square.

 DBDSQR computes the singular value decomposition of the bidiagonal
 matrix B as B = U S V'.  It is called three times to compute
    1)  B = U S1 V', where S1 is the diagonal matrix of singular
        values and the columns of the matrices U and V are the left
        and right singular vectors, respectively, of B.
    2)  Same as 1), but the singular values are stored in S2 and the
        singular vectors are not computed.
    3)  A = (UQ) S (P'V'), the SVD of the original matrix A.
 In addition, DBDSQR has an option to apply the left orthogonal matrix
 U to a matrix X, useful in least squares applications.

 DBDSDC computes the singular value decomposition of the bidiagonal
 matrix B as B = U S V' using divide-and-conquer. It is called twice
 to compute
    1) B = U S1 V', where S1 is the diagonal matrix of singular
        values and the columns of the matrices U and V are the left
        and right singular vectors, respectively, of B.
    2) Same as 1), but the singular values are stored in S2 and the
        singular vectors are not computed.

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix X are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x min(M,N) (but M x M if NRHS &gt; 0)
    P:          min(M,N) x N
    B:          min(M,N) x min(M,N)
    U, V:       min(M,N) x min(M,N)
    S1, S2      diagonal, order min(M,N)
    X:          M x NRHS

 For each generated matrix, 14 tests are performed:

 Test DGEBRD and DORGBR

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 Test DBDSQR on bidiagonal matrix B

 (4)   | B - U S1 VT | / ( |B| min(M,N) ulp ), VT = V'

 (5)   | Y - U Z | / ( |Y| max(min(M,N),k) ulp ), where Y = Q' X
                                                  and   Z = U' Y.
 (6)   | I - U' U | / ( min(M,N) ulp )

 (7)   | I - VT VT' | / ( min(M,N) ulp )

 (8)   S1 contains min(M,N) nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (9)   | S1 - S2 | / ( |S1| ulp ), where S2 is computed without
                                   computing U and V.

 (10)  0 if the true singular values of B are within THRESH of
       those in S1.  2*THRESH if they are not.  (Tested using
       DSVDCH)

 Test DBDSQR on matrix A

 (11)  | A - (QU) S (VT PT) | / ( |A| max(M,N) ulp )

 (12)  | X - (QU) Z | / ( |X| max(M,k) ulp )

 (13)  | I - (QU)'(QU) | / ( M ulp )

 (14)  | I - (VT PT) (PT'VT') | / ( N ulp )

 Test DBDSDC on bidiagonal matrix B

 (15)  | B - U S1 VT | / ( |B| min(M,N) ulp ), VT = V'

 (16)  | I - U' U | / ( min(M,N) ulp )

 (17)  | I - VT VT' | / ( min(M,N) ulp )

 (18)  S1 contains min(M,N) nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (19)  | S1 - S2 | / ( |S1| ulp ), where S2 is computed without
                                   computing U and V.
 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )

 Special case:
 (16) A bidiagonal matrix with random entries chosen from a
      logarithmic distribution on [ulp^2,ulp^(-2)]  (I.e., each
      entry is  e^x, where x is chosen uniformly on
      [ 2 log(ulp), -2 log(ulp) ] .)  For *this* type:
      (a) DGEBRD is not called to reduce it to bidiagonal form.
      (b) the bidiagonal is  min(M,N) x min(M,N); if M&lt;N, the
          matrix will be lower bidiagonal, otherwise upper.
      (c) only tests 5--8 and 14 are performed.

 A subset of the full set of matrix types may be selected through
 the logical array DOTYPE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DCHKBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of columns in the "right-hand side" matrices X, Y,
          and Z, used in testing DBDSQR.  If NRHS = 0, then the
          operations on the right-hand side will not be tested.
          NRHS must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The values of ISEED are changed on exit, and can be
          used in the next call to DCHKBD to continue the same random
          number sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.  Note that the
          expected value of the test ratios is O(1), so THRESH should
          be a reasonably small multiple of 1, e.g., 10 or 100.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,NMAX)
          where NMAX is the maximum value of N in NVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,MMAX),
          where MMAX is the maximum value of M in MVAL.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BD</td><td><pre class="fragment">          BD is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BE</td><td><pre class="fragment">          BE is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S1</td><td><pre class="fragment">          S1 is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S2</td><td><pre class="fragment">          S2 is DOUBLE PRECISION array, dimension
                      (max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (LDX,NRHS)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the arrays X, Y, and Z.
          LDX &gt;= max(1,MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td><pre class="fragment">          Y is DOUBLE PRECISION array, dimension (LDX,NRHS)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension (LDX,NRHS)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDQ,MMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ &gt;= max(1,MMAX).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PT</td><td><pre class="fragment">          PT is DOUBLE PRECISION array, dimension (LDPT,NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDPT</td><td><pre class="fragment">          LDPT is INTEGER
          The leading dimension of the arrays PT, U, and V.
          LDPT &gt;= max(1, max(min(MVAL(j),NVAL(j)))).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          3(M+N) and  M(M + max(M,N,k) + 1) + N*min(M,N)  for all
          pairs  (M,N)=(MM(j),NN(j))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension at least 8*min(M,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some MM(j) &lt; 0
           -3: Some NN(j) &lt; 0
           -4: NTYPES &lt; 0
           -6: NRHS  &lt; 0
           -8: THRESH &lt; 0
          -11: LDA &lt; 1 or LDA &lt; MMAX, where MMAX is max( MM(j) ).
          -17: LDB &lt; 1 or LDB &lt; MMAX.
          -21: LDQ &lt; 1 or LDQ &lt; MMAX.
          -23: LDPT&lt; 1 or LDPT&lt; MNMAX.
          -27: LWORK too small.
          If  DLATMR, SLATMS, DGEBRD, DORGBR, or DBDSQR,
              returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NTEST           The number of tests performed, or which can
                     be performed so far, for the current matrix.
     MMAX            Largest value in NN.
     NMAX            Largest value in NN.
     MNMIN           min(MM(j), NN(j)) (the dimension of the bidiagonal
                     matrix.)
     MNMAX           The maximum value of MNMIN for j=1,...,NSIZES.
     NFAIL           The number of tests which have exceeded THRESH
     COND, IMODE     Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     RTOVFL, RTUNFL  Square roots of the previous 2 values.
     ULP, ULPINV     Finest relative precision and its inverse.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bcf76f5f33d2f4905f61284d938d3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkbk </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKBK</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKBK tests DGEBAK, a routine for backward transformation of
 the computed right or left eigenvectors if the orginal matrix
 was preprocessed by balance subroutine DGEBAL.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gad48bef9c53d7828ee7b25c9ccf56fed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkbl </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKBL</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKBL tests DGEBAL, a routine for balancing a general real
 matrix and isolating some of its eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga909f6f89527e6667b8e49034a692f7b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkec </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>TSTERR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKEC</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKEC tests eigen- condition estimation routines
        DLALN2, DLASY2, DLANV2, DLAQTR, DLAEXC,
        DTRSYL, DTREXC, DTRSNA, DTRSEN

 In all cases, the routine runs through a fixed set of numerical
 examples, subjects them to various tests, and compares the test
 results to a threshold THRESH. In addition, DTREXC, DTRSNA and DTRSEN
 are tested by reading in precomputed examples from a file (on input
 unit NIN).  Output is written to output unit NOUT.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          Threshold for residual tests.  A computed test ratio passes
          the threshold if it is less than THRESH.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TSTERR</td><td><pre class="fragment">          TSTERR is LOGICAL
          Flag that indicates whether error exits are to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8356beeda2da8d0fef89ccb4bc414d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program dchkee </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKEE</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKEE tests the DOUBLE PRECISION LAPACK subroutines for the matrix
 eigenvalue problem.  The test paths in this version are

 NEP (Nonsymmetric Eigenvalue Problem):
     Test DGEHRD, DORGHR, DHSEQR, DTREVC, DHSEIN, and DORMHR

 SEP (Symmetric Eigenvalue Problem):
     Test DSYTRD, DORGTR, DSTEQR, DSTERF, DSTEIN, DSTEDC,
     and drivers DSYEV(X), DSBEV(X), DSPEV(X), DSTEV(X),
                 DSYEVD,   DSBEVD,   DSPEVD,   DSTEVD

 SVD (Singular Value Decomposition):
     Test DGEBRD, DORGBR, DBDSQR, DBDSDC
     and the drivers DGESVD, DGESDD

 DEV (Nonsymmetric Eigenvalue/eigenvector Driver):
     Test DGEEV

 DES (Nonsymmetric Schur form Driver):
     Test DGEES

 DVX (Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test DGEEVX

 DSX (Nonsymmetric Schur form Expert Driver):
     Test DGEESX

 DGG (Generalized Nonsymmetric Eigenvalue Problem):
     Test DGGHRD, DGGBAL, DGGBAK, DHGEQZ, and DTGEVC
     and the driver routines DGEGS and DGEGV

 DGS (Generalized Nonsymmetric Schur form Driver):
     Test DGGES

 DGV (Generalized Nonsymmetric Eigenvalue/eigenvector Driver):
     Test DGGEV

 DGX (Generalized Nonsymmetric Schur form Expert Driver):
     Test DGGESX

 DXV (Generalized Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test DGGEVX

 DSG (Symmetric Generalized Eigenvalue Problem):
     Test DSYGST, DSYGV, DSYGVD, DSYGVX, DSPGST, DSPGV, DSPGVD,
     DSPGVX, DSBGST, DSBGV, DSBGVD, and DSBGVX

 DSB (Symmetric Band Eigenvalue Problem):
     Test DSBTRD

 DBB (Band Singular Value Decomposition):
     Test DGBBRD

 DEC (Eigencondition estimation):
     Test DLALN2, DLASY2, DLAEQU, DLAEXC, DTRSYL, DTREXC, DTRSNA,
     DTRSEN, and DLAQTR

 DBL (Balancing a general matrix)
     Test DGEBAL

 DBK (Back transformation on a balanced matrix)
     Test DGEBAK

 DGL (Balancing a matrix pair)
     Test DGGBAL

 DGK (Back transformation on a matrix pair)
     Test DGGBAK

 GLM (Generalized Linear Regression Model):
     Tests DGGGLM

 GQR (Generalized QR and RQ factorizations):
     Tests DGGQRF and DGGRQF

 GSV (Generalized Singular Value Decomposition):
     Tests DGGSVD, DGGSVP, DTGSJA, DLAGS2, DLAPLL, and DLAPMT

 CSD (CS decomposition):
     Tests DORCSD

 LSE (Constrained Linear Least Squares):
     Tests DGGLSE

 Each test path has a different set of inputs, but the data sets for
 the driver routines xEV, xES, xVX, and xSX can be concatenated in a
 single input file.  The first line of input should contain one of the
 3-character path names in columns 1-3.  The number of remaining lines
 depends on what is found on the first line.

 The number of matrix types used in testing is often controllable from
 the input file.  The number of matrix types for each path, and the
 test routine that describes them, is as follows:

 Path name(s)  Types    Test routine

 DHS or NEP      21     DCHKHS
 DST or SEP      21     DCHKST (routines)
                 18     DDRVST (drivers)
 DBD or SVD      16     DCHKBD (routines)
                  5     DDRVBD (drivers)
 DEV             21     DDRVEV
 DES             21     DDRVES
 DVX             21     DDRVVX
 DSX             21     DDRVSX
 DGG             26     DCHKGG (routines)
                 26     DDRVGG (drivers)
 DGS             26     DDRGES
 DGX              5     DDRGSX
 DGV             26     DDRGEV
 DXV              2     DDRGVX
 DSG             21     DDRVSG
 DSB             15     DCHKSB
 DBB             15     DCHKBB
 DEC              -     DCHKEC
 DBL              -     DCHKBL
 DBK              -     DCHKBK
 DGL              -     DCHKGL
 DGK              -     DCHKGK
 GLM              8     DCKGLM
 GQR              8     DCKGQR
 GSV              8     DCKGSV
 CSD              3     DCKCSD
 LSE              8     DCKLSE

-----------------------------------------------------------------------

 NEP input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NX, NS, and
          MAXB.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  INMIN, INTEGER array, dimension (NPARMS)
          LAHQR vs TTQRE crossover point, &gt;= 11

 line 9:  INWIN, INTEGER array, dimension (NPARMS)
          recommended deflation window size

 line 10: INIBL, INTEGER array, dimension (NPARMS)
          nibble crossover point

 line 11: ISHFTS, INTEGER array, dimension (NPARMS)
          number of simultaneous shifts)

 line 12: IACC22, INTEGER array, dimension (NPARMS)
          select structured matrix multiply: 0, 1 or 2)

 line 13: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.  To have all of the test
          ratios printed, use THRESH = 0.0 .

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  The remaining lines occur in sets of 1 or 2 and allow
          the user to specify the matrix types.  Each line contains
          a 3-character path name in columns 1-3, and the number
          of matrix types must be the first nonblank item in columns
          4-80.  If the number of matrix types is at least 1 but is
          less than the maximum number of possible types, a second
          line will be read to get the numbers of the matrix types to
          be used.  For example,
 NEP 21
          requests all of the matrix types for the nonsymmetric
          eigenvalue problem, while
 NEP  4
 9 10 11 12
          requests only matrices of type 9, 10, 11, and 12.

          The valid 3-character path names are 'NEP' or 'SHS' for the
          nonsymmetric eigenvalue routines.

-----------------------------------------------------------------------

 SEP or DSG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, and NX.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 10: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 11: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 12: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 12 was 2:

 line 13: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 13-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path names are 'SEP' or 'SST' for the
          symmetric eigenvalue routines and driver routines, and
          'DSG' for the routines for the symmetric generalized
          eigenvalue problem.

-----------------------------------------------------------------------

 SVD input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 5:  NPARMS, INTEGER
          Number of values of the parameter NB, NBMIN, NX, and NRHS.

 line 6:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 7:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 8:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 9:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path names are 'SVD' or 'SBD' for both the
          SVD routines and the SVD driver routines.

-----------------------------------------------------------------------

 DEV and DES data files:

 line 1:  'DEV' or 'DES' in columns 1 to 3.

 line 2:  NSIZES, INTEGER
          Number of sizes of matrices to use. Should be at least 0
          and at most 20. If NSIZES = 0, no testing is done
          (although the remaining  3 lines are still read).

 line 3:  NN, INTEGER array, dimension(NSIZES)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHSEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9 and following:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'DEV' to test SGEEV, or
          'DES' to test SGEES.

-----------------------------------------------------------------------

 The DVX data has two parts. The first part is identical to DEV,
 and the second part consists of test matrices with precomputed
 solutions.

 line 1:  'DVX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  TSTERR, LOGICAL

 line 7:  NEWSD, INTEGER

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)

 lines 9 and following: The first line contains 'DVX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 1+2*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer). The next N lines contain the matrix, one
          row per line. The last N lines correspond to each
          eigenvalue. Each of these last N lines contains 4 real
          values: the real part of the eigenvalue, the imaginary
          part of the eigenvalue, the reciprocal condition number of
          the eigenvalues, and the reciprocal condition number of the
          eigenvector.  The end of data is indicated by dimension N=0.
          Even if no data is to be tested, there must be at least one
          line containing N=0.

-----------------------------------------------------------------------

 The DSX data is like DVX. The first part is identical to DEV, and the
 second part consists of test matrices with precomputed solutions.

 line 1:  'DSX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  TSTERR, LOGICAL

 line 7:  NEWSD, INTEGER

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)

 lines 9 and following: The first line contains 'DSX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 3+N lines, where N is its
          dimension. The first line contains the dimension N and the
          dimension M of an invariant subspace. The second line
          contains M integers, identifying the eigenvalues in the
          invariant subspace (by their position in a list of
          eigenvalues ordered by increasing real part). The next N
          lines contain the matrix. The last line contains the
          reciprocal condition number for the average of the selected
          eigenvalues, and the reciprocal condition number for the
          corresponding right invariant subspace. The end of data is
          indicated by a line containing N=0 and M=0. Even if no data
          is to be tested, there must be at least one line containing
          N=0 and M=0.

-----------------------------------------------------------------------

 DGG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NS, MAXB, and
          NBCOL.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for NBMIN, the minimum row dimension for blocks.

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of shifts.

 line 8:  MXBVAL, INTEGER array, dimension (NPARMS)
          The values for MAXB, used in determining minimum blocksize.

 line 9:  NBCOL, INTEGER array, dimension (NPARMS)
          The values for NBCOL, the minimum column dimension for
          blocks.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'DGG' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 DGS and DGV input files:

 line 1:  'DGS' or 'DGV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension(NN)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 17 was 2:

 line 7:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 7-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'DGS' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 DXV input files:

 line 1:  'DXV' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer). The next N lines contain the matrix A, one
          row per line. The next N lines contain the matrix B.  The
          next line contains the reciprocals of the eigenvalue
          condition numbers.  The last line contains the reciprocals of
          the eigenvector condition numbers.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 DGX input files:

 line 1:  'DGX' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer).  The next line contains an integer k such
          that only the last k eigenvalues will be selected and appear
          in the leading diagonal blocks of $A$ and $B$. The next N
          lines contain the matrix A, one row per line.  The next N
          lines contain the matrix B.  The last line contains the
          reciprocal of the eigenvalue cluster condition number and the
          reciprocal of the deflating subspace (associated with the
          selected eigencluster) condition number.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 DSB input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix dimension K.

 line 6:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 8-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'DSB'.

-----------------------------------------------------------------------

 DBB input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix bandwidth K.

 line 6:  NPARMS, INTEGER
          Number of values of the parameter NRHS

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 9 was 2:

 line 10: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 10-EOF:  Lines specifying matrix types, as for SVD.
          The 3-character path name is 'DBB'.

-----------------------------------------------------------------------

 DEC input file:

 line  2: THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 lines  3-EOF:

 Input for testing the eigencondition routines consists of a set of
 specially constructed test cases and their solutions.  The data
 format is not intended to be modified by the user.

-----------------------------------------------------------------------

 DBL and DBK input files:

 line 1:  'DBL' in columns 1-3 to test SGEBAL, or 'DBK' in
          columns 1-3 to test SGEBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 DGL and DGK input files:

 line 1:  'DGL' in columns 1-3 to test DGGBAL, or 'DGK' in
          columns 1-3 to test DGGBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 GLM data file:

 line 1:  'GLM' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension), note M &lt;= N &lt;= M+P.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GLM' for the generalized
          linear regression model routines.

-----------------------------------------------------------------------

 GQR data file:

 line 1:  'GQR' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GQR' for the generalized
          QR and RQ routines.

-----------------------------------------------------------------------

 GSV data file:

 line 1:  'GSV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 CSD data file:

 line 1:  'CSD' in columns 1 to 3.

 line 2:  NM, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NM)
          Values of M (row and column dimension of orthogonal matrix).

 line 4:  PVAL, INTEGER array, dimension(NM)
          Values of P (row dimension of top-left block).

 line 5:  NVAL, INTEGER array, dimension(NM)
          Values of N (column dimension of top-left block).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CSD' for the CSD routine.

-----------------------------------------------------------------------

 LSE data file:

 line 1:  'LSE' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N, note P &lt;= N &lt;= P+M.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 NMAX is currently set to 132 and must be at least 12 for some of the
 precomputed examples, and LWORK = NMAX*(5*NMAX+5)+1 in the parameter
 statements below.  For SVD, we assume NRHS may be as big as N.  The
 parameter NEED is set to 14 to allow for 14 N-by-N matrices for DGG.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ga90e3a487742ba9acb39f783362b5b300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkgg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>TSTDIF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRSHN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHR3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHI3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>LLWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 15 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKGG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKGG  checks the nonsymmetric generalized eigenvalue problem
 routines.
                                T          T        T
 DGGHRD factors A and B as U H V  and U T V , where   means
 transpose, H is hessenberg, T is triangular and U and V are
 orthogonal.
                                 T          T
 DHGEQZ factors H and T as  Q S Z  and Q P Z , where P is upper
 triangular, S is in generalized Schur form (block upper triangular,
 with 1x1 and 2x2 blocks on the diagonal, the 2x2 blocks
 corresponding to complex conjugate pairs of generalized
 eigenvalues), and Q and Z are orthogonal.  It also computes the
 generalized eigenvalues (alpha(1),beta(1)),...,(alpha(n),beta(n)),
 where alpha(j)=S(j,j) and beta(j)=P(j,j) -- thus,
 w(j) = alpha(j)/beta(j) is a root of the generalized eigenvalue
 problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 DTGEVC computes the matrix L of left eigenvectors and the matrix R
 of right eigenvectors for the matrix pair ( S, P ).  In the
 description below,  l and r are left and right eigenvectors
 corresponding to the generalized eigenvalues (alpha,beta).

 When DCHKGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 15
 tests will be performed.  The first twelve "test ratios" should be
 small -- O(1).  They will be compared with the threshhold THRESH:

                  T
 (1)   | A - U H V  | / ( |A| n ulp )

                  T
 (2)   | B - U T V  | / ( |B| n ulp )

               T
 (3)   | I - UU  | / ( n ulp )

               T
 (4)   | I - VV  | / ( n ulp )

                  T
 (5)   | H - Q S Z  | / ( |H| n ulp )

                  T
 (6)   | T - Q P Z  | / ( |T| n ulp )

               T
 (7)   | I - QQ  | / ( n ulp )

               T
 (8)   | I - ZZ  | / ( n ulp )

 (9)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta S - alpha P) | / ( ulp max( |beta S|, |alpha P| ) )

 (10)  max over all left eigenvalue/-vector pairs (beta/alpha,l') of
                           T
   | l'**H * (beta H - alpha T) | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors l' are the result of passing Q to
       DTGEVC and back transforming (HOWMNY='B').

 (11)  max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta S - alpha T) r | / ( ulp max( |beta S|, |alpha T| ) )

 (12)  max over all right eigenvalue/-vector pairs (beta/alpha,r') of

       | (beta H - alpha T) r' | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors r' are the result of passing Z to
       DTGEVC and back transforming (HOWMNY='B').

 The last three test ratios will usually be small, but there is no
 mathematical requirement that they be so.  They are therefore
 compared with THRESH only if TSTDIF is .TRUE.

 (13)  | S(Q,Z computed) - S(Q,Z not computed) | / ( |S| ulp )

 (14)  | P(Q,Z computed) - P(Q,Z not computed) | / ( |P| ulp )

 (15)  max( |alpha(Q,Z computed) - alpha(Q,Z not computed)|/|S| ,
            |beta(Q,Z computed) - beta(Q,Z not computed)|/|P| ) / ulp

 In addition, the normalization of L and R are checked, and compared
 with the threshhold THRSHN.

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) U ( J , J ) V     where U and V are random orthogonal matrices.

 (17) U ( T1, T2 ) V    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) U ( T1, T2 ) V    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) U ( T1, T2 ) V    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) U ( big*T1, small*T2 ) V    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) U ( small*T1, big*T2 ) V    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) U ( small*T1, small*T2 ) V  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) U ( big*T1, big*T2 ) V      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) U ( T1, T2 ) V     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DCHKGG does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DCHKGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DCHKGG to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TSTDIF</td><td><pre class="fragment">          TSTDIF is LOGICAL
          Specifies whether test ratios 13-15 will be computed and
          compared with THRESH.
          = .FALSE.: Only test ratios 1-12 will be computed and tested.
                     Ratios 13-15 will be set to zero.
          = .TRUE.:  All the test ratios 1-15 will be computed and
                     tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRSHN</td><td><pre class="fragment">          THRSHN is DOUBLE PRECISION
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension
                            (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, H, T, S1, P1, S2, and P2.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension
                            (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The upper Hessenberg matrix computed from A by DGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by DGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S1</td><td><pre class="fragment">          S1 is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The Schur (block upper triangular) matrix computed from H by
          DHGEQZ when Q and Z are also computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S2</td><td><pre class="fragment">          S2 is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The Schur (block upper triangular) matrix computed from H by
          DHGEQZ when Q and Z are not computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P1</td><td><pre class="fragment">          P1 is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by DHGEQZ
          when Q and Z are also computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td><pre class="fragment">          P2 is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by DHGEQZ
          when Q and Z are not computed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, max(NN))
          The (left) orthogonal matrix computed by DGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U, V, Q, Z, EVECTL, and EVEZTR.  It
          must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension (LDU, max(NN))
          The (right) orthogonal matrix computed by DGGHRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDU, max(NN))
          The (left) orthogonal matrix computed by DHGEQZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension (LDU, max(NN))
          The (left) orthogonal matrix computed by DHGEQZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHR1</td><td><pre class="fragment">          ALPHR1 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHI1</td><td><pre class="fragment">          ALPHI1 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA1</td><td><pre class="fragment">          BETA1 is DOUBLE PRECISION array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by DHGEQZ
          when Q, Z, and the full Schur matrices are computed.
          On exit, ( ALPHR1(k)+ALPHI1(k)*i ) / BETA1(k) is the k-th
          generalized eigenvalue of the matrices in A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHR3</td><td><pre class="fragment">          ALPHR3 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHI3</td><td><pre class="fragment">          ALPHI3 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA3</td><td><pre class="fragment">          BETA3 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EVECTL</td><td><pre class="fragment">          EVECTL is DOUBLE PRECISION array, dimension (LDU, max(NN))
          The (block lower triangular) left eigenvector matrix for
          the matrices in S1 and P1.  (See DTGEVC for the format.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EVECTR</td><td><pre class="fragment">          EVECTR is DOUBLE PRECISION array, dimension (LDU, max(NN))
          The (block upper triangular) right eigenvector matrix for
          the matrices in S1 and P1.  (See DTGEVC for the format.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( 2 * N**2, 6*N, 1 ), for all N=NN(j).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LLWORK</td><td><pre class="fragment">          LLWORK is LOGICAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c4c10b0d7b63d96afa90ce5928d6d30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkgk </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKGK</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKGK tests DGGBAK, a routine for backward balancing  of
 a matrix pair (A, B).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e823485a300f7a3e836dde971d0539b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkgl </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKGL</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKGL tests DGGBAL, a routine for balancing a matrix pair (A, B).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The logical unit number for input.  NIN &gt; 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The logical unit number for output.  NOUT &gt; 0.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c7d85c04f03e5a109a04a119293910b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkhs </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>UZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>EVECTX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>UU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SELECT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 14 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKHS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DCHKHS  checks the nonsymmetric eigenvalue problem routines.

            DGEHRD factors A as  U H U' , where ' means transpose,
            H is hessenberg, and U is an orthogonal matrix.

            DORGHR generates the orthogonal matrix U.

            DORMHR multiplies a matrix by the orthogonal matrix U.

            DHSEQR factors H as  Z T Z' , where Z is orthogonal and
            T is "quasi-triangular", and the eigenvalue vector W.

            DTREVC computes the left and right eigenvector matrices
            L and R for T.

            DHSEIN computes the left and right eigenvector matrices
            Y and X for H, using inverse iteration.

    When DCHKHS is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 14
    tests will be performed:

    (1)     | A - U H U**T | / ( |A| n ulp )

    (2)     | I - UU**T | / ( n ulp )

    (3)     | H - Z T Z**T | / ( |H| n ulp )

    (4)     | I - ZZ**T | / ( n ulp )

    (5)     | A - UZ H (UZ)**T | / ( |A| n ulp )

    (6)     | I - UZ (UZ)**T | / ( n ulp )

    (7)     | T(Z computed) - T(Z not computed) | / ( |T| ulp )

    (8)     | W(Z computed) - W(Z not computed) | / ( |W| ulp )

    (9)     | TR - RW | / ( |T| |R| ulp )

    (10)    | L**H T - W**H L | / ( |T| |L| ulp )

    (11)    | HX - XW | / ( |H| |X| ulp )

    (12)    | Y**H H - W**H Y | / ( |H| |Y| ulp )

    (13)    | AX - XW | / ( |A| |X| ulp )

    (14)    | Y**H A - W**H Y | / ( |A| |Y| ulp )

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by SQRT( overflow threshold )
    (8)  Same as (4), but multiplied by SQRT( underflow threshold )

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by SQRT( overflow threshold )
    (18) Same as (16), but multiplied by SQRT( underflow threshold )

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
    (20) Same as (19), but multiplied by SQRT( overflow threshold )
    (21) Same as (19), but multiplied by SQRT( underflow threshold )</pre> <pre class="fragment">  NSIZES - INTEGER
           The number of sizes of matrices to use.  If it is zero,
           DCHKHS does nothing.  It must be at least zero.
           Not modified.

  NN     - INTEGER array, dimension (NSIZES)
           An array containing the sizes to be used for the matrices.
           Zero values will be skipped.  The values must be at least
           zero.
           Not modified.

  NTYPES - INTEGER
           The number of elements in DOTYPE.   If it is zero, DCHKHS
           does nothing.  It must be at least zero.  If it is MAXTYP+1
           and NSIZES is 1, then an additional type, MAXTYP+1 is
           defined, which is to use whatever matrix is in A.  This
           is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
           DOTYPE(MAXTYP+1) is .TRUE. .
           Not modified.

  DOTYPE - LOGICAL array, dimension (NTYPES)
           If DOTYPE(j) is .TRUE., then for each size in NN a
           matrix of that size and of type j will be generated.
           If NTYPES is smaller than the maximum number of types
           defined (PARAMETER MAXTYP), then types NTYPES+1 through
           MAXTYP will not be generated.  If NTYPES is larger
           than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
           will be ignored.
           Not modified.

  ISEED  - INTEGER array, dimension (4)
           On entry ISEED specifies the seed of the random number
           generator. The array elements should be between 0 and 4095;
           if not they will be reduced mod 4096.  Also, ISEED(4) must
           be odd.  The random number generator uses a linear
           congruential sequence limited to small integers, and so
           should produce machine independent random numbers. The
           values of ISEED are changed on exit, and can be used in the
           next call to DCHKHS to continue the same random number
           sequence.
           Modified.

  THRESH - DOUBLE PRECISION
           A test will count as "failed" if the "error", computed as
           described above, exceeds THRESH.  Note that the error
           is scaled to be O(1), so THRESH should be a reasonably
           small multiple of 1, e.g., 10 or 100.  In particular,
           it should not depend on the precision (single vs. double)
           or the size of the matrix.  It must be at least zero.
           Not modified.

  NOUNIT - INTEGER
           The FORTRAN unit number for printing out error messages
           (e.g., if a routine returns IINFO not equal to 0.)
           Not modified.

  A      - DOUBLE PRECISION array, dimension (LDA,max(NN))
           Used to hold the matrix whose eigenvalues are to be
           computed.  On exit, A contains the last matrix actually
           used.
           Modified.

  LDA    - INTEGER
           The leading dimension of A, H, T1 and T2.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  H      - DOUBLE PRECISION array, dimension (LDA,max(NN))
           The upper hessenberg matrix computed by DGEHRD.  On exit,
           H contains the Hessenberg form of the matrix in A.
           Modified.

  T1     - DOUBLE PRECISION array, dimension (LDA,max(NN))
           The Schur (="quasi-triangular") matrix computed by DHSEQR
           if Z is computed.  On exit, T1 contains the Schur form of
           the matrix in A.
           Modified.

  T2     - DOUBLE PRECISION array, dimension (LDA,max(NN))
           The Schur matrix computed by DHSEQR when Z is not computed.
           This should be identical to T1.
           Modified.

  LDU    - INTEGER
           The leading dimension of U, Z, UZ and UU.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  U      - DOUBLE PRECISION array, dimension (LDU,max(NN))
           The orthogonal matrix computed by DGEHRD.
           Modified.

  Z      - DOUBLE PRECISION array, dimension (LDU,max(NN))
           The orthogonal matrix computed by DHSEQR.
           Modified.

  UZ     - DOUBLE PRECISION array, dimension (LDU,max(NN))
           The product of U times Z.
           Modified.

  WR1    - DOUBLE PRECISION array, dimension (max(NN))
  WI1    - DOUBLE PRECISION array, dimension (max(NN))
           The real and imaginary parts of the eigenvalues of A,
           as computed when Z is computed.
           On exit, WR1 + WI1*i are the eigenvalues of the matrix in A.
           Modified.

  WR3    - DOUBLE PRECISION array, dimension (max(NN))
  WI3    - DOUBLE PRECISION array, dimension (max(NN))
           Like WR1, WI1, these arrays contain the eigenvalues of A,
           but those computed when DHSEQR only computes the
           eigenvalues, i.e., not the Schur vectors and no more of the
           Schur form than is necessary for computing the
           eigenvalues.
           Modified.

  EVECTL - DOUBLE PRECISION array, dimension (LDU,max(NN))
           The (upper triangular) left eigenvector matrix for the
           matrix in T1.  For complex conjugate pairs, the real part
           is stored in one row and the imaginary part in the next.
           Modified.

  EVEZTR - DOUBLE PRECISION array, dimension (LDU,max(NN))
           The (upper triangular) right eigenvector matrix for the
           matrix in T1.  For complex conjugate pairs, the real part
           is stored in one column and the imaginary part in the next.
           Modified.

  EVECTY - DOUBLE PRECISION array, dimension (LDU,max(NN))
           The left eigenvector matrix for the
           matrix in H.  For complex conjugate pairs, the real part
           is stored in one row and the imaginary part in the next.
           Modified.

  EVECTX - DOUBLE PRECISION array, dimension (LDU,max(NN))
           The right eigenvector matrix for the
           matrix in H.  For complex conjugate pairs, the real part
           is stored in one column and the imaginary part in the next.
           Modified.

  UU     - DOUBLE PRECISION array, dimension (LDU,max(NN))
           Details of the orthogonal matrix computed by DGEHRD.
           Modified.

  TAU    - DOUBLE PRECISION array, dimension(max(NN))
           Further details of the orthogonal matrix computed by DGEHRD.
           Modified.

  WORK   - DOUBLE PRECISION array, dimension (NWORK)
           Workspace.
           Modified.

  NWORK  - INTEGER
           The number of entries in WORK.  NWORK &gt;= 4*NN(j)*NN(j) + 2.

  IWORK  - INTEGER array, dimension (max(NN))
           Workspace.
           Modified.

  SELECT - LOGICAL array, dimension (max(NN))
           Workspace.
           Modified.

  RESULT - DOUBLE PRECISION array, dimension (14)
           The values computed by the fourteen tests described above.
           The values are currently limited to 1/ulp, to avoid
           overflow.
           Modified.

  INFO   - INTEGER
           If 0, then everything ran OK.
            -1: NSIZES &lt; 0
            -2: Some NN(j) &lt; 0
            -3: NTYPES &lt; 0
            -6: THRESH &lt; 0
            -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
           -14: LDU &lt; 1 or LDU &lt; NMAX.
           -28: NWORK too small.
           If  DLATMR, SLATMS, or SLATME returns an error code, the
               absolute value of it is returned.
           If 1, then DHSEQR could not find all the shifts.
           If 2, then the EISPACK code (for small blocks) failed.
           If &gt;2, then 30*N iterations were not enough to find an
               eigenvalue or to decompose the problem.
           Modified.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     MTEST           The number of tests defined: care must be taken
                     that (1) the size of RESULT, (2) the number of
                     tests actually performed, and (3) MTEST agree.
     NTEST           The number of tests performed on this matrix
                     so far.  This should be less than MTEST, and
                     equal to it by the last test.  It will be less
                     if any of the routines being tested indicates
                     that it could not compute the matrices that
                     would be tested.
     NMAX            Largest value in NN.
     NMATS           The number of matrices generated so far.
     NERRS           The number of tests which have exceeded THRESH
                     so far (computed by DLAFTS).
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTOVFL, RTUNFL,
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selects whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ef9e79152c39b707e749d783f40e57b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchksb </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWDTHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>KK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKSB</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKSB tests the reduction of a symmetric band matrix to tridiagonal
 form, used with the symmetric eigenvalue problem.

 DSBTRD factors a symmetric band matrix A as  U S U' , where ' means
 transpose, S is symmetric tridiagonal, and U is orthogonal.
 DSBTRD can use either just the lower or just the upper triangle
 of A; DCHKSB checks both cases.

 When DCHKSB is called, a number of matrix "sizes" ("n's"), a number
 of bandwidths ("k's"), and a number of matrix "types" are
 specified.  For each size ("n"), each bandwidth ("k") less than or
 equal to "n", and each type of matrix, one matrix will be generated
 and used to test the symmetric banded reduction routine.  For each
 matrix, a number of tests will be performed:

 (1)     | A - V S V' | / ( |A| n ulp )  computed by DSBTRD with
                                         UPLO='U'

 (2)     | I - UU' | / ( n ulp )

 (3)     | A - V S V' | / ( |A| n ulp )  computed by DSBTRD with
                                         UPLO='L'

 (4)     | I - UU' | / ( n ulp )

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U' D U, where U is orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U' D U, where U is orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U' D U, where U is orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Symmetric matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DCHKSB does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWDTHS</td><td><pre class="fragment">          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          DCHKSB does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KK</td><td><pre class="fragment">          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DCHKSB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DCHKSB to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension
                            (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 2 (not 1!)
          and at least max( KK )+1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the diagonal of the tridiagonal matrix computed
          by DSBTRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is DOUBLE PRECISION array, dimension (max(NN))
          Used to hold the off-diagonal of the tridiagonal matrix
          computed by DSBTRD.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, max(NN))
          Used to hold the orthogonal matrix computed by DSBTRD.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fcde518d0efadd400e7ddf07235f188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dchkst </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WA3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCHKST</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCHKST  checks the symmetric eigenvalue problem routines.

    DSYTRD factors A as  U S U' , where ' means transpose,
    S is symmetric tridiagonal, and U is orthogonal.
    DSYTRD can use either just the lower or just the upper triangle
    of A; DCHKST checks both cases.
    U is represented as a product of Householder
    transformations, whose vectors are stored in the first
    n-1 columns of V, and whose scale factors are in TAU.

    DSPTRD does the same as DSYTRD, except that A and V are stored
    in "packed" format.

    DORGTR constructs the matrix U from the contents of V and TAU.

    DOPGTR constructs the matrix U from the contents of VP and TAU.

    DSTEQR factors S as  Z D1 Z' , where Z is the orthogonal
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal.  D2 is the matrix of
    eigenvalues computed when Z is not computed.

    DSTERF computes D3, the matrix of eigenvalues, by the
    PWK method, which does not yield eigenvectors.

    DPTEQR factors S as  Z4 D4 Z4' , for a
    symmetric positive definite tridiagonal matrix.
    D5 is the matrix of eigenvalues computed when Z is not
    computed.

    DSTEBZ computes selected eigenvalues.  WA1, WA2, and
    WA3 will denote eigenvalues computed to high
    absolute accuracy, with different range options.
    WR will denote eigenvalues computed to high relative
    accuracy.

    DSTEIN computes Y, the eigenvectors of S, given the
    eigenvalues.

    DSTEDC factors S as Z D1 Z' , where Z is the orthogonal
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option). It may also
    update an input orthogonal matrix, usually the output
    from DSYTRD/DORGTR or DSPTRD/DOPGTR ('V' option). It may
    also just compute eigenvalues ('N' option).

    DSTEMR factors S as Z D1 Z' , where Z is the orthogonal
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option).  DSTEMR
    uses the Relatively Robust Representation whenever possible.

 When DCHKST is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the symmetric eigenroutines.  For each matrix, a number
 of tests will be performed:

 (1)     | A - V S V' | / ( |A| n ulp ) DSYTRD( UPLO='U', ... )

 (2)     | I - UV' | / ( n ulp )        DORGTR( UPLO='U', ... )

 (3)     | A - V S V' | / ( |A| n ulp ) DSYTRD( UPLO='L', ... )

 (4)     | I - UV' | / ( n ulp )        DORGTR( UPLO='L', ... )

 (5-8)   Same as 1-4, but for DSPTRD and DOPGTR.

 (9)     | S - Z D Z' | / ( |S| n ulp ) DSTEQR('V',...)

 (10)    | I - ZZ' | / ( n ulp )        DSTEQR('V',...)

 (11)    | D1 - D2 | / ( |D1| ulp )        DSTEQR('N',...)

 (12)    | D1 - D3 | / ( |D1| ulp )        DSTERF

 (13)    0 if the true eigenvalues (computed by sturm count)
         of S are within THRESH of
         those in D1.  2*THRESH if they are not.  (Tested using
         DSTECH)

 For S positive definite,

 (14)    | S - Z4 D4 Z4' | / ( |S| n ulp ) DPTEQR('V',...)

 (15)    | I - Z4 Z4' | / ( n ulp )        DPTEQR('V',...)

 (16)    | D4 - D5 | / ( 100 |D4| ulp )       DPTEQR('N',...)

 When S is also diagonally dominant by the factor gamma &lt; 1,

 (17)    max | D4(i) - WR(i) | / ( |D4(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              DSTEBZ( 'A', 'E', ...)

 (18)    | WA1 - D3 | / ( |D3| ulp )          DSTEBZ( 'A', 'E', ...)

 (19)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
                                              DSTEBZ( 'I', 'E', ...)

 (20)    | S - Y WA1 Y' | / ( |S| n ulp )  DSTEBZ, SSTEIN

 (21)    | I - Y Y' | / ( n ulp )          DSTEBZ, SSTEIN

 (22)    | S - Z D Z' | / ( |S| n ulp )    DSTEDC('I')

 (23)    | I - ZZ' | / ( n ulp )           DSTEDC('I')

 (24)    | S - Z D Z' | / ( |S| n ulp )    DSTEDC('V')

 (25)    | I - ZZ' | / ( n ulp )           DSTEDC('V')

 (26)    | D1 - D2 | / ( |D1| ulp )           DSTEDC('V') and
                                              DSTEDC('N')

 Test 27 is disabled at the moment because DSTEMR does not
 guarantee high relatvie accuracy.

 (27)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              DSTEMR('V', 'A')

 (28)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              DSTEMR('V', 'I')

 Tests 29 through 34 are disable at present because DSTEMR
 does not handle partial specturm requests.

 (29)    | S - Z D Z' | / ( |S| n ulp )    DSTEMR('V', 'I')

 (30)    | I - ZZ' | / ( n ulp )           DSTEMR('V', 'I')

 (31)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         DSTEMR('N', 'I') vs. SSTEMR('V', 'I')

 (32)    | S - Z D Z' | / ( |S| n ulp )    DSTEMR('V', 'V')

 (33)    | I - ZZ' | / ( n ulp )           DSTEMR('V', 'V')

 (34)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         DSTEMR('N', 'V') vs. SSTEMR('V', 'V')

 (35)    | S - Z D Z' | / ( |S| n ulp )    DSTEMR('V', 'A')

 (36)    | I - ZZ' | / ( n ulp )           DSTEMR('V', 'A')

 (37)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         DSTEMR('N', 'A') vs. SSTEMR('V', 'A')

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U' D U, where U is orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U' D U, where U is orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U' D U, where U is orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Symmetric matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )
 (16) Same as (8), but diagonal elements are all positive.
 (17) Same as (9), but diagonal elements are all positive.
 (18) Same as (10), but diagonal elements are all positive.
 (19) Same as (16), but multiplied by SQRT( overflow threshold )
 (20) Same as (16), but multiplied by SQRT( underflow threshold )
 (21) A diagonally dominant tridiagonal matrix with geometrically
      spaced diagonal entries 1, ..., ULP.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DCHKST does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DCHKST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DCHKST to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array of
                                  dimension ( LDA , max(NN) )
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AP</td><td><pre class="fragment">          AP is DOUBLE PRECISION array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix A stored in packed format.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The diagonal of the tridiagonal matrix computed by DSYTRD.
          On exit, SD and SE contain the tridiagonal form of the
          matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The off-diagonal of the tridiagonal matrix computed by
          DSYTRD.  On exit, SD and SE contain the tridiagonal form of
          the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D1</td><td><pre class="fragment">          D1 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by DSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D2</td><td><pre class="fragment">          D2 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by DSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D3</td><td><pre class="fragment">          D3 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by DSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D4</td><td><pre class="fragment">          D4 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by DPTEQR(V).
          DPTEQR factors S as  Z4 D4 Z4*
          On exit, the eigenvalues in D4 correspond with the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D5</td><td><pre class="fragment">          D5 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by DPTEQR(N)
          when Z is not computed. On exit, the
          eigenvalues in D4 correspond with the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WA1</td><td><pre class="fragment">          WA1 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by DSTEBZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WA2</td><td><pre class="fragment">          WA2 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by DSTEBZ.
          Choose random values for IL and IU, and ask for the
          IL-th through IU-th eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WA3</td><td><pre class="fragment">          WA3 is DOUBLE PRECISION array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by DSTEBZ.
          Determine the values VL and VU of the IL-th and IU-th
          eigenvalues and ask for all eigenvalues in this range.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different options.
          as computed by DSTEBZ.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array of
                             dimension( LDU, max(NN) ).
          The orthogonal matrix computed by DSYTRD + DORGTR.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U, Z, and V.  It must be at least 1
          and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array of
                             dimension( LDU, max(NN) ).
          The Housholder vectors computed by DSYTRD in reducing A to
          tridiagonal form.  The vectors computed with UPLO='U' are
          in the upper triangle, and the vectors computed with UPLO='L'
          are in the lower triangle.  (As described in DSYTRD, the
          sub- and superdiagonal are not set to 1, although the
          true Householder vector has a 1 in that position.  The
          routines that use V, such as DORGTR, set those entries to
          1 before using them, and then restore them later.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VP</td><td><pre class="fragment">          VP is DOUBLE PRECISION array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix V stored in packed format.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is DOUBLE PRECISION array of
                             dimension( max(NN) )
          The Householder factors computed by DSYTRD in reducing A
          to tridiagonal form.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array of
                             dimension( LDU, max(NN) ).
          The orthogonal matrix of eigenvectors computed by DSTEQR,
          DPTEQR, and DSTEIN.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array of
                      dimension( LWORK )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          1 + 4 * Nmax + 2 * Nmax * lg Nmax + 3 * Nmax**2
          where Nmax = max( NN(j), 2 ) and lg = log base 2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array,
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          The number of entries in IWORK.  This must be at least
                  6 + 6*Nmax + 5 * Nmax * lg Nmax 
          where Nmax = max( NN(j), 2 ) and lg = log base 2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (26)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -5: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -23: LDU &lt; 1 or LDU &lt; NMAX.
          -29: LWORK too small.
          If  DLATMR, SLATMS, DSYTRD, DORGTR, DSTEQR, SSTERF,
              or DORMC2 returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NBLOCK          Blocksize as returned by ENVIR.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga21bc4aa635925a1753872278c38891b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dckcsd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>QVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>XF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V1T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V2T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>THETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCKCSD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCKCSD tests DORCSD:
        the CSD for an M-by-M orthogonal matrix X partitioned as
        [ X11 X12; X21 X22 ]. X11 is P-by-Q.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NM</td><td><pre class="fragment">          NM is INTEGER
          The number of values of M contained in the vector MVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QVAL</td><td><pre class="fragment">          QVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MMAX</td><td><pre class="fragment">          MMAX is INTEGER
          The maximum value permitted for M, used in dimensioning the
          work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">XF</td><td><pre class="fragment">          XF is DOUBLE PRECISION array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U1</td><td><pre class="fragment">          U1 is DOUBLE PRECISION array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is DOUBLE PRECISION array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V1T</td><td><pre class="fragment">          V1T is DOUBLE PRECISION array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V2T</td><td><pre class="fragment">          V2T is DOUBLE PRECISION array, dimension (MMAX*MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">THETA</td><td><pre class="fragment">          THETA is DOUBLE PRECISION array, dimension (MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If DLAROR returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6b8c9f14788fd8526a77c40a11e684f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dckglm </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCKGLM</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCKGLM tests DGGGLM - subroutine for solving generalized linear
                       model problem.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER
          The number of values of N, M and P contained in the vectors
          NVAL, MVAL and PVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix row dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESID &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (4*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If DLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d542e25f93c07e7fac6bdf79e741bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dckgqr </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCKGQR</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCKGQR tests
 DGGQRF: GQR factorization for N-by-M matrix A and N-by-P matrix B,
 DGGRQF: GRQ factorization for M-by-N matrix A and P-by-N matrix B.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NM</td><td><pre class="fragment">          NM is INTEGER
          The number of values of M contained in the vector MVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row(column) dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NP</td><td><pre class="fragment">          NP is INTEGER
          The number of values of P contained in the vector PVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row(column) dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER
          The number of values of N contained in the vector NVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AQ</td><td><pre class="fragment">          AQ is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AR</td><td><pre class="fragment">          AR is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUA</td><td><pre class="fragment">          TAUA is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BZ</td><td><pre class="fragment">          BZ is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BT</td><td><pre class="fragment">          BT is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWK</td><td><pre class="fragment">          BWK is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUB</td><td><pre class="fragment">          TAUB is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If DLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gafbc45ea9306629ad531d876544d73adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dckgsv </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCKGSV</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCKGSV tests DGGSVD:
        the GSVD for M-by-N matrix A and P-by-N matrix B.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NM</td><td><pre class="fragment">          NM is INTEGER
          The number of values of M contained in the vector MVAL.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If DLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d9cfcdec43b543507c9b770e2d4e0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dcklse </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>PVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NVAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMATS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCKLSE</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCKLSE tests DGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER
          The number of values of (M,P,N) contained in the vectors
          (MVAL, PVAL, NVAL).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MVAL</td><td><pre class="fragment">          MVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PVAL</td><td><pre class="fragment">          PVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension P.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NVAL</td><td><pre class="fragment">          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMATS</td><td><pre class="fragment">          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS &gt;= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS &lt; NTYPES, another input line
          is read to get the numbers of the matrix types to be used.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  To have
          every test ratio printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NMAX</td><td><pre class="fragment">          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (5*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (NMAX*NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The unit number for input.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The unit number for output.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0 :  successful exit
          &gt; 0 :  If DLATMS returns an error code, the absolute value
                 of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga03cd3ed37d8c793d58398c431d01ea1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dcsdts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>XF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu1, * )&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu2, * )&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv1t, * )&#160;</td>
          <td class="paramname"><em>V1T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV1T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv2t, * )&#160;</td>
          <td class="paramname"><em>V2T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV2T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>THETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 15 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DCSDTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DCSDTS tests DORCSD, which, given an M-by-M partitioned orthogonal
 matrix X,
              Q  M-Q
       X = [ X11 X12 ] P   ,
           [ X21 X22 ] M-P

 computes the CSD

       [ U1    ]**T * [ X11 X12 ] * [ V1    ]
       [    U2 ]      [ X21 X22 ]   [    V2 ]

                             [  I  0  0 |  0  0  0 ]
                             [  0  C  0 |  0 -S  0 ]
                             [  0  0  0 |  0  0 -I ]
                           = [---------------------] = [ D11 D12 ] ,
                             [  0  0  0 |  I  0  0 ]   [ D21 D22 ]
                             [  0  S  0 |  0  C  0 ]
                             [  0  0  I |  0  0  0 ]

 and also DORCSD2BY1, which, given
          Q
       [ X11 ] P   ,
       [ X21 ] M-P

 computes the 2-by-1 CSD

                                     [  I  0  0 ]
                                     [  0  C  0 ]
                                     [  0  0  0 ]
       [ U1    ]**T * [ X11 ] * V1 = [----------] = [ D11 ] ,
       [    U2 ]      [ X21 ]        [  0  0  0 ]   [ D21 ]
                                     [  0  S  0 ]
                                     [  0  0  I ]</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix X.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix X11.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is INTEGER
          The number of columns of the matrix X11.  Q &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (LDX,M)
          The M-by-M matrix X.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">XF</td><td><pre class="fragment">          XF is DOUBLE PRECISION array, dimension (LDX,M)
          Details of the CSD of X, as returned by DORCSD;
          see DORCSD for further details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the arrays X and XF.
          LDX &gt;= max( 1,M ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U1</td><td><pre class="fragment">          U1 is DOUBLE PRECISION array, dimension(LDU1,P)
          The P-by-P orthogonal matrix U1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU1</td><td><pre class="fragment">          LDU1 is INTEGER
          The leading dimension of the array U1. LDU &gt;= max(1,P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U2</td><td><pre class="fragment">          U2 is DOUBLE PRECISION array, dimension(LDU2,M-P)
          The (M-P)-by-(M-P) orthogonal matrix U2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU2</td><td><pre class="fragment">          LDU2 is INTEGER
          The leading dimension of the array U2. LDU &gt;= max(1,M-P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V1T</td><td><pre class="fragment">          V1T is DOUBLE PRECISION array, dimension(LDV1T,Q)
          The Q-by-Q orthogonal matrix V1T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV1T</td><td><pre class="fragment">          LDV1T is INTEGER
          The leading dimension of the array V1T. LDV1T &gt;=
          max(1,Q).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V2T</td><td><pre class="fragment">          V2T is DOUBLE PRECISION array, dimension(LDV2T,M-Q)
          The (M-Q)-by-(M-Q) orthogonal matrix V2T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV2T</td><td><pre class="fragment">          LDV2T is INTEGER
          The leading dimension of the array V2T. LDV2T &gt;=
          max(1,M-Q).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">THETA</td><td><pre class="fragment">          THETA is DOUBLE PRECISION array, dimension MIN(P,M-P,Q,M-Q)
          The CS values of X; the essentially diagonal matrices C and
          S are constructed from THETA; see subroutine DORCSD for
          details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (15)
          The test ratios:
          First, the 2-by-2 CSD:
          RESULT(1) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(2) = norm( U1'*X12*V2 - D12 ) / ( MAX(1,P,M-Q)*EPS2 )
          RESULT(3) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(4) = norm( U2'*X22*V2 - D22 ) / ( MAX(1,M-P,M-Q)*EPS2 )
          RESULT(5) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(6) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(7) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(8) = norm( I - V2T'*V2T ) / ( MAX(1,M-Q)*ULP )
          RESULT(9) = 0        if THETA is in increasing order and
                               all angles are in [0,pi/2];
                    = ULPINV   otherwise.
          Then, the 2-by-1 CSD:
          RESULT(10) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(11) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(12) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(13) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(14) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(15) = 0        if THETA is in increasing order and
                                all angles are in [0,pi/2];
                     = ULPINV   otherwise.
          ( EPS2 = MAX( norm( I - X'*X ) / M, ULP ). )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6cc419f7585f852ef90e140e55fdfd49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrges </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 13 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRGES</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DDRGES checks the nonsymmetric generalized eigenvalue (Schur form)
 problem driver DGGES.

 DGGES factors A and B as Q S Z'  and Q T Z' , where ' means
 transpose, T is upper triangular, S is in generalized Schur form
 (block upper triangular, with 1x1 and 2x2 blocks on the diagonal,
 the 2x2 blocks corresponding to complex conjugate pairs of
 generalized eigenvalues), and Q and Z are orthogonal. It also
 computes the generalized eigenvalues (alpha(j),beta(j)), j=1,...,n,
 Thus, w(j) = alpha(j)/beta(j) is a root of the characteristic
 equation
                 det( A - w(j) B ) = 0
 Optionally it also reorder the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms.

 When DDRGES is called, a number of matrix "sizes" ("N's") and a
 number of matrix "TYPES" are specified.  For each size ("N")
 and each TYPE of matrix, a pair of matrices (A, B) will be generated
 and used for testing. For each matrix pair, the following 13 tests
 will be performed and compared with the threshhold THRESH except
 the tests (5), (11) and (13).


 (1)   | A - Q S Z' | / ( |A| n ulp ) (no sorting of eigenvalues)


 (2)   | B - Q T Z' | / ( |B| n ulp ) (no sorting of eigenvalues)


 (3)   | I - QQ' | / ( n ulp ) (no sorting of eigenvalues)


 (4)   | I - ZZ' | / ( n ulp ) (no sorting of eigenvalues)

 (5)   if A is in Schur form (i.e. quasi-triangular form)
       (no sorting of eigenvalues)

 (6)   if eigenvalues = diagonal blocks of the Schur form (S, T),
       i.e., test the maximum over j of D(j)  where:

       if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

       and S and T are here the 2 x 2 diagonal blocks of S and T
       corresponding to the j-th and j+1-th eigenvalues.
       (no sorting of eigenvalues)

 (7)   | (A,B) - Q (S,T) Z' | / ( | (A,B) | n ulp )
            (with sorting of eigenvalues).

 (8)   | I - QQ' | / ( n ulp ) (with sorting of eigenvalues).

 (9)   | I - ZZ' | / ( n ulp ) (with sorting of eigenvalues).

 (10)  if A is in Schur form (i.e. quasi-triangular form)
       (with sorting of eigenvalues).

 (11)  if eigenvalues = diagonal blocks of the Schur form (S, T),
       i.e. test the maximum over j of D(j)  where:

       if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

       and S and T are here the 2 x 2 diagonal blocks of S and T
       corresponding to the j-th and j+1-th eigenvalues.
       (with sorting of eigenvalues).

 (12)  if sorting worked and SDIM is the number of eigenvalues
       which were SELECTed.

 Test Matrices
 =============

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRGES does nothing.  NSIZES &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRGES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A on input.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRGES to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  THRESH &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array,
                                       dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array,
                                       dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by DGGES.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by DGGES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDQ, max(NN))
          The (left) orthogonal matrix computed by DGGES.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by DGGES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAR</td><td><pre class="fragment">          ALPHAR is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAI</td><td><pre class="fragment">          ALPHAI is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by DGGES.
          ( ALPHAR(k)+ALPHAI(k)*i ) / BETA(k) is the k-th
          generalized eigenvalue of A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.
          LWORK &gt;= MAX( 10*(N+1), 3*N*N ), where N is the largest
          matrix dimension.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dd9ec32424dde4c58b7f7b35365e879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrgev </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldqe, * )&#160;</td>
          <td class="paramname"><em>QE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRGEV</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DDRGEV checks the nonsymmetric generalized eigenvalue problem driver
 routine DGGEV.

 DGGEV computes for a pair of n-by-n nonsymmetric matrices (A,B) the
 generalized eigenvalues and, optionally, the left and right
 eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio  alpha/beta = w, such that A - w*B is singular.  It is
 usually represented as the pair (alpha,beta), as there is reasonalbe
 interpretation for beta=0, and even for both being zero.

 A right generalized eigenvector corresponding to a generalized
 eigenvalue  w  for a pair of matrices (A,B) is a vector r  such that
 (A - wB) * r = 0.  A left generalized eigenvector is a vector l such
 that l**H * (A - wB) = 0, where l**H is the conjugate-transpose of l.

 When DDRGEV is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, a pair of matrices (A, B) will be generated
 and used for testing.  For each matrix pair, the following tests
 will be performed and compared with the threshhold THRESH.

 Results from DGGEV:

 (1)  max over all left eigenvalue/-vector pairs (alpha/beta,l) of

      | VL**H * (beta A - alpha B) |/( ulp max(|beta A|, |alpha B|) )

      where VL**H is the conjugate-transpose of VL.

 (2)  | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

 (3)  max over all left eigenvalue/-vector pairs (alpha/beta,r) of

      | (beta A - alpha B) * VR | / ( ulp max(|beta A|, |alpha B|) )

 (4)  | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

 (5)  W(full) = W(partial)
      W(full) denotes the eigenvalues computed when both l and r
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and r, or only W and l are
      computed.

 (6)  VL(full) = VL(partial)
      VL(full) denotes the left eigenvectors computed when both l
      and r are computed, and VL(partial) denotes the result
      when only l is computed.

 (7)  VR(full) = VR(partial)
      VR(full) denotes the right eigenvectors computed when both l
      and r are also computed, and VR(partial) denotes the result
      when only l is computed.


 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRGES does nothing.  NSIZES &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRGES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRGES to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IERR not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array,
                                       dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array,
                                       dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array,
                                 dimension (LDA, max(NN))
          The Schur form matrix computed from A by DGGES.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is DOUBLE PRECISION array,
                                 dimension (LDA, max(NN))
          The upper triangular matrix computed from B by DGGES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array,
                                 dimension (LDQ, max(NN))
          The (left) eigenvectors matrix computed by DGGEV.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by DGGES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">QE</td><td><pre class="fragment">          QE is DOUBLE PRECISION array, dimension( LDQ, max(NN) )
          QE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQE</td><td><pre class="fragment">          LDQE is INTEGER
          The leading dimension of QE. LDQE &gt;= max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAR</td><td><pre class="fragment">          ALPHAR is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAI</td><td><pre class="fragment">          ALPHAI is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by DGGEV.
          ( ALPHAR(k)+ALPHAI(k)*i ) / BETA(k) is the k-th
          generalized eigenvalue of A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHR1</td><td><pre class="fragment">          ALPHR1 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHI1</td><td><pre class="fragment">          ALPHI1 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA1</td><td><pre class="fragment">          BETA1 is DOUBLE PRECISION array, dimension (max(NN))

          Like ALPHAR, ALPHAI, BETA, these arrays contain the
          eigenvalues of A and B, but those computed when DGGEV only
          computes a partial eigendecomposition, i.e. not the
          eigenvalues and left and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  LWORK &gt;= MAX( 8*N, N*(N+1) ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5408eea13bb949e9ff502a7dfd447954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrgsx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NCMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>BI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRGSX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DDRGSX checks the nonsymmetric generalized eigenvalue (Schur form)
 problem expert driver DGGESX.

 DGGESX factors A and B as Q S Z' and Q T Z', where ' means
 transpose, T is upper triangular, S is in generalized Schur form
 (block upper triangular, with 1x1 and 2x2 blocks on the diagonal,
 the 2x2 blocks corresponding to complex conjugate pairs of
 generalized eigenvalues), and Q and Z are orthogonal.  It also
 computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)). Thus, w(j) = alpha(j)/beta(j) is a root of the
 characteristic equation

     det( A - w(j) B ) = 0

 Optionally it also reorders the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms; computes a reciprocal condition number for the average
 of the selected eigenvalues; and computes a reciprocal condition
 number for the right and left deflating subspaces corresponding to
 the selected eigenvalues.

 When DDRGSX is called with NSIZE &gt; 0, five (5) types of built-in
 matrix pairs are used to test the routine DGGESX.

 When DDRGSX is called with NSIZE = 0, it reads in test matrix data
 to test DGGESX.

 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH except for the tests (7) and (9):

 (1)   | A - Q S Z' | / ( |A| n ulp )

 (2)   | B - Q T Z' | / ( |B| n ulp )

 (3)   | I - QQ' | / ( n ulp )

 (4)   | I - ZZ' | / ( n ulp )

 (5)   if A is in Schur form (i.e. quasi-triangular form)

 (6)   maximum over j of D(j)  where:

       if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

           and S and T are here the 2 x 2 diagonal blocks of S and T
           corresponding to the j-th and j+1-th eigenvalues.

 (7)   if sorting worked and SDIM is the number of eigenvalues
       which were selected.

 (8)   the estimated value DIF does not differ from the true values of
       Difu and Difl more than a factor 10*THRESH. If the estimate DIF
       equals zero the corresponding true values of Difu and Difl
       should be less than EPS*norm(A, B). If the true value of Difu
       and Difl equal zero, the estimate DIF should be less than
       EPS*norm(A, B).

 (9)   If INFO = N+3 is returned by DGGESX, the reordering "failed"
       and we check that DIF = PL = PR = 0 and that the true value of
       Difu and Difl is &lt; EPS*norm(A, B). We count the events when
       INFO=N+3.

 For read-in test matrices, the above tests are run except that the
 exact value for DIF (and PL) is input data.  Additionally, there is
 one more test run for read-in test matrices:

 (10)  the estimated value PL does not differ from the true value of
       PLTRU more than a factor THRESH. If the estimate PL equals
       zero the corresponding true value of PLTRU should be less than
       EPS*norm(A, B). If the true value of PLTRU equal zero, the
       estimate PL should be less than EPS*norm(A, B).

 Note that for the built-in tests, a total of 10*NSIZE*(NSIZE-1)
 matrix pairs are generated and tested. NSIZE should be kept small.

 SVD (routine DGESVD) is used for computing the true value of DIF_u
 and DIF_l when testing the built-in test problems.

 Built-in Test Matrices
 ======================

 All built-in test matrices are the 2 by 2 block of triangular
 matrices

          A = [ A11 A12 ]    and      B = [ B11 B12 ]
              [     A22 ]                 [     B22 ]

 where for different type of A11 and A22 are given as the following.
 A12 and B12 are chosen so that the generalized Sylvester equation

          A11*R - L*A22 = -A12
          B11*R - L*B22 = -B12

 have prescribed solution R and L.

 Type 1:  A11 = J_m(1,-1) and A_22 = J_k(1-a,1).
          B11 = I_m, B22 = I_k
          where J_k(a,b) is the k-by-k Jordan block with ``a'' on
          diagonal and ``b'' on superdiagonal.

 Type 2:  A11 = (a_ij) = ( 2(.5-sin(i)) ) and
          B11 = (b_ij) = ( 2(.5-sin(ij)) ) for i=1,...,m, j=i,...,m
          A22 = (a_ij) = ( 2(.5-sin(i+j)) ) and
          B22 = (b_ij) = ( 2(.5-sin(ij)) ) for i=m+1,...,k, j=i,...,k

 Type 3:  A11, A22 and B11, B22 are chosen as for Type 2, but each
          second diagonal block in A_11 and each third diagonal block
          in A_22 are made as 2 by 2 blocks.

 Type 4:  A11 = ( 20(.5 - sin(ij)) ) and B22 = ( 2(.5 - sin(i+j)) )
             for i=1,...,m,  j=1,...,m and
          A22 = ( 20(.5 - sin(i+j)) ) and B22 = ( 2(.5 - sin(ij)) )
             for i=m+1,...,k,  j=m+1,...,k

 Type 5:  (A,B) and have potentially close or common eigenvalues and
          very large departure from block diagonality A_11 is chosen
          as the m x m leading submatrix of A_1:
                  |  1  b                            |
                  | -b  1                            |
                  |        1+d  b                    |
                  |         -b 1+d                   |
           A_1 =  |                  d  1            |
                  |                 -1  d            |
                  |                        -d  1     |
                  |                        -1 -d     |
                  |                               1  |
          and A_22 is chosen as the k x k leading submatrix of A_2:
                  | -1  b                            |
                  | -b -1                            |
                  |       1-d  b                     |
                  |       -b  1-d                    |
           A_2 =  |                 d 1+b            |
                  |               -1-b d             |
                  |                       -d  1+b    |
                  |                      -1+b  -d    |
                  |                              1-d |
          and matrix B are chosen as identity matrices (see DLATM5).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZE</td><td><pre class="fragment">          NSIZE is INTEGER
          The maximum size of the matrices to use. NSIZE &gt;= 0.
          If NSIZE = 0, no built-in tests matrices are used, but
          read-in test matrices are used to test DGGESX.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NCMAX</td><td><pre class="fragment">          NCMAX is INTEGER
          Maximum allowable NMAX for generating Kroneker matrix
          in call to DLAKF2</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  THRESH &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Z and Q,
          LDA &gt;= max( 1, NSIZE ). For the read-in test,
          LDA &gt;= max( 1, N ), N is the size of the test matrices.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AI</td><td><pre class="fragment">          AI is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Copy of A, modified by DGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BI</td><td><pre class="fragment">          BI is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Copy of B, modified by DGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Z holds the left Schur vectors computed by DGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Q holds the right Schur vectors computed by DGGESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAR</td><td><pre class="fragment">          ALPHAR is DOUBLE PRECISION array, dimension (NSIZE)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAI</td><td><pre class="fragment">          ALPHAI is DOUBLE PRECISION array, dimension (NSIZE)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION array, dimension (NSIZE)

          On exit, (ALPHAR + ALPHAI*i)/BETA are the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension (LDC, LDC)
          Store the matrix generated by subroutine DLAKF2, this is the
          matrix formed by Kronecker products used for estimating
          DIF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of C. LDC &gt;= max(1, LDA*LDA/2 ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension (LDC)
          Singular values of C</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.
          LWORK &gt;= MAX( 5*NSIZE*NSIZE/2 - 2, 10*(NSIZE+1) )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (LIWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          The dimension of the array IWORK. LIWORK &gt;= NSIZE + 6.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (LDA)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga12fe443f6eebc293d99eae77fa84d9c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrgvx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>BI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>LSCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RSCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DTRU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DIF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DIFTRU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 4 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRGVX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DDRGVX checks the nonsymmetric generalized eigenvalue problem
 expert driver DGGEVX.

 DGGEVX computes the generalized eigenvalues, (optionally) the left
 and/or right eigenvectors, (optionally) computes a balancing
 transformation to improve the conditioning, and (optionally)
 reciprocal condition numbers for the eigenvalues and eigenvectors.

 When DDRGVX is called with NSIZE &gt; 0, two types of test matrix pairs
 are generated by the subroutine DLATM6 and test the driver DGGEVX.
 The test matrices have the known exact condition numbers for
 eigenvalues. For the condition numbers of the eigenvectors
 corresponding the first and last eigenvalues are also know
 ``exactly'' (see DLATM6).

 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH.

 (1) max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

     where l**H is the conjugate tranpose of l.

 (2) max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 (3) The condition number S(i) of eigenvalues computed by DGGEVX
     differs less than a factor THRESH from the exact S(i) (see
     DLATM6).

 (4) DIF(i) computed by DTGSNA differs less than a factor 10*THRESH
     from the exact value (for the 1st and 5th vectors only).

 Test Matrices
 =============

 Two kinds of test matrix pairs

          (A, B) = inverse(YH) * (Da, Db) * inverse(X)

 are used in the tests:

 1: Da = 1+a   0    0    0    0    Db = 1   0   0   0   0
          0   2+a   0    0    0         0   1   0   0   0
          0    0   3+a   0    0         0   0   1   0   0
          0    0    0   4+a   0         0   0   0   1   0
          0    0    0    0   5+a ,      0   0   0   0   1 , and

 2: Da =  1   -1    0    0    0    Db = 1   0   0   0   0
          1    1    0    0    0         0   1   0   0   0
          0    0    1    0    0         0   0   1   0   0
          0    0    0   1+a  1+b        0   0   0   1   0
          0    0    0  -1-b  1+a ,      0   0   0   0   1 .

 In both cases the same inverse(YH) and inverse(X) are used to compute
 (A, B), giving the exact eigenvectors to (A,B) as (YH, X):

 YH:  =  1    0   -y    y   -y    X =  1   0  -x  -x   x
         0    1   -y    y   -y         0   1   x  -x  -x
         0    0    1    0    0         0   0   1   0   0
         0    0    0    1    0         0   0   0   1   0
         0    0    0    0    1,        0   0   0   0   1 , where

 a, b, x and y will have all values independently of each other from
 { sqrt(sqrt(ULP)),  0.1,  1,  10,  1/sqrt(sqrt(ULP)) }.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZE</td><td><pre class="fragment">          NSIZE is INTEGER
          The number of sizes of matrices to use.  NSIZE must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIN will be
          tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Ao, and Bo.
          It must be at least 1 and at least NSIZE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AI</td><td><pre class="fragment">          AI is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Copy of A, modified by DGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BI</td><td><pre class="fragment">          BI is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          Copy of B, modified by DGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAR</td><td><pre class="fragment">          ALPHAR is DOUBLE PRECISION array, dimension (NSIZE)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAI</td><td><pre class="fragment">          ALPHAI is DOUBLE PRECISION array, dimension (NSIZE)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION array, dimension (NSIZE)

          On exit, (ALPHAR + ALPHAI*i)/BETA are the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          VL holds the left eigenvectors computed by DGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is DOUBLE PRECISION array, dimension (LDA, NSIZE)
          VR holds the right eigenvectors computed by DGGEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ILO</td><td><pre class="fragment">        ILO is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IHI</td><td><pre class="fragment">        IHI is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LSCALE</td><td><pre class="fragment">        LSCALE is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RSCALE</td><td><pre class="fragment">        RSCALE is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">        S is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DTRU</td><td><pre class="fragment">        DTRU is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIF</td><td><pre class="fragment">        DIF is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DIFTRU</td><td><pre class="fragment">        DIFTRU is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          Leading dimension of WORK.  LWORK &gt;= 2*N*N+12*N+16.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (LIWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIWORK</td><td><pre class="fragment">          LIWORK is INTEGER
          Leading dimension of IWORK.  Must be at least N+6.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">        RESULT is DOUBLE PRECISION array, dimension (4)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ga154b2caeffc955bb3dede4c310ca3cd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrvbd </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>MM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>ASAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>USAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvt, * )&#160;</td>
          <td class="paramname"><em>VTSAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SSAV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVBD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DDRVBD checks the singular value decomposition (SVD) drivers
 DGESVD, DGESDD, DGESVJ, and DGEJSV.

 Both DGESVD and DGESDD factor A = U diag(S) VT, where U and VT are
 orthogonal and diag(S) is diagonal with the entries of the array S
 on its diagonal. The entries of S are the singular values,
 nonnegative and stored in decreasing order.  U and VT can be
 optionally not computed, overwritten on A, or computed partially.

 A is M by N. Let MNMIN = min( M, N ). S has dimension MNMIN.
 U can be M by M or M by MNMIN. VT can be N by N or MNMIN by N.

 When DDRVBD is called, a number of matrix "sizes" (M's and N's)
 and a number of matrix "types" are specified.  For each size (M,N)
 and each type of matrix, and for the minimal workspace as well as
 workspace adequate to permit blocking, an  M x N  matrix "A" will be
 generated and used to test the SVD routines.  For each matrix, A will
 be factored as A = U diag(S) VT and the following 12 tests computed:

 Test for DGESVD:

 (1)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (2)    | I - U'U | / ( M ulp )

 (3)    | I - VT VT' | / ( N ulp )

 (4)    S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 (5)    | U - Upartial | / ( M ulp ) where Upartial is a partially
        computed U.

 (6)    | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
        computed VT.

 (7)    | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
        vector of singular values from the partial SVD

 Test for DGESDD:

 (8)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (9)    | I - U'U | / ( M ulp )

 (10)   | I - VT VT' | / ( N ulp )

 (11)   S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 (12)   | U - Upartial | / ( M ulp ) where Upartial is a partially
        computed U.

 (13)   | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
        computed VT.

 (14)   | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
        vector of singular values from the partial SVD

 Test for SGESVJ:

 (15)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (16)    | I - U'U | / ( M ulp )

 (17)   | I - VT VT' | / ( N ulp )

 (18)   S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 Test for SGEJSV:

 (19)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (20)    | I - U'U | / ( M ulp )

 (21)   | I - VT VT' | / ( N ulp )

 (22)   S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 The "sizes" are specified by the arrays MM(1:NSIZES) and
 NN(1:NSIZES); the value of each element pair (MM(j),NN(j))
 specifies one size.  The "types" are specified by a logical array
 DOTYPE( 1:NTYPES ); if DOTYPE(j) is .TRUE., then matrix type "j"
 will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.
 (3)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.
 (4)  Same as (3), but multiplied by the underflow-threshold / ULP.
 (5)  Same as (3), but multiplied by the overflow-threshold * ULP.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of matrix sizes (M,N) contained in the vectors
          MM and NN.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MM</td><td><pre class="fragment">          MM is INTEGER array, dimension (NSIZES)
          The values of the matrix row dimension M.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          The values of the matrix column dimension N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRVBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095; if not they will be
          reduced mod 4096.  Also, ISEED(4) must be odd.
          On exit, ISEED is changed and can be used in the next call to
          DDRVBD to continue the same random number sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT &gt;= THRESH.  The test
          ratios are scaled to be O(1), so THRESH should be a small
          multiple of 1, e.g., 10 or 100.  To have every test ratio
          printed, use THRESH = 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,NMAX)
          where NMAX is the maximum value of N in NN.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,MMAX),
          where MMAX is the maximum value of M in MM.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU,MMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U.  LDU &gt;= max(1,MMAX).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VT</td><td><pre class="fragment">          VT is DOUBLE PRECISION array, dimension (LDVT,NMAX)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVT</td><td><pre class="fragment">          LDVT is INTEGER
          The leading dimension of the array VT.  LDVT &gt;= max(1,NMAX).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ASAV</td><td><pre class="fragment">          ASAV is DOUBLE PRECISION array, dimension (LDA,NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">USAV</td><td><pre class="fragment">          USAV is DOUBLE PRECISION array, dimension (LDU,MMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VTSAV</td><td><pre class="fragment">          VTSAV is DOUBLE PRECISION array, dimension (LDVT,NMAX)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension
                      (max(min(MM,NN)))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SSAV</td><td><pre class="fragment">          SSAV is DOUBLE PRECISION array, dimension
                      (max(min(MM,NN)))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension
                      (max(min(MM,NN)))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(3*MN+MX,5*MN-4)+2*MN**2 for all pairs
          pairs  (MN,MX)=( min(MM(j),NN(j), max(MM(j),NN(j)) )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension at least 8*min(M,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUT</td><td><pre class="fragment">          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some MM(j) &lt; 0
           -3: Some NN(j) &lt; 0
           -4: NTYPES &lt; 0
           -7: THRESH &lt; 0
          -10: LDA &lt; 1 or LDA &lt; MMAX, where MMAX is max( MM(j) ).
          -12: LDU &lt; 1 or LDU &lt; MMAX.
          -14: LDVT &lt; 1 or LDVT &lt; NMAX, where NMAX is max( NN(j) ).
          -21: LWORK too small.
          If  DLATMS, or DGESVD returns an error code, the
              absolute value of it is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ffc2a465b9b10ab80fc13e6197d0dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrves </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>HT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 13 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVES</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DDRVES checks the nonsymmetric eigenvalue (Schur form) problem
    driver DGEES.

    When DDRVES is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 13
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRVES does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRVES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRVES to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max(NN).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by DGEES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HT</td><td><pre class="fragment">          HT is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by DGEES.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION array, dimension (max(NN))

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WRT</td><td><pre class="fragment">          WRT is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WIT</td><td><pre class="fragment">          WIT is DOUBLE PRECISION array, dimension (max(NN))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when DGEES only computes a partial
          eigendecomposition, i.e. not Schur vectors</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS</td><td><pre class="fragment">          VS is DOUBLE PRECISION array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVS</td><td><pre class="fragment">          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (13)
          The values computed by the 13 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (NWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWORK</td><td><pre class="fragment">          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -6: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -17: LDVS &lt; 1 or LDVS &lt; NMAX, where NMAX is max( NN(j) ).
          -20: NWORK too small.
          If  DLATMR, SLATMS, SLATME or DGEES returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga11aeae4727a8a3236db6a56d3ca220c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrvev </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldlre, * )&#160;</td>
          <td class="paramname"><em>LRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDLRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 7 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVEV</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DDRVEV  checks the nonsymmetric eigenvalue problem driver DGEEV.

    When DDRVEV is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 7
    tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a block diagonal matrix, with a 1x1 block for each
      real eigenvalue and a 2x2 block for each complex conjugate
      pair.  If eigenvalues j and j+1 are a complex conjugate pair,
      so WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the
      2 x 2 block corresponding to the pair will be:

              (  wr  wi  )
              ( -wi  wr  )

      Such a block multiplying an n x 2 matrix  ( ur ui ) on the
      right will be the same as multiplying  ur + i*ui  by  wr + i*wi.

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when both VR and VL
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and VR, or only W and VL are
      computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when both VR
      and VL are computed, and VR(partial) denotes the result
      when only VR is computed.

     (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when both VR
      and VL are also computed, and VL(partial) denotes the result
      when only VL is computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRVEV does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRVEV
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRVEV to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max(NN).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by DGEEV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION array, dimension (max(NN))

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR1</td><td><pre class="fragment">          WR1 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI1</td><td><pre class="fragment">          WI1 is DOUBLE PRECISION array, dimension (max(NN))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when DGEEV only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension (LDVL, max(NN))
          VL holds the computed left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is DOUBLE PRECISION array, dimension (LDVR, max(NN))
          VR holds the computed right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LRE</td><td><pre class="fragment">          LRE is DOUBLE PRECISION array, dimension (LDLRE,max(NN))
          LRE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDLRE</td><td><pre class="fragment">          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (7)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (NWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWORK</td><td><pre class="fragment">          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -6: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -16: LDVL &lt; 1 or LDVL &lt; NMAX, where NMAX is max( NN(j) ).
          -18: LDVR &lt; 1 or LDVR &lt; NMAX, where NMAX is max( NN(j) ).
          -20: LDLRE &lt; 1 or LDLRE &lt; NMAX, where NMAX is max( NN(j) ).
          -23: NWORK too small.
          If  DLATMR, SLATMS, SLATME or DGEEV returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf88edcce9dcbf23eda454e31d1b422db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrvgg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRSHN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHR2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVGG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DDRVGG  checks the nonsymmetric generalized eigenvalue driver
 routines.
                               T          T        T
 DGEGS factors A and B as Q S Z  and Q T Z , where   means
 transpose, T is upper triangular, S is in generalized Schur form
 (block upper triangular, with 1x1 and 2x2 blocks on the diagonal,
 the 2x2 blocks corresponding to complex conjugate pairs of
 generalized eigenvalues), and Q and Z are orthogonal.  It also
 computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), where alpha(j)=S(j,j) and beta(j)=P(j,j) --
 thus, w(j) = alpha(j)/beta(j) is a root of the generalized
 eigenvalue problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 DGEGV computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), the matrix L whose columns contain the
 generalized left eigenvectors l, and the matrix R whose columns
 contain the generalized right eigenvectors r for the pair (A,B).

 When DDRVGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 7
 tests will be performed and compared with the threshhold THRESH:

 Results from DGEGS:

                  T
 (1)   | A - Q S Z  | / ( |A| n ulp )

                  T
 (2)   | B - Q T Z  | / ( |B| n ulp )

               T
 (3)   | I - QQ  | / ( n ulp )

               T
 (4)   | I - ZZ  | / ( n ulp )

 (5)   maximum over j of D(j)  where:

 if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

 if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

           and S and T are here the 2 x 2 diagonal blocks of S and T
           corresponding to the j-th eigenvalue.

 Results from DGEGV:

 (6)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

       where l**H is the conjugate tranpose of l.

 (7)   max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRVGG does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRVGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRVGG to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRSHN</td><td><pre class="fragment">          THRSHN is DOUBLE PRECISION
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension
                            (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, B, S, T, S2, and T2.
          It must be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension
                            (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by DGEGS.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by DGEGS.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S2</td><td><pre class="fragment">          S2 is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The matrix computed from A by DGEGV.  This will be the
          Schur form of some matrix related to A, but will not, in
          general, be the same as S.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T2</td><td><pre class="fragment">          T2 is DOUBLE PRECISION array, dimension (LDA, max(NN))
          The matrix computed from B by DGEGV.  This will be the
          Schur form of some matrix related to B, but will not, in
          general, be the same as T.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDQ, max(NN))
          The (left) orthogonal matrix computed by DGEGS.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of Q, Z, VL, and VR.  It must
          be at least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array of
                             dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by DGEGS.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHR1</td><td><pre class="fragment">          ALPHR1 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHI1</td><td><pre class="fragment">          ALPHI1 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA1</td><td><pre class="fragment">          BETA1 is DOUBLE PRECISION array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by DGEGS.
          ( ALPHR1(k)+ALPHI1(k)*i ) / BETA1(k) is the k-th
          generalized eigenvalue of the matrices in A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHR2</td><td><pre class="fragment">          ALPHR2 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHI2</td><td><pre class="fragment">          ALPHI2 is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA2</td><td><pre class="fragment">          BETA2 is DOUBLE PRECISION array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by DGEGV.
          ( ALPHR2(k)+ALPHI2(k)*i ) / BETA2(k) is the k-th
          generalized eigenvalue of the matrices in A and B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension (LDQ, max(NN))
          The (block lower triangular) left eigenvector matrix for
          the matrices in A and B.  (See DTGEVC for the format.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is DOUBLE PRECISION array, dimension (LDQ, max(NN))
          The (block upper triangular) right eigenvector matrix for
          the matrices in A and B.  (See DTGEVC for the format.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          2*N + MAX( 6*N, N*(NB+1), (k+1)*(2*k+N+1) ), where
          "k" is the sum of the blocksize and number-of-shifts for
          DHGEQZ, and NB is the greatest of the blocksizes for
          DGEQRF, DORMQR, and DORGQR.  (The blocksizes and the
          number-of-shifts are retrieved through calls to ILAENV.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          &gt; 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gac58eaea06da0e219700ba96536201242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrvsg </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVSG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      DDRVSG checks the real symmetric generalized eigenproblem
      drivers.

              DSYGV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem.

              DSYGVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem using a divide and conquer algorithm.

              DSYGVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem.

              DSPGV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem in packed storage.

              DSPGVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem in packed storage using a divide and
              conquer algorithm.

              DSPGVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem in packed storage.

              DSBGV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite banded
              generalized eigenproblem.

              DSBGVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite banded
              generalized eigenproblem using a divide and conquer
              algorithm.

              DSBGVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite banded
              generalized eigenproblem.

      When DDRVSG is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix A of the given type will be
      generated; a random well-conditioned matrix B is also generated
      and the pair (A,B) is used to test the drivers.

      For each pair (A,B), the following tests are performed:

      (1) DSYGV with ITYPE = 1 and UPLO ='U':

              | A Z - B Z D | / ( |A| |Z| n ulp )

      (2) as (1) but calling DSPGV
      (3) as (1) but calling DSBGV
      (4) as (1) but with UPLO = 'L'
      (5) as (4) but calling DSPGV
      (6) as (4) but calling DSBGV

      (7) DSYGV with ITYPE = 2 and UPLO ='U':

              | A B Z - Z D | / ( |A| |Z| n ulp )

      (8) as (7) but calling DSPGV
      (9) as (7) but with UPLO = 'L'
      (10) as (9) but calling DSPGV

      (11) DSYGV with ITYPE = 3 and UPLO ='U':

              | B A Z - Z D | / ( |A| |Z| n ulp )

      (12) as (11) but calling DSPGV
      (13) as (11) but with UPLO = 'L'
      (14) as (13) but calling DSPGV

      DSYGVD, DSPGVD and DSBGVD performed the same 14 tests.

      DSYGVX, DSPGVX and DSBGVX performed the above 14 tests with
      the parameter RANGE = 'A', 'N' and 'I', respectively.

      The "sizes" are specified by an array NN(1:NSIZES); the value
      of each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      This type is used for the matrix A which has half-bandwidth KA.
      B is generated as a well-conditioned positive definite matrix
      with half-bandwidth KB (&lt;= KA).
      Currently, the list of possible types for A is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced entries
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced entries
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" entries
           1, ULP, ..., ULP and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U* D U, where U is orthogonal and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U* D U, where U is orthogonal and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U* D U, where U is orthogonal and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) symmetric matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold)

      (16) Same as (8), but with KA = 1 and KB = 1
      (17) Same as (8), but with KA = 2 and KB = 1
      (18) Same as (8), but with KA = 2 and KB = 2
      (19) Same as (8), but with KA = 3 and KB = 1
      (20) Same as (8), but with KA = 3 and KB = 2
      (21) Same as (8), but with KA = 3 and KB = 3</pre> <pre class="fragment">  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRVSG does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRVSG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRVSG to continue the same random number
          sequence.
          Modified.

  THRESH  DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       DOUBLE PRECISION array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A and AB.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  B       DOUBLE PRECISION array, dimension (LDB , max(NN))
          Used to hold the symmetric positive definite matrix for
          the generailzed problem.
          On exit, B contains the last matrix actually
          used.
          Modified.

  LDB     INTEGER
          The leading dimension of B and BB.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D       DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A. On exit, the eigenvalues in D
          correspond with the matrix in A.
          Modified.

  Z       DOUBLE PRECISION array, dimension (LDZ, max(NN))
          The matrix of eigenvectors.
          Modified.

  LDZ     INTEGER
          The leading dimension of Z.  It must be at least 1 and
          at least max( NN ).
          Not modified.

  AB      DOUBLE PRECISION array, dimension (LDA, max(NN))
          Workspace.
          Modified.

  BB      DOUBLE PRECISION array, dimension (LDB, max(NN))
          Workspace.
          Modified.

  AP      DOUBLE PRECISION array, dimension (max(NN)**2)
          Workspace.
          Modified.

  BP      DOUBLE PRECISION array, dimension (max(NN)**2)
          Workspace.
          Modified.

  WORK    DOUBLE PRECISION array, dimension (NWORK)
          Workspace.
          Modified.

  NWORK   INTEGER
          The number of entries in WORK.  This must be at least
          1+5*N+2*N*lg(N)+3*N**2 where N = max( NN(j) ) and
          lg( N ) = smallest integer k such that 2**k &gt;= N.
          Not modified.

  IWORK   INTEGER array, dimension (LIWORK)
          Workspace.
          Modified.

  LIWORK  INTEGER
          The number of entries in WORK.  This must be at least 6*N.
          Not modified.

  RESULT  DOUBLE PRECISION array, dimension (70)
          The values computed by the 70 tests described above.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -5: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -16: LDZ &lt; 1 or LDZ &lt; NMAX.
          -21: NWORK too small.
          -23: LIWORK too small.
          If  DLATMR, SLATMS, DSYGV, DSPGV, DSBGV, SSYGVD, SSPGVD,
              DSBGVD, DSYGVX, DSPGVX or SSBGVX returns an error code,
              the absolute value of it is returned.
          Modified.

 ----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests that have been run
                       on this matrix.
       NTESTT          The total number of tests for this call.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by DLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga47fc55396c12e72375ade9b3b3fefc79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrvst </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>EVEIGS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WA1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WA3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LIWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVST</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      DDRVST  checks the symmetric eigenvalue problem drivers.

              DSTEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric tridiagonal matrix.

              DSTEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric tridiagonal matrix.

              DSTEVR computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric tridiagonal matrix
              using the Relatively Robust Representation where it can.

              DSYEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix.

              DSYEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix.

              DSYEVR computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix
              using the Relatively Robust Representation where it can.

              DSPEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix in packed
              storage.

              DSPEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix in packed
              storage.

              DSBEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric band matrix.

              DSBEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric band matrix.

              DSYEVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix using
              a divide and conquer algorithm.

              DSPEVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix in packed
              storage, using a divide and conquer algorithm.

              DSBEVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric band matrix,
              using a divide and conquer algorithm.

      When DDRVST is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix will be generated and used
      to test the appropriate drivers.  For each matrix and each
      driver routine called, the following tests will be performed:

      (1)     | A - Z D Z' | / ( |A| n ulp )

      (2)     | I - Z Z' | / ( n ulp )

      (3)     | D1 - D2 | / ( |D1| ulp )

      where Z is the matrix of eigenvectors returned when the
      eigenvector option is given and D1 and D2 are the eigenvalues
      returned with and without the eigenvector option.

      The "sizes" are specified by an array NN(1:NSIZES); the value of
      each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      Currently, the list of possible types is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced eigenvalues
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced eigenvalues
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" eigenvalues
           1, ULP, ..., ULP and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U' D U, where U is orthogonal and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U' D U, where U is orthogonal and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U' D U, where U is orthogonal and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) Symmetric matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold )
      (16) A band matrix with half bandwidth randomly chosen between
           0 and N-1, with evenly spaced eigenvalues 1, ..., ULP
           with random signs.
      (17) Same as (16), but multiplied by SQRT( overflow threshold )
      (18) Same as (16), but multiplied by SQRT( underflow threshold )</pre> <pre class="fragment">  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          DDRVST does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, DDRVST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRVST to continue the same random number
          sequence.
          Modified.

  THRESH  DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       DOUBLE PRECISION array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D1      DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A, as computed by DSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.
          Modified.

  D2      DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A, as computed by DSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.
          Modified.

  D3      DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues of A, as computed by DSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.
          Modified.

  D4      DOUBLE PRECISION array, dimension

  EVEIGS  DOUBLE PRECISION array, dimension (max(NN))
          The eigenvalues as computed by DSTEV('N', ... )
          (I reserve the right to change this to the output of
          whichever algorithm computes the most accurate eigenvalues).

  WA1     DOUBLE PRECISION array, dimension

  WA2     DOUBLE PRECISION array, dimension

  WA3     DOUBLE PRECISION array, dimension

  U       DOUBLE PRECISION array, dimension (LDU, max(NN))
          The orthogonal matrix computed by DSYTRD + DORGTR.
          Modified.

  LDU     INTEGER
          The leading dimension of U, Z, and V.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  V       DOUBLE PRECISION array, dimension (LDU, max(NN))
          The Housholder vectors computed by DSYTRD in reducing A to
          tridiagonal form.
          Modified.

  TAU     DOUBLE PRECISION array, dimension (max(NN))
          The Householder factors computed by DSYTRD in reducing A
          to tridiagonal form.
          Modified.

  Z       DOUBLE PRECISION array, dimension (LDU, max(NN))
          The orthogonal matrix of eigenvectors computed by DSTEQR,
          DPTEQR, and DSTEIN.
          Modified.

  WORK    DOUBLE PRECISION array, dimension (LWORK)
          Workspace.
          Modified.

  LWORK   INTEGER
          The number of entries in WORK.  This must be at least
          1 + 4 * Nmax + 2 * Nmax * lg Nmax + 4 * Nmax**2
          where Nmax = max( NN(j), 2 ) and lg = log base 2.
          Not modified.

  IWORK   INTEGER array,
             dimension (6 + 6*Nmax + 5 * Nmax * lg Nmax )
          where Nmax = max( NN(j), 2 ) and lg = log base 2.
          Workspace.
          Modified.

  RESULT  DOUBLE PRECISION array, dimension (105)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES &lt; 0
           -2: Some NN(j) &lt; 0
           -3: NTYPES &lt; 0
           -5: THRESH &lt; 0
           -9: LDA &lt; 1 or LDA &lt; NMAX, where NMAX is max( NN(j) ).
          -16: LDU &lt; 1 or LDU &lt; NMAX.
          -21: LWORK too small.
          If  DLATMR, DLATMS, DSYTRD, DORGTR, DSTEQR, DSTERF,
              or DORMTR returns an error code, the
              absolute value of it is returned.
          Modified.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by DLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )

     The tests performed are:                 Routine tested
    1= | A - U S U' | / ( |A| n ulp )         DSTEV('V', ... )
    2= | I - U U' | / ( n ulp )               DSTEV('V', ... )
    3= |D(with Z) - D(w/o Z)| / (|D| ulp)     DSTEV('N', ... )
    4= | A - U S U' | / ( |A| n ulp )         DSTEVX('V','A', ... )
    5= | I - U U' | / ( n ulp )               DSTEVX('V','A', ... )
    6= |D(with Z) - EVEIGS| / (|D| ulp)       DSTEVX('N','A', ... )
    7= | A - U S U' | / ( |A| n ulp )         DSTEVR('V','A', ... )
    8= | I - U U' | / ( n ulp )               DSTEVR('V','A', ... )
    9= |D(with Z) - EVEIGS| / (|D| ulp)       DSTEVR('N','A', ... )
    10= | A - U S U' | / ( |A| n ulp )        DSTEVX('V','I', ... )
    11= | I - U U' | / ( n ulp )              DSTEVX('V','I', ... )
    12= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSTEVX('N','I', ... )
    13= | A - U S U' | / ( |A| n ulp )        DSTEVX('V','V', ... )
    14= | I - U U' | / ( n ulp )              DSTEVX('V','V', ... )
    15= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSTEVX('N','V', ... )
    16= | A - U S U' | / ( |A| n ulp )        DSTEVD('V', ... )
    17= | I - U U' | / ( n ulp )              DSTEVD('V', ... )
    18= |D(with Z) - EVEIGS| / (|D| ulp)      DSTEVD('N', ... )
    19= | A - U S U' | / ( |A| n ulp )        DSTEVR('V','I', ... )
    20= | I - U U' | / ( n ulp )              DSTEVR('V','I', ... )
    21= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSTEVR('N','I', ... )
    22= | A - U S U' | / ( |A| n ulp )        DSTEVR('V','V', ... )
    23= | I - U U' | / ( n ulp )              DSTEVR('V','V', ... )
    24= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSTEVR('N','V', ... )

    25= | A - U S U' | / ( |A| n ulp )        DSYEV('L','V', ... )
    26= | I - U U' | / ( n ulp )              DSYEV('L','V', ... )
    27= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEV('L','N', ... )
    28= | A - U S U' | / ( |A| n ulp )        DSYEVX('L','V','A', ... )
    29= | I - U U' | / ( n ulp )              DSYEVX('L','V','A', ... )
    30= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEVX('L','N','A', ... )
    31= | A - U S U' | / ( |A| n ulp )        DSYEVX('L','V','I', ... )
    32= | I - U U' | / ( n ulp )              DSYEVX('L','V','I', ... )
    33= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEVX('L','N','I', ... )
    34= | A - U S U' | / ( |A| n ulp )        DSYEVX('L','V','V', ... )
    35= | I - U U' | / ( n ulp )              DSYEVX('L','V','V', ... )
    36= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEVX('L','N','V', ... )
    37= | A - U S U' | / ( |A| n ulp )        DSPEV('L','V', ... )
    38= | I - U U' | / ( n ulp )              DSPEV('L','V', ... )
    39= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEV('L','N', ... )
    40= | A - U S U' | / ( |A| n ulp )        DSPEVX('L','V','A', ... )
    41= | I - U U' | / ( n ulp )              DSPEVX('L','V','A', ... )
    42= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEVX('L','N','A', ... )
    43= | A - U S U' | / ( |A| n ulp )        DSPEVX('L','V','I', ... )
    44= | I - U U' | / ( n ulp )              DSPEVX('L','V','I', ... )
    45= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEVX('L','N','I', ... )
    46= | A - U S U' | / ( |A| n ulp )        DSPEVX('L','V','V', ... )
    47= | I - U U' | / ( n ulp )              DSPEVX('L','V','V', ... )
    48= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEVX('L','N','V', ... )
    49= | A - U S U' | / ( |A| n ulp )        DSBEV('L','V', ... )
    50= | I - U U' | / ( n ulp )              DSBEV('L','V', ... )
    51= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEV('L','N', ... )
    52= | A - U S U' | / ( |A| n ulp )        DSBEVX('L','V','A', ... )
    53= | I - U U' | / ( n ulp )              DSBEVX('L','V','A', ... )
    54= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEVX('L','N','A', ... )
    55= | A - U S U' | / ( |A| n ulp )        DSBEVX('L','V','I', ... )
    56= | I - U U' | / ( n ulp )              DSBEVX('L','V','I', ... )
    57= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEVX('L','N','I', ... )
    58= | A - U S U' | / ( |A| n ulp )        DSBEVX('L','V','V', ... )
    59= | I - U U' | / ( n ulp )              DSBEVX('L','V','V', ... )
    60= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEVX('L','N','V', ... )
    61= | A - U S U' | / ( |A| n ulp )        DSYEVD('L','V', ... )
    62= | I - U U' | / ( n ulp )              DSYEVD('L','V', ... )
    63= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEVD('L','N', ... )
    64= | A - U S U' | / ( |A| n ulp )        DSPEVD('L','V', ... )
    65= | I - U U' | / ( n ulp )              DSPEVD('L','V', ... )
    66= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEVD('L','N', ... )
    67= | A - U S U' | / ( |A| n ulp )        DSBEVD('L','V', ... )
    68= | I - U U' | / ( n ulp )              DSBEVD('L','V', ... )
    69= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEVD('L','N', ... )
    70= | A - U S U' | / ( |A| n ulp )        DSYEVR('L','V','A', ... )
    71= | I - U U' | / ( n ulp )              DSYEVR('L','V','A', ... )
    72= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEVR('L','N','A', ... )
    73= | A - U S U' | / ( |A| n ulp )        DSYEVR('L','V','I', ... )
    74= | I - U U' | / ( n ulp )              DSYEVR('L','V','I', ... )
    75= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEVR('L','N','I', ... )
    76= | A - U S U' | / ( |A| n ulp )        DSYEVR('L','V','V', ... )
    77= | I - U U' | / ( n ulp )              DSYEVR('L','V','V', ... )
    78= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSYEVR('L','N','V', ... )

    Tests 25 through 78 are repeated (as tests 79 through 132)
    with UPLO='U'

    To be added in 1999

    79= | A - U S U' | / ( |A| n ulp )        DSPEVR('L','V','A', ... )
    80= | I - U U' | / ( n ulp )              DSPEVR('L','V','A', ... )
    81= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEVR('L','N','A', ... )
    82= | A - U S U' | / ( |A| n ulp )        DSPEVR('L','V','I', ... )
    83= | I - U U' | / ( n ulp )              DSPEVR('L','V','I', ... )
    84= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEVR('L','N','I', ... )
    85= | A - U S U' | / ( |A| n ulp )        DSPEVR('L','V','V', ... )
    86= | I - U U' | / ( n ulp )              DSPEVR('L','V','V', ... )
    87= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSPEVR('L','N','V', ... )
    88= | A - U S U' | / ( |A| n ulp )        DSBEVR('L','V','A', ... )
    89= | I - U U' | / ( n ulp )              DSBEVR('L','V','A', ... )
    90= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEVR('L','N','A', ... )
    91= | A - U S U' | / ( |A| n ulp )        DSBEVR('L','V','I', ... )
    92= | I - U U' | / ( n ulp )              DSBEVR('L','V','I', ... )
    93= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEVR('L','N','I', ... )
    94= | A - U S U' | / ( |A| n ulp )        DSBEVR('L','V','V', ... )
    95= | I - U U' | / ( n ulp )              DSBEVR('L','V','V', ... )
    96= |D(with Z) - D(w/o Z)| / (|D| ulp)    DSBEVR('L','N','V', ... )</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga35b419f2aaa6ac71abbaa387a29e5ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrvsx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>HT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WRTMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WITMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 17 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVSX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DDRVSX checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver DGEESX.

    DDRVSX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When DDRVSX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 15
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare WR, WI with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalue
    average and right invariant subspace. For these matrices, in
    addition to tests (1) to (15) we will compute the following two
    tests:

   (16)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal average eigenvalue condition number
      computed by DGEESX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.

   (17)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right invariant subspace condition
      number computed by DGEESX and RCDVIN (the precomputed true
      value) is supplied as input. cond(RCONDV) is the condition
      number of RCONDV, and takes errors in computing RCONDV into
      account, so that the resulting quantity should be O(ULP).
      cond(RCONDV) is essentially given by norm(A)/RCONDE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRVSX to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIUNIT</td><td><pre class="fragment">          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by DGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HT</td><td><pre class="fragment">          HT is DOUBLE PRECISION array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by DGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION array, dimension (max(NN))

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WRT</td><td><pre class="fragment">          WRT is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WIT</td><td><pre class="fragment">          WIT is DOUBLE PRECISION array, dimension (max(NN))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when DGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WRTMP</td><td><pre class="fragment">          WRTMP is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WITMP</td><td><pre class="fragment">          WITMP is DOUBLE PRECISION array, dimension (max(NN))

          More temporary storage for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS</td><td><pre class="fragment">          VS is DOUBLE PRECISION array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVS</td><td><pre class="fragment">          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS1</td><td><pre class="fragment">          VS1 is DOUBLE PRECISION array, dimension (LDVS, max(NN))
          VS1 holds another copy of the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(3*NN(j),2*NN(j)**2) for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (max(NN)*max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  successful exit.
            &lt;0,  input parameter -INFO is incorrect
            &gt;0,  DLATMR, SLATMS, SLATME or DGET24 returned an error
                 code and INFO is its absolute value

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------
     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.
             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4db8108d75a2a49d865e766418fa0726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine ddrvvx </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSIZES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>NN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTYPES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DOTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldlre, * )&#160;</td>
          <td class="paramname"><em>LRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDLRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDVIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDEIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 11 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DDRVVX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DDRVVX  checks the nonsymmetric eigenvalue problem expert driver
    DGEEVX.

    DDRVVX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When DDRVVX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified in the calling sequence.
    For each size ("n") and each type of matrix, one matrix will be
    generated and used to test the nonsymmetric eigenroutines.  For
    each matrix, 9 tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a block diagonal matrix, with a 1x1 block for each
      real eigenvalue and a 2x2 block for each complex conjugate
      pair.  If eigenvalues j and j+1 are a complex conjugate pair,
      so WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the
      2 x 2 block corresponding to the pair will be:

              (  wr  wi  )
              ( -wi  wr  )

      Such a block multiplying an n x 2 matrix  ( ur ui ) on the
      right will be the same as multiplying  ur + i*ui  by  wr + i*wi.

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     RCONDV(full) = RCONDV(partial)

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalues
    and right eigenvectors. For these matrices, in addition to tests
    (1) to (9) we will compute the following two tests:

   (10)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by DGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by DGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NSIZES</td><td><pre class="fragment">          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NN</td><td><pre class="fragment">          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NTYPES</td><td><pre class="fragment">          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DOTYPE</td><td><pre class="fragment">          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to DDRVVX to continue the same random number
          sequence.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIUNIT</td><td><pre class="fragment">          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension
                      (LDA, max(NN,12))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A and H.
          LDA &gt;= max(NN,12), since 12 is the dimension of the largest
          matrix in the precomputed input file.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension
                      (LDA, max(NN,12))
          Another copy of the test matrix A, modified by DGEEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array, dimension (max(NN))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION array, dimension (max(NN))

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR1</td><td><pre class="fragment">          WR1 is DOUBLE PRECISION array, dimension (max(NN,12))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI1</td><td><pre class="fragment">          WI1 is DOUBLE PRECISION array, dimension (max(NN,12))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when DGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension
                      (LDVL, max(NN,12))
          VL holds the computed left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN,12)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is DOUBLE PRECISION array, dimension
                      (LDVR, max(NN,12))
          VR holds the computed right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN,12)).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LRE</td><td><pre class="fragment">          LRE is DOUBLE PRECISION array, dimension
                      (LDLRE, max(NN,12))
          LRE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDLRE</td><td><pre class="fragment">          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN,12))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDV</td><td><pre class="fragment">          RCONDV is DOUBLE PRECISION array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDV1</td><td><pre class="fragment">          RCNDV1 is DOUBLE PRECISION array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCDVIN</td><td><pre class="fragment">          RCDVIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDE</td><td><pre class="fragment">          RCONDE is DOUBLE PRECISION array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDE1</td><td><pre class="fragment">          RCNDE1 is DOUBLE PRECISION array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCDEIN</td><td><pre class="fragment">          RCDEIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE1</td><td><pre class="fragment">          SCALE1 is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (11)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (NWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NWORK</td><td><pre class="fragment">          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(6*12+2*12**2,6*NN(j)+2*NN(j)**2) =
          max(    360     ,6*NN(j)+2*NN(j)**2)    for all j.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (2*max(NN,12))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  then successful exit.
          If &lt;0, then input paramter -INFO is incorrect.
          If &gt;0, DLATMR, SLATMS, SLATME or DGET23 returned an error
                 code, and INFO is its absolute value.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN or 12.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gad5e18a852c76f0b059ad31c83f06b8cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine derrbd </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DERRBD</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DERRBD tests the error exits for DGEBRD, DORGBR, DORMBR, DBDSQR and
 DBDSDC.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5320e38d676febaa986dd34106f0bb2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine derrec </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DERREC</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DERREC tests the error exits for the routines for eigen- condition
 estimation for DOUBLE PRECISION matrices:
    DTRSYL, STREXC, STRSNA and STRSEN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gae397fe859a9ec662321082f76fb08b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine derred </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DERRED</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DERRED tests the error exits for the eigenvalue driver routines for
 DOUBLE PRECISION matrices:

 PATH  driver   description
 ----  ------   -----------
 SEV   DGEEV    find eigenvalues/eigenvectors for nonsymmetric A
 SES   DGEES    find eigenvalues/Schur form for nonsymmetric A
 SVX   DGEEVX   SGEEV + balancing and condition estimation
 SSX   DGEESX   SGEES + balancing and condition estimation
 DBD   DGESVD   compute SVD of an M-by-N matrix A
       DGESDD   compute SVD of an M-by-N matrix A (by divide and
                conquer)
       DGEJSV   compute SVD of an M-by-N matrix A where M &gt;= N</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab1d9ace812b32d503ff8f053720136c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine derrgg </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DERRGG</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DERRGG tests the error exits for DGGES, DGGESX, DGGEV, DGGEVX,
 DGGGLM, DGGHRD, DGGLSE, DGGQRF, DGGRQF, DGGSVD, DGGSVP, DHGEQZ,
 DORCSD, DTGEVC, DTGEXC, DTGSEN, DTGSJA, DTGSNA, and DTGSYL.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab764b80cbc14db00eaf61ea4d9b81b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine derrhs </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DERRHS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DERRHS tests the error exits for DGEBAK, SGEBAL, SGEHRD, DORGHR,
 DORMHR, DHSEQR, SHSEIN, and DTREVC.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gae21a3e291e9a00ac64068628a398361f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine derrst </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUNIT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DERRST</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DERRST tests the error exits for DSYTRD, DORGTR, DORMTR, DSPTRD,
 DOPGTR, DOPMTR, DSTEQR, SSTERF, SSTEBZ, SSTEIN, DPTEQR, DSBTRD,
 DSYEV, SSYEVX, SSYEVD, DSBEV, SSBEVX, SSBEVD,
 DSPEV, SSPEVX, SSPEVD, DSTEV, SSTEVX, SSTEVD, and SSTEDC.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NUNIT</td><td><pre class="fragment">          NUNIT is INTEGER
          The unit number for output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaed33a09e8bc0c43d32c67f83e1673630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget02 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET02</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET02 computes the residual for a solution of a system of linear
 equations  A*x = b  or  A'*x = b:
    RESID = norm(B - A*X) / ( norm(A) * norm(X) * EPS ),
 where EPS is the machine epsilon.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANS</td><td><pre class="fragment">          TRANS is CHARACTER*1
          Specifies the form of the system of equations:
          = 'N':  A *x = b
          = 'T':  A'*x = b, where A' is the transpose of A
          = 'C':  A'*x = b, where A' is the transpose of A</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of columns of B, the matrix of right hand sides.
          NRHS &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The original M x N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension (LDX,NRHS)
          The computed solution vectors for the system of linear
          equations.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX &gt;= max(1,N); if TRANS = 'T' or 'C', LDX &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,NRHS)
          On entry, the right hand side vectors for the system of
          linear equations.
          On exit, B is overwritten with the difference B - A*X.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  IF TRANS = 'N',
          LDB &gt;= max(1,M); if TRANS = 'T' or 'C', LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is DOUBLE PRECISION
          The maximum over the number of right hand sides of
          norm(B - A*X) / ( norm(A) * norm(X) * EPS ).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gafb713f19d6762f47a227399fcfdf6f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget10 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET10</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET10 compares two matrices A and B and computes the ratio
 RESULT = norm( A - B ) / ( norm(A) * M * EPS )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrices A and B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The m by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,N)
          The m by n matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION
          RESULT = norm( A - B ) / ( norm(A) * M * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga585a3526e86563a9452e9243c23ad31b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget22 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANSE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANSW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( <a class="el" href="dblat3_8f.html#a6fd3ddbe863b9e8e6e79ebf9c8594174">lde</a>, * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET22</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET22 does an eigenvector check.

 The basic test is:

    RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )

 using the 1-norm.  It also tests the normalization of E:

    RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )
                 j

 where E(j) is the j-th eigenvector, and m-norm is the max-norm of a
 vector.  If an eigenvector is complex, as determined from WI(j)
 nonzero, then the max-norm of the vector ( er + i*ei ) is the maximum
 of
    |er(1)| + |ei(1)|, ... , |er(n)| + |ei(n)|

 W is a block diagonal matrix, with a 1 by 1 block for each real
 eigenvalue and a 2 by 2 block for each complex conjugate pair.
 If eigenvalues j and j+1 are a complex conjugate pair, so that
 WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the 2 by 2
 block corresponding to the pair will be:

    (  wr  wi  )
    ( -wi  wr  )

 Such a block multiplying an n by 2 matrix ( ur ui ) on the right
 will be the same as multiplying  ur + i*ui  by  wr + i*wi.

 To handle various schemes for storage of left eigenvectors, there are
 options to use A-transpose instead of A, E-transpose instead of E,
 and/or W-transpose instead of W.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANSA</td><td><pre class="fragment">          TRANSA is CHARACTER*1
          Specifies whether or not A is transposed.
          = 'N':  No transpose
          = 'T':  Transpose
          = 'C':  Conjugate transpose (= Transpose)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANSE</td><td><pre class="fragment">          TRANSE is CHARACTER*1
          Specifies whether or not E is transposed.
          = 'N':  No transpose, eigenvectors are in columns of E
          = 'T':  Transpose, eigenvectors are in rows of E
          = 'C':  Conjugate transpose (= Transpose)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANSW</td><td><pre class="fragment">          TRANSW is CHARACTER*1
          Specifies whether or not W is transposed.
          = 'N':  No transpose
          = 'T':  Transpose, use -WI(j) instead of WI(j)
          = 'C':  Conjugate transpose, use -WI(j) instead of WI(j)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The matrix whose eigenvectors are in E.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (LDE,N)
          The matrix of eigenvectors. If TRANSE = 'N', the eigenvectors
          are stored in the columns of E, if TRANSE = 'T' or 'C', the
          eigenvectors are stored in the rows of E.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDE</td><td><pre class="fragment">          LDE is INTEGER
          The leading dimension of the array E.  LDE &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION array, dimension (N)

          The real and imaginary parts of the eigenvalues of A.
          Purely real eigenvalues are indicated by WI(j) = 0.
          Complex conjugate pairs are indicated by WR(j)=WR(j+1) and
          WI(j) = - WI(j+1) non-zero; the real part is assumed to be
          stored in the j-th row/column and the imaginary part in
          the (j+1)-th row/column.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N*(N+1))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )
          RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa52ccc18dfdd08a5c0af32a0bb689f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget23 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>COMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>BALANC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>JTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldlre, * )&#160;</td>
          <td class="paramname"><em>LRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDLRE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDVIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCNDE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RCDEIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SCALE1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 11 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET23</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DGET23  checks the nonsymmetric eigenvalue problem driver SGEEVX.
    If COMP = .FALSE., the first 8 of the following tests will be
    performed on the input matrix A, and also test 9 if LWORK is
    sufficiently large.
    if COMP is .TRUE. all 11 tests will be performed.

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a block diagonal matrix, with a 1x1 block for each
      real eigenvalue and a 2x2 block for each complex conjugate
      pair.  If eigenvalues j and j+1 are a complex conjugate pair,
      so WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the
      2 x 2 block corresponding to the pair will be:

              (  wr  wi  )
              ( -wi  wr  )

      Such a block multiplying an n x 2 matrix  ( ur ui ) on the
      right will be the same as multiplying  ur + i*ui  by  wr + i*wi.

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     0 if W(full) = W(partial), 1/ulp otherwise

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     0 if VR(full) = VR(partial), 1/ulp otherwise

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     0 if VL(full) = VL(partial), 1/ulp otherwise

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     0 if RCONDV(full) = RCONDV(partial), 1/ulp otherwise

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

   (10)     |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by DGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)     |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by DGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">COMP</td><td><pre class="fragment">          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BALANC</td><td><pre class="fragment">          BALANC is CHARACTER
          Describes the balancing option to be tested.
            = 'N' for no permuting or diagonal scaling
            = 'P' for permuting but no diagonal scaling
            = 'S' for no permuting but diagonal scaling
            = 'B' for permuting and diagonal scaling</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JTYPE</td><td><pre class="fragment">          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of A. N must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          Used to hold the matrix whose eigenvalues are to be
          computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension (LDA,N)
          Another copy of the test matrix A, modified by DGEEVX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION array, dimension (N)

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR1</td><td><pre class="fragment">          WR1 is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI1</td><td><pre class="fragment">          WI1 is DOUBLE PRECISION array, dimension (N)

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when DGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is DOUBLE PRECISION array, dimension (LDVL,N)
          VL holds the computed left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is DOUBLE PRECISION array, dimension (LDVR,N)
          VR holds the computed right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LRE</td><td><pre class="fragment">          LRE is DOUBLE PRECISION array, dimension (LDLRE,N)
          LRE holds the computed right or left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDLRE</td><td><pre class="fragment">          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDV</td><td><pre class="fragment">          RCONDV is DOUBLE PRECISION array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDV1</td><td><pre class="fragment">          RCNDV1 is DOUBLE PRECISION array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDVIN</td><td><pre class="fragment">          RCDVIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDE</td><td><pre class="fragment">          RCONDE is DOUBLE PRECISION array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCNDE1</td><td><pre class="fragment">          RCNDE1 is DOUBLE PRECISION array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDEIN</td><td><pre class="fragment">          RCDEIN is DOUBLE PRECISION array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SCALE1</td><td><pre class="fragment">          SCALE1 is DOUBLE PRECISION array, dimension (N)
          Holds information describing balancing of matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (11)
          The values computed by the 11 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          3*N, and 6*N+N**2 if tests 9, 10 or 11 are to be performed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (2*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  successful exit.
          If &lt;0, input parameter -INFO had an incorrect value.
          If &gt;0, DGEEVX returned an error code, the absolute
                 value of which is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga656556219b63123ac0f9abe66299ec50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget24 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>COMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>JTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>HT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WRT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WRTMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WITMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldvs, * )&#160;</td>
          <td class="paramname"><em>VS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RCDEIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RCDVIN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NSLCT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>ISLCT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 17 )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET24</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DGET24 checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver DGEESX.

    If COMP = .FALSE., the first 13 of the following tests will be
    be performed on the input matrix A, and also tests 14 and 15
    if LWORK is sufficiently large.
    If COMP = .TRUE., all 17 test will be performed.

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare WR, WI with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    (16)  |RCONDE - RCDEIN| / cond(RCONDE)

       RCONDE is the reciprocal average eigenvalue condition number
       computed by DGEESX and RCDEIN (the precomputed true value)
       is supplied as input.  cond(RCONDE) is the condition number
       of RCONDE, and takes errors in computing RCONDE into account,
       so that the resulting quantity should be O(ULP). cond(RCONDE)
       is essentially given by norm(A)/RCONDV.

    (17)  |RCONDV - RCDVIN| / cond(RCONDV)

       RCONDV is the reciprocal right invariant subspace condition
       number computed by DGEESX and RCDVIN (the precomputed true
       value) is supplied as input. cond(RCONDV) is the condition
       number of RCONDV, and takes errors in computing RCONDV into
       account, so that the resulting quantity should be O(ULP).
       cond(RCONDV) is essentially given by norm(A)/RCONDE.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">COMP</td><td><pre class="fragment">          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JTYPE</td><td><pre class="fragment">          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">THRESH</td><td><pre class="fragment">          THRESH is DOUBLE PRECISION
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NOUNIT</td><td><pre class="fragment">          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of A. N must be at least 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          Used to hold the matrix whose eigenvalues are to be
          computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension (LDA, N)
          Another copy of the test matrix A, modified by DGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HT</td><td><pre class="fragment">          HT is DOUBLE PRECISION array, dimension (LDA, N)
          Yet another copy of the test matrix A, modified by DGEESX.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION array, dimension (N)

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WRT</td><td><pre class="fragment">          WRT is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WIT</td><td><pre class="fragment">          WIT is DOUBLE PRECISION array, dimension (N)

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when DGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WRTMP</td><td><pre class="fragment">          WRTMP is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WITMP</td><td><pre class="fragment">          WITMP is DOUBLE PRECISION array, dimension (N)

          Like WR, WI, these arrays contain the eigenvalues of A,
          but sorted by increasing real part.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS</td><td><pre class="fragment">          VS is DOUBLE PRECISION array, dimension (LDVS, N)
          VS holds the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVS</td><td><pre class="fragment">          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1, N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VS1</td><td><pre class="fragment">          VS1 is DOUBLE PRECISION array, dimension (LDVS, N)
          VS1 holds another copy of the computed Schur vectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDEIN</td><td><pre class="fragment">          RCDEIN is DOUBLE PRECISION
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition number for the average of selected eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCDVIN</td><td><pre class="fragment">          RCDVIN is DOUBLE PRECISION
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition number for the selected right invariant subspace.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NSLCT</td><td><pre class="fragment">          NSLCT is INTEGER
          When COMP = .TRUE. the number of selected eigenvalues
          corresponding to the precomputed values RCDEIN and RCDVIN.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISLCT</td><td><pre class="fragment">          ISLCT is INTEGER array, dimension (NSLCT)
          When COMP = .TRUE. ISLCT selects the eigenvalues of the
          input matrix corresponding to the precomputed values RCDEIN
          and RCDVIN. For I=1, ... ,NSLCT, if ISLCT(I) = J, then the
          eigenvalue with the J-th largest real part is selected.
          Not referenced if COMP = .FALSE.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The number of entries in WORK to be passed to DGEESX. This
          must be at least 3*N, and N+N**2 if tests 14--16 are to
          be performed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (N*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          If 0,  successful exit.
          If &lt;0, input parameter -INFO had an incorrect value.
          If &gt;0, DGEESX returned an error code, the absolute
                 value of which is returned.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaec96be19f30761456f6973cfbfe302bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget31 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 2 )&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET31</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET31 tests DLALN2, a routine for solving

    (ca A - w D)X = sB

 where A is an NA by NA matrix (NA=1 or 2 only), w is a real (NW=1) or
 complex (NW=2) constant, ca is a real constant, D is an NA by NA real
 diagonal matrix, and B is an NA by NW matrix (when NW=2 the second
 column of B contains the imaginary part of the solution).  The code
 returns X and s, where s is a scale factor, less than or equal to 1,
 which is chosen to avoid overflow in X.

 If any singular values of ca A-w D are less than another input
 parameter SMIN, they are perturbed up to SMIN.

 The test condition is that the scaled residual

     norm( (ca A-w D)*X - s*B ) /
           ( max( ulp*norm(ca A-w D), SMIN )*norm(X) )

 should be on the order of 1.  Here, ulp is the machine precision.
 Also, it is verified that SCALE is less than or equal to 1, and that
 XNORM = infinity-norm(X).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER array, dimension (3)
          NINFO(1) = number of examples with INFO less than 0
          NINFO(2) = number of examples with INFO greater than 0</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7bb9df80003ec4b42399fac9972fcdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget32 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET32</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET32 tests DLASY2, a routine for solving

         op(TL)*X + ISGN*X*op(TR) = SCALE*B

 where TL is N1 by N1, TR is N2 by N2, and N1,N2 =1 or 2 only.
 X and B are N1 by N2, op() is an optional transpose, an
 ISGN = 1 or -1. SCALE is chosen less than or equal to 1 to
 avoid overflow in X.

 The test condition is that the scaled residual

 norm( op(TL)*X + ISGN*X*op(TR) = SCALE*B )
      / ( max( ulp*norm(TL), ulp*norm(TR)) * norm(X), SMLNUM )

 should be on the order of 1. Here, ulp is the machine precision.
 Also, it is verified that SCALE is less than or equal to 1, and
 that XNORM = infinity-norm(X).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER
          Number of examples returned with INFO.NE.0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d06279a44e3ee4af0c0122fc704857a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget33 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET33</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET33 tests DLANV2, a routine for putting 2 by 2 blocks into
 standard form.  In other words, it computes a two by two rotation
 [[C,S];[-S,C]] where in

    [ C S ][T(1,1) T(1,2)][ C -S ] = [ T11 T12 ]
    [-S C ][T(2,1) T(2,2)][ S  C ]   [ T21 T22 ]

 either
    1) T21=0 (real eigenvalues), or
    2) T11=T22 and T21*T12&lt;0 (complex conjugate eigenvalues).
 We also  verify that the residual is small.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER
          Number of examples returned with INFO .NE. 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gac5920e80cf7499fc8cdb1c71f4e97ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget34 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 2 )&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET34</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET34 tests DLAEXC, a routine for swapping adjacent blocks (either
 1 by 1 or 2 by 2) on the diagonal of a matrix in real Schur form.
 Thus, DLAEXC computes an orthogonal matrix Q such that

     Q' * [ A B ] * Q  = [ C1 B1 ]
          [ 0 C ]        [ 0  A1 ]

 where C1 is similar to C and A1 is similar to A.  Both A and C are
 assumed to be in standard form (equal diagonal entries and
 offdiagonal with differing signs) and A1 and C1 are returned with the
 same properties.

 The test code verifies these last last assertions, as well as that
 the residual in the above equation is small.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER array, dimension (2)
          NINFO(J) is the number of examples where INFO=J occurred.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gad85b2e71e578a368367a8c4043011129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget35 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET35</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET35 tests DTRSYL, a routine for solving the Sylvester matrix
 equation

    op(A)*X + ISGN*X*op(B) = scale*C,

 A and B are assumed to be in Schur canonical form, op() represents an
 optional transpose, and ISGN can be -1 or +1.  Scale is an output
 less than or equal to 1, chosen to avoid overflow in X.

 The test code verifies that the following residual is order 1:

    norm(op(A)*X + ISGN*X*op(B) - scale*C) /
        (EPS*max(norm(A),norm(B))*norm(X))</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER
          Number of examples where INFO is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaca33e5cebfce251ead6098f633c8bc13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget36 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET36</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET36 tests DTREXC, a routine for moving blocks (either 1 by 1 or
 2 by 2) on the diagonal of a matrix in real Schur form.  Thus, DLAEXC
 computes an orthogonal matrix Q such that

    Q' * T1 * Q  = T2

 and where one of the diagonal blocks of T1 (the one at row IFST) has
 been moved to position ILST.

 The test code verifies that the residual Q'*T1*Q-T2 is small, that T2
 is in Schur form, and that the final position of the IFST block is
 ILST (within +-1).

 The test matrices are read from a file with logical unit number NIN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER array, dimension (3)
          NINFO(J) is the number of examples where INFO=J.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          Input logical unit number.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gabdcacf57969bb6f47213da97e24ca706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget37 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 3 )&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET37</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET37 tests DTRSNA, a routine for estimating condition numbers of
 eigenvalues and/or right eigenvectors of a matrix.

 The test matrices are read from a file with logical unit number NIN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION array, dimension (3)
          Value of the largest test ratio.
          RMAX(1) = largest ratio comparing different calls to DTRSNA
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If DGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If DHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If DTRSNA returns INFO nonzero on example i, LMAX(3)=i</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times DGEHRD returned INFO nonzero
          NINFO(2) = No. of times DHSEQR returned INFO nonzero
          NINFO(3) = No. of times DTRSNA returned INFO nonzero</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          Input logical unit number</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gae6037bff69c348a29907e03c047b4ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget38 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 3 )&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 3 )&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NIN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET38</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET38 tests DTRSEN, a routine for estimating condition numbers of a
 cluster of eigenvalues and/or its associated right invariant subspace

 The test matrices are read from a file with logical unit number NIN.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION array, dimension (3)
          Values of the largest test ratios.
          RMAX(1) = largest residuals from DHST01 or comparing
                    different calls to DTRSEN
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If DGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If DHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If DTRSEN returns INFO nonzero on example i, LMAX(3)=i</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times DGEHRD returned INFO nonzero
          NINFO(2) = No. of times DHSEQR returned INFO nonzero
          NINFO(3) = No. of times DTRSEN returned INFO nonzero</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NIN</td><td><pre class="fragment">          NIN is INTEGER
          Input logical unit number.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa546404302fddb3545bcd1ca639b2dd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget39 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LMAX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NINFO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KNT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET39</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET39 tests DLAQTR, a routine for solving the real or
 special complex quasi upper triangular system

      op(T)*p = scale*c,
 or
      op(T + iB)*(p+iq) = scale*(c+id),

 in real arithmetic. T is upper quasi-triangular.
 If it is complex, then the first diagonal block of T must be
 1 by 1, B has the special structure

                B = [ b(1) b(2) ... b(n) ]
                    [       w            ]
                    [           w        ]
                    [              .     ]
                    [                 w  ]

 op(A) = A or A', where A' denotes the conjugate transpose of
 the matrix A.

 On input, X = [ c ].  On output, X = [ p ].
               [ d ]                  [ q ]

 Scale is an output less than or equal to 1, chosen to avoid
 overflow in X.
 This subroutine is specially designed for the condition number
 estimation in the eigenproblem routine DTRSNA.

 The test code verifies that the following residual is order 1:

      ||(T+i*B)*(x1+i*x2) - scale*(d1+i*d2)||
    -----------------------------------------
        max(ulp*(||T||+||B||)*(||x1||+||x2||),
            (||T||+||B||)*smlnum/ulp,
            smlnum)

 (The (||T||+||B||)*smlnum/ulp term accounts for possible
  (gradual or nongradual) underflow in x1 and x2.)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RMAX</td><td><pre class="fragment">          RMAX is DOUBLE PRECISION
          Value of the largest test ratio.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LMAX</td><td><pre class="fragment">          LMAX is INTEGER
          Example number where largest test ratio achieved.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NINFO</td><td><pre class="fragment">          NINFO is INTEGER
          Number of examples where INFO is nonzero.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KNT</td><td><pre class="fragment">          KNT is INTEGER
          Total number of examples tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6f9376de56715d7548005efd8e71a65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget51 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET51</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      DGET51  generally checks a decomposition of the form

              A = U B V'

      where ' means transpose and U and V are orthogonal.

      Specifically, if ITYPE=1

              RESULT = | A - U B V' | / ( |A| n ulp )

      If ITYPE=2, then:

              RESULT = | A - B | / ( |A| n ulp )

      If ITYPE=3, then:

              RESULT = | I - UU' | / ( n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          =1: RESULT = | A - U B V' | / ( |A| n ulp )
          =2: RESULT = | A - B | / ( |A| n ulp )
          =3: RESULT = | I - UU' | / ( n ulp )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, DGET51 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          The original (unfactored) matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB, N)
          The factored matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension (LDV, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (2*N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION
          The values computed by the test specified by ITYPE.  The
          value is currently limited to 1/ulp, to avoid overflow.
          Errors are flagged by RESULT=10/ulp.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8af5c9297a5d6bc3f84223b499442944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget52 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a>&#160;</td>
          <td class="paramname"><em>LEFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( <a class="el" href="dblat3_8f.html#a6fd3ddbe863b9e8e6e79ebf9c8594174">lde</a>, * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET52</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET52  does an eigenvector check for the generalized eigenvalue
 problem.

 The basic test for right eigenvectors is:

                           | b(j) A E(j) -  a(j) B E(j) |
         RESULT(1) = max   -------------------------------
                      j    n ulp max( |b(j) A|, |a(j) B| )

 using the 1-norm.  Here, a(j)/b(j) = w is the j-th generalized
 eigenvalue of A - w B, or, equivalently, b(j)/a(j) = m is the j-th
 generalized eigenvalue of m A - B.

 For real eigenvalues, the test is straightforward.  For complex
 eigenvalues, E(j) and a(j) are complex, represented by
 Er(j) + i*Ei(j) and ar(j) + i*ai(j), resp., so the test for that
 eigenvector becomes

                 max( |Wr|, |Wi| )
     --------------------------------------------
     n ulp max( |b(j) A|, (|ar(j)|+|ai(j)|) |B| )

 where

     Wr = b(j) A Er(j) - ar(j) B Er(j) + ai(j) B Ei(j)

     Wi = b(j) A Ei(j) - ai(j) B Er(j) - ar(j) B Ei(j)

                         T   T  _
 For left eigenvectors, A , B , a, and b  are used.

 DGET52 also tests the normalization of E.  Each eigenvector is
 supposed to be normalized so that the maximum "absolute value"
 of its elements is 1, where in this case, "absolute value"
 of a complex value x is  |Re(x)| + |Im(x)| ; let us call this
 maximum "absolute value" norm of a vector v  M(v).
 if a(j)=b(j)=0, then the eigenvector is set to be the jth coordinate
 vector.  The normalization test is:

         RESULT(2) =      max       | M(v(j)) - 1 | / ( n ulp )
                    eigenvectors v(j)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LEFT</td><td><pre class="fragment">          LEFT is LOGICAL
          =.TRUE.:  The eigenvectors in the columns of E are assumed
                    to be *left* eigenvectors.
          =.FALSE.: The eigenvectors in the columns of E are assumed
                    to be *right* eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrices.  If it is zero, DGET52 does
          nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          The matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB, N)
          The matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (LDE, N)
          The matrix of eigenvectors.  It must be O( 1 ).  Complex
          eigenvalues and eigenvectors always come in pairs, the
          eigenvalue and its conjugate being stored in adjacent
          elements of ALPHAR, ALPHAI, and BETA.  Thus, if a(j)/b(j)
          and a(j+1)/b(j+1) are a complex conjugate pair of
          generalized eigenvalues, then E(,j) contains the real part
          of the eigenvector and E(,j+1) contains the imaginary part.
          Note that whether E(,j) is a real eigenvector or part of a
          complex one is specified by whether ALPHAI(j) is zero or not.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDE</td><td><pre class="fragment">          LDE is INTEGER
          The leading dimension of E.  It must be at least 1 and at
          least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHAR</td><td><pre class="fragment">          ALPHAR is DOUBLE PRECISION array, dimension (N)
          The real parts of the values a(j) as described above, which,
          along with b(j), define the generalized eigenvalues.
          Complex eigenvalues always come in complex conjugate pairs
          a(j)/b(j) and a(j+1)/b(j+1), which are stored in adjacent
          elements in ALPHAR, ALPHAI, and BETA.  Thus, if the j-th
          and (j+1)-st eigenvalues form a pair, ALPHAR(j+1)/BETA(j+1)
          is assumed to be equal to ALPHAR(j)/BETA(j).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ALPHAI</td><td><pre class="fragment">          ALPHAI is DOUBLE PRECISION array, dimension (N)
          The imaginary parts of the values a(j) as described above,
          which, along with b(j), define the generalized eigenvalues.
          If ALPHAI(j)=0, then the eigenvalue is real, otherwise it
          is part of a complex conjugate pair.  Complex eigenvalues
          always come in complex conjugate pairs a(j)/b(j) and
          a(j+1)/b(j+1), which are stored in adjacent elements in
          ALPHAR, ALPHAI, and BETA.  Thus, if the j-th and (j+1)-st
          eigenvalues form a pair, ALPHAI(j+1)/BETA(j+1) is assumed to
          be equal to  -ALPHAI(j)/BETA(j).  Also, nonzero values in
          ALPHAI are assumed to always come in adjacent pairs.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION array, dimension (N)
          The values b(j) as described above, which, along with a(j),
          define the generalized eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N**2+N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the test described above.  If A E or
          B E is likely to overflow, then RESULT(1:2) is set to
          10 / ulp.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga50f4c00fce1f7d59566e68da4fecbf29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget53 </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET53</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET53  checks the generalized eigenvalues computed by DLAG2.

 The basic test for an eigenvalue is:

                              | det( s A - w B ) |
     RESULT =  ---------------------------------------------------
               ulp max( s norm(A), |w| norm(B) )*norm( s A - w B )

 Two "safety checks" are performed:

 (1)  ulp*max( s*norm(A), |w|*norm(B) )  must be at least
      safe_minimum.  This insures that the test performed is
      not essentially  det(0*A + 0*B)=0.

 (2)  s*norm(A) + |w|*norm(B) must be less than 1/safe_minimum.
      This insures that  s*A - w*B  will not overflow.

 If these tests are not passed, then  s  and  w  are scaled and
 tested anyway, if this is possible.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, 2)
          The 2x2 matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB, N)
          The 2x2 upper-triangular matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  It must be at least 2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SCALE</td><td><pre class="fragment">          SCALE is DOUBLE PRECISION
          The "scale factor" s in the formula  s A - w B .  It is
          assumed to be non-negative.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is DOUBLE PRECISION
          The real part of the eigenvalue  w  in the formula
          s A - w B .</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is DOUBLE PRECISION
          The imaginary part of the eigenvalue  w  in the formula
          s A - w B .</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION
          If INFO is 2 or less, the value computed by the test
             described above.
          If INFO=3, this will just be 1/ulp.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          =0:  The input data pass the "safety checks".
          =1:  s*norm(A) + |w|*norm(B) &gt; 1/safe_minimum.
          =2:  ulp*max( s*norm(A), |w|*norm(B) ) &lt; safe_minimum
          =3:  same as INFO=2, but  s  and  w  could not be scaled so
               as to compute the test.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga14537b71a6ca0def78c7edf19acfa8f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dget54 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lds, * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldt, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGET54</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGET54 checks a generalized decomposition of the form

          A = U*S*V'  and B = U*T* V'

 where ' means transpose and U and V are orthogonal.

 Specifically,

  RESULT = ||( A - U*S*V', B - U*T*V' )|| / (||( A, B )||*n*ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, DGET54 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          The original (unfactored) matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB, N)
          The original (unfactored) matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension (LDS, N)
          The factored matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDS</td><td><pre class="fragment">          LDS is INTEGER
          The leading dimension of S.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td><pre class="fragment">          T is DOUBLE PRECISION array, dimension (LDT, N)
          The factored matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDT</td><td><pre class="fragment">          LDT is INTEGER
          The leading dimension of T.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension (LDV, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (3*N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION
          The value RESULT, It is currently limited to 1/ulp, to
          avoid overflow. Errors are flagged by RESULT=10/ulp.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gadb6ee09a4853bbafa0ad4b5f5dd26f32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dglmts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGLMTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGLMTS tests DGGGLM - a subroutine for solving the generalized
 linear model problem.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of rows of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of columns of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of columns of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,M)
          The N-by-M matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (LDA,M)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF. LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,P)
          The N-by-P matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (LDB,P)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF. LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension( N )
          On input, the left hand side of the GLM.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DF</td><td><pre class="fragment">          DF is DOUBLE PRECISION array, dimension( N )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension( M )
          solution vector X in the GLM problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension( P )
          solution vector U in the GLM problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION
          The test ratio:
                           norm( d - A*x - B*u )
            RESULT = -----------------------------------------
                     (norm(A)+norm(B))*(norm(x)+norm(u))*EPS</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga73c45f96f24770b97239b6269c8d1cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dgqrts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BWK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 4 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGQRTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGQRTS tests DGGQRF, which computes the GQR factorization of an
 N-by-M matrix A and a N-by-P matrix B: A = Q*R and B = Q*T*Z.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of rows of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of columns of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of columns of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,M)
          The N-by-M matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (LDA,N)
          Details of the GQR factorization of A and B, as returned
          by DGGQRF, see SGGQRF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDA,N)
          The M-by-M orthogonal matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is DOUBLE PRECISION array, dimension (LDA,MAX(M,N))</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUA</td><td><pre class="fragment">          TAUA is DOUBLE PRECISION array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by DGGQRF.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,P)
          On entry, the N-by-P matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by DGGQRF, see SGGQRF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension (LDB,P)
          The P-by-P orthogonal matrix Z.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is DOUBLE PRECISION array, dimension (LDB,max(P,N))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWK</td><td><pre class="fragment">          BWK is DOUBLE PRECISION array, dimension (LDB,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUB</td><td><pre class="fragment">          TAUB is DOUBLE PRECISION array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by DGGRQF.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK, LWORK &gt;= max(N,M,P)**2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (max(N,M,P))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - Q'*A ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Z - Q'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( M*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7407f6eaf402bcb6bbda3e5bd46485fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dgrqts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BWK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 4 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGRQTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGRQTS tests DGGRQF, which computes the GRQ factorization of an
 M-by-N matrix A and a P-by-N matrix B: A = R*Q and B = Z*T*Q.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The M-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (LDA,N)
          Details of the GRQ factorization of A and B, as returned
          by DGGRQF, see SGGRQF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDA,N)
          The N-by-N orthogonal matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is DOUBLE PRECISION array, dimension (LDA,MAX(M,N))</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUA</td><td><pre class="fragment">          TAUA is DOUBLE PRECISION array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by DGGQRC.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,N)
          On entry, the P-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by DGGRQF, see SGGRQF for further details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension (LDB,P)
          The P-by-P orthogonal matrix Z.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td><pre class="fragment">          T is DOUBLE PRECISION array, dimension (LDB,max(P,N))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWK</td><td><pre class="fragment">          BWK is DOUBLE PRECISION array, dimension (LDB,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TAUB</td><td><pre class="fragment">          TAUB is DOUBLE PRECISION array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by DGGRQF.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK, LWORK &gt;= max(M,P,N)**2.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - A*Q' ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Q - Z'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( N*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gae3ad62ba253b56ff68e7007244ce988e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dgsvts </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldr, * )&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 6 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DGSVTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DGSVTS tests DGGSVD, which computes the GSVD of an M-by-N matrix A
 and a P-by-N matrix B:
              U'*A*Q = D1*R and V'*B*Q = D2*R.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,M)
          The M-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (LDA,N)
          Details of the GSVD of A and B, as returned by DGGSVD,
          see DGGSVD for further details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A and AF.
          LDA &gt;= max( 1,M ).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,P)
          On entry, the P-by-N matrix B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (LDB,N)
          Details of the GSVD of A and B, as returned by DGGSVD,
          see DGGSVD for further details.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B and BF.
          LDB &gt;= max(1,P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension(LDU,M)
          The M by M orthogonal matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U. LDU &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension(LDV,M)
          The P by P orthogonal matrix V.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of the array V. LDV &gt;= max(1,P).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension(LDQ,N)
          The N by N orthogonal matrix Q.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q. LDQ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHA</td><td><pre class="fragment">          ALPHA is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION array, dimension (N)

          The generalized singular value pairs of A and B, the
          ``diagonal'' matrices D1 and D2 are constructed from
          ALPHA and BETA, see subroutine DGGSVD for details.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td><pre class="fragment">          R is DOUBLE PRECISION array, dimension(LDQ,N)
          The upper triangular matrix R.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDR</td><td><pre class="fragment">          LDR is INTEGER
          The leading dimension of the array R. LDR &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK,
          LWORK &gt;= max(M,P,N)*max(M,P,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (max(M,P,N))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (6)
          The test ratios:
          RESULT(1) = norm( U'*A*Q - D1*R ) / ( MAX(M,N)*norm(A)*ULP)
          RESULT(2) = norm( V'*B*Q - D2*R ) / ( MAX(P,N)*norm(B)*ULP)
          RESULT(3) = norm( I - U'*U ) / ( M*ULP )
          RESULT(4) = norm( I - V'*V ) / ( P*ULP )
          RESULT(5) = norm( I - Q'*Q ) / ( N*ULP )
          RESULT(6) = 0        if ALPHA is in decreasing order;
                    = ULPINV   otherwise.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c2bc3739bff16d2f68bcce82a72e5bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dhst01 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldh, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldq, * )&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DHST01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DHST01 tests the reduction of a general matrix A to upper Hessenberg
 form:  A = Q*H*Q'.  Two test ratios are computed;

 RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
 RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )

 The matrix Q is assumed to be given explicitly as it would be
 following DGEHRD + DORGHR.

 In this version, ILO and IHI are not used and are assumed to be 1 and
 N, respectively.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILO</td><td><pre class="fragment">          ILO is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IHI</td><td><pre class="fragment">          IHI is INTEGER

          A is assumed to be upper triangular in rows and columns
          1:ILO-1 and IHI+1:N, so Q differs from the identity only in
          rows and columns ILO+1:IHI.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The original n by n matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td><pre class="fragment">          H is DOUBLE PRECISION array, dimension (LDH,N)
          The upper Hessenberg matrix H from the reduction A = Q*H*Q'
          as computed by DGEHRD.  H is assumed to be zero below the
          first subdiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDH</td><td><pre class="fragment">          LDH is INTEGER
          The leading dimension of the array H.  LDH &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><pre class="fragment">          Q is DOUBLE PRECISION array, dimension (LDQ,N)
          The orthogonal matrix Q from the reduction A = Q*H*Q' as
          computed by DGEHRD + DORGHR.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDQ</td><td><pre class="fragment">          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  LWORK &gt;= 2*N*N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
          RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f9c26a927bb292ac5cab99adc1a357c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlafts </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>TYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IMAT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NTESTS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>THRESH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAFTS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DLAFTS tests the result vector against the threshold value to
    see which tests for this matrix type failed to pass the threshold.
    Output is to the file given by unit IOUNIT.</pre> <pre class="fragment">  TYPE   - CHARACTER*3
           On entry, TYPE specifies the matrix type to be used in the
           printed messages.
           Not modified.

  N      - INTEGER
           On entry, N specifies the order of the test matrix.
           Not modified.

  IMAT   - INTEGER
           On entry, IMAT specifies the type of the test matrix.
           A listing of the different types is printed by DLAHD2
           to the output file if a test fails to pass the threshold.
           Not modified.

  NTESTS - INTEGER
           On entry, NTESTS is the number of tests performed on the
           subroutines in the path given by TYPE.
           Not modified.

  RESULT - DOUBLE PRECISION               array of dimension( NTESTS )
           On entry, RESULT contains the test ratios from the tests
           performed in the calling program.
           Not modified.

  ISEED  - INTEGER            array of dimension( 4 )
           Contains the random seed that generated the matrix used
           for the tests whose ratios are in RESULT.
           Not modified.

  THRESH - DOUBLE PRECISION
           On entry, THRESH specifies the acceptable threshold of the
           test ratios.  If RESULT( K ) &gt; THRESH, then the K-th test
           did not pass the threshold and a message will be printed.
           Not modified.

  IOUNIT - INTEGER
           On entry, IOUNIT specifies the unit number of the file
           to which the messages are printed.
           Not modified.

  IE     - INTEGER
           On entry, IE contains the number of tests which have
           failed to pass the threshold so far.
           Updated on exit if any of the ratios in RESULT also fail.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5ca6e066facb65a20568f3b790f1624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlahd2 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLAHD2</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLAHD2 prints header information for the different test paths.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IOUNIT</td><td><pre class="fragment">          IOUNIT is INTEGER.
          On entry, IOUNIT specifies the unit number to which the
          header information should be printed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3.
          On entry, PATH contains the name of the path for which the
          header information is to be printed.  Current paths are

             DHS, ZHS:  Non-symmetric eigenproblem.
             DST, ZST:  Symmetric eigenproblem.
             DSG, ZSG:  Symmetric Generalized eigenproblem.
             DBD, ZBD:  Singular Value Decomposition (SVD)
             DBB, ZBB:  General Banded reduction to bidiagonal form

          These paths also are supplied in double precision (replace
          leading S by D and leading C by Z in path names).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a374be57f1611d886c1ac0a6999351d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarfy </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INCV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldc, * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARFY</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARFY applies an elementary reflector, or Householder matrix, H,
 to an n x n symmetric matrix C, from both the left and the right.

 H is represented in the form

    H = I - tau * v * v'

 where  tau  is a scalar and  v  is a vector.

 If  tau  is  zero, then  H  is taken to be the unit matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          symmetric matrix C is stored.
          = 'U':  Upper triangle
          = 'L':  Lower triangle</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of rows and columns of the matrix C.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension
                  (1 + (N-1)*abs(INCV))
          The vector v as described above.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INCV</td><td><pre class="fragment">          INCV is INTEGER
          The increment between successive elements of v.  INCV must
          not be zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is DOUBLE PRECISION
          The value tau as described above.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension (LDC, N)
          On entry, the matrix C.
          On exit, C is overwritten by H * C * H'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDC</td><td><pre class="fragment">          LDC is INTEGER
          The leading dimension of the array C.  LDC &gt;= max( 1, N ).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N)</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gada4fcd971471a815d7d0bba57fdf627b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlarhs </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>XTYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldx, * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLARHS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLARHS chooses a set of NRHS random solution vectors and sets
 up the right hand sides for the linear system
    op( A ) * X = B,
 where op( A ) may be A or A' (transpose of A).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The type of the real matrix A.  PATH may be given in any
          combination of upper and lower case.  Valid types include
             xGE:  General m x n matrix
             xGB:  General banded matrix
             xPO:  Symmetric positive definite, 2-D storage
             xPP:  Symmetric positive definite packed
             xPB:  Symmetric positive definite banded
             xSY:  Symmetric indefinite, 2-D storage
             xSP:  Symmetric indefinite packed
             xSB:  Symmetric indefinite banded
             xTR:  Triangular
             xTP:  Triangular packed
             xTB:  Triangular banded
             xQR:  General m x n matrix
             xLQ:  General m x n matrix
             xQL:  General m x n matrix
             xRQ:  General m x n matrix
          where the leading character indicates the precision.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">XTYPE</td><td><pre class="fragment">          XTYPE is CHARACTER*1
          Specifies how the exact solution X will be determined:
          = 'N':  New solution; generate a random X.
          = 'C':  Computed; use value of X on entry.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          matrix A is stored, if A is symmetric.
          = 'U':  Upper triangular
          = 'L':  Lower triangular</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRANS</td><td><pre class="fragment">          TRANS is CHARACTER*1
          Specifies the operation applied to the matrix A.
          = 'N':  System is  A * x = b
          = 'T':  System is  A'* x = b
          = 'C':  System is  A'* x = b</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number or rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td><pre class="fragment">          KL is INTEGER
          Used only if A is a band matrix; specifies the number of
          subdiagonals of A if A is a general band matrix or if A is
          symmetric or triangular and UPLO = 'L'; specifies the number
          of superdiagonals of A if A is symmetric or triangular and
          UPLO = 'U'.  0 &lt;= KL &lt;= M-1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td><pre class="fragment">          KU is INTEGER
          Used only if A is a general band matrix or if A is
          triangular.

          If PATH = xGB, specifies the number of superdiagonals of A,
          and 0 &lt;= KU &lt;= N-1.

          If PATH = xTR, xTP, or xTB, specifies whether or not the
          matrix has unit diagonal:
          = 1:  matrix has non-unit diagonal (default)
          = 2:  matrix has unit diagonal</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NRHS</td><td><pre class="fragment">          NRHS is INTEGER
          The number of right hand side vectors in the system A*X = B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The test matrix whose type is given by PATH.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.
          If PATH = xGB, LDA &gt;= KL+KU+1.
          If PATH = xPB, xSB, xHB, or xTB, LDA &gt;= KL+1.
          Otherwise, LDA &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">X</td><td><pre class="fragment">          X is or output) DOUBLE PRECISION array, dimension(LDX,NRHS)
          On entry, if XTYPE = 'C' (for 'Computed'), then X contains
          the exact solution to the system of linear equations.
          On exit, if XTYPE = 'N' (for 'New'), then X is initialized
          with random values.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDX</td><td><pre class="fragment">          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX &gt;= max(1,N); if TRANS = 'T', LDX &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,NRHS)
          The right hand side vector(s) for the system of equations,
          computed from B = op(A) * X, where op(A) is determined by
          TRANS.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  If TRANS = 'N',
          LDB &gt;= max(1,M); if TRANS = 'T', LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          The seed vector for the random number generator (used in
          DLATMS).  Modified on exit.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3fd4cb18655d3b4b20912ad7f57c6890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlasum </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>TYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IOUNIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NRUN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLASUM</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLASUM prints a summary of the results from one of the test routines.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab048b044b8daf142a4780aa5dd1e68ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlatb9 </td>
          <td>(</td>
          <td class="paramtype">character*3&#160;</td>
          <td class="paramname"><em>PATH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IMAT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>TYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KLA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KLB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ANORM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>BNORM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODEA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MODEB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CNDNMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>CNDNMB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DISTA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>DISTB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLATB9</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLATB9 sets parameters for the matrix generator based on the type of
 matrix to be generated.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PATH</td><td><pre class="fragment">          PATH is CHARACTER*3
          The LAPACK path name.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IMAT</td><td><pre class="fragment">          IMAT is INTEGER
          An integer key describing which matrix to generate for this
          path.
          = 1:   A: diagonal, B: upper triangular
          = 2:   A: upper triangular, B: upper triangular
          = 3:   A: lower triangular, B: upper triangular
          Else:  A: general dense, B: general dense</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows in the matrix to be generated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns in the matrix to be generated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TYPE</td><td><pre class="fragment">          TYPE is CHARACTER*1
          The type of the matrix to be generated:
          = 'S':  symmetric matrix;
          = 'P':  symmetric positive (semi)definite matrix;
          = 'N':  nonsymmetric matrix.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KLA</td><td><pre class="fragment">          KLA is INTEGER
          The lower band width of the matrix to be generated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KUA</td><td><pre class="fragment">          KUA is INTEGER
          The upper band width of the matrix to be generated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KLB</td><td><pre class="fragment">          KLB is INTEGER
          The lower band width of the matrix to be generated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">KUB</td><td><pre class="fragment">          KUA is INTEGER
          The upper band width of the matrix to be generated.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ANORM</td><td><pre class="fragment">          ANORM is DOUBLE PRECISION
          The desired norm of the matrix to be generated.  The diagonal
          matrix of singular values or eigenvalues is scaled by this
          value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BNORM</td><td><pre class="fragment">          BNORM is DOUBLE PRECISION
          The desired norm of the matrix to be generated.  The diagonal
          matrix of singular values or eigenvalues is scaled by this
          value.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MODEA</td><td><pre class="fragment">          MODEA is INTEGER
          A key indicating how to choose the vector of eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MODEB</td><td><pre class="fragment">          MODEB is INTEGER
          A key indicating how to choose the vector of eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CNDNMA</td><td><pre class="fragment">          CNDNMA is DOUBLE PRECISION
          The desired condition number.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CNDNMB</td><td><pre class="fragment">          CNDNMB is DOUBLE PRECISION
          The desired condition number.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DISTA</td><td><pre class="fragment">          DISTA is CHARACTER*1
          The type of distribution to be used by the random number
          generator.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DISTB</td><td><pre class="fragment">          DISTB is CHARACTER*1
          The type of distribution to be used by the random number
          generator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ac7051d7e9a8e10930e4b1bcd19fe3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlatm4 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NZ1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NZ2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ISIGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>AMAGN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RCOND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>TRIANG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( 4 )&#160;</td>
          <td class="paramname"><em>ISEED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLATM4</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLATM4 generates basic square matrices, which may later be
 multiplied by others in order to produce test matrices.  It is
 intended mainly to be used to test the generalized eigenvalue
 routines.

 It first generates the diagonal and (possibly) subdiagonal,
 according to the value of ITYPE, NZ1, NZ2, ISIGN, AMAGN, and RCOND.
 It then fills in the upper triangle with random numbers, if TRIANG is
 non-zero.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          The "type" of matrix on the diagonal and sub-diagonal.
          If ITYPE &lt; 0, then type abs(ITYPE) is generated and then
             swapped end for end (A(I,J) := A'(N-J,N-I).)  See also
             the description of AMAGN and ISIGN.

          Special types:
          = 0:  the zero matrix.
          = 1:  the identity.
          = 2:  a transposed Jordan block.
          = 3:  If N is odd, then a k+1 x k+1 transposed Jordan block
                followed by a k x k identity block, where k=(N-1)/2.
                If N is even, then k=(N-2)/2, and a zero diagonal entry
                is tacked onto the end.

          Diagonal types.  The diagonal consists of NZ1 zeros, then
             k=N-NZ1-NZ2 nonzeros.  The subdiagonal is zero.  ITYPE
             specifies the nonzero diagonal entries as follows:
          = 4:  1, ..., k
          = 5:  1, RCOND, ..., RCOND
          = 6:  1, ..., 1, RCOND
          = 7:  1, a, a^2, ..., a^(k-1)=RCOND
          = 8:  1, 1-d, 1-2*d, ..., 1-(k-1)*d=RCOND
          = 9:  random numbers chosen from (RCOND,1)
          = 10: random numbers with distribution IDIST (see DLARND.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NZ1</td><td><pre class="fragment">          NZ1 is INTEGER
          If abs(ITYPE) &gt; 3, then the first NZ1 diagonal entries will
          be zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NZ2</td><td><pre class="fragment">          NZ2 is INTEGER
          If abs(ITYPE) &gt; 3, then the last NZ2 diagonal entries will
          be zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ISIGN</td><td><pre class="fragment">          ISIGN is INTEGER
          = 0: The sign of the diagonal and subdiagonal entries will
               be left unchanged.
          = 1: The diagonal and subdiagonal entries will have their
               sign changed at random.
          = 2: If ITYPE is 2 or 3, then the same as ISIGN=1.
               Otherwise, with probability 0.5, odd-even pairs of
               diagonal entries A(2*j-1,2*j-1), A(2*j,2*j) will be
               converted to a 2x2 block by pre- and post-multiplying
               by distinct random orthogonal rotations.  The remaining
               diagonal entries will have their sign changed at random.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AMAGN</td><td><pre class="fragment">          AMAGN is DOUBLE PRECISION
          The diagonal and subdiagonal entries will be multiplied by
          AMAGN.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RCOND</td><td><pre class="fragment">          RCOND is DOUBLE PRECISION
          If abs(ITYPE) &gt; 4, then the smallest diagonal entry will be
          entry will be RCOND.  RCOND must be between 0 and 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TRIANG</td><td><pre class="fragment">          TRIANG is DOUBLE PRECISION
          The entries above the diagonal will be random numbers with
          magnitude bounded by TRIANG (i.e., random numbers multiplied
          by TRIANG.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IDIST</td><td><pre class="fragment">          IDIST is INTEGER
          Specifies the type of distribution to be used to generate a
          random matrix.
          = 1:  UNIFORM( 0, 1 )
          = 2:  UNIFORM( -1, 1 )
          = 3:  NORMAL ( 0, 1 )</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ISEED</td><td><pre class="fragment">          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator.  The values of ISEED are changed on exit, and can
          be used in the next call to DLATM4 to continue the same
          random number sequence.
          Note: ISEED(4) should be odd, for the random number generator
          used at present.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          Array to be computed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          Leading dimension of A.  Must be at least 1 and at least N.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9773e3d39987ec10a5a58e224ff7582b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlctes </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ZR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ZI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLCTES</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLCTES returns .TRUE. if the eigenvalue (ZR/D) + sqrt(-1)*(ZI/D)
 is to be selected (specifically, in this subroutine, if the real
 part of the eigenvalue is negative), and otherwise it returns
 .FALSE..

 It is used by the test routine DDRGES to test whether the driver
 routine DGGES succesfully sorts eigenvalues.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ZR</td><td><pre class="fragment">          ZR is DOUBLE PRECISION
          The numerator of the real part of a complex eigenvalue
          (ZR/D) + i*(ZI/D).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZI</td><td><pre class="fragment">          ZI is DOUBLE PRECISION
          The numerator of the imaginary part of a complex eigenvalue
          (ZR/D) + i*(ZI).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION
          The denominator part of a complex eigenvalue
          (ZR/D) + i*(ZI/D).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga14489af521606715c20ff53663f535c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dlctsx </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>BETA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLCTSX</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> This function is used to determine what eigenvalues will be
 selected.  If this is part of the test driver DDRGSX, do not
 change the code UNLESS you are testing input examples and not
 using the built-in examples.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">AR</td><td><pre class="fragment">          AR is DOUBLE PRECISION
          The numerator of the real part of a complex eigenvalue
          (AR/BETA) + i*(AI/BETA).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AI</td><td><pre class="fragment">          AI is DOUBLE PRECISION
          The numerator of the imaginary part of a complex eigenvalue
          (AR/BETA) + i*(AI).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is DOUBLE PRECISION
          The denominator part of a complex eigenvalue
          (AR/BETA) + i*(AI/BETA).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f7f392f14da20c2cc0d33982627b1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dlsets </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>AF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>CF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>DF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lwork )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DLSETS</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DLSETS tests DGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix A.  M &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">          P is INTEGER
          The number of rows of the matrix B.  P &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrices A and B.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA,N)
          The M-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AF</td><td><pre class="fragment">          AF is DOUBLE PRECISION array, dimension (LDA,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the arrays A, AF, Q and R.
          LDA &gt;= max(M,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB,N)
          The P-by-N matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td><pre class="fragment">          BF is DOUBLE PRECISION array, dimension (LDB,N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the arrays B, BF, V and S.
          LDB &gt;= max(P,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td><pre class="fragment">          C is DOUBLE PRECISION array, dimension( M )
          the vector C in the LSE problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CF</td><td><pre class="fragment">          CF is DOUBLE PRECISION array, dimension( M )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension( P )
          the vector D in the LSE problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DF</td><td><pre class="fragment">          DF is DOUBLE PRECISION array, dimension( P )</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td><pre class="fragment">          X is DOUBLE PRECISION array, dimension( N )
          solution vector X in the LSE problem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RWORK</td><td><pre class="fragment">          RWORK is DOUBLE PRECISION array, dimension (M)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The test ratios:
            RESULT(1) = norm( A*x - c )/ norm(A)*norm(X)*EPS
            RESULT(2) = norm( B*x - d )/ norm(B)*norm(X)*EPS</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d1a5c2792c183c95bcab211a6c8027a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dort01 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>ROWCOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DORT01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DORT01 checks that the matrix U is orthogonal by computing the ratio

    RESID = norm( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = norm( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 Alternatively, if there isn't sufficient workspace to form
 I - U*U' or I - U'*U, the ratio is computed as

    RESID = abs( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = abs( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 where EPS is the machine precision.  ROWCOL is used only if m = n;
 if m &gt; n, ROWCOL is assumed to be 'C', and if m &lt; n, ROWCOL is
 assumed to be 'R'.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ROWCOL</td><td><pre class="fragment">          ROWCOL is CHARACTER
          Specifies whether the rows or columns of U should be checked
          for orthogonality.  Used only if M = N.
          = 'R':  Check for orthogonal rows of U
          = 'C':  Check for orthogonal columns of U</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of rows of the matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The number of columns of the matrix U.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU,N)
          The orthogonal matrix U.  U is checked for orthogonal columns
          if m &gt; n or if m = n and ROWCOL = 'C'.  U is checked for
          orthogonal rows if m &lt; n or if m = n and ROWCOL = 'R'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of the array U.  LDU &gt;= max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*(N+1) if ROWCOL = 'C' or M*(M+1) if
          ROWCOL = 'R', but the test will be done even if LWORK is 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESID</td><td><pre class="fragment">          RESID is DOUBLE PRECISION
          RESID = norm( I - U * U' ) / ( n * EPS ), if ROWCOL = 'R', or
          RESID = norm( I - U' * U ) / ( m * EPS ), if ROWCOL = 'C'.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab5b5f991af6cf4cbd658c1ceb7dd70bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dort03 </td>
          <td>(</td>
          <td class="paramtype">character*( * )&#160;</td>
          <td class="paramname"><em>RC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>RESULT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DORT03</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DORT03 compares two orthogonal matrices U and V to see if their
 corresponding rows or columns span the same spaces.  The rows are
 checked if RC = 'R', and the columns are checked if RC = 'C'.

 RESULT is the maximum of

    | V*V' - I | / ( MV ulp ), if RC = 'R', or

    | V'*V - I | / ( MV ulp ), if RC = 'C',

 and the maximum over rows (or columns) 1 to K of

    | U(i) - S*V(i) |/ ( N ulp )

 where S is +-1 (chosen to minimize the expression), U(i) is the i-th
 row (column) of U, and V(i) is the i-th row (column) of V.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RC</td><td><pre class="fragment">          RC is CHARACTER*1
          If RC = 'R' the rows of U and V are to be compared.
          If RC = 'C' the columns of U and V are to be compared.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MU</td><td><pre class="fragment">          MU is INTEGER
          The number of rows of U if RC = 'R', and the number of
          columns if RC = 'C'.  If MU = 0 DORT03 does nothing.
          MU must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MV</td><td><pre class="fragment">          MV is INTEGER
          The number of rows of V if RC = 'R', and the number of
          columns if RC = 'C'.  If MV = 0 DORT03 does nothing.
          MV must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          If RC = 'R', the number of columns in the matrices U and V,
          and if RC = 'C', the number of rows in U and V.  If N = 0
          DORT03 does nothing.  N must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">          K is INTEGER
          The number of rows or columns of U and V to compare.
          0 &lt;= K &lt;= max(MU,MV).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU,N)
          The first matrix to compare.  If RC = 'R', U is MU by N, and
          if RC = 'C', U is N by MU.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  If RC = 'R', LDU &gt;= max(1,MU),
          and if RC = 'C', LDU &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension (LDV,N)
          The second matrix to compare.  If RC = 'R', V is MV by N, and
          if RC = 'C', V is N by MV.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  If RC = 'R', LDV &gt;= max(1,MV),
          and if RC = 'C', LDV &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LWORK)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*N if RC = 'C' or M*M if RC = 'R', but
          the tests will be done even if LWORK is 0.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION
          The value computed by the test described above.  RESULT is
          limited to 1/ulp to avoid overflow.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          0  indicates a successful exit
          -k indicates the k-th parameter had an illegal value</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b9fe83560bacaba5de4d7ac54653b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dsbt21 </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSBT21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSBT21  generally checks a decomposition of the form

         A = U S U'

 where ' means transpose, A is symmetric banded, U is
 orthogonal, and S is diagonal (if KS=0) or symmetric
 tridiagonal (if KS=1).

 Specifically:

         RESULT(1) = | A - U S U' | / ( |A| n ulp ) *andC&gt;         RESULT(2) = | I - UU' | / ( n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, DSBT21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KA</td><td><pre class="fragment">          KA is INTEGER
          The bandwidth of the matrix A.  It must be at least zero.  If
          it is larger than N-1, then max( 0, N-1 ) will be used.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KS</td><td><pre class="fragment">          KS is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least min( KA, N-1 ).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KS=0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
          The orthogonal matrix in the decomposition, expressed as a
          dense matrix (i.e., not as a product of Householder
          transformations, Givens transformations, etc.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N**2+N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga928f4bcc4b7ac39d393fd7df69b1c6dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dsgt01 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSGT01</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DDGT01 checks a decomposition of the form

    A Z   =  B Z D or
    A B Z =  Z D or
    B A Z =  Z D

 where A is a symmetric matrix, B is
 symmetric positive definite, Z is orthogonal, and D is diagonal.

 One of the following test ratios is computed:

 ITYPE = 1:  RESULT(1) = | A Z - B Z D | / ( |A| |Z| n ulp )

 ITYPE = 2:  RESULT(1) = | A B Z - Z D | / ( |A| |Z| n ulp )

 ITYPE = 3:  RESULT(1) = | B A Z - Z D | / ( |A| |Z| n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          The form of the symmetric generalized eigenproblem.
          = 1:  A*z = (lambda)*B*z
          = 2:  A*B*z = (lambda)*z
          = 3:  B*A*z = (lambda)*z</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          symmetric matrices A and B is stored.
          = 'U':  Upper triangular
          = 'L':  Lower triangular</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix A.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of eigenvalues found.  0 &lt;= M &lt;= N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          The original symmetric matrix A.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (LDB, N)
          The original symmetric positive definite matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is DOUBLE PRECISION array, dimension (LDZ, M)
          The computed eigenvectors of the generalized eigenproblem.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDZ</td><td><pre class="fragment">          LDZ is INTEGER
          The leading dimension of the array Z.  LDZ &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (M)
          The computed eigenvalues of the generalized eigenproblem.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (1)
          The test ratio as described above.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gab8c1ed076508e5ae3b39e824e27790cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tnc_8c.html#aa7b64cdf39500931f7b333343791a104">logical</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dslect </td>
          <td>(</td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ZR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ZI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSLECT</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSLECT returns .TRUE. if the eigenvalue ZR+sqrt(-1)*ZI is to be
 selected, and otherwise it returns .FALSE.
 It is used by DCHK41 to test if DGEES succesfully sorts eigenvalues,
 and by DCHK43 to test if DGEESX succesfully sorts eigenvalues.

 The common block /SSLCT/ controls how eigenvalues are selected.
 If SELOPT = 0, then DSLECT return .TRUE. when ZR is less than zero,
 and .FALSE. otherwise.
 If SELOPT is at least 1, DSLECT returns SELVAL(SELOPT) and adds 1
 to SELOPT, cycling back to 1 at SELMAX.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ZR</td><td><pre class="fragment">          ZR is DOUBLE PRECISION
          The real part of a complex eigenvalue ZR + i*ZI.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZI</td><td><pre class="fragment">          ZI is DOUBLE PRECISION
          The imaginary part of a complex eigenvalue ZR + i*ZI.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaecf7333dd6afe3a4fb228534b24c1533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dspt21 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSPT21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSPT21  generally checks a decomposition of the form

         A = U S U'

 where ' means transpose, A is symmetric (stored in packed format), U
 is orthogonal, and S is diagonal (if KBAND=0) or symmetric
 tridiagonal (if KBAND=1).  If ITYPE=1, then U is represented as a
 dense matrix, otherwise the U is expressed as a product of
 Householder transformations, whose vectors are stored in the array
 "V" and whose scaling constants are in "TAU"; we shall use the
 letter "V" to refer to the product of Householder transformations
 (which should be equal to U).

 Specifically, if ITYPE=1, then:

         RESULT(1) = | A - U S U' | / ( |A| n ulp ) *andC&gt;         RESULT(2) = | I - UU' | / ( n ulp )

 If ITYPE=2, then:

         RESULT(1) = | A - V S V' | / ( |A| n ulp )

 If ITYPE=3, then:

         RESULT(1) = | I - VU' | / ( n ulp )

 Packed storage means that, for example, if UPLO='U', then the columns
 of the upper triangle of A are stored one after another, so that
 A(1,j+1) immediately follows A(j,j) in the array AP.  Similarly, if
 UPLO='L', then the columns of the lower triangle of A are stored one
 after another in AP, so that A(j+1,j+1) immediately follows A(n,j)
 in the array AP.  This means that A(i,j) is stored in:

    AP( i + j*(j-1)/2 )                 if UPLO='U'

    AP( i + (2*n-j)*(j-1)/2 )           if UPLO='L'

 The array VP bears the same relation to the matrix V that A does to
 AP.

 For ITYPE &gt; 1, the transformation U is expressed as a product
 of Householder transformations:

    If UPLO='U', then  V = H(n-1)...H(1),  where

        H(j) = I  -  tau(j) v(j) v(j)'

    and the first j-1 elements of v(j) are stored in V(1:j-1,j+1),
    (i.e., VP( j*(j+1)/2 + 1 : j*(j+1)/2 + j-1 ) ),
    the j-th element is 1, and the last n-j elements are 0.

    If UPLO='L', then  V = H(1)...H(n-1),  where

        H(j) = I  -  tau(j) v(j) v(j)'

    and the first j elements of v(j) are 0, the (j+1)-st is 1, and the
    (j+2)-nd through n-th elements are stored in V(j+2:n,j) (i.e.,
    in VP( (2*n-j)*(j-1)/2 + j+2 : (2*n-j)*(j-1)/2 + n ) .)</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC&gt;             RESULT(2) = | I - UU' | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V' | / ( |A| n ulp )

          3: U expressed both as a dense orthogonal matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - VU' | / ( n ulp )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER
          If UPLO='U', AP and VP are considered to contain the upper
          triangle of A and V.
          If UPLO='L', AP and VP are considered to contain the lower
          triangle of A and V.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, DSPT21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AP</td><td><pre class="fragment">          AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and contains the columns of just the upper
          triangle (UPLO='U') or only the lower triangle (UPLO='L'),
          packed one after another.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VP</td><td><pre class="fragment">          VP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the orthogonal matrix
          in the decomposition, as described in purpose.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is DOUBLE PRECISION array, dimension (N)
          If ITYPE &gt;= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE &lt; 2, then TAU is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N**2+N)
          Workspace.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaee97881cc8f081baf0b4bf6bc4abfd46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dstech </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>EIG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSTECH</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    Let T be the tridiagonal matrix with diagonal entries A(1) ,...,
    A(N) and offdiagonal entries B(1) ,..., B(N-1)).  DSTECH checks to
    see if EIG(1) ,..., EIG(N) are indeed accurate eigenvalues of T.
    It does this by expanding each EIG(I) into an interval
    [SVD(I) - EPS, SVD(I) + EPS], merging overlapping intervals if
    any, and using Sturm sequences to count and verify whether each
    resulting interval has the correct number of eigenvalues (using
    DSTECT).  Here EPS = TOL*MAZHEPS*MAXEIG, where MACHEPS is the
    machine precision and MAXEIG is the absolute value of the largest
    eigenvalue. If each interval contains the correct number of
    eigenvalues, INFO = 0 is returned, otherwise INFO is the index of
    the first eigenvalue in the first bad interval.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (N)
          The diagonal entries of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (N-1)
          The offdiagonal entries of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EIG</td><td><pre class="fragment">          EIG is DOUBLE PRECISION array, dimension (N)
          The purported eigenvalues to be checked.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TOL</td><td><pre class="fragment">          TOL is DOUBLE PRECISION
          Error tolerance for checking, a multiple of the
          machine precision.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          0  if the eigenvalues are all correct (to within
             1 +- TOL*MAZHEPS*MAXEIG)
          &gt;0 if the interval containing the INFO-th eigenvalue
             contains the incorrect number of eigenvalues.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5467550660ec78049bd9d095d06fc25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dstect </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SHIFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSTECT</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    DSTECT counts the number NUM of eigenvalues of a tridiagonal
    matrix T which are less than or equal to SHIFT. T has
    diagonal entries A(1), ... , A(N), and offdiagonal entries
    B(1), ..., B(N-1).
    See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
    Matrix", Report CS41, Computer Science Dept., Stanford
    University, July 21, 1966</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (N)
          The diagonal entries of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">          B is DOUBLE PRECISION array, dimension (N-1)
          The offdiagonal entries of the tridiagonal matrix T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SHIFT</td><td><pre class="fragment">          SHIFT is DOUBLE PRECISION
          The shift, used as described under Purpose.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NUM</td><td><pre class="fragment">          NUM is INTEGER
          The number of eigenvalues of T less than or equal
          to SHIFT.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gafcc98f0ae883a4f4a2be0bb1ae45b608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dstt21 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSTT21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSTT21 checks a decomposition of the form

    A = U S U'

 where ' means transpose, A is symmetric tridiagonal, U is orthogonal,
 and S is diagonal (if KBAND=0) or symmetric tridiagonal (if KBAND=1).
 Two tests are performed:

    RESULT(1) = | A - U S U' | / ( |A| n ulp )

    RESULT(2) = | I - UU' | / ( n ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, DSTT21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AD</td><td><pre class="fragment">          AD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be symmetric tridiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AE</td><td><pre class="fragment">          AE is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be symmetric tridiagonal.  AE(1) is the (1,2)
          and (2,1) element, AE(2) is the (2,3) and (3,2) element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is the
          (1,2) and (2,1) element, SE(2) is the (2,3) and (3,2)
          element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
          The orthogonal matrix in the decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (N*(N+1))</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gabffce2d056146c156467c485904cb413"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dstt22 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>AE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldwork, * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSTT22</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSTT22  checks a set of M eigenvalues and eigenvectors,

     A U = U S

 where A is symmetric tridiagonal, the columns of U are orthogonal,
 and S is diagonal (if KBAND=0) or symmetric tridiagonal (if KBAND=1).
 Two tests are performed:

    RESULT(1) = | U' A U - S | / ( |A| m ulp )

    RESULT(2) = | I - U'U | / ( m ulp )</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, DSTT22 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of eigenpairs to check.  If it is zero, DSTT22
          does nothing.  It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AD</td><td><pre class="fragment">          AD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be symmetric tridiagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AE</td><td><pre class="fragment">          AE is DOUBLE PRECISION array, dimension (N)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be symmetric tridiagonal.  AE(1) is ignored,
          AE(2) is the (1,2) and (2,1) element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SD</td><td><pre class="fragment">          SD is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SE</td><td><pre class="fragment">          SE is DOUBLE PRECISION array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is
          ignored, SE(2) is the (1,2) and (2,1) element, etc.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
          The orthogonal matrix in the decomposition.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (LDWORK, M+1)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDWORK</td><td><pre class="fragment">          LDWORK is INTEGER
          The leading dimension of WORK.  LDWORK must be at least
          max(1,M).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga970e8ed2adc72fcf96d412fcb3d33226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dsvdch </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>SVD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSVDCH</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSVDCH checks to see if SVD(1) ,..., SVD(N) are accurate singular
 values of the bidiagonal matrix B with diagonal entries
 S(1) ,..., S(N) and superdiagonal entries E(1) ,..., E(N-1)).
 It does this by expanding each SVD(I) into an interval
 [SVD(I) * (1-EPS) , SVD(I) * (1+EPS)], merging overlapping intervals
 if any, and using Sturm sequences to count and verify whether each
 resulting interval has the correct number of singular values (using
 DSVDCT). Here EPS=TOL*MAX(N/10,1)*MAZHEP, where MACHEP is the
 machine precision. The routine assumes the singular values are sorted
 with SVD(1) the largest and SVD(N) smallest.  If each interval
 contains the correct number of singular values, INFO = 0 is returned,
 otherwise INFO is the index of the first singular value in the first
 bad interval.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension (N)
          The diagonal entries of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N-1)
          The superdiagonal entries of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SVD</td><td><pre class="fragment">          SVD is DOUBLE PRECISION array, dimension (N)
          The computed singular values to be checked.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TOL</td><td><pre class="fragment">          TOL is DOUBLE PRECISION
          Error tolerance for checking, a multiplier of the
          machine precision.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          =0 if the singular values are all correct (to within
             1 +- TOL*MAZHEPS)
          &gt;0 if the interval containing the INFO-th singular value
             contains the incorrect number of singular values.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gacfc6bc302348dc1e4790a98d3bcefb67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dsvdct </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>SHIFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>NUM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSVDCT</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSVDCT counts the number NUM of eigenvalues of a 2*N by 2*N
 tridiagonal matrix T which are less than or equal to SHIFT.  T is
 formed by putting zeros on the diagonal and making the off-diagonals
 equal to S(1), E(1), S(2), E(2), ... , E(N-1), S(N).  If SHIFT is
 positive, NUM is equal to N plus the number of singular values of a
 bidiagonal matrix B less than or equal to SHIFT.  Here B has diagonal
 entries S(1), ..., S(N) and superdiagonal entries E(1), ... E(N-1).
 If SHIFT is negative, NUM is equal to the number of singular values
 of B greater than or equal to -SHIFT.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford University,
 July 21, 1966</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The dimension of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td><pre class="fragment">          S is DOUBLE PRECISION array, dimension (N)
          The diagonal entries of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array of dimension (N-1)
          The superdiagonal entries of the bidiagonal matrix B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SHIFT</td><td><pre class="fragment">          SHIFT is DOUBLE PRECISION
          The shift, used as described under Purpose.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NUM</td><td><pre class="fragment">          NUM is INTEGER
          The number of eigenvalues of T less than or equal to SHIFT.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ddc3e6002ccca1ee7b31370e4e8b523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a> <a class="el" href="afunc_8m.html#a7b5e596df91eadea6c537c0825e894a7">function</a> dsxt1 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IJOB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ABSTOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>ULP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>&#160;</td>
          <td class="paramname"><em>UNFL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSXT1</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSXT1  computes the difference between a set of eigenvalues.
 The result is returned as the function value.

 IJOB = 1:   Computes   max { min | D1(i)-D2(j) | }
                         i     j

 IJOB = 2:   Computes   max { min | D1(i)-D2(j) | /
                         i     j
                              ( ABSTOL + |D1(i)|*ULP ) }</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IJOB</td><td><pre class="fragment">          IJOB is INTEGER
          Specifies the type of tests to be performed.  (See above.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D1</td><td><pre class="fragment">          D1 is DOUBLE PRECISION array, dimension (N1)
          The first array.  D1 should be in increasing order, i.e.,
          D1(j) &lt;= D1(j+1).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N1</td><td><pre class="fragment">          N1 is INTEGER
          The length of D1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D2</td><td><pre class="fragment">          D2 is DOUBLE PRECISION array, dimension (N2)
          The second array.  D2 should be in increasing order, i.e.,
          D2(j) &lt;= D2(j+1).</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N2</td><td><pre class="fragment">          N2 is INTEGER
          The length of D2.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ABSTOL</td><td><pre class="fragment">          ABSTOL is DOUBLE PRECISION
          The absolute tolerance, used as a measure of the error.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ULP</td><td><pre class="fragment">          ULP is DOUBLE PRECISION
          Machine precision.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UNFL</td><td><pre class="fragment">          UNFL is DOUBLE PRECISION
          The smallest positive number whose reciprocal does not
          overflow.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6ec778bf025e73e4c067632270cd5e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dsyt21 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSYT21</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> DSYT21 generally checks a decomposition of the form

    A = U S U'

 where ' means transpose, A is symmetric, U is orthogonal, and S is
 diagonal (if KBAND=0) or symmetric tridiagonal (if KBAND=1).

 If ITYPE=1, then U is represented as a dense matrix; otherwise U is
 expressed as a product of Householder transformations, whose vectors
 are stored in the array "V" and whose scaling constants are in "TAU".
 We shall use the letter "V" to refer to the product of Householder
 transformations (which should be equal to U).

 Specifically, if ITYPE=1, then:

    RESULT(1) = | A - U S U' | / ( |A| n ulp ) *andC&gt;    RESULT(2) = | I - UU' | / ( n ulp )

 If ITYPE=2, then:

    RESULT(1) = | A - V S V' | / ( |A| n ulp )

 If ITYPE=3, then:

    RESULT(1) = | I - VU' | / ( n ulp )

 For ITYPE &gt; 1, the transformation U is expressed as a product
 V = H(1)...H(n-2),  where H(j) = I  -  tau(j) v(j) v(j)' and each
 vector v(j) has its first j elements 0 and the remaining n-j elements
 stored in V(j+1:n,j).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ITYPE</td><td><pre class="fragment">          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC&gt;             RESULT(2) = | I - UU' | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V' | / ( |A| n ulp )

          3: U expressed both as a dense orthogonal matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - VU' | / ( n ulp )</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UPLO</td><td><pre class="fragment">          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The size of the matrix.  If it is zero, DSYT21 does nothing.
          It must be at least zero.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KBAND</td><td><pre class="fragment">          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classA.html">A</a></td><td><pre class="fragment">          A is DOUBLE PRECISION array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td><pre class="fragment">          D is DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td><pre class="fragment">          E is DOUBLE PRECISION array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td><pre class="fragment">          U is DOUBLE PRECISION array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDU</td><td><pre class="fragment">          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td><pre class="fragment">          V is DOUBLE PRECISION array, dimension (LDV, N)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the orthogonal matrix
          in the decomposition.  If UPLO='L', then the vectors are in
          the lower triangle, if UPLO='U', then in the upper
          triangle.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDV</td><td><pre class="fragment">          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TAU</td><td><pre class="fragment">          TAU is DOUBLE PRECISION array, dimension (N)
          If ITYPE &gt;= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE &lt; 2, then TAU is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is DOUBLE PRECISION array, dimension (2*N**2)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RESULT</td><td><pre class="fragment">          RESULT is DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa55d41534d46929dbd30b8abc36f11b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine dsyt22 </td>
          <td>(</td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ITYPE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>UPLO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>KBAND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldu, * )&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( ldv, * )&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>TAU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double <a class="el" href="numinquire_8h.html#a2c8e616467665d0b2814d4c1589ba74e">precision</a>, dimension( 2 )&#160;</td>
          <td class="paramname"><em>RESULT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>DSYT22</b> </p>
<dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">      DSYT22  generally checks a decomposition of the form

              A U = U S

      where A is symmetric, the columns of U are orthonormal, and S
      is diagonal (if KBAND=0) or symmetric tridiagonal (if
      KBAND=1).  If ITYPE=1, then U is represented as a dense matrix,
      otherwise the U is expressed as a product of Householder
      transformations, whose vectors are stored in the array "V" and
      whose scaling constants are in "TAU"; we shall use the letter
      "V" to refer to the product of Householder transformations
      (which should be equal to U).

      Specifically, if ITYPE=1, then:

              RESULT(1) = | U' A U - S | / ( |A| m ulp ) *andC&gt;              RESULT(2) = | I - U'U | / ( m ulp )</pre> <pre class="fragment">  ITYPE   INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC&gt;             RESULT(2) = | I - UU' | / ( n ulp )

  UPLO    CHARACTER
          If UPLO='U', the upper triangle of A will be used and the
          (strictly) lower triangle will not be referenced.  If
          UPLO='L', the lower triangle of A will be used and the
          (strictly) upper triangle will not be referenced.
          Not modified.

  N       INTEGER
          The size of the matrix.  If it is zero, DSYT22 does nothing.
          It must be at least zero.
          Not modified.

  M       INTEGER
          The number of columns of U.  If it is zero, DSYT22 does
          nothing.  It must be at least zero.
          Not modified.

  KBAND   INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.
          Not modified.

  A       DOUBLE PRECISION array, dimension (LDA , N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.
          Not modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.
          Not modified.

  D       DOUBLE PRECISION array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.
          Not modified.

  E       DOUBLE PRECISION array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is ignored, E(2) is the (1,2) and (2,1) element, etc.
          Not referenced if KBAND=0.
          Not modified.

  U       DOUBLE PRECISION array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.
          Not modified.

  LDU     INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.
          Not modified.

  V       DOUBLE PRECISION array, dimension (LDV, N)
          If ITYPE=2 or 3, the lower triangle of this array contains
          the Householder vectors used to describe the orthogonal
          matrix in the decomposition.  If ITYPE=1, then it is not
          referenced.
          Not modified.

  LDV     INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.
          Not modified.

  TAU     DOUBLE PRECISION array, dimension (N)
          If ITYPE &gt;= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE &lt; 2, then TAU is not referenced.
          Not modified.

  WORK    DOUBLE PRECISION array, dimension (2*N**2)
          Workspace.
          Modified.

  RESULT  DOUBLE PRECISION array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if LDU is at least N.
          Modified.</pre> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2011 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:25:22 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
