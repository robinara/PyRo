\hypertarget{chegvd_8f}{}\section{packages/lapack-\/3.5.0/\+S\+R\+C/chegvd.f File Reference}
\label{chegvd_8f}\index{packages/lapack-\/3.\+5.\+0/\+S\+R\+C/chegvd.\+f@{packages/lapack-\/3.\+5.\+0/\+S\+R\+C/chegvd.\+f}}
\subsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
subroutine \hyperlink{chegvd_8f_a28ad734cb8f4deb96ba59c568cf3389e}{chegvd} (I\+T\+Y\+P\+E, J\+O\+B\+Z, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, W, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, L\+R\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries C\+H\+E\+G\+S\+T} \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function/\+Subroutine Documentation}
\hypertarget{chegvd_8f_a28ad734cb8f4deb96ba59c568cf3389e}{}\index{chegvd.\+f@{chegvd.\+f}!chegvd@{chegvd}}
\index{chegvd@{chegvd}!chegvd.\+f@{chegvd.\+f}}
\subsubsection[{chegvd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine chegvd (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{J\+O\+B\+Z, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{{\bf complex}, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{{\bf complex}, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{W, }
\item[{{\bf complex}, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{L\+R\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{chegvd_8f_a28ad734cb8f4deb96ba59c568cf3389e}


{\bfseries C\+H\+E\+G\+S\+T} 

 \begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} CHEGVD computes all the eigenvalues, and optionally, the eigenvectors
 of a complex generalized Hermitian-definite eigenproblem, of the form
 A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
 B are assumed to be Hermitian and B is also positive definite.
 If eigenvectors are desired, it uses a divide and conquer algorithm.

 The divide and conquer algorithm makes very mild assumptions about
 floating point arithmetic. It will work on machines with a guard
 digit in add/subtract, or on those binary machines without guard
 digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
 Cray-2. It could conceivably fail on hexadecimal or decimal machines
 without guard digits, but we know of none.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          Specifies the problem type to be solved:
          = 1:  A*x = (lambda)*B*x
          = 2:  A*B*x = (lambda)*x
          = 3:  B*A*x = (lambda)*x\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em J\+O\+B\+Z} & \begin{DoxyVerb}          JOBZ is CHARACTER*1
          = 'N':  Compute eigenvalues only;
          = 'V':  Compute eigenvalues and eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          = 'U':  Upper triangles of A and B are stored;
          = 'L':  Lower triangles of A and B are stored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is COMPLEX array, dimension (LDA, N)
          On entry, the Hermitian matrix A.  If UPLO = 'U', the
          leading N-by-N upper triangular part of A contains the
          upper triangular part of the matrix A.  If UPLO = 'L',
          the leading N-by-N lower triangular part of A contains
          the lower triangular part of the matrix A.

          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
          matrix Z of eigenvectors.  The eigenvectors are normalized
          as follows:
          if ITYPE = 1 or 2, Z**H*B*Z = I;
          if ITYPE = 3, Z**H*inv(B)*Z = I.
          If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
          or the lower triangle (if UPLO='L') of A, including the
          diagonal, is destroyed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is COMPLEX array, dimension (LDB, N)
          On entry, the Hermitian matrix B.  If UPLO = 'U', the
          leading N-by-N upper triangular part of B contains the
          upper triangular part of the matrix B.  If UPLO = 'L',
          the leading N-by-N lower triangular part of B contains
          the lower triangular part of the matrix B.

          On exit, if INFO <= N, the part of B containing the matrix is
          overwritten by the triangular factor U or L from the Cholesky
          factorization B = U**H*U or B = L*L**H.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W} & \begin{DoxyVerb}          W is REAL array, dimension (N)
          If INFO = 0, the eigenvalues in ascending order.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is COMPLEX array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The length of the array WORK.
          If N <= 1,                LWORK >= 1.
          If JOBZ  = 'N' and N > 1, LWORK >= N + 1.
          If JOBZ  = 'V' and N > 1, LWORK >= 2*N + N**2.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal sizes of the WORK, RWORK and
          IWORK arrays, returns these values as the first entries of
          the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (MAX(1,LRWORK))
          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+R\+W\+O\+R\+K} & \begin{DoxyVerb}          LRWORK is INTEGER
          The dimension of the array RWORK.
          If N <= 1,                LRWORK >= 1.
          If JOBZ  = 'N' and N > 1, LRWORK >= N.
          If JOBZ  = 'V' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.

          If LRWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (MAX(1,LIWORK))
          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+I\+W\+O\+R\+K} & \begin{DoxyVerb}          LIWORK is INTEGER
          The dimension of the array IWORK.
          If N <= 1,                LIWORK >= 1.
          If JOBZ  = 'N' and N > 1, LIWORK >= 1.
          If JOBZ  = 'V' and N > 1, LIWORK >= 3 + 5*N.

          If LIWORK = -1, then a workspace query is assumed; the
          routine only calculates the optimal sizes of the WORK, RWORK
          and IWORK arrays, returns these values as the first entries
          of the WORK, RWORK and IWORK arrays, and no error message
          related to LWORK or LRWORK or LIWORK is issued by XERBLA.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value
          > 0:  CPOTRF or CHEEVD returned an error code:
             <= N:  if INFO = i and JOBZ = 'N', then the algorithm
                    failed to converge; i off-diagonal elements of an
                    intermediate tridiagonal form did not converge to
                    zero;
                    if INFO = i and JOBZ = 'V', then the algorithm
                    failed to compute an eigenvalue while working on
                    the submatrix lying in rows and columns INFO/(N+1)
                    through mod(INFO,N+1);
             > N:   if INFO = N + i, for 1 <= i <= N, then the leading
                    minor of order i of B is not positive definite.
                    The factorization of B could not be completed and
                    no eigenvalues or eigenvectors were computed.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\begin{DoxyParagraph}{Further Details\+: }
\begin{DoxyVerb}  Modified so that no backsubstitution is performed if CHEEVD fails to
  converge (NEIG in old code could be greater than N causing out of
  bounds reference to A - reported by Ralf Meyer).  Also corrected the
  description of INFO and the test on ITYPE. Sven, 16 Feb 05.\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Contributors\+: }
Mark Fahey, Department of Mathematics, Univ. of Kentucky, U\+S\+A 
\end{DoxyParagraph}
