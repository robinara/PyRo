\hypertarget{group__single__eig}{}\section{real}
\label{group__single__eig}\index{real@{real}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
subroutine \hyperlink{group__single__eig_ga8ea54400bae844773a0e4cec9ab51ccd}{sbdt01} (M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, Q, L\+D\+Q, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, P\+T, L\+D\+P\+T, W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+B\+D\+T01} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga65060c7c0f1fcff75daedf24c07e1024}{sbdt02} (M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, C, L\+D\+C, U, L\+D\+U, W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+B\+D\+T02} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gadade0477c176c076de24e4e719687a5d}{sbdt03} (U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+D, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, S, V\+T, L\+D\+V\+T, W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+B\+D\+T03} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga561a20d64458f92f3e4cf00aab784a20}{schkbb} (N\+S\+I\+Z\+E\+S, M\+V\+A\+L, N\+V\+A\+L, N\+W\+D\+T\+H\+S, K\+K, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, A\+B, L\+D\+A\+B, B\+D, B\+E, Q, L\+D\+Q, P, L\+D\+P, C, L\+D\+C, C\+C, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+B\+B} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga03e7367f702235ab4a852cec4d6dd1c8}{schkbd} (N\+S\+I\+Z\+E\+S, M\+V\+A\+L, N\+V\+A\+L, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B\+D, B\+E, S1, S2, X, L\+D\+X, Y, Z, Q, L\+D\+Q, P\+T, L\+D\+P\+T, U, V\+T, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+B\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaf2b54e7c6663d08f2287b4d8227e53bf}{schkbk} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+B\+K} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga0625d9829033282f25e479936bdaee20}{schkbl} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+B\+L} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga59636355218ca7955eee8e253db3329a}{schkec} (\hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, T\+S\+T\+E\+R\+R, N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+E\+C} \end{DoxyCompactList}\item 
program \hyperlink{group__single__eig_gaa05ae9ee47877fe74bea22f30f3e1b41}{schkee}
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+E\+E} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga9f423a19ff92049fe736bf71a7bfa7c7}{schkgg} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, T\+S\+T\+D\+I\+F, T\+H\+R\+S\+H\+N, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, H, T, S1, S2, P1, P2, U, L\+D\+U, V, Q, Z, A\+L\+P\+H\+R1, A\+L\+P\+H\+I1, B\+E\+T\+A1, A\+L\+P\+H\+R3, A\+L\+P\+H\+I3, B\+E\+T\+A3, E\+V\+E\+C\+T\+L, E\+V\+E\+C\+T\+R, W\+O\+R\+K, L\+W\+O\+R\+K, L\+L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+G\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga30cf9f83367d540b803fbd2b264dde8f}{schkgk} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+G\+K} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gae4e43fee22351ea965e03ba9228aff5a}{schkgl} (N\+I\+N, N\+O\+U\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+G\+L} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gad6528d7acb91f950d1fae5bf68961251}{schkhs} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, T1, T2, U, L\+D\+U, Z, U\+Z, W\+R1, W\+I1, W\+R3, W\+I3, E\+V\+E\+C\+T\+L, E\+V\+E\+C\+T\+R, E\+V\+E\+C\+T\+Y, E\+V\+E\+C\+T\+X, U\+U, T\+A\+U, W\+O\+R\+K, N\+W\+O\+R\+K, I\+W\+O\+R\+K, S\+E\+L\+E\+C\+T, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+H\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gadbebec63ce21bd4a5e4f86e93fbfbd16}{schksb} (N\+S\+I\+Z\+E\+S, N\+N, N\+W\+D\+T\+H\+S, K\+K, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, S\+D, S\+E, U, L\+D\+U, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+S\+B} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga78dcfb18a5c0e962c63effd1914f11a3}{schkst} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, A\+P, S\+D, S\+E, D1, D2, D3, D4, D5, W\+A1, W\+A2, W\+A3, W\+R, U, L\+D\+U, V, V\+P, T\+A\+U, Z, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+H\+K\+S\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga41b0a1a7d888674eac14ad251c2d94ec}{sckcsd} (N\+M, M\+V\+A\+L, P\+V\+A\+L, Q\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, M\+M\+A\+X, X, X\+F, U1, U2, V1\+T, V2\+T, T\+H\+E\+T\+A, I\+W\+O\+R\+K, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+K\+C\+S\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga0bb2e8d26a324ab0a58f7f742aef9033}{sckglm} (N\+N, M\+V\+A\+L, P\+V\+A\+L, N\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, B, B\+F, X, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+K\+G\+L\+M} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaf6b93922e8173c77def9bd60602f8cf0}{sckgqr} (N\+M, M\+V\+A\+L, N\+P, P\+V\+A\+L, N\+N, N\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, A\+Q, A\+R, T\+A\+U\+A, B, B\+F, B\+Z, B\+T, B\+W\+K, T\+A\+U\+B, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+K\+G\+Q\+R} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga44899af4fbfbe9973dcdfbce9e32977d}{sckgsv} (N\+M, M\+V\+A\+L, P\+V\+A\+L, N\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, B, B\+F, U, V, Q, A\+L\+P\+H\+A, B\+E\+T\+A, R, I\+W\+O\+R\+K, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+K\+G\+S\+V} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gab468002a1d34c94fa7185710bac534a3}{scklse} (N\+N, M\+V\+A\+L, P\+V\+A\+L, N\+V\+A\+L, N\+M\+A\+T\+S, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+M\+A\+X, \hyperlink{classA}{A}, A\+F, B, B\+F, X, W\+O\+R\+K, R\+W\+O\+R\+K, N\+I\+N, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+K\+L\+S\+E} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga78ceb344e13f1336e85930c14689975f}{scsdts} (M, P, Q, X, X\+F, L\+D\+X, U1, L\+D\+U1, U2, L\+D\+U2, V1\+T, L\+D\+V1\+T, V2\+T, L\+D\+V2\+T, T\+H\+E\+T\+A, I\+W\+O\+R\+K, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+C\+S\+D\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaf011c82fb3efb201f7568fe7acac6d3b}{sdrges} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, S, T, Q, L\+D\+Q, Z, A\+L\+P\+H\+A\+R, A\+L\+P\+H\+A\+I, B\+E\+T\+A, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+G\+E\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gae07927c6321c12cd0d92450eaa21ea9c}{sdrgev} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, S, T, Q, L\+D\+Q, Z, Q\+E, L\+D\+Q\+E, A\+L\+P\+H\+A\+R, A\+L\+P\+H\+A\+I, B\+E\+T\+A, A\+L\+P\+H\+R1, A\+L\+P\+H\+I1, B\+E\+T\+A1, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+G\+E\+V} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gae0b0f905c9537cea1599d61c17e003bc}{sdrgsx} (N\+S\+I\+Z\+E, N\+C\+M\+A\+X, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+N, N\+O\+U\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, A\+I, B\+I, Z, Q, A\+L\+P\+H\+A\+R, A\+L\+P\+H\+A\+I, B\+E\+T\+A, C, L\+D\+C, S, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+G\+S\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga01b4d3586799e995efa59513c1bc9ec2}{sdrgvx} (N\+S\+I\+Z\+E, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+N, N\+O\+U\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, A\+I, B\+I, A\+L\+P\+H\+A\+R, A\+L\+P\+H\+A\+I, B\+E\+T\+A, V\+L, V\+R, I\+L\+O, I\+H\+I, L\+S\+C\+A\+L\+E, R\+S\+C\+A\+L\+E, S, S\+T\+R\+U, D\+I\+F, D\+I\+F\+T\+R\+U, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+G\+V\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga7a1566f98bf91396ed2fd1e2c70865eb}{sdrvbd} (N\+S\+I\+Z\+E\+S, M\+M, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, U, L\+D\+U, V\+T, L\+D\+V\+T, A\+S\+A\+V, U\+S\+A\+V, V\+T\+S\+A\+V, S, S\+S\+A\+V, E, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, N\+O\+U\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+B\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga1f741a939ab68209bb2d6028538da0c1}{sdrves} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, H\+T, W\+R, W\+I, W\+R\+T, W\+I\+T, V\+S, L\+D\+V\+S, R\+E\+S\+U\+L\+T, W\+O\+R\+K, N\+W\+O\+R\+K, I\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+E\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga375903897d1816ffdc66d54f50f80338}{sdrvev} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, W\+R, W\+I, W\+R1, W\+I1, V\+L, L\+D\+V\+L, V\+R, L\+D\+V\+R, L\+R\+E, L\+D\+L\+R\+E, R\+E\+S\+U\+L\+T, W\+O\+R\+K, N\+W\+O\+R\+K, I\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+E\+V} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gac7154f368e4073c5194d3976de3c83e8}{sdrvgg} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, T\+H\+R\+S\+H\+N, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, S, T, S2, T2, Q, L\+D\+Q, Z, A\+L\+P\+H\+R1, A\+L\+P\+H\+I1, B\+E\+T\+A1, A\+L\+P\+H\+R2, A\+L\+P\+H\+I2, B\+E\+T\+A2, V\+L, V\+R, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+G\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga1d66b6ef4236d0d0cf318e1c64930a38}{sdrvsg} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, Z, L\+D\+Z, A\+B, B\+B, A\+P, B\+P, W\+O\+R\+K, N\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+S\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga4965dd452a2ac5ea65814add61ac0113}{sdrvst} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, D1, D2, D3, D4, E\+V\+E\+I\+G\+S, W\+A1, W\+A2, W\+A3, U, L\+D\+U, V, T\+A\+U, Z, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, L\+I\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+S\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga411333994f433776dd07049fe3973a66}{sdrvsx} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+U\+N\+I\+T, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, H\+T, W\+R, W\+I, W\+R\+T, W\+I\+T, W\+R\+T\+M\+P, W\+I\+T\+M\+P, V\+S, L\+D\+V\+S, V\+S1, R\+E\+S\+U\+L\+T, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+S\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga91d3493bce6a97430fded1ad19b1bead}{sdrvvx} (N\+S\+I\+Z\+E\+S, N\+N, N\+T\+Y\+P\+E\+S, D\+O\+T\+Y\+P\+E, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, N\+I\+U\+N\+I\+T, N\+O\+U\+N\+I\+T, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, W\+R, W\+I, W\+R1, W\+I1, V\+L, L\+D\+V\+L, V\+R, L\+D\+V\+R, L\+R\+E, L\+D\+L\+R\+E, R\+C\+O\+N\+D\+V, R\+C\+N\+D\+V1, R\+C\+D\+V\+I\+N, R\+C\+O\+N\+D\+E, R\+C\+N\+D\+E1, R\+C\+D\+E\+I\+N, S\+C\+A\+L\+E, S\+C\+A\+L\+E1, R\+E\+S\+U\+L\+T, W\+O\+R\+K, N\+W\+O\+R\+K, I\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+D\+R\+V\+V\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaa15f9b7d5c1bd62dd1688a853242f973}{serrbd} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+E\+R\+R\+B\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga53ee6e84c6661f0c5f453945a0c6693d}{serrec} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+E\+R\+R\+E\+C} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gadd1c890cd165b23a2c57f8e0ea2e02dd}{serred} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+E\+R\+R\+E\+D} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga451a5d8e7e6e4ccb9e1f1fb915c022c0}{serrgg} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+E\+R\+R\+G\+G} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga6fd701d129a4ff99faeb82018435d60c}{serrhs} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+E\+R\+R\+H\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gae70b9c462a9febd73364f58aa8f4ad81}{serrst} (P\+A\+T\+H, N\+U\+N\+I\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+E\+R\+R\+S\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga3c268bce93f7da1dd297b590955402dd}{sget02} (\hyperlink{superlu__enum__consts_8h_a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58}{T\+R\+A\+N\+S}, M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, X, L\+D\+X, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, R\+W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T02} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga0e9e61f3b94abf4f82b4f53f382e11dc}{sget10} (M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T10} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga2a7d9603b3bd0ebb820f3a0ed88d760a}{sget22} (T\+R\+A\+N\+S\+A, T\+R\+A\+N\+S\+E, T\+R\+A\+N\+S\+W, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, E, L\+D\+E, W\+R, W\+I, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T22} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gade26c43e6d095c1129bdadb44e996089}{sget23} (C\+O\+M\+P, B\+A\+L\+A\+N\+C, J\+T\+Y\+P\+E, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, I\+S\+E\+E\+D, N\+O\+U\+N\+I\+T, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, W\+R, W\+I, W\+R1, W\+I1, V\+L, L\+D\+V\+L, V\+R, L\+D\+V\+R, L\+R\+E, L\+D\+L\+R\+E, R\+C\+O\+N\+D\+V, R\+C\+N\+D\+V1, R\+C\+D\+V\+I\+N, R\+C\+O\+N\+D\+E, R\+C\+N\+D\+E1, R\+C\+D\+E\+I\+N, S\+C\+A\+L\+E, S\+C\+A\+L\+E1, R\+E\+S\+U\+L\+T, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T23} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga35b38ff82fbc9f1d0f4e0eba2f7c497f}{sget24} (C\+O\+M\+P, J\+T\+Y\+P\+E, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, I\+S\+E\+E\+D, N\+O\+U\+N\+I\+T, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, H\+T, W\+R, W\+I, W\+R\+T, W\+I\+T, W\+R\+T\+M\+P, W\+I\+T\+M\+P, V\+S, L\+D\+V\+S, V\+S1, R\+C\+D\+E\+I\+N, R\+C\+D\+V\+I\+N, N\+S\+L\+C\+T, I\+S\+L\+C\+T, R\+E\+S\+U\+L\+T, W\+O\+R\+K, L\+W\+O\+R\+K, I\+W\+O\+R\+K, B\+W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T24} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga3ecf18b5f5029225a7ddd4a1c42208f2}{sget31} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T31} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaed4fdc62ebe7c28b1c0f06c7c7c53850}{sget32} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T32} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga3a331380ca2ad1894f1324093ca0b6bc}{sget33} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T33} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga982b1b2bcfb91803ffe5fe2c9ed62a19}{sget34} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T34} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gad00416cde934f3821bd9cbe854ddbd1e}{sget35} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T35} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga142bffda1c42659908f951ac51744638}{sget36} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T, N\+I\+N)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T36} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gac812301fb70fec79ae94eb13b0fa1466}{sget37} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T, N\+I\+N)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T37} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga15b379af6192edfd74986d7ef1b2e822}{sget38} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T, N\+I\+N)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T38} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gada7ad6b7b5fd36f8101d62c7b3d378dc}{sget39} (R\+M\+A\+X, L\+M\+A\+X, N\+I\+N\+F\+O, K\+N\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T39} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gac817155b9a60030bdc313807c2a10f76}{sget51} (I\+T\+Y\+P\+E, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, U, L\+D\+U, V, L\+D\+V, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T51} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaccd03e1eb309d22da705f8bd9a6b0b61}{sget52} (L\+E\+F\+T, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, E, L\+D\+E, A\+L\+P\+H\+A\+R, A\+L\+P\+H\+A\+I, B\+E\+T\+A, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T52} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga5fa2eab03c0b6a8a406b804107622c1f}{sget53} (\hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, S\+C\+A\+L\+E, W\+R, W\+I, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T53} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga445a7d10a693e781798a410681ab92a6}{sget54} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, S, L\+D\+S, T, L\+D\+T, U, L\+D\+U, V, L\+D\+V, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+E\+T54} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaa51af534646f9b5375c14c87ededdfbd}{sglmts} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, P, \hyperlink{classA}{A}, A\+F, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, B\+F, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, D\+F, X, U, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+L\+M\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga412f58b485b08b55197171f8c070dcee}{sgqrts} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, P, \hyperlink{classA}{A}, A\+F, Q, R, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, T\+A\+U\+A, B, B\+F, Z, T, B\+W\+K, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, T\+A\+U\+B, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+Q\+R\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga38549b2e96321b31dceb6b549fba78dc}{sgrqts} (M, P, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, A\+F, Q, R, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, T\+A\+U\+A, B, B\+F, Z, T, B\+W\+K, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, T\+A\+U\+B, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+R\+Q\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga7832a2929b4429ee218f59c00dab4956}{sgsvts} (M, P, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, A\+F, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, B\+F, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, U, L\+D\+U, V, L\+D\+V, Q, L\+D\+Q, A\+L\+P\+H\+A, B\+E\+T\+A, R, L\+D\+R, I\+W\+O\+R\+K, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+G\+S\+V\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gac3cc6f97fd6bdc607aab5f8bd0034054}{shst01} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, I\+L\+O, I\+H\+I, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, H, L\+D\+H, Q, L\+D\+Q, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+H\+S\+T01} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gac380bedffc2273fb83d72d857a28876a}{slafts} (T\+Y\+P\+E, M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, I\+M\+A\+T, N\+T\+E\+S\+T\+S, R\+E\+S\+U\+L\+T, I\+S\+E\+E\+D, \hyperlink{zlaqgs_8c_a0656018abfc9fa2821827415f5d5ea57}{T\+H\+R\+E\+S\+H}, I\+O\+U\+N\+I\+T, I\+E)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+A\+F\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaed2b768a1738ac80fc4df77690614cd9}{slahd2} (I\+O\+U\+N\+I\+T, P\+A\+T\+H)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+A\+H\+D2} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga3cbcfa1d9632a6c7fbf5611dc86826ab}{slarfy} (U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, V, I\+N\+C\+V, T\+A\+U, C, L\+D\+C, W\+O\+R\+K)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+A\+R\+F\+Y} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga67befe1509ef6eaf403bedf1c4bf4058}{slarhs} (P\+A\+T\+H, X\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{superlu__enum__consts_8h_a0c4e17b2d5cea33f9991ccc6a6678d62a1f61e3015bfe0f0c2c3fda4c5a0cdf58}{T\+R\+A\+N\+S}, M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+L, K\+U, \hyperlink{example__user_8c_aa0138da002ce2a90360df2f521eb3198}{N\+R\+H\+S}, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, X, L\+D\+X, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, I\+S\+E\+E\+D, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+A\+R\+H\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga9540564c76aed17bc8b26a879ee5ca46}{slatb9} (P\+A\+T\+H, I\+M\+A\+T, M, P, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, T\+Y\+P\+E, K\+L\+A, K\+U\+A, K\+L\+B, K\+U\+B, A\+N\+O\+R\+M, B\+N\+O\+R\+M, M\+O\+D\+E\+A, M\+O\+D\+E\+B, C\+N\+D\+N\+M\+A, C\+N\+D\+N\+M\+B, D\+I\+S\+T\+A, D\+I\+S\+T\+B)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+A\+T\+B9} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gae46d8275d9069151d2cf111296204a54}{slatm4} (I\+T\+Y\+P\+E, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, N\+Z1, N\+Z2, I\+S\+I\+G\+N, A\+M\+A\+G\+N, \hyperlink{superlu__enum__consts_8h_af00a42ecad444bbda75cde1b64bd7e72a9b5c151728d8512307565994c89919d5}{R\+C\+O\+N\+D}, T\+R\+I\+A\+N\+G, I\+D\+I\+S\+T, I\+S\+E\+E\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A})
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+A\+T\+M4} \end{DoxyCompactList}\item 
\hyperlink{tnc_8c_aa7b64cdf39500931f7b333343791a104}{logical} \hyperlink{afunc_8m_a7b5e596df91eadea6c537c0825e894a7}{function} \hyperlink{group__single__eig_ga895e457eb85e862c2a2caa9f12c060e2}{slctes} (Z\+R, Z\+I, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D})
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+C\+T\+E\+S} \end{DoxyCompactList}\item 
\hyperlink{tnc_8c_aa7b64cdf39500931f7b333343791a104}{logical} \hyperlink{afunc_8m_a7b5e596df91eadea6c537c0825e894a7}{function} \hyperlink{group__single__eig_gabe65b08f429234a57b6b3253ec7da694}{slctsx} (A\+R, A\+I, B\+E\+T\+A)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+C\+T\+S\+X} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga20ea4c39bd0bee5f869b9f9131c0c53d}{slsets} (M, P, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, A\+F, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, B\+F, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, C, C\+F, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, D\+F, X, W\+O\+R\+K, L\+W\+O\+R\+K, R\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+L\+S\+E\+T\+S} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga117c87e8771c05b0d10909b2a7176979}{sort01} (R\+O\+W\+C\+O\+L, M, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, U, L\+D\+U, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+I\+D)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+O\+R\+T01} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gacdb40a265d764f2ce962040de230c2f1}{sort03} (R\+C, M\+U, M\+V, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K, U, L\+D\+U, V, L\+D\+V, W\+O\+R\+K, L\+W\+O\+R\+K, R\+E\+S\+U\+L\+T, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+O\+R\+T03} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gaf79abbc26c3852094a0788e7a5a67daf}{ssbt21} (U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+A, K\+S, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+B\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga2e1600d5ba10895a2ed94275d190b187}{ssgt01} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, B, \hyperlink{example__user_8c_a50e90a7104df172b5a89a06c47fcca04}{L\+D\+B}, Z, L\+D\+Z, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+G\+T01} \end{DoxyCompactList}\item 
\hyperlink{tnc_8c_aa7b64cdf39500931f7b333343791a104}{logical} \hyperlink{afunc_8m_a7b5e596df91eadea6c537c0825e894a7}{function} \hyperlink{group__single__eig_ga9051201041524e344b189e8504011c6f}{sslect} (Z\+R, Z\+I)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+L\+E\+C\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gad6ad2fe75e582845dea427676497bbca}{sspt21} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+B\+A\+N\+D, A\+P, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, V\+P, T\+A\+U, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+P\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga455b022ce67894011ee08a1a4b0eb1ad}{sstech} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, B, E\+I\+G, T\+O\+L, W\+O\+R\+K, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+T\+E\+C\+H} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga1f72bc4c21b1b37d449ec5911e36d7d1}{sstect} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, \hyperlink{classA}{A}, B, S\+H\+I\+F\+T, N\+U\+M)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+T\+E\+C\+T} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga7e0e860e3759067b5e3ace2787d8415d}{sstt21} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+B\+A\+N\+D, A\+D, A\+E, S\+D, S\+E, U, L\+D\+U, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+T\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga939255a845788e786a4a5b786f878a22}{sstt22} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, K\+B\+A\+N\+D, A\+D, A\+E, S\+D, S\+E, U, L\+D\+U, W\+O\+R\+K, L\+D\+W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+T\+T22} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga27173aa839453594dfc1a893dff10f60}{ssvdch} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, S, E, S\+V\+D, T\+O\+L, I\+N\+F\+O)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+V\+D\+C\+H} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga1f89a00fd5baa9f3d801169211b98930}{ssvdct} (\hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, S, E, S\+H\+I\+F\+T, N\+U\+M)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+V\+D\+C\+T} \end{DoxyCompactList}\item 
real \hyperlink{afunc_8m_a7b5e596df91eadea6c537c0825e894a7}{function} \hyperlink{group__single__eig_ga8f56dead1fe2a44da7b5e261280a441e}{ssxt1} (I\+J\+O\+B, D1, N1, D2, N2, A\+B\+S\+T\+O\+L, U\+L\+P, U\+N\+F\+L)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+X\+T1} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_gacd0abbe15d93a0180c975f8b2af5f801}{ssyt21} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, K\+B\+A\+N\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, V, L\+D\+V, T\+A\+U, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+Y\+T21} \end{DoxyCompactList}\item 
subroutine \hyperlink{group__single__eig_ga4031914169fb1a0ddfd7dd67359c8b4f}{ssyt22} (I\+T\+Y\+P\+E, U\+P\+L\+O, \hyperlink{polmisc_8c_a0240ac851181b84ac374872dc5434ee4}{N}, M, K\+B\+A\+N\+D, \hyperlink{classA}{A}, \hyperlink{example__user_8c_ae946da542ce0db94dced19b2ecefd1aa}{L\+D\+A}, \hyperlink{odrpack_8h_a7dae6ea403d00f3687f24a874e67d139}{D}, E, U, L\+D\+U, V, L\+D\+V, T\+A\+U, W\+O\+R\+K, R\+E\+S\+U\+L\+T)
\begin{DoxyCompactList}\small\item\em {\bfseries S\+S\+Y\+T22} \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This is the group of real L\+A\+P\+A\+C\+K T\+E\+S\+T\+I\+N\+G E\+I\+G routines. 

\subsection{Function Documentation}
\hypertarget{group__single__eig_ga8ea54400bae844773a0e4cec9ab51ccd}{}\index{real@{real}!sbdt01@{sbdt01}}
\index{sbdt01@{sbdt01}!real@{real}}
\subsubsection[{sbdt01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sbdt01 (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{integer}]{K\+D, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( ldpt, $\ast$ )}]{P\+T, }
\item[{integer}]{L\+D\+P\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga8ea54400bae844773a0e4cec9ab51ccd}


{\bfseries S\+B\+D\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SBDT01 reconstructs a general matrix A from its bidiagonal form
    A = Q * B * P'
 where Q (m by min(m,n)) and P' (min(m,n) by n) are orthogonal
 matrices and B is bidiagonal.

 The test ratio to test the reduction is
    RESID = norm( A - Q * B * PT ) / ( n * norm(A) * EPS )
 where PT = P' and EPS is the machine precision.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrices A and Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and P'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+D} & \begin{DoxyVerb}          KD is INTEGER
          If KD = 0, B is diagonal and the array E is not referenced.
          If KD = 1, the reduction was performed by xGEBRD; B is upper
          bidiagonal if M >= N, and lower bidiagonal if M < N.
          If KD = -1, the reduction was performed by xGBBRD; B is
          always upper bidiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The m by n matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDQ,N)
          The m by min(m,n) orthogonal matrix Q in the reduction
          A = Q * B * P'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension (min(M,N))
          The diagonal elements of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (min(M,N)-1)
          The superdiagonal elements of the bidiagonal matrix B if
          m >= n, or the subdiagonal elements of B if m < n.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+T} & \begin{DoxyVerb}          PT is REAL array, dimension (LDPT,N)
          The min(m,n) by n orthogonal matrix P' in the reduction
          A = Q * B * P'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+P\+T} & \begin{DoxyVerb}          LDPT is INTEGER
          The leading dimension of the array PT.
          LDPT >= max(1,min(M,N)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (M+N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is REAL
          The test ratio:  norm(A - Q * B * P') / ( n * norm(A) * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga65060c7c0f1fcff75daedf24c07e1024}{}\index{real@{real}!sbdt02@{sbdt02}}
\index{sbdt02@{sbdt02}!real@{real}}
\subsubsection[{sbdt02}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sbdt02 (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga65060c7c0f1fcff75daedf24c07e1024}


{\bfseries S\+B\+D\+T02} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SBDT02 tests the change of basis C = U' * B by computing the residual

    RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),

 where B and C are M by N matrices, U is an M by M orthogonal matrix,
 and EPS is the machine precision.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrices B and C and the order of
          the matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices B and C.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,N)
          The m by n matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em C} & \begin{DoxyVerb}          C is REAL array, dimension (LDC,N)
          The m by n matrix C, assumed to contain U' * B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of the array C.  LDC >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU,M)
          The m by m orthogonal matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U.  LDU >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is REAL
          RESID = norm( B - U * C ) / ( max(m,n) * norm(B) * EPS ),\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gadade0477c176c076de24e4e719687a5d}{}\index{real@{real}!sbdt03@{sbdt03}}
\index{sbdt03@{sbdt03}!real@{real}}
\subsubsection[{sbdt03}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sbdt03 (
\begin{DoxyParamCaption}
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+D, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( $\ast$ )}]{S, }
\item[{real, dimension( ldvt, $\ast$ )}]{V\+T, }
\item[{integer}]{L\+D\+V\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__single__eig_gadade0477c176c076de24e4e719687a5d}


{\bfseries S\+B\+D\+T03} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SBDT03 reconstructs a bidiagonal matrix B from its SVD:
    S = U' * B * V
 where U and V are orthogonal matrices and S is diagonal.

 The test ratio to test the singular value decomposition is
    RESID = norm( B - U * S * VT ) / ( n * norm(B) * EPS )
 where VT = V' and EPS is the machine precision.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Specifies whether the matrix B is upper or lower bidiagonal.
          = 'U':  Upper bidiagonal
          = 'L':  Lower bidiagonal\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+D} & \begin{DoxyVerb}          KD is INTEGER
          The bandwidth of the bidiagonal matrix B.  If KD = 1, the
          matrix B is bidiagonal, and if KD = 0, B is diagonal and E is
          not referenced.  If KD is greater than 1, it is assumed to be
          1, and if KD is less than 0, it is assumed to be 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension (N)
          The n diagonal elements of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (N-1)
          The (n-1) superdiagonal elements of the bidiagonal matrix B
          if UPLO = 'U', or the (n-1) subdiagonal elements of B if
          UPLO = 'L'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU,N)
          The n by n orthogonal matrix U in the reduction B = U'*A*P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U.  LDU >= max(1,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension (N)
          The singular values from the SVD of B, sorted in decreasing
          order.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V\+T} & \begin{DoxyVerb}          VT is REAL array, dimension (LDVT,N)
          The n by n orthogonal matrix V' in the reduction
          B = U * S * V'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+T} & \begin{DoxyVerb}          LDVT is INTEGER
          The leading dimension of the array VT.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (2*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is REAL
          The test ratio:  norm(B - U * S * V') / ( n * norm(A) * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga561a20d64458f92f3e4cf00aab784a20}{}\index{real@{real}!schkbb@{schkbb}}
\index{schkbb@{schkbb}!real@{real}}
\subsubsection[{schkbb}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkbb (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+W\+D\+T\+H\+S, }
\item[{integer, dimension( $\ast$ )}]{K\+K, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer}]{N\+R\+H\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldab, $\ast$ )}]{A\+B, }
\item[{integer}]{L\+D\+A\+B, }
\item[{real, dimension( $\ast$ )}]{B\+D, }
\item[{real, dimension( $\ast$ )}]{B\+E, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( {\bf ldp}, $\ast$ )}]{P, }
\item[{integer}]{L\+D\+P, }
\item[{real, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{real, dimension( ldc, $\ast$ )}]{C\+C, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga561a20d64458f92f3e4cf00aab784a20}


{\bfseries S\+C\+H\+K\+B\+B} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKBB tests the reduction of a general real rectangular band
 matrix to bidiagonal form.

 SGBBRD factors a general band matrix A as  Q B P* , where * means
 transpose, B is upper bidiagonal, and Q and P are orthogonal;
 SGBBRD can also overwrite a given matrix C with Q* C .

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix C are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x M
    P:          N x N
    B:          min(M,N) x min(M,N)
    C:          M x NRHS

 For each generated matrix, 4 tests are performed:

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 (4)   | Y - Q' C | / ( |Y| max(M,NRHS) ulp ), where Y = Q' C.

 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).
          If NSIZES is zero, SCHKBB does nothing.  NSIZES must be at
          least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NSIZES)
          The values of the matrix column dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+D\+T\+H\+S} & \begin{DoxyVerb}          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          SCHKBB does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+K} & \begin{DoxyVerb}          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SCHKBB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of columns in the "right-hand side" matrix C.
          If NRHS = 0, then the operations on the right-hand side will
          not be tested. NRHS must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SCHKBB to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension
                            (LDA, max(NN))
          Used to hold the matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+B} & \begin{DoxyVerb}          AB is REAL array, dimension (LDAB, max(NN))
          Used to hold A in band storage format.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A\+B} & \begin{DoxyVerb}          LDAB is INTEGER
          The leading dimension of AB.  It must be at least 2 (not 1!)
          and at least max( KK )+1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+D} & \begin{DoxyVerb}          BD is REAL array, dimension (max(NN))
          Used to hold the diagonal of the bidiagonal matrix computed
          by SGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E} & \begin{DoxyVerb}          BE is REAL array, dimension (max(NN))
          Used to hold the off-diagonal of the bidiagonal matrix
          computed by SGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDQ, max(NN))
          Used to hold the orthogonal matrix Q computed by SGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P} & \begin{DoxyVerb}          P is REAL array, dimension (LDP, max(NN))
          Used to hold the orthogonal matrix P computed by SGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+P} & \begin{DoxyVerb}          LDP is INTEGER
          The leading dimension of P.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C} & \begin{DoxyVerb}          C is REAL array, dimension (LDC, max(NN))
          Used to hold the matrix C updated by SGBBRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C\+C} & \begin{DoxyVerb}          CC is REAL array, dimension (LDC, max(NN))
          Used to hold a copy of the matrix C.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga03e7367f702235ab4a852cec4d6dd1c8}{}\index{real@{real}!schkbd@{schkbd}}
\index{schkbd@{schkbd}!real@{real}}
\subsubsection[{schkbd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkbd (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer}]{N\+R\+H\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{B\+D, }
\item[{real, dimension( $\ast$ )}]{B\+E, }
\item[{real, dimension( $\ast$ )}]{S1, }
\item[{real, dimension( $\ast$ )}]{S2, }
\item[{real, dimension( ldx, $\ast$ )}]{X, }
\item[{integer}]{L\+D\+X, }
\item[{real, dimension( ldx, $\ast$ )}]{Y, }
\item[{real, dimension( ldx, $\ast$ )}]{Z, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( ldpt, $\ast$ )}]{P\+T, }
\item[{integer}]{L\+D\+P\+T, }
\item[{real, dimension( ldpt, $\ast$ )}]{U, }
\item[{real, dimension( ldpt, $\ast$ )}]{V\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga03e7367f702235ab4a852cec4d6dd1c8}


{\bfseries S\+C\+H\+K\+B\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKBD checks the singular value decomposition (SVD) routines.

 SGEBRD reduces a real general m by n matrix A to upper or lower
 bidiagonal form B by an orthogonal transformation:  Q' * A * P = B
 (or A = Q * B * P').  The matrix B is upper bidiagonal if m >= n
 and lower bidiagonal if m < n.

 SORGBR generates the orthogonal matrices Q and P' from SGEBRD.
 Note that Q and P are not necessarily square.

 SBDSQR computes the singular value decomposition of the bidiagonal
 matrix B as B = U S V'.  It is called three times to compute
    1)  B = U S1 V', where S1 is the diagonal matrix of singular
        values and the columns of the matrices U and V are the left
        and right singular vectors, respectively, of B.
    2)  Same as 1), but the singular values are stored in S2 and the
        singular vectors are not computed.
    3)  A = (UQ) S (P'V'), the SVD of the original matrix A.
 In addition, SBDSQR has an option to apply the left orthogonal matrix
 U to a matrix X, useful in least squares applications.

 SBDSDC computes the singular value decomposition of the bidiagonal
 matrix B as B = U S V' using divide-and-conquer. It is called twice
 to compute
    1) B = U S1 V', where S1 is the diagonal matrix of singular
        values and the columns of the matrices U and V are the left
        and right singular vectors, respectively, of B.
    2) Same as 1), but the singular values are stored in S2 and the
        singular vectors are not computed.

 For each pair of matrix dimensions (M,N) and each selected matrix
 type, an M by N matrix A and an M by NRHS matrix X are generated.
 The problem dimensions are as follows
    A:          M x N
    Q:          M x min(M,N) (but M x M if NRHS > 0)
    P:          min(M,N) x N
    B:          min(M,N) x min(M,N)
    U, V:       min(M,N) x min(M,N)
    S1, S2      diagonal, order min(M,N)
    X:          M x NRHS

 For each generated matrix, 14 tests are performed:

 Test SGEBRD and SORGBR

 (1)   | A - Q B PT | / ( |A| max(M,N) ulp ), PT = P'

 (2)   | I - Q' Q | / ( M ulp )

 (3)   | I - PT PT' | / ( N ulp )

 Test SBDSQR on bidiagonal matrix B

 (4)   | B - U S1 VT | / ( |B| min(M,N) ulp ), VT = V'

 (5)   | Y - U Z | / ( |Y| max(min(M,N),k) ulp ), where Y = Q' X
                                                  and   Z = U' Y.
 (6)   | I - U' U | / ( min(M,N) ulp )

 (7)   | I - VT VT' | / ( min(M,N) ulp )

 (8)   S1 contains min(M,N) nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (9)   | S1 - S2 | / ( |S1| ulp ), where S2 is computed without
                                   computing U and V.

 (10)  0 if the true singular values of B are within THRESH of
       those in S1.  2*THRESH if they are not.  (Tested using
       SSVDCH)

 Test SBDSQR on matrix A

 (11)  | A - (QU) S (VT PT) | / ( |A| max(M,N) ulp )

 (12)  | X - (QU) Z | / ( |X| max(M,k) ulp )

 (13)  | I - (QU)'(QU) | / ( M ulp )

 (14)  | I - (VT PT) (PT'VT') | / ( N ulp )

 Test SBDSDC on bidiagonal matrix B

 (15)  | B - U S1 VT | / ( |B| min(M,N) ulp ), VT = V'

 (16)  | I - U' U | / ( min(M,N) ulp )

 (17)  | I - VT VT' | / ( min(M,N) ulp )

 (18)  S1 contains min(M,N) nonnegative values in decreasing order.
       (Return 0 if true, 1/ULP if false.)

 (19)  | S1 - S2 | / ( |S1| ulp ), where S2 is computed without
                                   computing U and V.
 The possible matrix types are

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (3), but multiplied by SQRT( overflow threshold )
 (7)  Same as (3), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U D V, where U and V are orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U D V, where U and V are orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Rectangular matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )

 Special case:
 (16) A bidiagonal matrix with random entries chosen from a
      logarithmic distribution on [ulp^2,ulp^(-2)]  (I.e., each
      entry is  e^x, where x is chosen uniformly on
      [ 2 log(ulp), -2 log(ulp) ] .)  For *this* type:
      (a) SGEBRD is not called to reduce it to bidiagonal form.
      (b) the bidiagonal is  min(M,N) x min(M,N); if M<N, the
          matrix will be lower bidiagonal, otherwise upper.
      (c) only tests 5--8 and 14 are performed.

 A subset of the full set of matrix types may be selected through
 the logical array DOTYPE.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of values of M and N contained in the vectors
          MVAL and NVAL.  The matrix sizes are used in pairs (M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SCHKBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of columns in the "right-hand side" matrices X, Y,
          and Z, used in testing SBDSQR.  If NRHS = 0, then the
          operations on the right-hand side will not be tested.
          NRHS must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The values of ISEED are changed on exit, and can be
          used in the next call to SCHKBD to continue the same random
          number sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.  Note that the
          expected value of the test ratios is O(1), so THRESH should
          be a reasonably small multiple of 1, e.g., 10 or 100.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,NMAX)
          where NMAX is the maximum value of N in NVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,MMAX),
          where MMAX is the maximum value of M in MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+D} & \begin{DoxyVerb}          BD is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E} & \begin{DoxyVerb}          BE is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S1} & \begin{DoxyVerb}          S1 is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S2} & \begin{DoxyVerb}          S2 is REAL array, dimension
                      (max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension (LDX,NRHS)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the arrays X, Y, and Z.
          LDX >= max(1,MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Y} & \begin{DoxyVerb}          Y is REAL array, dimension (LDX,NRHS)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension (LDX,NRHS)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDQ,MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ >= max(1,MMAX).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P\+T} & \begin{DoxyVerb}          PT is REAL array, dimension (LDPT,NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+P\+T} & \begin{DoxyVerb}          LDPT is INTEGER
          The leading dimension of the arrays PT, U, and V.
          LDPT >= max(1, max(min(MVAL(j),NVAL(j)))).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+T} & \begin{DoxyVerb}          VT is REAL array, dimension
                      (LDPT,max(min(MVAL(j),NVAL(j))))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          3(M+N) and  M(M + max(M,N,k) + 1) + N*min(M,N)  for all
          pairs  (M,N)=(MM(j),NN(j))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension at least 8*min(M,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some MM(j) < 0
           -3: Some NN(j) < 0
           -4: NTYPES < 0
           -6: NRHS  < 0
           -8: THRESH < 0
          -11: LDA < 1 or LDA < MMAX, where MMAX is max( MM(j) ).
          -17: LDB < 1 or LDB < MMAX.
          -21: LDQ < 1 or LDQ < MMAX.
          -23: LDPT< 1 or LDPT< MNMAX.
          -27: LWORK too small.
          If  SLATMR, SLATMS, SGEBRD, SORGBR, or SBDSQR,
              returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NTEST           The number of tests performed, or which can
                     be performed so far, for the current matrix.
     MMAX            Largest value in NN.
     NMAX            Largest value in NN.
     MNMIN           min(MM(j), NN(j)) (the dimension of the bidiagonal
                     matrix.)
     MNMAX           The maximum value of MNMIN for j=1,...,NSIZES.
     NFAIL           The number of tests which have exceeded THRESH
     COND, IMODE     Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     RTOVFL, RTUNFL  Square roots of the previous 2 values.
     ULP, ULPINV     Finest relative precision and its inverse.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaf2b54e7c6663d08f2287b4d8227e53bf}{}\index{real@{real}!schkbk@{schkbk}}
\index{schkbk@{schkbk}!real@{real}}
\subsubsection[{schkbk}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkbk (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaf2b54e7c6663d08f2287b4d8227e53bf}


{\bfseries S\+C\+H\+K\+B\+K} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKBK tests SGEBAK, a routine for backward transformation of
 the computed right or left eigenvectors if the orginal matrix
 was preprocessed by balance subroutine SGEBAL.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga0625d9829033282f25e479936bdaee20}{}\index{real@{real}!schkbl@{schkbl}}
\index{schkbl@{schkbl}!real@{real}}
\subsubsection[{schkbl}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkbl (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga0625d9829033282f25e479936bdaee20}


{\bfseries S\+C\+H\+K\+B\+L} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKBL tests SGEBAL, a routine for balancing a general real
 matrix and isolating some of its eigenvalues.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga59636355218ca7955eee8e253db3329a}{}\index{real@{real}!schkec@{schkec}}
\index{schkec@{schkec}!real@{real}}
\subsubsection[{schkec}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkec (
\begin{DoxyParamCaption}
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{{\bf logical}}]{T\+S\+T\+E\+R\+R, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga59636355218ca7955eee8e253db3329a}


{\bfseries S\+C\+H\+K\+E\+C} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKEC tests eigen- condition estimation routines
        SLALN2, SLASY2, SLANV2, SLAQTR, SLAEXC,
        STRSYL, STREXC, STRSNA, STRSEN

 In all cases, the routine runs through a fixed set of numerical
 examples, subjects them to various tests, and compares the test
 results to a threshold THRESH. In addition, STREXC, STRSNA and STRSEN
 are tested by reading in precomputed examples from a file (on input
 unit NIN).  Output is written to output unit NOUT.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          Threshold for residual tests.  A computed test ratio passes
          the threshold if it is less than THRESH.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+S\+T\+E\+R\+R} & \begin{DoxyVerb}          TSTERR is LOGICAL
          Flag that indicates whether error exits are to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaa05ae9ee47877fe74bea22f30f3e1b41}{}\index{real@{real}!schkee@{schkee}}
\index{schkee@{schkee}!real@{real}}
\subsubsection[{schkee}]{\setlength{\rightskip}{0pt plus 5cm}program schkee (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaa05ae9ee47877fe74bea22f30f3e1b41}


{\bfseries S\+C\+H\+K\+E\+E} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKEE tests the REAL LAPACK subroutines for the matrix
 eigenvalue problem.  The test paths in this version are

 NEP (Nonsymmetric Eigenvalue Problem):
     Test SGEHRD, SORGHR, SHSEQR, STREVC, SHSEIN, and SORMHR

 SEP (Symmetric Eigenvalue Problem):
     Test SSYTRD, SORGTR, SSTEQR, SSTERF, SSTEIN, SSTEDC,
     and drivers SSYEV(X), SSBEV(X), SSPEV(X), SSTEV(X),
                 SSYEVD,   SSBEVD,   SSPEVD,   SSTEVD

 SVD (Singular Value Decomposition):
     Test SGEBRD, SORGBR, SBDSQR, SBDSDC
     and the drivers SGESVD, SGESDD

 SEV (Nonsymmetric Eigenvalue/eigenvector Driver):
     Test SGEEV

 SES (Nonsymmetric Schur form Driver):
     Test SGEES

 SVX (Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test SGEEVX

 SSX (Nonsymmetric Schur form Expert Driver):
     Test SGEESX

 SGG (Generalized Nonsymmetric Eigenvalue Problem):
     Test SGGHRD, SGGBAL, SGGBAK, SHGEQZ, and STGEVC
     and the driver routines SGEGS and SGEGV

 SGS (Generalized Nonsymmetric Schur form Driver):
     Test SGGES

 SGV (Generalized Nonsymmetric Eigenvalue/eigenvector Driver):
     Test SGGEV

 SGX (Generalized Nonsymmetric Schur form Expert Driver):
     Test SGGESX

 SXV (Generalized Nonsymmetric Eigenvalue/eigenvector Expert Driver):
     Test SGGEVX

 SSG (Symmetric Generalized Eigenvalue Problem):
     Test SSYGST, SSYGV, SSYGVD, SSYGVX, SSPGST, SSPGV, SSPGVD,
     SSPGVX, SSBGST, SSBGV, SSBGVD, and SSBGVX

 SSB (Symmetric Band Eigenvalue Problem):
     Test SSBTRD

 SBB (Band Singular Value Decomposition):
     Test SGBBRD

 SEC (Eigencondition estimation):
     Test SLALN2, SLASY2, SLAEQU, SLAEXC, STRSYL, STREXC, STRSNA,
     STRSEN, and SLAQTR

 SBL (Balancing a general matrix)
     Test SGEBAL

 SBK (Back transformation on a balanced matrix)
     Test SGEBAK

 SGL (Balancing a matrix pair)
     Test SGGBAL

 SGK (Back transformation on a matrix pair)
     Test SGGBAK

 GLM (Generalized Linear Regression Model):
     Tests SGGGLM

 GQR (Generalized QR and RQ factorizations):
     Tests SGGQRF and SGGRQF

 GSV (Generalized Singular Value Decomposition):
     Tests SGGSVD, SGGSVP, STGSJA, SLAGS2, SLAPLL, and SLAPMT

 CSD (CS decomposition):
     Tests SORCSD

 LSE (Constrained Linear Least Squares):
     Tests SGGLSE

 Each test path has a different set of inputs, but the data sets for
 the driver routines xEV, xES, xVX, and xSX can be concatenated in a
 single input file.  The first line of input should contain one of the
 3-character path names in columns 1-3.  The number of remaining lines
 depends on what is found on the first line.

 The number of matrix types used in testing is often controllable from
 the input file.  The number of matrix types for each path, and the
 test routine that describes them, is as follows:

 Path name(s)  Types    Test routine

 SHS or NEP      21     SCHKHS
 SST or SEP      21     SCHKST (routines)
                 18     SDRVST (drivers)
 SBD or SVD      16     SCHKBD (routines)
                  5     SDRVBD (drivers)
 SEV             21     SDRVEV
 SES             21     SDRVES
 SVX             21     SDRVVX
 SSX             21     SDRVSX
 SGG             26     SCHKGG (routines)
                 26     SDRVGG (drivers)
 SGS             26     SDRGES
 SGX              5     SDRGSX
 SGV             26     SDRGEV
 SXV              2     SDRGVX
 SSG             21     SDRVSG
 SSB             15     SCHKSB
 SBB             15     SCHKBB
 SEC              -     SCHKEC
 SBL              -     SCHKBL
 SBK              -     SCHKBK
 SGL              -     SCHKGL
 SGK              -     SCHKGK
 GLM              8     SCKGLM
 GQR              8     SCKGQR
 GSV              8     SCKGSV
 CSD              3     SCKCSD
 LSE              8     SCKLSE

-----------------------------------------------------------------------

 NEP input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NX, NS, and
          MAXB.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  INMIN, INTEGER array, dimension (NPARMS)
          LAHQR vs TTQRE crossover point, >= 11

 line 9:  INWIN, INTEGER array, dimension (NPARMS)
          recommended deflation window size

 line 10: INIBL, INTEGER array, dimension (NPARMS)
          nibble crossover point

 line 11:  ISHFTS, INTEGER array, dimension (NPARMS)
          number of simultaneous shifts)

 line 12:  IACC22, INTEGER array, dimension (NPARMS)
          select structured matrix multiply: 0, 1 or 2)

 line 13: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.  To have all of the test
          ratios printed, use THRESH = 0.0 .

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  The remaining lines occur in sets of 1 or 2 and allow
          the user to specify the matrix types.  Each line contains
          a 3-character path name in columns 1-3, and the number
          of matrix types must be the first nonblank item in columns
          4-80.  If the number of matrix types is at least 1 but is
          less than the maximum number of possible types, a second
          line will be read to get the numbers of the matrix types to
          be used.  For example,
 NEP 21
          requests all of the matrix types for the nonsymmetric
          eigenvalue problem, while
 NEP  4
 9 10 11 12
          requests only matrices of type 9, 10, 11, and 12.

          The valid 3-character path names are 'NEP' or 'SHS' for the
          nonsymmetric eigenvalue routines.

-----------------------------------------------------------------------

 SEP or SSG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, and NX.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 7:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 10: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 11: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 12: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 12 was 2:

 line 13: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 13-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path names are 'SEP' or 'SST' for the
          symmetric eigenvalue routines and driver routines, and
          'SSG' for the routines for the symmetric generalized
          eigenvalue problem.

-----------------------------------------------------------------------

 SVD input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 5:  NPARMS, INTEGER
          Number of values of the parameter NB, NBMIN, NX, and NRHS.

 line 6:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 7:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for the minimum blocksize NBMIN.

 line 8:  NXVAL, INTEGER array, dimension (NPARMS)
          The values for the crossover point NX.

 line 9:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path names are 'SVD' or 'SBD' for both the
          SVD routines and the SVD driver routines.

-----------------------------------------------------------------------

 SEV and SES data files:

 line 1:  'SEV' or 'SES' in columns 1 to 3.

 line 2:  NSIZES, INTEGER
          Number of sizes of matrices to use. Should be at least 0
          and at most 20. If NSIZES = 0, no testing is done
          (although the remaining  3 lines are still read).

 line 3:  NN, INTEGER array, dimension(NSIZES)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHSEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9 and following:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'SEV' to test SGEEV, or
          'SES' to test SGEES.

-----------------------------------------------------------------------

 The SVX data has two parts. The first part is identical to SEV,
 and the second part consists of test matrices with precomputed
 solutions.

 line 1:  'SVX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  TSTERR, LOGICAL

 line 7:  NEWSD, INTEGER

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)

 lines 9 and following: The first line contains 'SVX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 1+2*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer). The next N lines contain the matrix, one
          row per line. The last N lines correspond to each
          eigenvalue. Each of these last N lines contains 4 real
          values: the real part of the eigenvalue, the imaginary
          part of the eigenvalue, the reciprocal condition number of
          the eigenvalues, and the reciprocal condition number of the
          eigenvector.  The end of data is indicated by dimension N=0.
          Even if no data is to be tested, there must be at least one
          line containing N=0.

-----------------------------------------------------------------------

 The SSX data is like SVX. The first part is identical to SEV, and the
 second part consists of test matrices with precomputed solutions.

 line 1:  'SSX' in columns 1-3.

 line 2:  NSIZES, INTEGER
          If NSIZES = 0, no testing of randomly generated examples
          is done, but any precomputed examples are tested.

 line 3:  NN, INTEGER array, dimension(NSIZES)

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs

 line 5:  THRESH, REAL

 line 6:  TSTERR, LOGICAL

 line 7:  NEWSD, INTEGER

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)

 lines 9 and following: The first line contains 'SSX' in columns 1-3
          followed by the number of matrix types, possibly with
          a second line to specify certain matrix types.
          If the number of matrix types = 0, no testing of randomly
          generated examples is done, but any precomputed examples
          are tested.

 remaining lines : Each matrix is stored on 3+N lines, where N is its
          dimension. The first line contains the dimension N and the
          dimension M of an invariant subspace. The second line
          contains M integers, identifying the eigenvalues in the
          invariant subspace (by their position in a list of
          eigenvalues ordered by increasing real part). The next N
          lines contain the matrix. The last line contains the
          reciprocal condition number for the average of the selected
          eigenvalues, and the reciprocal condition number for the
          corresponding right invariant subspace. The end of data is
          indicated by a line containing N=0 and M=0. Even if no data
          is to be tested, there must be at least one line containing
          N=0 and M=0.

-----------------------------------------------------------------------

 SGG input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NPARMS, INTEGER
          Number of values of the parameters NB, NBMIN, NS, MAXB, and
          NBCOL.

 line 5:  NBVAL, INTEGER array, dimension (NPARMS)
          The values for the blocksize NB.

 line 6:  NBMIN, INTEGER array, dimension (NPARMS)
          The values for NBMIN, the minimum row dimension for blocks.

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of shifts.

 line 8:  MXBVAL, INTEGER array, dimension (NPARMS)
          The values for MAXB, used in determining minimum blocksize.

 line 9:  NBCOL, INTEGER array, dimension (NPARMS)
          The values for NBCOL, the minimum column dimension for
          blocks.

 line 10: THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 11: TSTCHK, LOGICAL
          Flag indicating whether or not to test the LAPACK routines.

 line 12: TSTDRV, LOGICAL
          Flag indicating whether or not to test the driver routines.

 line 13: TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 14: NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 14 was 2:

 line 15: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 15-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'SGG' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 SGS and SGV input files:

 line 1:  'SGS' or 'SGV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension(NN)
          Dimensions of matrices to be tested.

 line 4:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 5:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          If it is 0., all test case data will be printed.

 line 6:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 17 was 2:

 line 7:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 7-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'SGS' for the generalized
          eigenvalue problem routines and driver routines.

-----------------------------------------------------------------------

 SXV input files:

 line 1:  'SXV' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer). The next N lines contain the matrix A, one
          row per line. The next N lines contain the matrix B.  The
          next line contains the reciprocals of the eigenvalue
          condition numbers.  The last line contains the reciprocals of
          the eigenvector condition numbers.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 SGX input files:

 line 1:  'SGX' in columns 1 to 3.

 line 2:  N, INTEGER
          Value of N.

 line 3:  NB, NBMIN, NX, NS, NBCOL, INTEGERs
          These integer parameters determine how blocking is done
          (see ILAENV for details)
          NB     : block size
          NBMIN  : minimum block size
          NX     : minimum dimension for blocking
          NS     : number of shifts in xHGEQR
          NBCOL  : minimum column dimension for blocking

 line 4:  THRESH, REAL
          The test threshold against which computed residuals are
          compared. Should generally be in the range from 10. to 20.
          Information will be printed about each test for which the
          test ratio is greater than or equal to the threshold.

 line 5:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 6:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 6 was 2:

 line 7: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 If line 2 was 0:

 line 7-EOF: Precomputed examples are tested.

 remaining lines : Each example is stored on 3+2*N lines, where N is
          its dimension. The first line contains the dimension (a
          single integer).  The next line contains an integer k such
          that only the last k eigenvalues will be selected and appear
          in the leading diagonal blocks of $A$ and $B$. The next N
          lines contain the matrix A, one row per line.  The next N
          lines contain the matrix B.  The last line contains the
          reciprocal of the eigenvalue cluster condition number and the
          reciprocal of the deflating subspace (associated with the
          selected eigencluster) condition number.  The end of data is
          indicated by dimension N=0.  Even if no data is to be tested,
          there must be at least one line containing N=0.

-----------------------------------------------------------------------

 SSB input file:

 line 2:  NN, INTEGER
          Number of values of N.

 line 3:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix dimension K.

 line 6:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 7 was 2:

 line 8:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 8-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'SSB'.

-----------------------------------------------------------------------

 SBB input file:

 line 2:  NN, INTEGER
          Number of values of M and N.

 line 3:  MVAL, INTEGER array, dimension (NN)
          The values for the matrix row dimension M.

 line 4:  NVAL, INTEGER array, dimension (NN)
          The values for the matrix column dimension N.

 line 4:  NK, INTEGER
          Number of values of K.

 line 5:  KVAL, INTEGER array, dimension (NK)
          The values for the matrix bandwidth K.

 line 6:  NPARMS, INTEGER
          Number of values of the parameter NRHS

 line 7:  NSVAL, INTEGER array, dimension (NPARMS)
          The values for the number of right hand sides NRHS.

 line 8:  THRESH
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 9:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 9 was 2:

 line 10: INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 10-EOF:  Lines specifying matrix types, as for SVD.
          The 3-character path name is 'SBB'.

-----------------------------------------------------------------------

 SEC input file:

 line  2: THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 lines  3-EOF:

 Input for testing the eigencondition routines consists of a set of
 specially constructed test cases and their solutions.  The data
 format is not intended to be modified by the user.

-----------------------------------------------------------------------

 SBL and SBK input files:

 line 1:  'SBL' in columns 1-3 to test SGEBAL, or 'SBK' in
          columns 1-3 to test SGEBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 SGL and SGK input files:

 line 1:  'SGL' in columns 1-3 to test SGGBAL, or 'SGK' in
          columns 1-3 to test SGGBAK.

 The remaining lines consist of specially constructed test cases.

-----------------------------------------------------------------------

 GLM data file:

 line 1:  'GLM' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension), note M <= N <= M+P.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GLM' for the generalized
          linear regression model routines.

-----------------------------------------------------------------------

 GQR data file:

 line 1:  'GQR' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GQR' for the generalized
          QR and RQ routines.

-----------------------------------------------------------------------

 GSV data file:

 line 1:  'GSV' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M (row dimension).

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P (row dimension).

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N (column dimension).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 CSD data file:

 line 1:  'CSD' in columns 1 to 3.

 line 2:  NM, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NM)
          Values of M (row and column dimension of orthogonal matrix).

 line 4:  PVAL, INTEGER array, dimension(NM)
          Values of P (row dimension of top-left block).

 line 5:  NVAL, INTEGER array, dimension(NM)
          Values of N (column dimension of top-left block).

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'CSD' for the CSD routine.

-----------------------------------------------------------------------

 LSE data file:

 line 1:  'LSE' in columns 1 to 3.

 line 2:  NN, INTEGER
          Number of values of M, P, and N.

 line 3:  MVAL, INTEGER array, dimension(NN)
          Values of M.

 line 4:  PVAL, INTEGER array, dimension(NN)
          Values of P.

 line 5:  NVAL, INTEGER array, dimension(NN)
          Values of N, note P <= N <= P+M.

 line 6:  THRESH, REAL
          Threshold value for the test ratios.  Information will be
          printed about each test for which the test ratio is greater
          than or equal to the threshold.

 line 7:  TSTERR, LOGICAL
          Flag indicating whether or not to test the error exits for
          the LAPACK routines and driver routines.

 line 8:  NEWSD, INTEGER
          A code indicating how to set the random number seed.
          = 0:  Set the seed to a default value before each run
          = 1:  Initialize the seed to a default value only before the
                first run
          = 2:  Like 1, but use the seed values on the next line

 If line 8 was 2:

 line 9:  INTEGER array, dimension (4)
          Four integer values for the random number seed.

 lines 9-EOF:  Lines specifying matrix types, as for NEP.
          The 3-character path name is 'GSV' for the generalized
          SVD routines.

-----------------------------------------------------------------------

 NMAX is currently set to 132 and must be at least 12 for some of the
 precomputed examples, and LWORK = NMAX*(5*NMAX+5)+1 in the parameter
 statements below.  For SVD, we assume NRHS may be as big as N.  The
 parameter NEED is set to 14 to allow for 14 N-by-N matrices for SGG.\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2013 
\end{DoxyDate}
\hypertarget{group__single__eig_ga9f423a19ff92049fe736bf71a7bfa7c7}{}\index{real@{real}!schkgg@{schkgg}}
\index{schkgg@{schkgg}!real@{real}}
\subsubsection[{schkgg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkgg (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{{\bf logical}}]{T\+S\+T\+D\+I\+F, }
\item[{real}]{T\+H\+R\+S\+H\+N, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{B, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( lda, $\ast$ )}]{T, }
\item[{real, dimension( lda, $\ast$ )}]{S1, }
\item[{real, dimension( lda, $\ast$ )}]{S2, }
\item[{real, dimension( lda, $\ast$ )}]{P1, }
\item[{real, dimension( lda, $\ast$ )}]{P2, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldu, $\ast$ )}]{V, }
\item[{real, dimension( ldu, $\ast$ )}]{Q, }
\item[{real, dimension( ldu, $\ast$ )}]{Z, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+R1, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+I1, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A1, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+R3, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+I3, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A3, }
\item[{real, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+L, }
\item[{real, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+R, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{L\+L\+W\+O\+R\+K, }
\item[{real, dimension( 15 )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga9f423a19ff92049fe736bf71a7bfa7c7}


{\bfseries S\+C\+H\+K\+G\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKGG  checks the nonsymmetric generalized eigenvalue problem
 routines.
                                T          T        T
 SGGHRD factors A and B as U H V  and U T V , where   means
 transpose, H is hessenberg, T is triangular and U and V are
 orthogonal.
                                 T          T
 SHGEQZ factors H and T as  Q S Z  and Q P Z , where P is upper
 triangular, S is in generalized Schur form (block upper triangular,
 with 1x1 and 2x2 blocks on the diagonal, the 2x2 blocks
 corresponding to complex conjugate pairs of generalized
 eigenvalues), and Q and Z are orthogonal.  It also computes the
 generalized eigenvalues (alpha(1),beta(1)),...,(alpha(n),beta(n)),
 where alpha(j)=S(j,j) and beta(j)=P(j,j) -- thus,
 w(j) = alpha(j)/beta(j) is a root of the generalized eigenvalue
 problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 STGEVC computes the matrix L of left eigenvectors and the matrix R
 of right eigenvectors for the matrix pair ( S, P ).  In the
 description below,  l and r are left and right eigenvectors
 corresponding to the generalized eigenvalues (alpha,beta).

 When SCHKGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 15
 tests will be performed.  The first twelve "test ratios" should be
 small -- O(1).  They will be compared with the threshhold THRESH:

                  T
 (1)   | A - U H V  | / ( |A| n ulp )

                  T
 (2)   | B - U T V  | / ( |B| n ulp )

               T
 (3)   | I - UU  | / ( n ulp )

               T
 (4)   | I - VV  | / ( n ulp )

                  T
 (5)   | H - Q S Z  | / ( |H| n ulp )

                  T
 (6)   | T - Q P Z  | / ( |T| n ulp )

               T
 (7)   | I - QQ  | / ( n ulp )

               T
 (8)   | I - ZZ  | / ( n ulp )

 (9)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta S - alpha P) | / ( ulp max( |beta S|, |alpha P| ) )

 (10)  max over all left eigenvalue/-vector pairs (beta/alpha,l') of
                           T
   | l'**H * (beta H - alpha T) | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors l' are the result of passing Q to
       STGEVC and back transforming (HOWMNY='B').

 (11)  max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta S - alpha T) r | / ( ulp max( |beta S|, |alpha T| ) )

 (12)  max over all right eigenvalue/-vector pairs (beta/alpha,r') of

       | (beta H - alpha T) r' | / ( ulp max( |beta H|, |alpha T| ) )

       where the eigenvectors r' are the result of passing Z to
       STGEVC and back transforming (HOWMNY='B').

 The last three test ratios will usually be small, but there is no
 mathematical requirement that they be so.  They are therefore
 compared with THRESH only if TSTDIF is .TRUE.

 (13)  | S(Q,Z computed) - S(Q,Z not computed) | / ( |S| ulp )

 (14)  | P(Q,Z computed) - P(Q,Z not computed) | / ( |P| ulp )

 (15)  max( |alpha(Q,Z computed) - alpha(Q,Z not computed)|/|S| ,
            |beta(Q,Z computed) - beta(Q,Z not computed)|/|P| ) / ulp

 In addition, the normalization of L and R are checked, and compared
 with the threshhold THRSHN.

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) U ( J , J ) V     where U and V are random orthogonal matrices.

 (17) U ( T1, T2 ) V    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) U ( T1, T2 ) V    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) U ( T1, T2 ) V    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) U ( T1, T2 ) V    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) U ( big*T1, small*T2 ) V    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) U ( small*T1, big*T2 ) V    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) U ( small*T1, small*T2 ) V  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) U ( big*T1, big*T2 ) V      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) U ( T1, T2 ) V     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SCHKGG does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SCHKGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SCHKGG to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+S\+T\+D\+I\+F} & \begin{DoxyVerb}          TSTDIF is LOGICAL
          Specifies whether test ratios 13-15 will be computed and
          compared with THRESH.
          = .FALSE.: Only test ratios 1-12 will be computed and tested.
                     Ratios 13-15 will be set to zero.
          = .TRUE.:  All the test ratios 1-15 will be computed and
                     tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+S\+H\+N} & \begin{DoxyVerb}          THRSHN is REAL
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension
                            (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, H, T, S1, P1, S2, and P2.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension
                            (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension (LDA, max(NN))
          The upper Hessenberg matrix computed from A by SGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is REAL array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by SGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S1} & \begin{DoxyVerb}          S1 is REAL array, dimension (LDA, max(NN))
          The Schur (block upper triangular) matrix computed from H by
          SHGEQZ when Q and Z are also computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S2} & \begin{DoxyVerb}          S2 is REAL array, dimension (LDA, max(NN))
          The Schur (block upper triangular) matrix computed from H by
          SHGEQZ when Q and Z are not computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P1} & \begin{DoxyVerb}          P1 is REAL array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by SHGEQZ
          when Q and Z are also computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em P2} & \begin{DoxyVerb}          P2 is REAL array, dimension (LDA, max(NN))
          The upper triangular matrix computed from T by SHGEQZ
          when Q and Z are not computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, max(NN))
          The (left) orthogonal matrix computed by SGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U, V, Q, Z, EVECTL, and EVECTR.  It
          must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension (LDU, max(NN))
          The (right) orthogonal matrix computed by SGGHRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDU, max(NN))
          The (left) orthogonal matrix computed by SHGEQZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension (LDU, max(NN))
          The (left) orthogonal matrix computed by SHGEQZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+R1} & \begin{DoxyVerb}          ALPHR1 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+I1} & \begin{DoxyVerb}          ALPHI1 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A1} & \begin{DoxyVerb}          BETA1 is REAL array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by SHGEQZ
          when Q, Z, and the full Schur matrices are computed.
          On exit, ( ALPHR1(k)+ALPHI1(k)*i ) / BETA1(k) is the k-th
          generalized eigenvalue of the matrices in A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+R3} & \begin{DoxyVerb}          ALPHR3 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+I3} & \begin{DoxyVerb}          ALPHI3 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A3} & \begin{DoxyVerb}          BETA3 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em E\+V\+E\+C\+T\+L} & \begin{DoxyVerb}          EVECTL is REAL array, dimension (LDU, max(NN))
          The (block lower triangular) left eigenvector matrix for
          the matrices in S1 and P1.  (See STGEVC for the format.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em E\+V\+E\+C\+T\+R} & \begin{DoxyVerb}          EVECTR is REAL array, dimension (LDU, max(NN))
          The (block upper triangular) right eigenvector matrix for
          the matrices in S1 and P1.  (See STGEVC for the format.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( 2 * N**2, 6*N, 1 ), for all N=NN(j).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+L\+W\+O\+R\+K} & \begin{DoxyVerb}          LLWORK is LOGICAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga30cf9f83367d540b803fbd2b264dde8f}{}\index{real@{real}!schkgk@{schkgk}}
\index{schkgk@{schkgk}!real@{real}}
\subsubsection[{schkgk}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkgk (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga30cf9f83367d540b803fbd2b264dde8f}


{\bfseries S\+C\+H\+K\+G\+K} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKGK tests SGGBAK, a routine for backward balancing  of
 a matrix pair (A, B).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gae4e43fee22351ea965e03ba9228aff5a}{}\index{real@{real}!schkgl@{schkgl}}
\index{schkgl@{schkgl}!real@{real}}
\subsubsection[{schkgl}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkgl (
\begin{DoxyParamCaption}
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gae4e43fee22351ea965e03ba9228aff5a}


{\bfseries S\+C\+H\+K\+G\+L} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKGL tests SGGBAL, a routine for balancing a matrix pair (A, B).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The logical unit number for input.  NIN > 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The logical unit number for output.  NOUT > 0.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gad6528d7acb91f950d1fae5bf68961251}{}\index{real@{real}!schkhs@{schkhs}}
\index{schkhs@{schkhs}!real@{real}}
\subsubsection[{schkhs}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkhs (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( lda, $\ast$ )}]{T1, }
\item[{real, dimension( lda, $\ast$ )}]{T2, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldu, $\ast$ )}]{Z, }
\item[{real, dimension( ldu, $\ast$ )}]{U\+Z, }
\item[{real, dimension( $\ast$ )}]{W\+R1, }
\item[{real, dimension( $\ast$ )}]{W\+I1, }
\item[{real, dimension( $\ast$ )}]{W\+R3, }
\item[{real, dimension( $\ast$ )}]{W\+I3, }
\item[{real, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+L, }
\item[{real, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+R, }
\item[{real, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+Y, }
\item[{real, dimension( ldu, $\ast$ )}]{E\+V\+E\+C\+T\+X, }
\item[{real, dimension( ldu, $\ast$ )}]{U\+U, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{S\+E\+L\+E\+C\+T, }
\item[{real, dimension( 14 )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gad6528d7acb91f950d1fae5bf68961251}


{\bfseries S\+C\+H\+K\+H\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SCHKHS  checks the nonsymmetric eigenvalue problem routines.

            SGEHRD factors A as  U H U' , where ' means transpose,
            H is hessenberg, and U is an orthogonal matrix.

            SORGHR generates the orthogonal matrix U.

            SORMHR multiplies a matrix by the orthogonal matrix U.

            SHSEQR factors H as  Z T Z' , where Z is orthogonal and
            T is "quasi-triangular", and the eigenvalue vector W.

            STREVC computes the left and right eigenvector matrices
            L and R for T.

            SHSEIN computes the left and right eigenvector matrices
            Y and X for H, using inverse iteration.

    When SCHKHS is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 14
    tests will be performed:

    (1)     | A - U H U**T | / ( |A| n ulp )

    (2)     | I - UU**T | / ( n ulp )

    (3)     | H - Z T Z**T | / ( |H| n ulp )

    (4)     | I - ZZ**T | / ( n ulp )

    (5)     | A - UZ H (UZ)**T | / ( |A| n ulp )

    (6)     | I - UZ (UZ)**T | / ( n ulp )

    (7)     | T(Z computed) - T(Z not computed) | / ( |T| ulp )

    (8)     | W(Z computed) - W(Z not computed) | / ( |W| ulp )

    (9)     | TR - RW | / ( |T| |R| ulp )

    (10)    | L**H T - W**H L | / ( |T| |L| ulp )

    (11)    | HX - XW | / ( |H| |X| ulp )

    (12)    | Y**H H - W**H Y | / ( |H| |Y| ulp )

    (13)    | AX - XW | / ( |A| |X| ulp )

    (14)    | Y**H A - W**H Y | / ( |A| |Y| ulp )

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by SQRT( overflow threshold )
    (8)  Same as (4), but multiplied by SQRT( underflow threshold )

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by SQRT( overflow threshold )
    (18) Same as (16), but multiplied by SQRT( underflow threshold )

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
    (20) Same as (19), but multiplied by SQRT( overflow threshold )
    (21) Same as (19), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 \begin{DoxyVerb}  NSIZES - INTEGER
           The number of sizes of matrices to use.  If it is zero,
           SCHKHS does nothing.  It must be at least zero.
           Not modified.

  NN     - INTEGER array, dimension (NSIZES)
           An array containing the sizes to be used for the matrices.
           Zero values will be skipped.  The values must be at least
           zero.
           Not modified.

  NTYPES - INTEGER
           The number of elements in DOTYPE.   If it is zero, SCHKHS
           does nothing.  It must be at least zero.  If it is MAXTYP+1
           and NSIZES is 1, then an additional type, MAXTYP+1 is
           defined, which is to use whatever matrix is in A.  This
           is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
           DOTYPE(MAXTYP+1) is .TRUE. .
           Not modified.

  DOTYPE - LOGICAL array, dimension (NTYPES)
           If DOTYPE(j) is .TRUE., then for each size in NN a
           matrix of that size and of type j will be generated.
           If NTYPES is smaller than the maximum number of types
           defined (PARAMETER MAXTYP), then types NTYPES+1 through
           MAXTYP will not be generated.  If NTYPES is larger
           than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
           will be ignored.
           Not modified.

  ISEED  - INTEGER array, dimension (4)
           On entry ISEED specifies the seed of the random number
           generator. The array elements should be between 0 and 4095;
           if not they will be reduced mod 4096.  Also, ISEED(4) must
           be odd.  The random number generator uses a linear
           congruential sequence limited to small integers, and so
           should produce machine independent random numbers. The
           values of ISEED are changed on exit, and can be used in the
           next call to SCHKHS to continue the same random number
           sequence.
           Modified.

  THRESH - REAL
           A test will count as "failed" if the "error", computed as
           described above, exceeds THRESH.  Note that the error
           is scaled to be O(1), so THRESH should be a reasonably
           small multiple of 1, e.g., 10 or 100.  In particular,
           it should not depend on the precision (single vs. double)
           or the size of the matrix.  It must be at least zero.
           Not modified.

  NOUNIT - INTEGER
           The FORTRAN unit number for printing out error messages
           (e.g., if a routine returns IINFO not equal to 0.)
           Not modified.

  A      - REAL array, dimension (LDA,max(NN))
           Used to hold the matrix whose eigenvalues are to be
           computed.  On exit, A contains the last matrix actually
           used.
           Modified.

  LDA    - INTEGER
           The leading dimension of A, H, T1 and T2.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  H      - REAL array, dimension (LDA,max(NN))
           The upper hessenberg matrix computed by SGEHRD.  On exit,
           H contains the Hessenberg form of the matrix in A.
           Modified.

  T1     - REAL array, dimension (LDA,max(NN))
           The Schur (="quasi-triangular") matrix computed by SHSEQR
           if Z is computed.  On exit, T1 contains the Schur form of
           the matrix in A.
           Modified.

  T2     - REAL array, dimension (LDA,max(NN))
           The Schur matrix computed by SHSEQR when Z is not computed.
           This should be identical to T1.
           Modified.

  LDU    - INTEGER
           The leading dimension of U, Z, UZ and UU.  It must be at
           least 1 and at least max( NN ).
           Not modified.

  U      - REAL array, dimension (LDU,max(NN))
           The orthogonal matrix computed by SGEHRD.
           Modified.

  Z      - REAL array, dimension (LDU,max(NN))
           The orthogonal matrix computed by SHSEQR.
           Modified.

  UZ     - REAL array, dimension (LDU,max(NN))
           The product of U times Z.
           Modified.

  WR1    - REAL array, dimension (max(NN))
  WI1    - REAL array, dimension (max(NN))
           The real and imaginary parts of the eigenvalues of A,
           as computed when Z is computed.
           On exit, WR1 + WI1*i are the eigenvalues of the matrix in A.
           Modified.

  WR3    - REAL array, dimension (max(NN))
  WI3    - REAL array, dimension (max(NN))
           Like WR1, WI1, these arrays contain the eigenvalues of A,
           but those computed when SHSEQR only computes the
           eigenvalues, i.e., not the Schur vectors and no more of the
           Schur form than is necessary for computing the
           eigenvalues.
           Modified.

  EVECTL - REAL array, dimension (LDU,max(NN))
           The (upper triangular) left eigenvector matrix for the
           matrix in T1.  For complex conjugate pairs, the real part
           is stored in one row and the imaginary part in the next.
           Modified.

  EVECTR - REAL array, dimension (LDU,max(NN))
           The (upper triangular) right eigenvector matrix for the
           matrix in T1.  For complex conjugate pairs, the real part
           is stored in one column and the imaginary part in the next.
           Modified.

  EVECTY - REAL array, dimension (LDU,max(NN))
           The left eigenvector matrix for the
           matrix in H.  For complex conjugate pairs, the real part
           is stored in one row and the imaginary part in the next.
           Modified.

  EVECTX - REAL array, dimension (LDU,max(NN))
           The right eigenvector matrix for the
           matrix in H.  For complex conjugate pairs, the real part
           is stored in one column and the imaginary part in the next.
           Modified.

  UU     - REAL array, dimension (LDU,max(NN))
           Details of the orthogonal matrix computed by SGEHRD.
           Modified.

  TAU    - REAL array, dimension(max(NN))
           Further details of the orthogonal matrix computed by SGEHRD.
           Modified.

  WORK   - REAL array, dimension (NWORK)
           Workspace.
           Modified.

  NWORK  - INTEGER
           The number of entries in WORK.  NWORK >= 4*NN(j)*NN(j) + 2.

  IWORK  - INTEGER array, dimension (max(NN))
           Workspace.
           Modified.

  SELECT - LOGICAL array, dimension (max(NN))
           Workspace.
           Modified.

  RESULT - REAL array, dimension (14)
           The values computed by the fourteen tests described above.
           The values are currently limited to 1/ulp, to avoid
           overflow.
           Modified.

  INFO   - INTEGER
           If 0, then everything ran OK.
            -1: NSIZES < 0
            -2: Some NN(j) < 0
            -3: NTYPES < 0
            -6: THRESH < 0
            -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
           -14: LDU < 1 or LDU < NMAX.
           -28: NWORK too small.
           If  SLATMR, SLATMS, or SLATME returns an error code, the
               absolute value of it is returned.
           If 1, then SHSEQR could not find all the shifts.
           If 2, then the EISPACK code (for small blocks) failed.
           If >2, then 30*N iterations were not enough to find an
               eigenvalue or to decompose the problem.
           Modified.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     MTEST           The number of tests defined: care must be taken
                     that (1) the size of RESULT, (2) the number of
                     tests actually performed, and (3) MTEST agree.
     NTEST           The number of tests performed on this matrix
                     so far.  This should be less than MTEST, and
                     equal to it by the last test.  It will be less
                     if any of the routines being tested indicates
                     that it could not compute the matrices that
                     would be tested.
     NMAX            Largest value in NN.
     NMATS           The number of matrices generated so far.
     NERRS           The number of tests which have exceeded THRESH
                     so far (computed by SLAFTS).
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTOVFL, RTUNFL,
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selects whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gadbebec63ce21bd4a5e4f86e93fbfbd16}{}\index{real@{real}!schksb@{schksb}}
\index{schksb@{schksb}!real@{real}}
\subsubsection[{schksb}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schksb (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+W\+D\+T\+H\+S, }
\item[{integer, dimension( $\ast$ )}]{K\+K, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{S\+D, }
\item[{real, dimension( $\ast$ )}]{S\+E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gadbebec63ce21bd4a5e4f86e93fbfbd16}


{\bfseries S\+C\+H\+K\+S\+B} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKSB tests the reduction of a symmetric band matrix to tridiagonal
 form, used with the symmetric eigenvalue problem.

 SSBTRD factors a symmetric band matrix A as  U S U' , where ' means
 transpose, S is symmetric tridiagonal, and U is orthogonal.
 SSBTRD can use either just the lower or just the upper triangle
 of A; SCHKSB checks both cases.

 When SCHKSB is called, a number of matrix "sizes" ("n's"), a number
 of bandwidths ("k's"), and a number of matrix "types" are
 specified.  For each size ("n"), each bandwidth ("k") less than or
 equal to "n", and each type of matrix, one matrix will be generated
 and used to test the symmetric banded reduction routine.  For each
 matrix, a number of tests will be performed:

 (1)     | A - V S V' | / ( |A| n ulp )  computed by SSBTRD with
                                         UPLO='U'

 (2)     | I - UU' | / ( n ulp )

 (3)     | A - V S V' | / ( |A| n ulp )  computed by SSBTRD with
                                         UPLO='L'

 (4)     | I - UU' | / ( n ulp )

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U' D U, where U is orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U' D U, where U is orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U' D U, where U is orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Symmetric matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SCHKSB does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+D\+T\+H\+S} & \begin{DoxyVerb}          NWDTHS is INTEGER
          The number of bandwidths to use.  If it is zero,
          SCHKSB does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+K} & \begin{DoxyVerb}          KK is INTEGER array, dimension (NWDTHS)
          An array containing the bandwidths to be used for the band
          matrices.  The values must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SCHKSB
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SCHKSB to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension
                            (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 2 (not 1!)
          and at least max( KK )+1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+D} & \begin{DoxyVerb}          SD is REAL array, dimension (max(NN))
          Used to hold the diagonal of the tridiagonal matrix computed
          by SSBTRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+E} & \begin{DoxyVerb}          SE is REAL array, dimension (max(NN))
          Used to hold the off-diagonal of the tridiagonal matrix
          computed by SSBTRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, max(NN))
          Used to hold the orthogonal matrix computed by SSBTRD.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max( LDA+1, max(NN)+1 )*max(NN).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (4)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga78dcfb18a5c0e962c63effd1914f11a3}{}\index{real@{real}!schkst@{schkst}}
\index{schkst@{schkst}!real@{real}}
\subsubsection[{schkst}]{\setlength{\rightskip}{0pt plus 5cm}subroutine schkst (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{A\+P, }
\item[{real, dimension( $\ast$ )}]{S\+D, }
\item[{real, dimension( $\ast$ )}]{S\+E, }
\item[{real, dimension( $\ast$ )}]{D1, }
\item[{real, dimension( $\ast$ )}]{D2, }
\item[{real, dimension( $\ast$ )}]{D3, }
\item[{real, dimension( $\ast$ )}]{D4, }
\item[{real, dimension( $\ast$ )}]{D5, }
\item[{real, dimension( $\ast$ )}]{W\+A1, }
\item[{real, dimension( $\ast$ )}]{W\+A2, }
\item[{real, dimension( $\ast$ )}]{W\+A3, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldu, $\ast$ )}]{V, }
\item[{real, dimension( $\ast$ )}]{V\+P, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U, }
\item[{real, dimension( ldu, $\ast$ )}]{Z, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga78dcfb18a5c0e962c63effd1914f11a3}


{\bfseries S\+C\+H\+K\+S\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCHKST  checks the symmetric eigenvalue problem routines.

    SSYTRD factors A as  U S U' , where ' means transpose,
    S is symmetric tridiagonal, and U is orthogonal.
    SSYTRD can use either just the lower or just the upper triangle
    of A; SCHKST checks both cases.
    U is represented as a product of Householder
    transformations, whose vectors are stored in the first
    n-1 columns of V, and whose scale factors are in TAU.

    SSPTRD does the same as SSYTRD, except that A and V are stored
    in "packed" format.

    SORGTR constructs the matrix U from the contents of V and TAU.

    SOPGTR constructs the matrix U from the contents of VP and TAU.

    SSTEQR factors S as  Z D1 Z' , where Z is the orthogonal
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal.  D2 is the matrix of
    eigenvalues computed when Z is not computed.

    SSTERF computes D3, the matrix of eigenvalues, by the
    PWK method, which does not yield eigenvectors.

    SPTEQR factors S as  Z4 D4 Z4' , for a
    symmetric positive definite tridiagonal matrix.
    D5 is the matrix of eigenvalues computed when Z is not
    computed.

    SSTEBZ computes selected eigenvalues.  WA1, WA2, and
    WA3 will denote eigenvalues computed to high
    absolute accuracy, with different range options.
    WR will denote eigenvalues computed to high relative
    accuracy.

    SSTEIN computes Y, the eigenvectors of S, given the
    eigenvalues.

    SSTEDC factors S as Z D1 Z' , where Z is the orthogonal
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option). It may also
    update an input orthogonal matrix, usually the output
    from SSYTRD/SORGTR or SSPTRD/SOPGTR ('V' option). It may
    also just compute eigenvalues ('N' option).

    SSTEMR factors S as Z D1 Z' , where Z is the orthogonal
    matrix of eigenvectors and D1 is a diagonal matrix with
    the eigenvalues on the diagonal ('I' option).  SSTEMR
    uses the Relatively Robust Representation whenever possible.

 When SCHKST is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the symmetric eigenroutines.  For each matrix, a number
 of tests will be performed:

 (1)     | A - V S V' | / ( |A| n ulp ) SSYTRD( UPLO='U', ... )

 (2)     | I - UV' | / ( n ulp )        SORGTR( UPLO='U', ... )

 (3)     | A - V S V' | / ( |A| n ulp ) SSYTRD( UPLO='L', ... )

 (4)     | I - UV' | / ( n ulp )        SORGTR( UPLO='L', ... )

 (5-8)   Same as 1-4, but for SSPTRD and SOPGTR.

 (9)     | S - Z D Z' | / ( |S| n ulp ) SSTEQR('V',...)

 (10)    | I - ZZ' | / ( n ulp )        SSTEQR('V',...)

 (11)    | D1 - D2 | / ( |D1| ulp )        SSTEQR('N',...)

 (12)    | D1 - D3 | / ( |D1| ulp )        SSTERF

 (13)    0 if the true eigenvalues (computed by sturm count)
         of S are within THRESH of
         those in D1.  2*THRESH if they are not.  (Tested using
         SSTECH)

 For S positive definite,

 (14)    | S - Z4 D4 Z4' | / ( |S| n ulp ) SPTEQR('V',...)

 (15)    | I - Z4 Z4' | / ( n ulp )        SPTEQR('V',...)

 (16)    | D4 - D5 | / ( 100 |D4| ulp )       SPTEQR('N',...)

 When S is also diagonally dominant by the factor gamma < 1,

 (17)    max | D4(i) - WR(i) | / ( |D4(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              SSTEBZ( 'A', 'E', ...)

 (18)    | WA1 - D3 | / ( |D3| ulp )          SSTEBZ( 'A', 'E', ...)

 (19)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
                                              SSTEBZ( 'I', 'E', ...)

 (20)    | S - Y WA1 Y' | / ( |S| n ulp )  SSTEBZ, SSTEIN

 (21)    | I - Y Y' | / ( n ulp )          SSTEBZ, SSTEIN

 (22)    | S - Z D Z' | / ( |S| n ulp )    SSTEDC('I')

 (23)    | I - ZZ' | / ( n ulp )           SSTEDC('I')

 (24)    | S - Z D Z' | / ( |S| n ulp )    SSTEDC('V')

 (25)    | I - ZZ' | / ( n ulp )           SSTEDC('V')

 (26)    | D1 - D2 | / ( |D1| ulp )           SSTEDC('V') and
                                              SSTEDC('N')

 Test 27 is disabled at the moment because SSTEMR does not
 guarantee high relatvie accuracy.

 (27)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              SSTEMR('V', 'A')

 (28)    max | D6(i) - WR(i) | / ( |D6(i)| omega ) ,
          i
         omega = 2 (2n-1) ULP (1 + 8 gamma**2) / (1 - gamma)**4
                                              SSTEMR('V', 'I')

 Tests 29 through 34 are disable at present because SSTEMR
 does not handle partial specturm requests.

 (29)    | S - Z D Z' | / ( |S| n ulp )    SSTEMR('V', 'I')

 (30)    | I - ZZ' | / ( n ulp )           SSTEMR('V', 'I')

 (31)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         SSTEMR('N', 'I') vs. SSTEMR('V', 'I')

 (32)    | S - Z D Z' | / ( |S| n ulp )    SSTEMR('V', 'V')

 (33)    | I - ZZ' | / ( n ulp )           SSTEMR('V', 'V')

 (34)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         SSTEMR('N', 'V') vs. SSTEMR('V', 'V')

 (35)    | S - Z D Z' | / ( |S| n ulp )    SSTEMR('V', 'A')

 (36)    | I - ZZ' | / ( n ulp )           SSTEMR('V', 'A')

 (37)    ( max { min | WA2(i)-WA3(j) | } +
            i     j
           max { min | WA3(i)-WA2(j) | } ) / ( |D3| ulp )
            i     j
         SSTEMR('N', 'A') vs. SSTEMR('V', 'A')

 The "sizes" are specified by an array NN(1:NSIZES); the value of
 each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES );
 if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.

 (3)  A diagonal matrix with evenly spaced entries
      1, ..., ULP  and random signs.
      (ULP = (first number larger than 1) - 1 )
 (4)  A diagonal matrix with geometrically spaced entries
      1, ..., ULP  and random signs.
 (5)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
      and random signs.

 (6)  Same as (4), but multiplied by SQRT( overflow threshold )
 (7)  Same as (4), but multiplied by SQRT( underflow threshold )

 (8)  A matrix of the form  U' D U, where U is orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.

 (9)  A matrix of the form  U' D U, where U is orthogonal and
      D has geometrically spaced entries 1, ..., ULP with random
      signs on the diagonal.

 (10) A matrix of the form  U' D U, where U is orthogonal and
      D has "clustered" entries 1, ULP,..., ULP with random
      signs on the diagonal.

 (11) Same as (8), but multiplied by SQRT( overflow threshold )
 (12) Same as (8), but multiplied by SQRT( underflow threshold )

 (13) Symmetric matrix with random entries chosen from (-1,1).
 (14) Same as (13), but multiplied by SQRT( overflow threshold )
 (15) Same as (13), but multiplied by SQRT( underflow threshold )
 (16) Same as (8), but diagonal elements are all positive.
 (17) Same as (9), but diagonal elements are all positive.
 (18) Same as (10), but diagonal elements are all positive.
 (19) Same as (16), but multiplied by SQRT( overflow threshold )
 (20) Same as (16), but multiplied by SQRT( underflow threshold )
 (21) A diagonally dominant tridiagonal matrix with geometrically
      spaced diagonal entries 1, ..., ULP.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SCHKST does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SCHKST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SCHKST to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array of
                                  dimension ( LDA , max(NN) )
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+P} & \begin{DoxyVerb}          AP is REAL array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix A stored in packed format.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+D} & \begin{DoxyVerb}          SD is REAL array of
                             dimension( max(NN) )
          The diagonal of the tridiagonal matrix computed by SSYTRD.
          On exit, SD and SE contain the tridiagonal form of the
          matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+E} & \begin{DoxyVerb}          SE is REAL array of
                             dimension( max(NN) )
          The off-diagonal of the tridiagonal matrix computed by
          SSYTRD.  On exit, SD and SE contain the tridiagonal form of
          the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D1} & \begin{DoxyVerb}          D1 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by SSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D2} & \begin{DoxyVerb}          D2 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by SSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D3} & \begin{DoxyVerb}          D3 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by SSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D4} & \begin{DoxyVerb}          D4 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by SPTEQR(V).
          ZPTEQR factors S as  Z4 D4 Z4*
          On exit, the eigenvalues in D4 correspond with the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D5} & \begin{DoxyVerb}          D5 is REAL array of
                             dimension( max(NN) )
          The eigenvalues of A, as computed by SPTEQR(N)
          when Z is not computed. On exit, the
          eigenvalues in D4 correspond with the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+A1} & \begin{DoxyVerb}          WA1 is REAL array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by SSTEBZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+A2} & \begin{DoxyVerb}          WA2 is REAL array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by SSTEBZ.
          Choose random values for IL and IU, and ask for the
          IL-th through IU-th eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+A3} & \begin{DoxyVerb}          WA3 is REAL array of
                             dimension( max(NN) )
          Selected eigenvalues of A, computed to high
          absolute accuracy, with different range options.
          as computed by SSTEBZ.
          Determine the values VL and VU of the IL-th and IU-th
          eigenvalues and ask for all eigenvalues in this range.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array of
                             dimension( max(NN) )
          All eigenvalues of A, computed to high
          absolute accuracy, with different options.
          as computed by SSTEBZ.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array of
                             dimension( LDU, max(NN) ).
          The orthogonal matrix computed by SSYTRD + SORGTR.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U, Z, and V.  It must be at least 1
          and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is REAL array of
                             dimension( LDU, max(NN) ).
          The Housholder vectors computed by SSYTRD in reducing A to
          tridiagonal form.  The vectors computed with UPLO='U' are
          in the upper triangle, and the vectors computed with UPLO='L'
          are in the lower triangle.  (As described in SSYTRD, the
          sub- and superdiagonal are not set to 1, although the
          true Householder vector has a 1 in that position.  The
          routines that use V, such as SORGTR, set those entries to
          1 before using them, and then restore them later.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+P} & \begin{DoxyVerb}          VP is REAL array of
                      dimension( max(NN)*max(NN+1)/2 )
          The matrix V stored in packed format.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is REAL array of
                             dimension( max(NN) )
          The Householder factors computed by SSYTRD in reducing A
          to tridiagonal form.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array of
                             dimension( LDU, max(NN) ).
          The orthogonal matrix of eigenvectors computed by SSTEQR,
          SPTEQR, and SSTEIN.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array of
                      dimension( LWORK )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          1 + 4 * Nmax + 2 * Nmax * lg Nmax + 3 * Nmax**2
          where Nmax = max( NN(j), 2 ) and lg = log base 2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array,
          Workspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+I\+W\+O\+R\+K} & \begin{DoxyVerb}          LIWORK is INTEGER
          The number of entries in IWORK.  This must be at least
                  6 + 6*Nmax + 5 * Nmax * lg Nmax 
          where Nmax = max( NN(j), 2 ) and lg = log base 2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (26)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -5: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -23: LDU < 1 or LDU < NMAX.
          -29: LWORK too small.
          If  SLATMR, SLATMS, SSYTRD, SORGTR, SSTEQR, SSTERF,
              or SORMC2 returns an error code, the
              absolute value of it is returned.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NBLOCK          Blocksize as returned by ENVIR.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far.
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga41b0a1a7d888674eac14ad251c2d94ec}{}\index{real@{real}!sckcsd@{sckcsd}}
\index{sckcsd@{sckcsd}!real@{real}}
\subsubsection[{sckcsd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sckcsd (
\begin{DoxyParamCaption}
\item[{integer}]{N\+M, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{Q\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{M\+M\+A\+X, }
\item[{real, dimension( $\ast$ )}]{X, }
\item[{real, dimension( $\ast$ )}]{X\+F, }
\item[{real, dimension( $\ast$ )}]{U1, }
\item[{real, dimension( $\ast$ )}]{U2, }
\item[{real, dimension( $\ast$ )}]{V1\+T, }
\item[{real, dimension( $\ast$ )}]{V2\+T, }
\item[{real, dimension( $\ast$ )}]{T\+H\+E\+T\+A, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga41b0a1a7d888674eac14ad251c2d94ec}


{\bfseries S\+C\+K\+C\+S\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCKCSD tests SORCSD:
        the CSD for an M-by-M orthogonal matrix X partitioned as
        [ X11 X12; X21 X22 ]. X11 is P-by-Q.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+M} & \begin{DoxyVerb}          NM is INTEGER
          The number of values of M contained in the vector MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q\+V\+A\+L} & \begin{DoxyVerb}          QVAL is INTEGER array, dimension (NM)
          The values of the matrix column dimension Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+M\+A\+X} & \begin{DoxyVerb}          MMAX is INTEGER
          The maximum value permitted for M, used in dimensioning the
          work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X\+F} & \begin{DoxyVerb}          XF is REAL array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U1} & \begin{DoxyVerb}          U1 is REAL array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U2} & \begin{DoxyVerb}          U2 is REAL array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V1\+T} & \begin{DoxyVerb}          V1T is REAL array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V2\+T} & \begin{DoxyVerb}          V2T is REAL array, dimension (MMAX*MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+H\+E\+T\+A} & \begin{DoxyVerb}          THETA is REAL array, dimension (MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If SLAROR returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga0bb2e8d26a324ab0a58f7f742aef9033}{}\index{real@{real}!sckglm@{sckglm}}
\index{sckglm@{sckglm}!real@{real}}
\subsubsection[{sckglm}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sckglm (
\begin{DoxyParamCaption}
\item[{integer}]{N\+N, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{real, dimension( $\ast$ )}]{A, }
\item[{real, dimension( $\ast$ )}]{A\+F, }
\item[{real, dimension( $\ast$ )}]{B, }
\item[{real, dimension( $\ast$ )}]{B\+F, }
\item[{real, dimension( $\ast$ )}]{X, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga0bb2e8d26a324ab0a58f7f742aef9033}


{\bfseries S\+C\+K\+G\+L\+M} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCKGLM tests SGGGLM - subroutine for solving generalized linear
                       model problem.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER
          The number of values of N, M and P contained in the vectors
          NVAL, MVAL and PVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix row dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESID >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension (4*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If SLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaf6b93922e8173c77def9bd60602f8cf0}{}\index{real@{real}!sckgqr@{sckgqr}}
\index{sckgqr@{sckgqr}!real@{real}}
\subsubsection[{sckgqr}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sckgqr (
\begin{DoxyParamCaption}
\item[{integer}]{N\+M, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer}]{N\+P, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer}]{N\+N, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{real, dimension( $\ast$ )}]{A, }
\item[{real, dimension( $\ast$ )}]{A\+F, }
\item[{real, dimension( $\ast$ )}]{A\+Q, }
\item[{real, dimension( $\ast$ )}]{A\+R, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U\+A, }
\item[{real, dimension( $\ast$ )}]{B, }
\item[{real, dimension( $\ast$ )}]{B\+F, }
\item[{real, dimension( $\ast$ )}]{B\+Z, }
\item[{real, dimension( $\ast$ )}]{B\+T, }
\item[{real, dimension( $\ast$ )}]{B\+W\+K, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U\+B, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaf6b93922e8173c77def9bd60602f8cf0}


{\bfseries S\+C\+K\+G\+Q\+R} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCKGQR tests
 SGGQRF: GQR factorization for N-by-M matrix A and N-by-P matrix B,
 SGGRQF: GRQ factorization for M-by-N matrix A and P-by-N matrix B.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+M} & \begin{DoxyVerb}          NM is INTEGER
          The number of values of M contained in the vector MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row(column) dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+P} & \begin{DoxyVerb}          NP is INTEGER
          The number of values of P contained in the vector PVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row(column) dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER
          The number of values of N contained in the vector NVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+Q} & \begin{DoxyVerb}          AQ is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+R} & \begin{DoxyVerb}          AR is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+A} & \begin{DoxyVerb}          TAUA is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+Z} & \begin{DoxyVerb}          BZ is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+T} & \begin{DoxyVerb}          BT is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+K} & \begin{DoxyVerb}          BWK is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+B} & \begin{DoxyVerb}          TAUB is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If SLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga44899af4fbfbe9973dcdfbce9e32977d}{}\index{real@{real}!sckgsv@{sckgsv}}
\index{sckgsv@{sckgsv}!real@{real}}
\subsubsection[{sckgsv}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sckgsv (
\begin{DoxyParamCaption}
\item[{integer}]{N\+M, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{real, dimension( $\ast$ )}]{A, }
\item[{real, dimension( $\ast$ )}]{A\+F, }
\item[{real, dimension( $\ast$ )}]{B, }
\item[{real, dimension( $\ast$ )}]{B\+F, }
\item[{real, dimension( $\ast$ )}]{U, }
\item[{real, dimension( $\ast$ )}]{V, }
\item[{real, dimension( $\ast$ )}]{Q, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{real, dimension( $\ast$ )}]{R, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga44899af4fbfbe9973dcdfbce9e32977d}


{\bfseries S\+C\+K\+G\+S\+V} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCKGSV tests SGGSVD:
        the GSVD for M-by-N matrix A and P-by-N matrix B.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+M} & \begin{DoxyVerb}          NM is INTEGER
          The number of values of M contained in the vector MVAL.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NM)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NP)
          The values of the matrix row dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If SLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gab468002a1d34c94fa7185710bac534a3}{}\index{real@{real}!scklse@{scklse}}
\index{scklse@{scklse}!real@{real}}
\subsubsection[{scklse}]{\setlength{\rightskip}{0pt plus 5cm}subroutine scklse (
\begin{DoxyParamCaption}
\item[{integer}]{N\+N, }
\item[{integer, dimension( $\ast$ )}]{M\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{P\+V\+A\+L, }
\item[{integer, dimension( $\ast$ )}]{N\+V\+A\+L, }
\item[{integer}]{N\+M\+A\+T\+S, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+M\+A\+X, }
\item[{real, dimension( $\ast$ )}]{A, }
\item[{real, dimension( $\ast$ )}]{A\+F, }
\item[{real, dimension( $\ast$ )}]{B, }
\item[{real, dimension( $\ast$ )}]{B\+F, }
\item[{real, dimension( $\ast$ )}]{X, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gab468002a1d34c94fa7185710bac534a3}


{\bfseries S\+C\+K\+L\+S\+E} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCKLSE tests SGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER
          The number of values of (M,P,N) contained in the vectors
          (MVAL, PVAL, NVAL).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V\+A\+L} & \begin{DoxyVerb}          MVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+V\+A\+L} & \begin{DoxyVerb}          PVAL is INTEGER array, dimension (NN)
          The values of the matrix row(column) dimension P.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+V\+A\+L} & \begin{DoxyVerb}          NVAL is INTEGER array, dimension (NN)
          The values of the matrix column(row) dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+T\+S} & \begin{DoxyVerb}          NMATS is INTEGER
          The number of matrix types to be tested for each combination
          of matrix dimensions.  If NMATS >= NTYPES (the maximum
          number of matrix types), then all the different types are
          generated for testing.  If NMATS < NTYPES, another input line
          is read to get the numbers of the matrix types to be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095, otherwise they will be
          reduced mod 4096, and ISEED(4) must be odd.
          On exit, the next seed in the random number sequence after
          all the test matrices have been generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  To have
          every test ratio printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+M\+A\+X} & \begin{DoxyVerb}          NMAX is INTEGER
          The maximum value permitted for M or N, used in dimensioning
          the work arrays.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension (5*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (NMAX*NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The unit number for input.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The unit number for output.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0 :  successful exit
          > 0 :  If SLATMS returns an error code, the absolute value
                 of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga78ceb344e13f1336e85930c14689975f}{}\index{real@{real}!scsdts@{scsdts}}
\index{scsdts@{scsdts}!real@{real}}
\subsubsection[{scsdts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine scsdts (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{Q, }
\item[{real, dimension( ldx, $\ast$ )}]{X, }
\item[{real, dimension( ldx, $\ast$ )}]{X\+F, }
\item[{integer}]{L\+D\+X, }
\item[{real, dimension( ldu1, $\ast$ )}]{U1, }
\item[{integer}]{L\+D\+U1, }
\item[{real, dimension( ldu2, $\ast$ )}]{U2, }
\item[{integer}]{L\+D\+U2, }
\item[{real, dimension( ldv1t, $\ast$ )}]{V1\+T, }
\item[{integer}]{L\+D\+V1\+T, }
\item[{real, dimension( ldv2t, $\ast$ )}]{V2\+T, }
\item[{integer}]{L\+D\+V2\+T, }
\item[{real, dimension( $\ast$ )}]{T\+H\+E\+T\+A, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{real, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{real, dimension( 15 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga78ceb344e13f1336e85930c14689975f}


{\bfseries S\+C\+S\+D\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SCSDTS tests SORCSD, which, given an M-by-M partitioned orthogonal
 matrix X,
              Q  M-Q
       X = [ X11 X12 ] P   ,
           [ X21 X22 ] M-P

 computes the CSD

       [ U1    ]**T * [ X11 X12 ] * [ V1    ]
       [    U2 ]      [ X21 X22 ]   [    V2 ]

                             [  I  0  0 |  0  0  0 ]
                             [  0  C  0 |  0 -S  0 ]
                             [  0  0  0 |  0  0 -I ]
                           = [---------------------] = [ D11 D12 ] .
                             [  0  0  0 |  I  0  0 ]   [ D21 D22 ]
                             [  0  S  0 |  0  C  0 ]
                             [  0  0  I |  0  0  0 ]

 and also SORCSD2BY1, which, given
          Q
       [ X11 ] P   ,
       [ X21 ] M-P

 computes the 2-by-1 CSD

                                     [  I  0  0 ]
                                     [  0  C  0 ]
                                     [  0  0  0 ]
       [ U1    ]**T * [ X11 ] * V1 = [----------] = [ D11 ] ,
       [    U2 ]      [ X21 ]        [  0  0  0 ]   [ D21 ]
                                     [  0  S  0 ]
                                     [  0  0  I ]\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix X.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix X11.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q} & \begin{DoxyVerb}          Q is INTEGER
          The number of columns of the matrix X11.  Q >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension (LDX,M)
          The M-by-M matrix X.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X\+F} & \begin{DoxyVerb}          XF is REAL array, dimension (LDX,M)
          Details of the CSD of X, as returned by SORCSD;
          see SORCSD for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the arrays X and XF.
          LDX >= max( 1,M ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U1} & \begin{DoxyVerb}          U1 is REAL array, dimension(LDU1,P)
          The P-by-P orthogonal matrix U1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U1} & \begin{DoxyVerb}          LDU1 is INTEGER
          The leading dimension of the array U1. LDU >= max(1,P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U2} & \begin{DoxyVerb}          U2 is REAL array, dimension(LDU2,M-P)
          The (M-P)-by-(M-P) orthogonal matrix U2.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U2} & \begin{DoxyVerb}          LDU2 is INTEGER
          The leading dimension of the array U2. LDU >= max(1,M-P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V1\+T} & \begin{DoxyVerb}          V1T is REAL array, dimension(LDV1T,Q)
          The Q-by-Q orthogonal matrix V1T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V1\+T} & \begin{DoxyVerb}          LDV1T is INTEGER
          The leading dimension of the array V1T. LDV1T >=
          max(1,Q).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V2\+T} & \begin{DoxyVerb}          V2T is REAL array, dimension(LDV2T,M-Q)
          The (M-Q)-by-(M-Q) orthogonal matrix V2T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V2\+T} & \begin{DoxyVerb}          LDV2T is INTEGER
          The leading dimension of the array V2T. LDV2T >=
          max(1,M-Q).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+H\+E\+T\+A} & \begin{DoxyVerb}          THETA is REAL array, dimension MIN(P,M-P,Q,M-Q)
          The CS values of X; the essentially diagonal matrices C and
          S are constructed from THETA; see subroutine SORCSD for
          details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (15)
          The test ratios:
          First, the 2-by-2 CSD:
          RESULT(1) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(2) = norm( U1'*X12*V2 - D12 ) / ( MAX(1,P,M-Q)*EPS2 )
          RESULT(3) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(4) = norm( U2'*X22*V2 - D22 ) / ( MAX(1,M-P,M-Q)*EPS2 )
          RESULT(5) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(6) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(7) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(8) = norm( I - V2T'*V2T ) / ( MAX(1,M-Q)*ULP )
          RESULT(9) = 0        if THETA is in increasing order and
                               all angles are in [0,pi/2];
                    = ULPINV   otherwise.
          Then, the 2-by-1 CSD:
          RESULT(10) = norm( U1'*X11*V1 - D11 ) / ( MAX(1,P,Q)*EPS2 )
          RESULT(11) = norm( U2'*X21*V1 - D21 ) / ( MAX(1,M-P,Q)*EPS2 )
          RESULT(12) = norm( I - U1'*U1 ) / ( MAX(1,P)*ULP )
          RESULT(13) = norm( I - U2'*U2 ) / ( MAX(1,M-P)*ULP )
          RESULT(14) = norm( I - V1T'*V1T ) / ( MAX(1,Q)*ULP )
          RESULT(15) = 0        if THETA is in increasing order and
                                all angles are in [0,pi/2];
                     = ULPINV   otherwise.
          ( EPS2 = MAX( norm( I - X'*X ) / M, ULP ). )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaf011c82fb3efb201f7568fe7acac6d3b}{}\index{real@{real}!sdrges@{sdrges}}
\index{sdrges@{sdrges}!real@{real}}
\subsubsection[{sdrges}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrges (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{B, }
\item[{real, dimension( lda, $\ast$ )}]{S, }
\item[{real, dimension( lda, $\ast$ )}]{T, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( ldq, $\ast$ )}]{Z, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+R, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+I, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( 13 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaf011c82fb3efb201f7568fe7acac6d3b}


{\bfseries S\+D\+R\+G\+E\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SDRGES checks the nonsymmetric generalized eigenvalue (Schur form)
 problem driver SGGES.

 SGGES factors A and B as Q S Z'  and Q T Z' , where ' means
 transpose, T is upper triangular, S is in generalized Schur form
 (block upper triangular, with 1x1 and 2x2 blocks on the diagonal,
 the 2x2 blocks corresponding to complex conjugate pairs of
 generalized eigenvalues), and Q and Z are orthogonal. It also
 computes the generalized eigenvalues (alpha(j),beta(j)), j=1,...,n,
 Thus, w(j) = alpha(j)/beta(j) is a root of the characteristic
 equation
                 det( A - w(j) B ) = 0
 Optionally it also reorder the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms.

 When SDRGES is called, a number of matrix "sizes" ("N's") and a
 number of matrix "TYPES" are specified.  For each size ("N")
 and each TYPE of matrix, a pair of matrices (A, B) will be generated
 and used for testing. For each matrix pair, the following 13 tests
 will be performed and compared with the threshhold THRESH except
 the tests (5), (11) and (13).


 (1)   | A - Q S Z' | / ( |A| n ulp ) (no sorting of eigenvalues)


 (2)   | B - Q T Z' | / ( |B| n ulp ) (no sorting of eigenvalues)


 (3)   | I - QQ' | / ( n ulp ) (no sorting of eigenvalues)


 (4)   | I - ZZ' | / ( n ulp ) (no sorting of eigenvalues)

 (5)   if A is in Schur form (i.e. quasi-triangular form)
       (no sorting of eigenvalues)

 (6)   if eigenvalues = diagonal blocks of the Schur form (S, T),
       i.e., test the maximum over j of D(j)  where:

       if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

       and S and T are here the 2 x 2 diagonal blocks of S and T
       corresponding to the j-th and j+1-th eigenvalues.
       (no sorting of eigenvalues)

 (7)   | (A,B) - Q (S,T) Z' | / ( | (A,B) | n ulp )
            (with sorting of eigenvalues).

 (8)   | I - QQ' | / ( n ulp ) (with sorting of eigenvalues).

 (9)   | I - ZZ' | / ( n ulp ) (with sorting of eigenvalues).

 (10)  if A is in Schur form (i.e. quasi-triangular form)
       (with sorting of eigenvalues).

 (11)  if eigenvalues = diagonal blocks of the Schur form (S, T),
       i.e. test the maximum over j of D(j)  where:

       if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

       and S and T are here the 2 x 2 diagonal blocks of S and T
       corresponding to the j-th and j+1-th eigenvalues.
       (with sorting of eigenvalues).

 (12)  if sorting worked and SDIM is the number of eigenvalues
       which were SELECTed.

 Test Matrices
 =============

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRGES does nothing.  NSIZES >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRGES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A on input.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRGES to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  THRESH >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array,
                                       dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is REAL array,
                                       dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by SGGES.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is REAL array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by SGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDQ, max(NN))
          The (left) orthogonal matrix computed by SGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by SGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+R} & \begin{DoxyVerb}          ALPHAR is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+I} & \begin{DoxyVerb}          ALPHAI is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by SGGES.
          ( ALPHAR(k)+ALPHAI(k)*i ) / BETA(k) is the k-th
          generalized eigenvalue of A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.
          LWORK >= MAX( 10*(N+1), 3*N*N ), where N is the largest
          matrix dimension.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gae07927c6321c12cd0d92450eaa21ea9c}{}\index{real@{real}!sdrgev@{sdrgev}}
\index{sdrgev@{sdrgev}!real@{real}}
\subsubsection[{sdrgev}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrgev (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{B, }
\item[{real, dimension( lda, $\ast$ )}]{S, }
\item[{real, dimension( lda, $\ast$ )}]{T, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( ldq, $\ast$ )}]{Z, }
\item[{real, dimension( ldqe, $\ast$ )}]{Q\+E, }
\item[{integer}]{L\+D\+Q\+E, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+R, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+I, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+R1, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+I1, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A1, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gae07927c6321c12cd0d92450eaa21ea9c}


{\bfseries S\+D\+R\+G\+E\+V} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SDRGEV checks the nonsymmetric generalized eigenvalue problem driver
 routine SGGEV.

 SGGEV computes for a pair of n-by-n nonsymmetric matrices (A,B) the
 generalized eigenvalues and, optionally, the left and right
 eigenvectors.

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
 or a ratio  alpha/beta = w, such that A - w*B is singular.  It is
 usually represented as the pair (alpha,beta), as there is reasonalbe
 interpretation for beta=0, and even for both being zero.

 A right generalized eigenvector corresponding to a generalized
 eigenvalue  w  for a pair of matrices (A,B) is a vector r  such that
 (A - wB) * r = 0.  A left generalized eigenvector is a vector l such
 that l**H * (A - wB) = 0, where l**H is the conjugate-transpose of l.

 When SDRGEV is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, a pair of matrices (A, B) will be generated
 and used for testing.  For each matrix pair, the following tests
 will be performed and compared with the threshhold THRESH.

 Results from SGGEV:

 (1)  max over all left eigenvalue/-vector pairs (alpha/beta,l) of

      | VL**H * (beta A - alpha B) |/( ulp max(|beta A|, |alpha B|) )

      where VL**H is the conjugate-transpose of VL.

 (2)  | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

 (3)  max over all left eigenvalue/-vector pairs (alpha/beta,r) of

      | (beta A - alpha B) * VR | / ( ulp max(|beta A|, |alpha B|) )

 (4)  | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

 (5)  W(full) = W(partial)
      W(full) denotes the eigenvalues computed when both l and r
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and r, or only W and l are
      computed.

 (6)  VL(full) = VL(partial)
      VL(full) denotes the left eigenvectors computed when both l
      and r are computed, and VL(partial) denotes the result
      when only l is computed.

 (7)  VR(full) = VR(partial)
      VR(full) denotes the right eigenvectors computed when both l
      and r are also computed, and VR(partial) denotes the result
      when only l is computed.


 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRGES does nothing.  NSIZES >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  NN >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRGES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated. If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096. Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRGES to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IERR not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array,
                                       dimension(LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, S, and T.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is REAL array,
                                       dimension(LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is REAL array,
                                 dimension (LDA, max(NN))
          The Schur form matrix computed from A by SGGES.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is REAL array,
                                 dimension (LDA, max(NN))
          The upper triangular matrix computed from B by SGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array,
                                 dimension (LDQ, max(NN))
          The (left) eigenvectors matrix computed by SGGEV.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q and Z. It must
          be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by SGGES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q\+E} & \begin{DoxyVerb}          QE is REAL array, dimension( LDQ, max(NN) )
          QE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q\+E} & \begin{DoxyVerb}          LDQE is INTEGER
          The leading dimension of QE. LDQE >= max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+R} & \begin{DoxyVerb}          ALPHAR is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+I} & \begin{DoxyVerb}          ALPHAI is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL array, dimension (max(NN))
 \verbatim
          The generalized eigenvalues of (A,B) computed by SGGEV.
          ( ALPHAR(k)+ALPHAI(k)*i ) / BETA(k) is the k-th
          generalized eigenvalue of A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+R1} & \begin{DoxyVerb}          ALPHR1 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+I1} & \begin{DoxyVerb}          ALPHI1 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A1} & \begin{DoxyVerb}          BETA1 is REAL array, dimension (max(NN))

          Like ALPHAR, ALPHAI, BETA, these arrays contain the
          eigenvalues of A and B, but those computed when SGGEV only
          computes a partial eigendecomposition, i.e. not the
          eigenvalues and left and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  LWORK >= MAX( 8*N, N*(N+1) ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gae0b0f905c9537cea1599d61c17e003bc}{}\index{real@{real}!sdrgsx@{sdrgsx}}
\index{sdrgsx@{sdrgsx}!real@{real}}
\subsubsection[{sdrgsx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrgsx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E, }
\item[{integer}]{N\+C\+M\+A\+X, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{B, }
\item[{real, dimension( lda, $\ast$ )}]{A\+I, }
\item[{real, dimension( lda, $\ast$ )}]{B\+I, }
\item[{real, dimension( lda, $\ast$ )}]{Z, }
\item[{real, dimension( lda, $\ast$ )}]{Q, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+R, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+I, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{real, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{real, dimension( $\ast$ )}]{S, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gae0b0f905c9537cea1599d61c17e003bc}


{\bfseries S\+D\+R\+G\+S\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SDRGSX checks the nonsymmetric generalized eigenvalue (Schur form)
 problem expert driver SGGESX.

 SGGESX factors A and B as Q S Z' and Q T Z', where ' means
 transpose, T is upper triangular, S is in generalized Schur form
 (block upper triangular, with 1x1 and 2x2 blocks on the diagonal,
 the 2x2 blocks corresponding to complex conjugate pairs of
 generalized eigenvalues), and Q and Z are orthogonal.  It also
 computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)). Thus, w(j) = alpha(j)/beta(j) is a root of the
 characteristic equation

     det( A - w(j) B ) = 0

 Optionally it also reorders the eigenvalues so that a selected
 cluster of eigenvalues appears in the leading diagonal block of the
 Schur forms; computes a reciprocal condition number for the average
 of the selected eigenvalues; and computes a reciprocal condition
 number for the right and left deflating subspaces corresponding to
 the selected eigenvalues.

 When SDRGSX is called with NSIZE > 0, five (5) types of built-in
 matrix pairs are used to test the routine SGGESX.

 When SDRGSX is called with NSIZE = 0, it reads in test matrix data
 to test SGGESX.

 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH except for the tests (7) and (9):

 (1)   | A - Q S Z' | / ( |A| n ulp )

 (2)   | B - Q T Z' | / ( |B| n ulp )

 (3)   | I - QQ' | / ( n ulp )

 (4)   | I - ZZ' | / ( n ulp )

 (5)   if A is in Schur form (i.e. quasi-triangular form)

 (6)   maximum over j of D(j)  where:

       if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

       if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

           and S and T are here the 2 x 2 diagonal blocks of S and T
           corresponding to the j-th and j+1-th eigenvalues.

 (7)   if sorting worked and SDIM is the number of eigenvalues
       which were selected.

 (8)   the estimated value DIF does not differ from the true values of
       Difu and Difl more than a factor 10*THRESH. If the estimate DIF
       equals zero the corresponding true values of Difu and Difl
       should be less than EPS*norm(A, B). If the true value of Difu
       and Difl equal zero, the estimate DIF should be less than
       EPS*norm(A, B).

 (9)   If INFO = N+3 is returned by SGGESX, the reordering "failed"
       and we check that DIF = PL = PR = 0 and that the true value of
       Difu and Difl is < EPS*norm(A, B). We count the events when
       INFO=N+3.

 For read-in test matrices, the above tests are run except that the
 exact value for DIF (and PL) is input data.  Additionally, there is
 one more test run for read-in test matrices:

 (10)  the estimated value PL does not differ from the true value of
       PLTRU more than a factor THRESH. If the estimate PL equals
       zero the corresponding true value of PLTRU should be less than
       EPS*norm(A, B). If the true value of PLTRU equal zero, the
       estimate PL should be less than EPS*norm(A, B).

 Note that for the built-in tests, a total of 10*NSIZE*(NSIZE-1)
 matrix pairs are generated and tested. NSIZE should be kept small.

 SVD (routine SGESVD) is used for computing the true value of DIF_u
 and DIF_l when testing the built-in test problems.

 Built-in Test Matrices
 ======================

 All built-in test matrices are the 2 by 2 block of triangular
 matrices

          A = [ A11 A12 ]    and      B = [ B11 B12 ]
              [     A22 ]                 [     B22 ]

 where for different type of A11 and A22 are given as the following.
 A12 and B12 are chosen so that the generalized Sylvester equation

          A11*R - L*A22 = -A12
          B11*R - L*B22 = -B12

 have prescribed solution R and L.

 Type 1:  A11 = J_m(1,-1) and A_22 = J_k(1-a,1).
          B11 = I_m, B22 = I_k
          where J_k(a,b) is the k-by-k Jordan block with ``a'' on
          diagonal and ``b'' on superdiagonal.

 Type 2:  A11 = (a_ij) = ( 2(.5-sin(i)) ) and
          B11 = (b_ij) = ( 2(.5-sin(ij)) ) for i=1,...,m, j=i,...,m
          A22 = (a_ij) = ( 2(.5-sin(i+j)) ) and
          B22 = (b_ij) = ( 2(.5-sin(ij)) ) for i=m+1,...,k, j=i,...,k

 Type 3:  A11, A22 and B11, B22 are chosen as for Type 2, but each
          second diagonal block in A_11 and each third diagonal block
          in A_22 are made as 2 by 2 blocks.

 Type 4:  A11 = ( 20(.5 - sin(ij)) ) and B22 = ( 2(.5 - sin(i+j)) )
             for i=1,...,m,  j=1,...,m and
          A22 = ( 20(.5 - sin(i+j)) ) and B22 = ( 2(.5 - sin(ij)) )
             for i=m+1,...,k,  j=m+1,...,k

 Type 5:  (A,B) and have potentially close or common eigenvalues and
          very large departure from block diagonality A_11 is chosen
          as the m x m leading submatrix of A_1:
                  |  1  b                            |
                  | -b  1                            |
                  |        1+d  b                    |
                  |         -b 1+d                   |
           A_1 =  |                  d  1            |
                  |                 -1  d            |
                  |                        -d  1     |
                  |                        -1 -d     |
                  |                               1  |
          and A_22 is chosen as the k x k leading submatrix of A_2:
                  | -1  b                            |
                  | -b -1                            |
                  |       1-d  b                     |
                  |       -b  1-d                    |
           A_2 =  |                 d 1+b            |
                  |               -1-b d             |
                  |                       -d  1+b    |
                  |                      -1+b  -d    |
                  |                              1-d |
          and matrix B are chosen as identity matrices (see SLATM5).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E} & \begin{DoxyVerb}          NSIZE is INTEGER
          The maximum size of the matrices to use. NSIZE >= 0.
          If NSIZE = 0, no built-in tests matrices are used, but
          read-in test matrices are used to test SGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+C\+M\+A\+X} & \begin{DoxyVerb}          NCMAX is INTEGER
          Maximum allowable NMAX for generating Kroneker matrix
          in call to SLAKF2\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  THRESH >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Z and Q,
          LDA >= max( 1, NSIZE ). For the read-in test,
          LDA >= max( 1, N ), N is the size of the test matrices.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDA, NSIZE)
          Used to store the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+I} & \begin{DoxyVerb}          AI is REAL array, dimension (LDA, NSIZE)
          Copy of A, modified by SGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+I} & \begin{DoxyVerb}          BI is REAL array, dimension (LDA, NSIZE)
          Copy of B, modified by SGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension (LDA, NSIZE)
          Z holds the left Schur vectors computed by SGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDA, NSIZE)
          Q holds the right Schur vectors computed by SGGESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+R} & \begin{DoxyVerb}          ALPHAR is REAL array, dimension (NSIZE)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+I} & \begin{DoxyVerb}          ALPHAI is REAL array, dimension (NSIZE)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL array, dimension (NSIZE)
 \verbatim
          On exit, (ALPHAR + ALPHAI*i)/BETA are the eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C} & \begin{DoxyVerb}          C is REAL array, dimension (LDC, LDC)
          Store the matrix generated by subroutine SLAKF2, this is the
          matrix formed by Kronecker products used for estimating
          DIF.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of C. LDC >= max(1, LDA*LDA/2 ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension (LDC)
          Singular values of C\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.
          LWORK >= MAX( 5*NSIZE*NSIZE/2 - 2, 10*(NSIZE+1) )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (LIWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+I\+W\+O\+R\+K} & \begin{DoxyVerb}          LIWORK is INTEGER
          The dimension of the array IWORK. LIWORK >= NSIZE + 6.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (LDA)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga01b4d3586799e995efa59513c1bc9ec2}{}\index{real@{real}!sdrgvx@{sdrgvx}}
\index{sdrgvx@{sdrgvx}!real@{real}}
\subsubsection[{sdrgvx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrgvx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+N, }
\item[{integer}]{N\+O\+U\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{B, }
\item[{real, dimension( lda, $\ast$ )}]{A\+I, }
\item[{real, dimension( lda, $\ast$ )}]{B\+I, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+R, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+I, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{real, dimension( lda, $\ast$ )}]{V\+L, }
\item[{real, dimension( lda, $\ast$ )}]{V\+R, }
\item[{integer}]{I\+L\+O, }
\item[{integer}]{I\+H\+I, }
\item[{real, dimension( $\ast$ )}]{L\+S\+C\+A\+L\+E, }
\item[{real, dimension( $\ast$ )}]{R\+S\+C\+A\+L\+E, }
\item[{real, dimension( $\ast$ )}]{S, }
\item[{real, dimension( $\ast$ )}]{S\+T\+R\+U, }
\item[{real, dimension( $\ast$ )}]{D\+I\+F, }
\item[{real, dimension( $\ast$ )}]{D\+I\+F\+T\+R\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{real, dimension( 4 )}]{R\+E\+S\+U\+L\+T, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga01b4d3586799e995efa59513c1bc9ec2}


{\bfseries S\+D\+R\+G\+V\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SDRGVX checks the nonsymmetric generalized eigenvalue problem
 expert driver SGGEVX.

 SGGEVX computes the generalized eigenvalues, (optionally) the left
 and/or right eigenvectors, (optionally) computes a balancing
 transformation to improve the conditioning, and (optionally)
 reciprocal condition numbers for the eigenvalues and eigenvectors.

 When SDRGVX is called with NSIZE > 0, two types of test matrix pairs
 are generated by the subroutine SLATM6 and test the driver SGGEVX.
 The test matrices have the known exact condition numbers for
 eigenvalues. For the condition numbers of the eigenvectors
 corresponding the first and last eigenvalues are also know
 ``exactly'' (see SLATM6).

 For each matrix pair, the following tests will be performed and
 compared with the threshhold THRESH.

 (1) max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

     where l**H is the conjugate tranpose of l.

 (2) max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 (3) The condition number S(i) of eigenvalues computed by SGGEVX
     differs less than a factor THRESH from the exact S(i) (see
     SLATM6).

 (4) DIF(i) computed by STGSNA differs less than a factor 10*THRESH
     from the exact value (for the 1st and 5th vectors only).

 Test Matrices
 =============

 Two kinds of test matrix pairs

          (A, B) = inverse(YH) * (Da, Db) * inverse(X)

 are used in the tests:

 1: Da = 1+a   0    0    0    0    Db = 1   0   0   0   0
          0   2+a   0    0    0         0   1   0   0   0
          0    0   3+a   0    0         0   0   1   0   0
          0    0    0   4+a   0         0   0   0   1   0
          0    0    0    0   5+a ,      0   0   0   0   1 , and

 2: Da =  1   -1    0    0    0    Db = 1   0   0   0   0
          1    1    0    0    0         0   1   0   0   0
          0    0    1    0    0         0   0   1   0   0
          0    0    0   1+a  1+b        0   0   0   1   0
          0    0    0  -1-b  1+a ,      0   0   0   0   1 .

 In both cases the same inverse(YH) and inverse(X) are used to compute
 (A, B), giving the exact eigenvectors to (A,B) as (YH, X):

 YH:  =  1    0   -y    y   -y    X =  1   0  -x  -x   x
         0    1   -y    y   -y         0   1   x  -x  -x
         0    0    1    0    0         0   0   1   0   0
         0    0    0    1    0         0   0   0   1   0
         0    0    0    0    1,        0   0   0   0   1 , where

 a, b, x and y will have all values independently of each other from
 { sqrt(sqrt(ULP)),  0.1,  1,  10,  1/sqrt(sqrt(ULP)) }.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E} & \begin{DoxyVerb}          NSIZE is INTEGER
          The number of sizes of matrices to use.  NSIZE must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIN will be
          tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, AI, BI, Ao, and Bo.
          It must be at least 1 and at least NSIZE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDA, NSIZE)
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, B contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+I} & \begin{DoxyVerb}          AI is REAL array, dimension (LDA, NSIZE)
          Copy of A, modified by SGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+I} & \begin{DoxyVerb}          BI is REAL array, dimension (LDA, NSIZE)
          Copy of B, modified by SGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+R} & \begin{DoxyVerb}          ALPHAR is REAL array, dimension (NSIZE)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A\+I} & \begin{DoxyVerb}          ALPHAI is REAL array, dimension (NSIZE)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL array, dimension (NSIZE)

          On exit, (ALPHAR + ALPHAI*i)/BETA are the eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is REAL array, dimension (LDA, NSIZE)
          VL holds the left eigenvectors computed by SGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is REAL array, dimension (LDA, NSIZE)
          VR holds the right eigenvectors computed by SGGEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+L\+O} & \begin{DoxyVerb}        ILO is INTEGER\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+H\+I} & \begin{DoxyVerb}        IHI is INTEGER\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+S\+C\+A\+L\+E} & \begin{DoxyVerb}        LSCALE is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+S\+C\+A\+L\+E} & \begin{DoxyVerb}        RSCALE is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}        S is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+T\+R\+U} & \begin{DoxyVerb}        STRU is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+I\+F} & \begin{DoxyVerb}        DIF is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+I\+F\+T\+R\+U} & \begin{DoxyVerb}        DIFTRU is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          Leading dimension of WORK.  LWORK >= 2*N*N+12*N+16.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (LIWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+I\+W\+O\+R\+K} & \begin{DoxyVerb}          LIWORK is INTEGER
          Leading dimension of IWORK.  Must be at least N+6.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}        RESULT is REAL array, dimension (4)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga7a1566f98bf91396ed2fd1e2c70865eb}{}\index{real@{real}!sdrvbd@{sdrvbd}}
\index{sdrvbd@{sdrvbd}!real@{real}}
\subsubsection[{sdrvbd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrvbd (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{M\+M, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldvt, $\ast$ )}]{V\+T, }
\item[{integer}]{L\+D\+V\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A\+S\+A\+V, }
\item[{real, dimension( ldu, $\ast$ )}]{U\+S\+A\+V, }
\item[{real, dimension( ldvt, $\ast$ )}]{V\+T\+S\+A\+V, }
\item[{real, dimension( $\ast$ )}]{S, }
\item[{real, dimension( $\ast$ )}]{S\+S\+A\+V, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{N\+O\+U\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga7a1566f98bf91396ed2fd1e2c70865eb}


{\bfseries S\+D\+R\+V\+B\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SDRVBD checks the singular value decomposition (SVD) drivers
 SGESVD, SGESDD, SGESVJ, and SGEJSV.

 Both SGESVD and SGESDD factor A = U diag(S) VT, where U and VT are
 orthogonal and diag(S) is diagonal with the entries of the array S
 on its diagonal. The entries of S are the singular values,
 nonnegative and stored in decreasing order.  U and VT can be
 optionally not computed, overwritten on A, or computed partially.

 A is M by N. Let MNMIN = min( M, N ). S has dimension MNMIN.
 U can be M by M or M by MNMIN. VT can be N by N or MNMIN by N.

 When SDRVBD is called, a number of matrix "sizes" (M's and N's)
 and a number of matrix "types" are specified.  For each size (M,N)
 and each type of matrix, and for the minimal workspace as well as
 workspace adequate to permit blocking, an  M x N  matrix "A" will be
 generated and used to test the SVD routines.  For each matrix, A will
 be factored as A = U diag(S) VT and the following 12 tests computed:

 Test for SGESVD:

 (1)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (2)    | I - U'U | / ( M ulp )

 (3)    | I - VT VT' | / ( N ulp )

 (4)    S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 (5)    | U - Upartial | / ( M ulp ) where Upartial is a partially
        computed U.

 (6)    | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
        computed VT.

 (7)    | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
        vector of singular values from the partial SVD

 Test for SGESDD:

 (8)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (9)    | I - U'U | / ( M ulp )

 (10)   | I - VT VT' | / ( N ulp )

 (11)   S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 (12)   | U - Upartial | / ( M ulp ) where Upartial is a partially
        computed U.

 (13)   | VT - VTpartial | / ( N ulp ) where VTpartial is a partially
        computed VT.

 (14)   | S - Spartial | / ( MNMIN ulp |S| ) where Spartial is the
        vector of singular values from the partial SVD

 Test for SGESVJ:

 (15)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (16)    | I - U'U | / ( M ulp )

 (17)   | I - VT VT' | / ( N ulp )

 (18)   S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 Test for SGEJSV:

 (19)    | A - U diag(S) VT | / ( |A| max(M,N) ulp )

 (20)    | I - U'U | / ( M ulp )

 (21)   | I - VT VT' | / ( N ulp )

 (22)   S contains MNMIN nonnegative values in decreasing order.
        (Return 0 if true, 1/ULP if false.)

 The "sizes" are specified by the arrays MM(1:NSIZES) and
 NN(1:NSIZES); the value of each element pair (MM(j),NN(j))
 specifies one size.  The "types" are specified by a logical array
 DOTYPE( 1:NTYPES ); if DOTYPE(j) is .TRUE., then matrix type "j"
 will be generated.
 Currently, the list of possible types is:

 (1)  The zero matrix.
 (2)  The identity matrix.
 (3)  A matrix of the form  U D V, where U and V are orthogonal and
      D has evenly spaced entries 1, ..., ULP with random signs
      on the diagonal.
 (4)  Same as (3), but multiplied by the underflow-threshold / ULP.
 (5)  Same as (3), but multiplied by the overflow-threshold * ULP.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of matrix sizes (M,N) contained in the vectors
          MM and NN.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+M} & \begin{DoxyVerb}          MM is INTEGER array, dimension (NSIZES)
          The values of the matrix row dimension M.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          The values of the matrix column dimension N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRVBD
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrices are in A and B.
          This is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size (m,n), a matrix
          of type j will be generated.  If NTYPES is smaller than the
          maximum number of types defined (PARAMETER MAXTYP), then
          types NTYPES+1 through MAXTYP will not be generated.  If
          NTYPES is larger than MAXTYP, DOTYPE(MAXTYP+1) through
          DOTYPE(NTYPES) will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry, the seed of the random number generator.  The array
          elements should be between 0 and 4095; if not they will be
          reduced mod 4096.  Also, ISEED(4) must be odd.
          On exit, ISEED is changed and can be used in the next call to
          SDRVBD to continue the same random number sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          The threshold value for the test ratios.  A result is
          included in the output file if RESULT >= THRESH.  The test
          ratios are scaled to be O(1), so THRESH should be a small
          multiple of 1, e.g., 10 or 100.  To have every test ratio
          printed, use THRESH = 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,NMAX)
          where NMAX is the maximum value of N in NN.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,MMAX),
          where MMAX is the maximum value of M in MM.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU,MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U.  LDU >= max(1,MMAX).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+T} & \begin{DoxyVerb}          VT is REAL array, dimension (LDVT,NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+T} & \begin{DoxyVerb}          LDVT is INTEGER
          The leading dimension of the array VT.  LDVT >= max(1,NMAX).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+S\+A\+V} & \begin{DoxyVerb}          ASAV is REAL array, dimension (LDA,NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U\+S\+A\+V} & \begin{DoxyVerb}          USAV is REAL array, dimension (LDU,MMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+T\+S\+A\+V} & \begin{DoxyVerb}          VTSAV is REAL array, dimension (LDVT,NMAX)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension
                      (max(min(MM,NN)))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+S\+A\+V} & \begin{DoxyVerb}          SSAV is REAL array, dimension
                      (max(min(MM,NN)))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension
                      (max(min(MM,NN)))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(3*MN+MX,5*MN-4)+2*MN**2 for all pairs
          pairs  (MN,MX)=( min(MM(j),NN(j), max(MM(j),NN(j)) )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension at least 8*min(M,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+T} & \begin{DoxyVerb}          NOUT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some MM(j) < 0
           -3: Some NN(j) < 0
           -4: NTYPES < 0
           -7: THRESH < 0
          -10: LDA < 1 or LDA < MMAX, where MMAX is max( MM(j) ).
          -12: LDU < 1 or LDU < MMAX.
          -14: LDVT < 1 or LDVT < NMAX, where NMAX is max( NN(j) ).
          -21: LWORK too small.
          If  SLATMS, or SGESVD returns an error code, the
              absolute value of it is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga1f741a939ab68209bb2d6028538da0c1}{}\index{real@{real}!sdrves@{sdrves}}
\index{sdrves@{sdrves}!real@{real}}
\subsubsection[{sdrves}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrves (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( lda, $\ast$ )}]{H\+T, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( $\ast$ )}]{W\+I, }
\item[{real, dimension( $\ast$ )}]{W\+R\+T, }
\item[{real, dimension( $\ast$ )}]{W\+I\+T, }
\item[{real, dimension( ldvs, $\ast$ )}]{V\+S, }
\item[{integer}]{L\+D\+V\+S, }
\item[{real, dimension( 13 )}]{R\+E\+S\+U\+L\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga1f741a939ab68209bb2d6028538da0c1}


{\bfseries S\+D\+R\+V\+E\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SDRVES checks the nonsymmetric eigenvalue (Schur form) problem
    driver SGEES.

    When SDRVES is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 13
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRVES does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRVES
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRVES to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max(NN).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by SGEES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H\+T} & \begin{DoxyVerb}          HT is REAL array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by SGEES.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL array, dimension (max(NN))

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R\+T} & \begin{DoxyVerb}          WRT is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I\+T} & \begin{DoxyVerb}          WIT is REAL array, dimension (max(NN))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when SGEES only computes a partial
          eigendecomposition, i.e. not Schur vectors\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S} & \begin{DoxyVerb}          VS is REAL array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+S} & \begin{DoxyVerb}          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (13)
          The values computed by the 13 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (NWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+O\+R\+K} & \begin{DoxyVerb}          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -6: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -17: LDVS < 1 or LDVS < NMAX, where NMAX is max( NN(j) ).
          -20: NWORK too small.
          If  SLATMR, SLATMS, SLATME or SGEES returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga375903897d1816ffdc66d54f50f80338}{}\index{real@{real}!sdrvev@{sdrvev}}
\index{sdrvev@{sdrvev}!real@{real}}
\subsubsection[{sdrvev}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrvev (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( $\ast$ )}]{W\+I, }
\item[{real, dimension( $\ast$ )}]{W\+R1, }
\item[{real, dimension( $\ast$ )}]{W\+I1, }
\item[{real, dimension( ldvl, $\ast$ )}]{V\+L, }
\item[{integer}]{L\+D\+V\+L, }
\item[{real, dimension( ldvr, $\ast$ )}]{V\+R, }
\item[{integer}]{L\+D\+V\+R, }
\item[{real, dimension( ldlre, $\ast$ )}]{L\+R\+E, }
\item[{integer}]{L\+D\+L\+R\+E, }
\item[{real, dimension( 7 )}]{R\+E\+S\+U\+L\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga375903897d1816ffdc66d54f50f80338}


{\bfseries S\+D\+R\+V\+E\+V} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SDRVEV  checks the nonsymmetric eigenvalue problem driver SGEEV.

    When SDRVEV is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 7
    tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a block diagonal matrix, with a 1x1 block for each
      real eigenvalue and a 2x2 block for each complex conjugate
      pair.  If eigenvalues j and j+1 are a complex conjugate pair,
      so WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the
      2 x 2 block corresponding to the pair will be:

              (  wr  wi  )
              ( -wi  wr  )

      Such a block multiplying an n x 2 matrix  ( ur ui ) on the
      right will be the same as multiplying  ur + i*ui  by  wr + i*wi.

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and whether largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and whether largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when both VR and VL
      are also computed, and W(partial) denotes the eigenvalues
      computed when only W, only W and VR, or only W and VL are
      computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when both VR
      and VL are computed, and VR(partial) denotes the result
      when only VR is computed.

     (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when both VR
      and VL are also computed, and VL(partial) denotes the result
      when only VL is computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRVEV does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRVEV
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRVEV to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max(NN).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by SGEEV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL array, dimension (max(NN))

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R1} & \begin{DoxyVerb}          WR1 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I1} & \begin{DoxyVerb}          WI1 is REAL array, dimension (max(NN))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when SGEEV only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is REAL array, dimension (LDVL, max(NN))
          VL holds the computed left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+L} & \begin{DoxyVerb}          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is REAL array, dimension (LDVR, max(NN))
          VR holds the computed right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+R} & \begin{DoxyVerb}          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+R\+E} & \begin{DoxyVerb}          LRE is REAL array, dimension (LDLRE,max(NN))
          LRE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+L\+R\+E} & \begin{DoxyVerb}          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (7)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (NWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+O\+R\+K} & \begin{DoxyVerb}          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          5*NN(j)+2*NN(j)**2 for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -6: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -16: LDVL < 1 or LDVL < NMAX, where NMAX is max( NN(j) ).
          -18: LDVR < 1 or LDVR < NMAX, where NMAX is max( NN(j) ).
          -20: LDLRE < 1 or LDLRE < NMAX, where NMAX is max( NN(j) ).
          -23: NWORK too small.
          If  SLATMR, SLATMS, SLATME or SGEEV returns an error code,
              the absolute value of it is returned.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gac7154f368e4073c5194d3976de3c83e8}{}\index{real@{real}!sdrvgg@{sdrvgg}}
\index{sdrvgg@{sdrvgg}!real@{real}}
\subsubsection[{sdrvgg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrvgg (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{real}]{T\+H\+R\+S\+H\+N, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{B, }
\item[{real, dimension( lda, $\ast$ )}]{S, }
\item[{real, dimension( lda, $\ast$ )}]{T, }
\item[{real, dimension( lda, $\ast$ )}]{S2, }
\item[{real, dimension( lda, $\ast$ )}]{T2, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( ldq, $\ast$ )}]{Z, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+R1, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+I1, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A1, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+R2, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+I2, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A2, }
\item[{real, dimension( ldq, $\ast$ )}]{V\+L, }
\item[{real, dimension( ldq, $\ast$ )}]{V\+R, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gac7154f368e4073c5194d3976de3c83e8}


{\bfseries S\+D\+R\+V\+G\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SDRVGG  checks the nonsymmetric generalized eigenvalue driver
 routines.
                               T          T        T
 SGEGS factors A and B as Q S Z  and Q T Z , where   means
 transpose, T is upper triangular, S is in generalized Schur form
 (block upper triangular, with 1x1 and 2x2 blocks on the diagonal,
 the 2x2 blocks corresponding to complex conjugate pairs of
 generalized eigenvalues), and Q and Z are orthogonal.  It also
 computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), where alpha(j)=S(j,j) and beta(j)=P(j,j) --
 thus, w(j) = alpha(j)/beta(j) is a root of the generalized
 eigenvalue problem

     det( A - w(j) B ) = 0

 and m(j) = beta(j)/alpha(j) is a root of the essentially equivalent
 problem

     det( m(j) A - B ) = 0

 SGEGV computes the generalized eigenvalues (alpha(1),beta(1)), ...,
 (alpha(n),beta(n)), the matrix L whose columns contain the
 generalized left eigenvectors l, and the matrix R whose columns
 contain the generalized right eigenvectors r for the pair (A,B).

 When SDRVGG is called, a number of matrix "sizes" ("n's") and a
 number of matrix "types" are specified.  For each size ("n")
 and each type of matrix, one matrix will be generated and used
 to test the nonsymmetric eigenroutines.  For each matrix, 7
 tests will be performed and compared with the threshhold THRESH:

 Results from SGEGS:

                  T
 (1)   | A - Q S Z  | / ( |A| n ulp )

                  T
 (2)   | B - Q T Z  | / ( |B| n ulp )

               T
 (3)   | I - QQ  | / ( n ulp )

               T
 (4)   | I - ZZ  | / ( n ulp )

 (5)   maximum over j of D(j)  where:

 if alpha(j) is real:
                     |alpha(j) - S(j,j)|        |beta(j) - T(j,j)|
           D(j) = ------------------------ + -----------------------
                  max(|alpha(j)|,|S(j,j)|)   max(|beta(j)|,|T(j,j)|)

 if alpha(j) is complex:
                                 | det( s S - w T ) |
           D(j) = ---------------------------------------------------
                  ulp max( s norm(S), |w| norm(T) )*norm( s S - w T )

           and S and T are here the 2 x 2 diagonal blocks of S and T
           corresponding to the j-th eigenvalue.

 Results from SGEGV:

 (6)   max over all left eigenvalue/-vector pairs (beta/alpha,l) of

    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )

       where l**H is the conjugate tranpose of l.

 (7)   max over all right eigenvalue/-vector pairs (beta/alpha,r) of

       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )

 Test Matrices
 ---- --------

 The sizes of the test matrices are specified by an array
 NN(1:NSIZES); the value of each element NN(j) specifies one size.
 The "types" are specified by a logical array DOTYPE( 1:NTYPES ); if
 DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
 Currently, the list of possible types is:

 (1)  ( 0, 0 )         (a pair of zero matrices)

 (2)  ( I, 0 )         (an identity and a zero matrix)

 (3)  ( 0, I )         (an identity and a zero matrix)

 (4)  ( I, I )         (a pair of identity matrices)

         t   t
 (5)  ( J , J  )       (a pair of transposed Jordan blocks)

                                     t                ( I   0  )
 (6)  ( X, Y )         where  X = ( J   0  )  and Y = (      t )
                                  ( 0   I  )          ( 0   J  )
                       and I is a k x k identity and J a (k+1)x(k+1)
                       Jordan block; k=(N-1)/2

 (7)  ( D, I )         where D is diag( 0, 1,..., N-1 ) (a diagonal
                       matrix with those diagonal entries.)
 (8)  ( I, D )

 (9)  ( big*D, small*I ) where "big" is near overflow and small=1/big

 (10) ( small*D, big*I )

 (11) ( big*I, small*D )

 (12) ( small*I, big*D )

 (13) ( big*D, big*I )

 (14) ( small*D, small*I )

 (15) ( D1, D2 )        where D1 is diag( 0, 0, 1, ..., N-3, 0 ) and
                        D2 is diag( 0, N-3, N-4,..., 1, 0, 0 )
           t   t
 (16) Q ( J , J ) Z     where Q and Z are random orthogonal matrices.

 (17) Q ( T1, T2 ) Z    where T1 and T2 are upper triangular matrices
                        with random O(1) entries above the diagonal
                        and diagonal entries diag(T1) =
                        ( 0, 0, 1, ..., N-3, 0 ) and diag(T2) =
                        ( 0, N-3, N-4,..., 1, 0, 0 )

 (18) Q ( T1, T2 ) Z    diag(T1) = ( 0, 0, 1, 1, s, ..., s, 0 )
                        diag(T2) = ( 0, 1, 0, 1,..., 1, 0 )
                        s = machine precision.

 (19) Q ( T1, T2 ) Z    diag(T1)=( 0,0,1,1, 1-d, ..., 1-(N-5)*d=s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0 )

                                                        N-5
 (20) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, 1, a, ..., a   =s, 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )

 (21) Q ( T1, T2 ) Z    diag(T1)=( 0, 0, 1, r1, r2, ..., r(N-4), 0 )
                        diag(T2) = ( 0, 1, 0, 1, ..., 1, 0, 0 )
                        where r1,..., r(N-4) are random.

 (22) Q ( big*T1, small*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (23) Q ( small*T1, big*T2 ) Z    diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (24) Q ( small*T1, small*T2 ) Z  diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (25) Q ( big*T1, big*T2 ) Z      diag(T1) = ( 0, 0, 1, ..., N-3, 0 )
                                  diag(T2) = ( 0, 1, ..., 1, 0, 0 )

 (26) Q ( T1, T2 ) Z     where T1 and T2 are random upper-triangular
                         matrices.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRVGG does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRVGG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRVGG to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error is
          scaled to be O(1), so THRESH should be a reasonably small
          multiple of 1, e.g., 10 or 100.  In particular, it should
          not depend on the precision (single vs. double) or the size
          of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+S\+H\+N} & \begin{DoxyVerb}          THRSHN is REAL
          Threshhold for reporting eigenvector normalization error.
          If the normalization of any eigenvector differs from 1 by
          more than THRSHN*ulp, then a special error message will be
          printed.  (This is handled separately from the other tests,
          since only a compiler or programming error should cause an
          error message, at least if THRSHN is at least 5--10.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension
                            (LDA, max(NN))
          Used to hold the original A matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, B, S, T, S2, and T2.
          It must be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension
                            (LDA, max(NN))
          Used to hold the original B matrix.  Used as input only
          if NTYPES=MAXTYP+1, DOTYPE(1:MAXTYP)=.FALSE., and
          DOTYPE(MAXTYP+1)=.TRUE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension (LDA, max(NN))
          The Schur form matrix computed from A by SGEGS.  On exit, S
          contains the Schur form matrix corresponding to the matrix
          in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is REAL array, dimension (LDA, max(NN))
          The upper triangular matrix computed from B by SGEGS.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S2} & \begin{DoxyVerb}          S2 is REAL array, dimension (LDA, max(NN))
          The matrix computed from A by SGEGV.  This will be the
          Schur form of some matrix related to A, but will not, in
          general, be the same as S.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T2} & \begin{DoxyVerb}          T2 is REAL array, dimension (LDA, max(NN))
          The matrix computed from B by SGEGV.  This will be the
          Schur form of some matrix related to B, but will not, in
          general, be the same as T.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDQ, max(NN))
          The (left) orthogonal matrix computed by SGEGS.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of Q, Z, VL, and VR.  It must
          be at least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array of
                             dimension( LDQ, max(NN) )
          The (right) orthogonal matrix computed by SGEGS.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+R1} & \begin{DoxyVerb}          ALPHR1 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+I1} & \begin{DoxyVerb}          ALPHI1 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A1} & \begin{DoxyVerb}          BETA1 is REAL array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by SGEGS.
          ( ALPHR1(k)+ALPHI1(k)*i ) / BETA1(k) is the k-th
          generalized eigenvalue of the matrices in A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+R2} & \begin{DoxyVerb}          ALPHR2 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+I2} & \begin{DoxyVerb}          ALPHI2 is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A2} & \begin{DoxyVerb}          BETA2 is REAL array, dimension (max(NN))

          The generalized eigenvalues of (A,B) computed by SGEGV.
          ( ALPHR2(k)+ALPHI2(k)*i ) / BETA2(k) is the k-th
          generalized eigenvalue of the matrices in A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is REAL array, dimension (LDQ, max(NN))
          The (block lower triangular) left eigenvector matrix for
          the matrices in A and B.  (See STGEVC for the format.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is REAL array, dimension (LDQ, max(NN))
          The (block upper triangular) right eigenvector matrix for
          the matrices in A and B.  (See STGEVC for the format.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          2*N + MAX( 6*N, N*(NB+1), (k+1)*(2*k+N+1) ), where
          "k" is the sum of the blocksize and number-of-shifts for
          SHGEQZ, and NB is the greatest of the blocksizes for
          SGEQRF, SORMQR, and SORGQR.  (The blocksizes and the
          number-of-shifts are retrieved through calls to ILAENV.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (15)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value.
          > 0:  A routine returned an error code.  INFO is the
                absolute value of the INFO value returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga1d66b6ef4236d0d0cf318e1c64930a38}{}\index{real@{real}!sdrvsg@{sdrvsg}}
\index{sdrvsg@{sdrvsg}!real@{real}}
\subsubsection[{sdrvsg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrvsg (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( ldz, $\ast$ )}]{Z, }
\item[{integer}]{L\+D\+Z, }
\item[{real, dimension( lda, $\ast$ )}]{A\+B, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+B, }
\item[{real, dimension( $\ast$ )}]{A\+P, }
\item[{real, dimension( $\ast$ )}]{B\+P, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga1d66b6ef4236d0d0cf318e1c64930a38}


{\bfseries S\+D\+R\+V\+S\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      SDRVSG checks the real symmetric generalized eigenproblem
      drivers.

              SSYGV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem.

              SSYGVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem using a divide and conquer algorithm.

              SSYGVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem.

              SSPGV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem in packed storage.

              SSPGVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem in packed storage using a divide and
              conquer algorithm.

              SSPGVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite generalized
              eigenproblem in packed storage.

              SSBGV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite banded
              generalized eigenproblem.

              SSBGVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite banded
              generalized eigenproblem using a divide and conquer
              algorithm.

              SSBGVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric-definite banded
              generalized eigenproblem.

      When SDRVSG is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix A of the given type will be
      generated; a random well-conditioned matrix B is also generated
      and the pair (A,B) is used to test the drivers.

      For each pair (A,B), the following tests are performed:

      (1) SSYGV with ITYPE = 1 and UPLO ='U':

              | A Z - B Z D | / ( |A| |Z| n ulp )

      (2) as (1) but calling SSPGV
      (3) as (1) but calling SSBGV
      (4) as (1) but with UPLO = 'L'
      (5) as (4) but calling SSPGV
      (6) as (4) but calling SSBGV

      (7) SSYGV with ITYPE = 2 and UPLO ='U':

              | A B Z - Z D | / ( |A| |Z| n ulp )

      (8) as (7) but calling SSPGV
      (9) as (7) but with UPLO = 'L'
      (10) as (9) but calling SSPGV

      (11) SSYGV with ITYPE = 3 and UPLO ='U':

              | B A Z - Z D | / ( |A| |Z| n ulp )

      (12) as (11) but calling SSPGV
      (13) as (11) but with UPLO = 'L'
      (14) as (13) but calling SSPGV

      SSYGVD, SSPGVD and SSBGVD performed the same 14 tests.

      SSYGVX, SSPGVX and SSBGVX performed the above 14 tests with
      the parameter RANGE = 'A', 'N' and 'I', respectively.

      The "sizes" are specified by an array NN(1:NSIZES); the value
      of each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      This type is used for the matrix A which has half-bandwidth KA.
      B is generated as a well-conditioned positive definite matrix
      with half-bandwidth KB (<= KA).
      Currently, the list of possible types for A is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced entries
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced entries
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" entries
           1, ULP, ..., ULP and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U* D U, where U is orthogonal and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U* D U, where U is orthogonal and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U* D U, where U is orthogonal and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) symmetric matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold)

      (16) Same as (8), but with KA = 1 and KB = 1
      (17) Same as (8), but with KA = 2 and KB = 1
      (18) Same as (8), but with KA = 2 and KB = 2
      (19) Same as (8), but with KA = 3 and KB = 1
      (20) Same as (8), but with KA = 3 and KB = 2
      (21) Same as (8), but with KA = 3 and KB = 3\end{DoxyVerb}
 \begin{DoxyVerb}  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRVSG does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRVSG
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRVSG to continue the same random number
          sequence.
          Modified.

  THRESH  REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       REAL array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A and AB.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  B       REAL array, dimension (LDB , max(NN))
          Used to hold the symmetric positive definite matrix for
          the generailzed problem.
          On exit, B contains the last matrix actually
          used.
          Modified.

  LDB     INTEGER
          The leading dimension of B and BB.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D       REAL array, dimension (max(NN))
          The eigenvalues of A. On exit, the eigenvalues in D
          correspond with the matrix in A.
          Modified.

  Z       REAL array, dimension (LDZ, max(NN))
          The matrix of eigenvectors.
          Modified.

  LDZ     INTEGER
          The leading dimension of Z.  It must be at least 1 and
          at least max( NN ).
          Not modified.

  AB      REAL array, dimension (LDA, max(NN))
          Workspace.
          Modified.

  BB      REAL array, dimension (LDB, max(NN))
          Workspace.
          Modified.

  AP      REAL array, dimension (max(NN)**2)
          Workspace.
          Modified.

  BP      REAL array, dimension (max(NN)**2)
          Workspace.
          Modified.

  WORK    REAL array, dimension (NWORK)
          Workspace.
          Modified.

  NWORK   INTEGER
          The number of entries in WORK.  This must be at least
          1+5*N+2*N*lg(N)+3*N**2 where N = max( NN(j) ) and
          lg( N ) = smallest integer k such that 2**k >= N.
          Not modified.

  IWORK   INTEGER array, dimension (LIWORK)
          Workspace.
          Modified.

  LIWORK  INTEGER
          The number of entries in WORK.  This must be at least 6*N.
          Not modified.

  RESULT  REAL array, dimension (70)
          The values computed by the 70 tests described above.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -5: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -16: LDZ < 1 or LDZ < NMAX.
          -21: NWORK too small.
          -23: LIWORK too small.
          If  SLATMR, SLATMS, SSYGV, SSPGV, SSBGV, SSYGVD, SSPGVD,
              SSBGVD, SSYGVX, SSPGVX or SSBGVX returns an error code,
              the absolute value of it is returned.
          Modified.

 ----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests that have been run
                       on this matrix.
       NTESTT          The total number of tests for this call.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by SLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga4965dd452a2ac5ea65814add61ac0113}{}\index{real@{real}!sdrvst@{sdrvst}}
\index{sdrvst@{sdrvst}!real@{real}}
\subsubsection[{sdrvst}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrvst (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{D1, }
\item[{real, dimension( $\ast$ )}]{D2, }
\item[{real, dimension( $\ast$ )}]{D3, }
\item[{real, dimension( $\ast$ )}]{D4, }
\item[{real, dimension( $\ast$ )}]{E\+V\+E\+I\+G\+S, }
\item[{real, dimension( $\ast$ )}]{W\+A1, }
\item[{real, dimension( $\ast$ )}]{W\+A2, }
\item[{real, dimension( $\ast$ )}]{W\+A3, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldu, $\ast$ )}]{V, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U, }
\item[{real, dimension( ldu, $\ast$ )}]{Z, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{L\+I\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga4965dd452a2ac5ea65814add61ac0113}


{\bfseries S\+D\+R\+V\+S\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      SDRVST  checks the symmetric eigenvalue problem drivers.

              SSTEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric tridiagonal matrix.

              SSTEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric tridiagonal matrix.

              SSTEVR computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric tridiagonal matrix
              using the Relatively Robust Representation where it can.

              SSYEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix.

              SSYEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix.

              SSYEVR computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix
              using the Relatively Robust Representation where it can.

              SSPEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix in packed
              storage.

              SSPEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix in packed
              storage.

              SSBEV computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric band matrix.

              SSBEVX computes selected eigenvalues and, optionally,
              eigenvectors of a real symmetric band matrix.

              SSYEVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix using
              a divide and conquer algorithm.

              SSPEVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric matrix in packed
              storage, using a divide and conquer algorithm.

              SSBEVD computes all eigenvalues and, optionally,
              eigenvectors of a real symmetric band matrix,
              using a divide and conquer algorithm.

      When SDRVST is called, a number of matrix "sizes" ("n's") and a
      number of matrix "types" are specified.  For each size ("n")
      and each type of matrix, one matrix will be generated and used
      to test the appropriate drivers.  For each matrix and each
      driver routine called, the following tests will be performed:

      (1)     | A - Z D Z' | / ( |A| n ulp )

      (2)     | I - Z Z' | / ( n ulp )

      (3)     | D1 - D2 | / ( |D1| ulp )

      where Z is the matrix of eigenvectors returned when the
      eigenvector option is given and D1 and D2 are the eigenvalues
      returned with and without the eigenvector option.

      The "sizes" are specified by an array NN(1:NSIZES); the value of
      each element NN(j) specifies one size.
      The "types" are specified by a logical array DOTYPE( 1:NTYPES );
      if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
      Currently, the list of possible types is:

      (1)  The zero matrix.
      (2)  The identity matrix.

      (3)  A diagonal matrix with evenly spaced eigenvalues
           1, ..., ULP  and random signs.
           (ULP = (first number larger than 1) - 1 )
      (4)  A diagonal matrix with geometrically spaced eigenvalues
           1, ..., ULP  and random signs.
      (5)  A diagonal matrix with "clustered" eigenvalues
           1, ULP, ..., ULP and random signs.

      (6)  Same as (4), but multiplied by SQRT( overflow threshold )
      (7)  Same as (4), but multiplied by SQRT( underflow threshold )

      (8)  A matrix of the form  U' D U, where U is orthogonal and
           D has evenly spaced entries 1, ..., ULP with random signs
           on the diagonal.

      (9)  A matrix of the form  U' D U, where U is orthogonal and
           D has geometrically spaced entries 1, ..., ULP with random
           signs on the diagonal.

      (10) A matrix of the form  U' D U, where U is orthogonal and
           D has "clustered" entries 1, ULP,..., ULP with random
           signs on the diagonal.

      (11) Same as (8), but multiplied by SQRT( overflow threshold )
      (12) Same as (8), but multiplied by SQRT( underflow threshold )

      (13) Symmetric matrix with random entries chosen from (-1,1).
      (14) Same as (13), but multiplied by SQRT( overflow threshold )
      (15) Same as (13), but multiplied by SQRT( underflow threshold )
      (16) A band matrix with half bandwidth randomly chosen between
           0 and N-1, with evenly spaced eigenvalues 1, ..., ULP
           with random signs.
      (17) Same as (16), but multiplied by SQRT( overflow threshold )
      (18) Same as (16), but multiplied by SQRT( underflow threshold )\end{DoxyVerb}
 \begin{DoxyVerb}  NSIZES  INTEGER
          The number of sizes of matrices to use.  If it is zero,
          SDRVST does nothing.  It must be at least zero.
          Not modified.

  NN      INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.
          Not modified.

  NTYPES  INTEGER
          The number of elements in DOTYPE.   If it is zero, SDRVST
          does nothing.  It must be at least zero.  If it is MAXTYP+1
          and NSIZES is 1, then an additional type, MAXTYP+1 is
          defined, which is to use whatever matrix is in A.  This
          is only useful if DOTYPE(1:MAXTYP) is .FALSE. and
          DOTYPE(MAXTYP+1) is .TRUE. .
          Not modified.

  DOTYPE  LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.
          Not modified.

  ISEED   INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRVST to continue the same random number
          sequence.
          Modified.

  THRESH  REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.
          Not modified.

  NOUNIT  INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns IINFO not equal to 0.)
          Not modified.

  A       REAL array, dimension (LDA , max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually
          used.
          Modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  D1      REAL array, dimension (max(NN))
          The eigenvalues of A, as computed by SSTEQR simlutaneously
          with Z.  On exit, the eigenvalues in D1 correspond with the
          matrix in A.
          Modified.

  D2      REAL array, dimension (max(NN))
          The eigenvalues of A, as computed by SSTEQR if Z is not
          computed.  On exit, the eigenvalues in D2 correspond with
          the matrix in A.
          Modified.

  D3      REAL array, dimension (max(NN))
          The eigenvalues of A, as computed by SSTERF.  On exit, the
          eigenvalues in D3 correspond with the matrix in A.
          Modified.

  D4      REAL array, dimension

  EVEIGS  REAL array, dimension (max(NN))
          The eigenvalues as computed by SSTEV('N', ... )
          (I reserve the right to change this to the output of
          whichever algorithm computes the most accurate eigenvalues).

  WA1     REAL array, dimension

  WA2     REAL array, dimension

  WA3     REAL array, dimension

  U       REAL array, dimension (LDU, max(NN))
          The orthogonal matrix computed by SSYTRD + SORGTR.
          Modified.

  LDU     INTEGER
          The leading dimension of U, Z, and V.  It must be at
          least 1 and at least max( NN ).
          Not modified.

  V       REAL array, dimension (LDU, max(NN))
          The Housholder vectors computed by SSYTRD in reducing A to
          tridiagonal form.
          Modified.

  TAU     REAL array, dimension (max(NN))
          The Householder factors computed by SSYTRD in reducing A
          to tridiagonal form.
          Modified.

  Z       REAL array, dimension (LDU, max(NN))
          The orthogonal matrix of eigenvectors computed by SSTEQR,
          SPTEQR, and SSTEIN.
          Modified.

  WORK    REAL array, dimension (LWORK)
          Workspace.
          Modified.

  LWORK   INTEGER
          The number of entries in WORK.  This must be at least
          1 + 4 * Nmax + 2 * Nmax * lg Nmax + 4 * Nmax**2
          where Nmax = max( NN(j), 2 ) and lg = log base 2.
          Not modified.

  IWORK   INTEGER array,
             dimension (6 + 6*Nmax + 5 * Nmax * lg Nmax )
          where Nmax = max( NN(j), 2 ) and lg = log base 2.
          Workspace.
          Modified.

  RESULT  REAL array, dimension (105)
          The values computed by the tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.
          Modified.

  INFO    INTEGER
          If 0, then everything ran OK.
           -1: NSIZES < 0
           -2: Some NN(j) < 0
           -3: NTYPES < 0
           -5: THRESH < 0
           -9: LDA < 1 or LDA < NMAX, where NMAX is max( NN(j) ).
          -16: LDU < 1 or LDU < NMAX.
          -21: LWORK too small.
          If  SLATMR, SLATMS, SSYTRD, SORGTR, SSTEQR, SSTERF,
              or SORMTR returns an error code, the
              absolute value of it is returned.
          Modified.

-----------------------------------------------------------------------

       Some Local Variables and Parameters:
       ---- ----- --------- --- ----------
       ZERO, ONE       Real 0 and 1.
       MAXTYP          The number of types defined.
       NTEST           The number of tests performed, or which can
                       be performed so far, for the current matrix.
       NTESTT          The total number of tests performed so far.
       NMAX            Largest value in NN.
       NMATS           The number of matrices generated so far.
       NERRS           The number of tests which have exceeded THRESH
                       so far (computed by SLAFTS).
       COND, IMODE     Values to be passed to the matrix generators.
       ANORM           Norm of A; passed to matrix generators.

       OVFL, UNFL      Overflow and underflow thresholds.
       ULP, ULPINV     Finest relative precision and its inverse.
       RTOVFL, RTUNFL  Square roots of the previous 2 values.
               The following four arrays decode JTYPE:
       KTYPE(j)        The general type (1-10) for type "j".
       KMODE(j)        The MODE value to be passed to the matrix
                       generator for type "j".
       KMAGN(j)        The order of magnitude ( O(1),
                       O(overflow^(1/2) ), O(underflow^(1/2) )

     The tests performed are:                 Routine tested
    1= | A - U S U' | / ( |A| n ulp )         SSTEV('V', ... )
    2= | I - U U' | / ( n ulp )               SSTEV('V', ... )
    3= |D(with Z) - D(w/o Z)| / (|D| ulp)     SSTEV('N', ... )
    4= | A - U S U' | / ( |A| n ulp )         SSTEVX('V','A', ... )
    5= | I - U U' | / ( n ulp )               SSTEVX('V','A', ... )
    6= |D(with Z) - EVEIGS| / (|D| ulp)       SSTEVX('N','A', ... )
    7= | A - U S U' | / ( |A| n ulp )         SSTEVR('V','A', ... )
    8= | I - U U' | / ( n ulp )               SSTEVR('V','A', ... )
    9= |D(with Z) - EVEIGS| / (|D| ulp)       SSTEVR('N','A', ... )
    10= | A - U S U' | / ( |A| n ulp )        SSTEVX('V','I', ... )
    11= | I - U U' | / ( n ulp )              SSTEVX('V','I', ... )
    12= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSTEVX('N','I', ... )
    13= | A - U S U' | / ( |A| n ulp )        SSTEVX('V','V', ... )
    14= | I - U U' | / ( n ulp )              SSTEVX('V','V', ... )
    15= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSTEVX('N','V', ... )
    16= | A - U S U' | / ( |A| n ulp )        SSTEVD('V', ... )
    17= | I - U U' | / ( n ulp )              SSTEVD('V', ... )
    18= |D(with Z) - EVEIGS| / (|D| ulp)      SSTEVD('N', ... )
    19= | A - U S U' | / ( |A| n ulp )        SSTEVR('V','I', ... )
    20= | I - U U' | / ( n ulp )              SSTEVR('V','I', ... )
    21= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSTEVR('N','I', ... )
    22= | A - U S U' | / ( |A| n ulp )        SSTEVR('V','V', ... )
    23= | I - U U' | / ( n ulp )              SSTEVR('V','V', ... )
    24= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSTEVR('N','V', ... )

    25= | A - U S U' | / ( |A| n ulp )        SSYEV('L','V', ... )
    26= | I - U U' | / ( n ulp )              SSYEV('L','V', ... )
    27= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEV('L','N', ... )
    28= | A - U S U' | / ( |A| n ulp )        SSYEVX('L','V','A', ... )
    29= | I - U U' | / ( n ulp )              SSYEVX('L','V','A', ... )
    30= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEVX('L','N','A', ... )
    31= | A - U S U' | / ( |A| n ulp )        SSYEVX('L','V','I', ... )
    32= | I - U U' | / ( n ulp )              SSYEVX('L','V','I', ... )
    33= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEVX('L','N','I', ... )
    34= | A - U S U' | / ( |A| n ulp )        SSYEVX('L','V','V', ... )
    35= | I - U U' | / ( n ulp )              SSYEVX('L','V','V', ... )
    36= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEVX('L','N','V', ... )
    37= | A - U S U' | / ( |A| n ulp )        SSPEV('L','V', ... )
    38= | I - U U' | / ( n ulp )              SSPEV('L','V', ... )
    39= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEV('L','N', ... )
    40= | A - U S U' | / ( |A| n ulp )        SSPEVX('L','V','A', ... )
    41= | I - U U' | / ( n ulp )              SSPEVX('L','V','A', ... )
    42= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEVX('L','N','A', ... )
    43= | A - U S U' | / ( |A| n ulp )        SSPEVX('L','V','I', ... )
    44= | I - U U' | / ( n ulp )              SSPEVX('L','V','I', ... )
    45= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEVX('L','N','I', ... )
    46= | A - U S U' | / ( |A| n ulp )        SSPEVX('L','V','V', ... )
    47= | I - U U' | / ( n ulp )              SSPEVX('L','V','V', ... )
    48= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEVX('L','N','V', ... )
    49= | A - U S U' | / ( |A| n ulp )        SSBEV('L','V', ... )
    50= | I - U U' | / ( n ulp )              SSBEV('L','V', ... )
    51= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEV('L','N', ... )
    52= | A - U S U' | / ( |A| n ulp )        SSBEVX('L','V','A', ... )
    53= | I - U U' | / ( n ulp )              SSBEVX('L','V','A', ... )
    54= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEVX('L','N','A', ... )
    55= | A - U S U' | / ( |A| n ulp )        SSBEVX('L','V','I', ... )
    56= | I - U U' | / ( n ulp )              SSBEVX('L','V','I', ... )
    57= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEVX('L','N','I', ... )
    58= | A - U S U' | / ( |A| n ulp )        SSBEVX('L','V','V', ... )
    59= | I - U U' | / ( n ulp )              SSBEVX('L','V','V', ... )
    60= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEVX('L','N','V', ... )
    61= | A - U S U' | / ( |A| n ulp )        SSYEVD('L','V', ... )
    62= | I - U U' | / ( n ulp )              SSYEVD('L','V', ... )
    63= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEVD('L','N', ... )
    64= | A - U S U' | / ( |A| n ulp )        SSPEVD('L','V', ... )
    65= | I - U U' | / ( n ulp )              SSPEVD('L','V', ... )
    66= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEVD('L','N', ... )
    67= | A - U S U' | / ( |A| n ulp )        SSBEVD('L','V', ... )
    68= | I - U U' | / ( n ulp )              SSBEVD('L','V', ... )
    69= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEVD('L','N', ... )
    70= | A - U S U' | / ( |A| n ulp )        SSYEVR('L','V','A', ... )
    71= | I - U U' | / ( n ulp )              SSYEVR('L','V','A', ... )
    72= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEVR('L','N','A', ... )
    73= | A - U S U' | / ( |A| n ulp )        SSYEVR('L','V','I', ... )
    74= | I - U U' | / ( n ulp )              SSYEVR('L','V','I', ... )
    75= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEVR('L','N','I', ... )
    76= | A - U S U' | / ( |A| n ulp )        SSYEVR('L','V','V', ... )
    77= | I - U U' | / ( n ulp )              SSYEVR('L','V','V', ... )
    78= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSYEVR('L','N','V', ... )

    Tests 25 through 78 are repeated (as tests 79 through 132)
    with UPLO='U'

    To be added in 1999

    79= | A - U S U' | / ( |A| n ulp )        SSPEVR('L','V','A', ... )
    80= | I - U U' | / ( n ulp )              SSPEVR('L','V','A', ... )
    81= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEVR('L','N','A', ... )
    82= | A - U S U' | / ( |A| n ulp )        SSPEVR('L','V','I', ... )
    83= | I - U U' | / ( n ulp )              SSPEVR('L','V','I', ... )
    84= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEVR('L','N','I', ... )
    85= | A - U S U' | / ( |A| n ulp )        SSPEVR('L','V','V', ... )
    86= | I - U U' | / ( n ulp )              SSPEVR('L','V','V', ... )
    87= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSPEVR('L','N','V', ... )
    88= | A - U S U' | / ( |A| n ulp )        SSBEVR('L','V','A', ... )
    89= | I - U U' | / ( n ulp )              SSBEVR('L','V','A', ... )
    90= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEVR('L','N','A', ... )
    91= | A - U S U' | / ( |A| n ulp )        SSBEVR('L','V','I', ... )
    92= | I - U U' | / ( n ulp )              SSBEVR('L','V','I', ... )
    93= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEVR('L','N','I', ... )
    94= | A - U S U' | / ( |A| n ulp )        SSBEVR('L','V','V', ... )
    95= | I - U U' | / ( n ulp )              SSBEVR('L','V','V', ... )
    96= |D(with Z) - D(w/o Z)| / (|D| ulp)    SSBEVR('L','N','V', ... )\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga411333994f433776dd07049fe3973a66}{}\index{real@{real}!sdrvsx@{sdrvsx}}
\index{sdrvsx@{sdrvsx}!real@{real}}
\subsubsection[{sdrvsx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrvsx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+U\+N\+I\+T, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( lda, $\ast$ )}]{H\+T, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( $\ast$ )}]{W\+I, }
\item[{real, dimension( $\ast$ )}]{W\+R\+T, }
\item[{real, dimension( $\ast$ )}]{W\+I\+T, }
\item[{real, dimension( $\ast$ )}]{W\+R\+T\+M\+P, }
\item[{real, dimension( $\ast$ )}]{W\+I\+T\+M\+P, }
\item[{real, dimension( ldvs, $\ast$ )}]{V\+S, }
\item[{integer}]{L\+D\+V\+S, }
\item[{real, dimension( ldvs, $\ast$ )}]{V\+S1, }
\item[{real, dimension( 17 )}]{R\+E\+S\+U\+L\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga411333994f433776dd07049fe3973a66}


{\bfseries S\+D\+R\+V\+S\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SDRVSX checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver SGEESX.

    SDRVSX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When SDRVSX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified.  For each size ("n")
    and each type of matrix, one matrix will be generated and used
    to test the nonsymmetric eigenroutines.  For each matrix, 15
    tests will be performed:

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare WR, WI with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalue
    average and right invariant subspace. For these matrices, in
    addition to tests (1) to (15) we will compute the following two
    tests:

   (16)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal average eigenvalue condition number
      computed by SGEESX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.

   (17)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right invariant subspace condition
      number computed by SGEESX and RCDVIN (the precomputed true
      value) is supplied as input. cond(RCONDV) is the condition
      number of RCONDV, and takes errors in computing RCONDV into
      account, so that the resulting quantity should be O(ULP).
      cond(RCONDV) is essentially given by norm(A)/RCONDE.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRVSX to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+U\+N\+I\+T} & \begin{DoxyVerb}          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, max(NN))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least max( NN ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension (LDA, max(NN))
          Another copy of the test matrix A, modified by SGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H\+T} & \begin{DoxyVerb}          HT is REAL array, dimension (LDA, max(NN))
          Yet another copy of the test matrix A, modified by SGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL array, dimension (max(NN))

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R\+T} & \begin{DoxyVerb}          WRT is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I\+T} & \begin{DoxyVerb}          WIT is REAL array, dimension (max(NN))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when SGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R\+T\+M\+P} & \begin{DoxyVerb}          WRTMP is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I\+T\+M\+P} & \begin{DoxyVerb}          WITMP is REAL array, dimension (max(NN))

          More temporary storage for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S} & \begin{DoxyVerb}          VS is REAL array, dimension (LDVS, max(NN))
          VS holds the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+S} & \begin{DoxyVerb}          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1,max(NN)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S1} & \begin{DoxyVerb}          VS1 is REAL array, dimension (LDVS, max(NN))
          VS1 holds another copy of the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(3*NN(j),2*NN(j)**2) for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (max(NN)*max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  successful exit.
            <0,  input parameter -INFO is incorrect
            >0,  SLATMR, SLATMS, SLATME or SGET24 returned an error
                 code and INFO is its absolute value

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------
     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.
             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga91d3493bce6a97430fded1ad19b1bead}{}\index{real@{real}!sdrvvx@{sdrvvx}}
\index{sdrvvx@{sdrvvx}!real@{real}}
\subsubsection[{sdrvvx}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sdrvvx (
\begin{DoxyParamCaption}
\item[{integer}]{N\+S\+I\+Z\+E\+S, }
\item[{integer, dimension( $\ast$ )}]{N\+N, }
\item[{integer}]{N\+T\+Y\+P\+E\+S, }
\item[{{\bf logical}, dimension( $\ast$ )}]{D\+O\+T\+Y\+P\+E, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{N\+I\+U\+N\+I\+T, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( $\ast$ )}]{W\+I, }
\item[{real, dimension( $\ast$ )}]{W\+R1, }
\item[{real, dimension( $\ast$ )}]{W\+I1, }
\item[{real, dimension( ldvl, $\ast$ )}]{V\+L, }
\item[{integer}]{L\+D\+V\+L, }
\item[{real, dimension( ldvr, $\ast$ )}]{V\+R, }
\item[{integer}]{L\+D\+V\+R, }
\item[{real, dimension( ldlre, $\ast$ )}]{L\+R\+E, }
\item[{integer}]{L\+D\+L\+R\+E, }
\item[{real, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+V, }
\item[{real, dimension( $\ast$ )}]{R\+C\+N\+D\+V1, }
\item[{real, dimension( $\ast$ )}]{R\+C\+D\+V\+I\+N, }
\item[{real, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+E, }
\item[{real, dimension( $\ast$ )}]{R\+C\+N\+D\+E1, }
\item[{real, dimension( $\ast$ )}]{R\+C\+D\+E\+I\+N, }
\item[{real, dimension( $\ast$ )}]{S\+C\+A\+L\+E, }
\item[{real, dimension( $\ast$ )}]{S\+C\+A\+L\+E1, }
\item[{real, dimension( 11 )}]{R\+E\+S\+U\+L\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{N\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga91d3493bce6a97430fded1ad19b1bead}


{\bfseries S\+D\+R\+V\+V\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SDRVVX  checks the nonsymmetric eigenvalue problem expert driver
    SGEEVX.

    SDRVVX uses both test matrices generated randomly depending on
    data supplied in the calling sequence, as well as on data
    read from an input file and including precomputed condition
    numbers to which it compares the ones it computes.

    When SDRVVX is called, a number of matrix "sizes" ("n's") and a
    number of matrix "types" are specified in the calling sequence.
    For each size ("n") and each type of matrix, one matrix will be
    generated and used to test the nonsymmetric eigenroutines.  For
    each matrix, 9 tests will be performed:

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a block diagonal matrix, with a 1x1 block for each
      real eigenvalue and a 2x2 block for each complex conjugate
      pair.  If eigenvalues j and j+1 are a complex conjugate pair,
      so WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the
      2 x 2 block corresponding to the pair will be:

              (  wr  wi  )
              ( -wi  wr  )

      Such a block multiplying an n x 2 matrix  ( ur ui ) on the
      right will be the same as multiplying  ur + i*ui  by  wr + i*wi.

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     W(full) = W(partial)

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     VR(full) = VR(partial)

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     VL(full) = VL(partial)

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     RCONDV(full) = RCONDV(partial)

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

    The "sizes" are specified by an array NN(1:NSIZES); the value of
    each element NN(j) specifies one size.
    The "types" are specified by a logical array DOTYPE( 1:NTYPES );
    if DOTYPE(j) is .TRUE., then matrix type "j" will be generated.
    Currently, the list of possible types is:

    (1)  The zero matrix.
    (2)  The identity matrix.
    (3)  A (transposed) Jordan block, with 1's on the diagonal.

    (4)  A diagonal matrix with evenly spaced entries
         1, ..., ULP  and random signs.
         (ULP = (first number larger than 1) - 1 )
    (5)  A diagonal matrix with geometrically spaced entries
         1, ..., ULP  and random signs.
    (6)  A diagonal matrix with "clustered" entries 1, ULP, ..., ULP
         and random signs.

    (7)  Same as (4), but multiplied by a constant near
         the overflow threshold
    (8)  Same as (4), but multiplied by a constant near
         the underflow threshold

    (9)  A matrix of the form  U' T U, where U is orthogonal and
         T has evenly spaced entries 1, ..., ULP with random signs
         on the diagonal and random O(1) entries in the upper
         triangle.

    (10) A matrix of the form  U' T U, where U is orthogonal and
         T has geometrically spaced entries 1, ..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (11) A matrix of the form  U' T U, where U is orthogonal and
         T has "clustered" entries 1, ULP,..., ULP with random
         signs on the diagonal and random O(1) entries in the upper
         triangle.

    (12) A matrix of the form  U' T U, where U is orthogonal and
         T has real or complex conjugate paired eigenvalues randomly
         chosen from ( ULP, 1 ) and random O(1) entries in the upper
         triangle.

    (13) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has evenly spaced entries 1, ..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (14) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has geometrically spaced entries
         1, ..., ULP with random signs on the diagonal and random
         O(1) entries in the upper triangle.

    (15) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has "clustered" entries 1, ULP,..., ULP
         with random signs on the diagonal and random O(1) entries
         in the upper triangle.

    (16) A matrix of the form  X' T X, where X has condition
         SQRT( ULP ) and T has real or complex conjugate paired
         eigenvalues randomly chosen from ( ULP, 1 ) and random
         O(1) entries in the upper triangle.

    (17) Same as (16), but multiplied by a constant
         near the overflow threshold
    (18) Same as (16), but multiplied by a constant
         near the underflow threshold

    (19) Nonsymmetric matrix with random entries chosen from (-1,1).
         If N is at least 4, all entries in first two rows and last
         row, and first column and last two columns are zero.
    (20) Same as (19), but multiplied by a constant
         near the overflow threshold
    (21) Same as (19), but multiplied by a constant
         near the underflow threshold

    In addition, an input file will be read from logical unit number
    NIUNIT. The file contains matrices along with precomputed
    eigenvalues and reciprocal condition numbers for the eigenvalues
    and right eigenvectors. For these matrices, in addition to tests
    (1) to (9) we will compute the following two tests:

   (10)  |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by SGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)  |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by SGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+S\+I\+Z\+E\+S} & \begin{DoxyVerb}          NSIZES is INTEGER
          The number of sizes of matrices to use.  NSIZES must be at
          least zero. If it is zero, no randomly generated matrices
          are tested, but any test matrices read from NIUNIT will be
          tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+N} & \begin{DoxyVerb}          NN is INTEGER array, dimension (NSIZES)
          An array containing the sizes to be used for the matrices.
          Zero values will be skipped.  The values must be at least
          zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+T\+Y\+P\+E\+S} & \begin{DoxyVerb}          NTYPES is INTEGER
          The number of elements in DOTYPE. NTYPES must be at least
          zero. If it is zero, no randomly generated test matrices
          are tested, but and test matrices read from NIUNIT will be
          tested. If it is MAXTYP+1 and NSIZES is 1, then an
          additional type, MAXTYP+1 is defined, which is to use
          whatever matrix is in A.  This is only useful if
          DOTYPE(1:MAXTYP) is .FALSE. and DOTYPE(MAXTYP+1) is .TRUE. .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D\+O\+T\+Y\+P\+E} & \begin{DoxyVerb}          DOTYPE is LOGICAL array, dimension (NTYPES)
          If DOTYPE(j) is .TRUE., then for each size in NN a
          matrix of that size and of type j will be generated.
          If NTYPES is smaller than the maximum number of types
          defined (PARAMETER MAXTYP), then types NTYPES+1 through
          MAXTYP will not be generated.  If NTYPES is larger
          than MAXTYP, DOTYPE(MAXTYP+1) through DOTYPE(NTYPES)
          will be ignored.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator. The array elements should be between 0 and 4095;
          if not they will be reduced mod 4096.  Also, ISEED(4) must
          be odd.  The random number generator uses a linear
          congruential sequence limited to small integers, and so
          should produce machine independent random numbers. The
          values of ISEED are changed on exit, and can be used in the
          next call to SDRVVX to continue the same random number
          sequence.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+U\+N\+I\+T} & \begin{DoxyVerb}          NIUNIT is INTEGER
          The FORTRAN unit number for reading in the data file of
          problems to solve.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension
                      (LDA, max(NN,12))
          Used to hold the matrix whose eigenvalues are to be
          computed.  On exit, A contains the last matrix actually used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A and H.
          LDA >= max(NN,12), since 12 is the dimension of the largest
          matrix in the precomputed input file.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension
                      (LDA, max(NN,12))
          Another copy of the test matrix A, modified by SGEEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array, dimension (max(NN))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL array, dimension (max(NN))
          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R1} & \begin{DoxyVerb}          WR1 is REAL array, dimension (max(NN,12))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I1} & \begin{DoxyVerb}          WI1 is REAL array, dimension (max(NN,12))

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when SGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is REAL array, dimension
                      (LDVL, max(NN,12))
          VL holds the computed left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+L} & \begin{DoxyVerb}          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,max(NN,12)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is REAL array, dimension
                      (LDVR, max(NN,12))
          VR holds the computed right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+R} & \begin{DoxyVerb}          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,max(NN,12)).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+R\+E} & \begin{DoxyVerb}          LRE is REAL array, dimension
                      (LDLRE, max(NN,12))
          LRE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+L\+R\+E} & \begin{DoxyVerb}          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,max(NN,12))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+V} & \begin{DoxyVerb}          RCONDV is REAL array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+V1} & \begin{DoxyVerb}          RCNDV1 is REAL array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+D\+V\+I\+N} & \begin{DoxyVerb}          RCDVIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+E} & \begin{DoxyVerb}          RCONDE is REAL array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+E1} & \begin{DoxyVerb}          RCNDE1 is REAL array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+D\+E\+I\+N} & \begin{DoxyVerb}          RCDEIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E} & \begin{DoxyVerb}          SCALE is REAL array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E1} & \begin{DoxyVerb}          SCALE1 is REAL array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (11)
          The values computed by the seven tests described above.
          The values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (NWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+W\+O\+R\+K} & \begin{DoxyVerb}          NWORK is INTEGER
          The number of entries in WORK.  This must be at least
          max(6*12+2*12**2,6*NN(j)+2*NN(j)**2) =
          max(    360     ,6*NN(j)+2*NN(j)**2)    for all j.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (2*max(NN,12))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  then successful exit.
          If <0, then input paramter -INFO is incorrect.
          If >0, SLATMR, SLATMS, SLATME or SGET23 returned an error
                 code, and INFO is its absolute value.

-----------------------------------------------------------------------

     Some Local Variables and Parameters:
     ---- ----- --------- --- ----------

     ZERO, ONE       Real 0 and 1.
     MAXTYP          The number of types defined.
     NMAX            Largest value in NN or 12.
     NERRS           The number of tests which have exceeded THRESH
     COND, CONDS,
     IMODE           Values to be passed to the matrix generators.
     ANORM           Norm of A; passed to matrix generators.

     OVFL, UNFL      Overflow and underflow thresholds.
     ULP, ULPINV     Finest relative precision and its inverse.
     RTULP, RTULPI   Square roots of the previous 4 values.

             The following four arrays decode JTYPE:
     KTYPE(j)        The general type (1-10) for type "j".
     KMODE(j)        The MODE value to be passed to the matrix
                     generator for type "j".
     KMAGN(j)        The order of magnitude ( O(1),
                     O(overflow^(1/2) ), O(underflow^(1/2) )
     KCONDS(j)       Selectw whether CONDS is to be 1 or
                     1/sqrt(ulp).  (0 means irrelevant.)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaa15f9b7d5c1bd62dd1688a853242f973}{}\index{real@{real}!serrbd@{serrbd}}
\index{serrbd@{serrbd}!real@{real}}
\subsubsection[{serrbd}]{\setlength{\rightskip}{0pt plus 5cm}subroutine serrbd (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaa15f9b7d5c1bd62dd1688a853242f973}


{\bfseries S\+E\+R\+R\+B\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SERRBD tests the error exits for SGEBRD, SORGBR, SORMBR, SBDSQR and
 SBDSDC.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga53ee6e84c6661f0c5f453945a0c6693d}{}\index{real@{real}!serrec@{serrec}}
\index{serrec@{serrec}!real@{real}}
\subsubsection[{serrec}]{\setlength{\rightskip}{0pt plus 5cm}subroutine serrec (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga53ee6e84c6661f0c5f453945a0c6693d}


{\bfseries S\+E\+R\+R\+E\+C} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SERREC tests the error exits for the routines for eigen- condition
 estimation for REAL matrices:
    STRSYL, STREXC, STRSNA and STRSEN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gadd1c890cd165b23a2c57f8e0ea2e02dd}{}\index{real@{real}!serred@{serred}}
\index{serred@{serred}!real@{real}}
\subsubsection[{serred}]{\setlength{\rightskip}{0pt plus 5cm}subroutine serred (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gadd1c890cd165b23a2c57f8e0ea2e02dd}


{\bfseries S\+E\+R\+R\+E\+D} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SERRED tests the error exits for the eigenvalue driver routines for
 REAL matrices:

 PATH  driver   description
 ----  ------   -----------
 SEV   SGEEV    find eigenvalues/eigenvectors for nonsymmetric A
 SES   SGEES    find eigenvalues/Schur form for nonsymmetric A
 SVX   SGEEVX   SGEEV + balancing and condition estimation
 SSX   SGEESX   SGEES + balancing and condition estimation
 SBD   SGESVD   compute SVD of an M-by-N matrix A
       SGESDD   compute SVD of an M-by-N matrix A (by divide and
                conquer)
       SGEJSV   compute SVD of an M-by-N matrix A where M >= N\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga451a5d8e7e6e4ccb9e1f1fb915c022c0}{}\index{real@{real}!serrgg@{serrgg}}
\index{serrgg@{serrgg}!real@{real}}
\subsubsection[{serrgg}]{\setlength{\rightskip}{0pt plus 5cm}subroutine serrgg (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga451a5d8e7e6e4ccb9e1f1fb915c022c0}


{\bfseries S\+E\+R\+R\+G\+G} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SERRGG tests the error exits for SGGES, SGGESX, SGGEV, SGGEVX,
 SGGGLM, SGGHRD, SGGLSE, SGGQRF, SGGRQF, SGGSVD, SGGSVP, SHGEQZ,
 SORCSD, STGEVC, STGEXC, STGSEN, STGSJA, STGSNA, and STGSYL.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga6fd701d129a4ff99faeb82018435d60c}{}\index{real@{real}!serrhs@{serrhs}}
\index{serrhs@{serrhs}!real@{real}}
\subsubsection[{serrhs}]{\setlength{\rightskip}{0pt plus 5cm}subroutine serrhs (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga6fd701d129a4ff99faeb82018435d60c}


{\bfseries S\+E\+R\+R\+H\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SERRHS tests the error exits for SGEBAK, SGEBAL, SGEHRD, SORGHR,
 SORMHR, SHSEQR, SHSEIN, and STREVC.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gae70b9c462a9febd73364f58aa8f4ad81}{}\index{real@{real}!serrst@{serrst}}
\index{serrst@{serrst}!real@{real}}
\subsubsection[{serrst}]{\setlength{\rightskip}{0pt plus 5cm}subroutine serrst (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{N\+U\+N\+I\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gae70b9c462a9febd73364f58aa8f4ad81}


{\bfseries S\+E\+R\+R\+S\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SERRST tests the error exits for SSYTRD, SORGTR, SORMTR, SSPTRD,
 SOPGTR, SOPMTR, SSTEQR, SSTERF, SSTEBZ, SSTEIN, SPTEQR, SSBTRD,
 SSYEV, SSYEVX, SSYEVD, SSBEV, SSBEVX, SSBEVD,
 SSPEV, SSPEVX, SSPEVD, SSTEV, SSTEVX, SSTEVD, and SSTEDC.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name for the routines to be tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+U\+N\+I\+T} & \begin{DoxyVerb}          NUNIT is INTEGER
          The unit number for output.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga3c268bce93f7da1dd297b590955402dd}{}\index{real@{real}!sget02@{sget02}}
\index{sget02@{sget02}!real@{real}}
\subsubsection[{sget02}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget02 (
\begin{DoxyParamCaption}
\item[{character}]{T\+R\+A\+N\+S, }
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{integer}]{N\+R\+H\+S, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldx, $\ast$ )}]{X, }
\item[{integer}]{L\+D\+X, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga3c268bce93f7da1dd297b590955402dd}


{\bfseries S\+G\+E\+T02} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET02 computes the residual for a solution of a system of linear
 equations  A*x = b  or  A'*x = b:
    RESID = norm(B - A*X) / ( norm(A) * norm(X) * EPS ),
 where EPS is the machine epsilon.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em T\+R\+A\+N\+S} & \begin{DoxyVerb}          TRANS is CHARACTER*1
          Specifies the form of the system of equations:
          = 'N':  A *x = b
          = 'T':  A'*x = b, where A' is the transpose of A
          = 'C':  A'*x = b, where A' is the transpose of A\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of columns of B, the matrix of right hand sides.
          NRHS >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The original M x N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension (LDX,NRHS)
          The computed solution vectors for the system of linear
          equations.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX >= max(1,N); if TRANS = 'T' or 'C', LDX >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,NRHS)
          On entry, the right hand side vectors for the system of
          linear equations.
          On exit, B is overwritten with the difference B - A*X.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  IF TRANS = 'N',
          LDB >= max(1,M); if TRANS = 'T' or 'C', LDB >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is REAL
          The maximum over the number of right hand sides of
          norm(B - A*X) / ( norm(A) * norm(X) * EPS ).\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga0e9e61f3b94abf4f82b4f53f382e11dc}{}\index{real@{real}!sget10@{sget10}}
\index{sget10@{sget10}!real@{real}}
\subsubsection[{sget10}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget10 (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga0e9e61f3b94abf4f82b4f53f382e11dc}


{\bfseries S\+G\+E\+T10} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET10 compares two matrices A and B and computes the ratio
 RESULT = norm( A - B ) / ( norm(A) * M * EPS )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrices A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The m by n matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,N)
          The m by n matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL
          RESULT = norm( A - B ) / ( norm(A) * M * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga2a7d9603b3bd0ebb820f3a0ed88d760a}{}\index{real@{real}!sget22@{sget22}}
\index{sget22@{sget22}!real@{real}}
\subsubsection[{sget22}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget22 (
\begin{DoxyParamCaption}
\item[{character}]{T\+R\+A\+N\+S\+A, }
\item[{character}]{T\+R\+A\+N\+S\+E, }
\item[{character}]{T\+R\+A\+N\+S\+W, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( {\bf lde}, $\ast$ )}]{E, }
\item[{integer}]{L\+D\+E, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( $\ast$ )}]{W\+I, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga2a7d9603b3bd0ebb820f3a0ed88d760a}


{\bfseries S\+G\+E\+T22} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET22 does an eigenvector check.

 The basic test is:

    RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )

 using the 1-norm.  It also tests the normalization of E:

    RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )
                 j

 where E(j) is the j-th eigenvector, and m-norm is the max-norm of a
 vector.  If an eigenvector is complex, as determined from WI(j)
 nonzero, then the max-norm of the vector ( er + i*ei ) is the maximum
 of
    |er(1)| + |ei(1)|, ... , |er(n)| + |ei(n)|

 W is a block diagonal matrix, with a 1 by 1 block for each real
 eigenvalue and a 2 by 2 block for each complex conjugate pair.
 If eigenvalues j and j+1 are a complex conjugate pair, so that
 WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the 2 by 2
 block corresponding to the pair will be:

    (  wr  wi  )
    ( -wi  wr  )

 Such a block multiplying an n by 2 matrix ( ur ui ) on the right
 will be the same as multiplying  ur + i*ui  by  wr + i*wi.

 To handle various schemes for storage of left eigenvectors, there are
 options to use A-transpose instead of A, E-transpose instead of E,
 and/or W-transpose instead of W.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em T\+R\+A\+N\+S\+A} & \begin{DoxyVerb}          TRANSA is CHARACTER*1
          Specifies whether or not A is transposed.
          = 'N':  No transpose
          = 'T':  Transpose
          = 'C':  Conjugate transpose (= Transpose)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+A\+N\+S\+E} & \begin{DoxyVerb}          TRANSE is CHARACTER*1
          Specifies whether or not E is transposed.
          = 'N':  No transpose, eigenvectors are in columns of E
          = 'T':  Transpose, eigenvectors are in rows of E
          = 'C':  Conjugate transpose (= Transpose)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+A\+N\+S\+W} & \begin{DoxyVerb}          TRANSW is CHARACTER*1
          Specifies whether or not W is transposed.
          = 'N':  No transpose
          = 'T':  Transpose, use -WI(j) instead of WI(j)
          = 'C':  Conjugate transpose, use -WI(j) instead of WI(j)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The matrix whose eigenvectors are in E.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (LDE,N)
          The matrix of eigenvectors. If TRANSE = 'N', the eigenvectors
          are stored in the columns of E, if TRANSE = 'T' or 'C', the
          eigenvectors are stored in the rows of E.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+E} & \begin{DoxyVerb}          LDE is INTEGER
          The leading dimension of the array E.  LDE >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL array, dimension (N)

          The real and imaginary parts of the eigenvalues of A.
          Purely real eigenvalues are indicated by WI(j) = 0.
          Complex conjugate pairs are indicated by WR(j)=WR(j+1) and
          WI(j) = - WI(j+1) non-zero; the real part is assumed to be
          stored in the j-th row/column and the imaginary part in
          the (j+1)-th row/column.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N*(N+1))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          RESULT(1) = | A E  -  E W | / ( |A| |E| ulp )
          RESULT(2) = max | m-norm(E(j)) - 1 | / ( n ulp )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gade26c43e6d095c1129bdadb44e996089}{}\index{real@{real}!sget23@{sget23}}
\index{sget23@{sget23}!real@{real}}
\subsubsection[{sget23}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget23 (
\begin{DoxyParamCaption}
\item[{{\bf logical}}]{C\+O\+M\+P, }
\item[{character}]{B\+A\+L\+A\+N\+C, }
\item[{integer}]{J\+T\+Y\+P\+E, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( $\ast$ )}]{W\+I, }
\item[{real, dimension( $\ast$ )}]{W\+R1, }
\item[{real, dimension( $\ast$ )}]{W\+I1, }
\item[{real, dimension( ldvl, $\ast$ )}]{V\+L, }
\item[{integer}]{L\+D\+V\+L, }
\item[{real, dimension( ldvr, $\ast$ )}]{V\+R, }
\item[{integer}]{L\+D\+V\+R, }
\item[{real, dimension( ldlre, $\ast$ )}]{L\+R\+E, }
\item[{integer}]{L\+D\+L\+R\+E, }
\item[{real, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+V, }
\item[{real, dimension( $\ast$ )}]{R\+C\+N\+D\+V1, }
\item[{real, dimension( $\ast$ )}]{R\+C\+D\+V\+I\+N, }
\item[{real, dimension( $\ast$ )}]{R\+C\+O\+N\+D\+E, }
\item[{real, dimension( $\ast$ )}]{R\+C\+N\+D\+E1, }
\item[{real, dimension( $\ast$ )}]{R\+C\+D\+E\+I\+N, }
\item[{real, dimension( $\ast$ )}]{S\+C\+A\+L\+E, }
\item[{real, dimension( $\ast$ )}]{S\+C\+A\+L\+E1, }
\item[{real, dimension( 11 )}]{R\+E\+S\+U\+L\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gade26c43e6d095c1129bdadb44e996089}


{\bfseries S\+G\+E\+T23} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SGET23  checks the nonsymmetric eigenvalue problem driver SGEEVX.
    If COMP = .FALSE., the first 8 of the following tests will be
    performed on the input matrix A, and also test 9 if LWORK is
    sufficiently large.
    if COMP is .TRUE. all 11 tests will be performed.

    (1)     | A * VR - VR * W | / ( n |A| ulp )

      Here VR is the matrix of unit right eigenvectors.
      W is a block diagonal matrix, with a 1x1 block for each
      real eigenvalue and a 2x2 block for each complex conjugate
      pair.  If eigenvalues j and j+1 are a complex conjugate pair,
      so WR(j) = WR(j+1) = wr and WI(j) = - WI(j+1) = wi, then the
      2 x 2 block corresponding to the pair will be:

              (  wr  wi  )
              ( -wi  wr  )

      Such a block multiplying an n x 2 matrix  ( ur ui ) on the
      right will be the same as multiplying  ur + i*ui  by  wr + i*wi.

    (2)     | A**H * VL - VL * W**H | / ( n |A| ulp )

      Here VL is the matrix of unit left eigenvectors, A**H is the
      conjugate transpose of A, and W is as above.

    (3)     | |VR(i)| - 1 | / ulp and largest component real

      VR(i) denotes the i-th column of VR.

    (4)     | |VL(i)| - 1 | / ulp and largest component real

      VL(i) denotes the i-th column of VL.

    (5)     0 if W(full) = W(partial), 1/ulp otherwise

      W(full) denotes the eigenvalues computed when VR, VL, RCONDV
      and RCONDE are also computed, and W(partial) denotes the
      eigenvalues computed when only some of VR, VL, RCONDV, and
      RCONDE are computed.

    (6)     0 if VR(full) = VR(partial), 1/ulp otherwise

      VR(full) denotes the right eigenvectors computed when VL, RCONDV
      and RCONDE are computed, and VR(partial) denotes the result
      when only some of VL and RCONDV are computed.

    (7)     0 if VL(full) = VL(partial), 1/ulp otherwise

      VL(full) denotes the left eigenvectors computed when VR, RCONDV
      and RCONDE are computed, and VL(partial) denotes the result
      when only some of VR and RCONDV are computed.

    (8)     0 if SCALE, ILO, IHI, ABNRM (full) =
                 SCALE, ILO, IHI, ABNRM (partial)
            1/ulp otherwise

      SCALE, ILO, IHI and ABNRM describe how the matrix is balanced.
      (full) is when VR, VL, RCONDE and RCONDV are also computed, and
      (partial) is when some are not computed.

    (9)     0 if RCONDV(full) = RCONDV(partial), 1/ulp otherwise

      RCONDV(full) denotes the reciprocal condition numbers of the
      right eigenvectors computed when VR, VL and RCONDE are also
      computed. RCONDV(partial) denotes the reciprocal condition
      numbers when only some of VR, VL and RCONDE are computed.

   (10)     |RCONDV - RCDVIN| / cond(RCONDV)

      RCONDV is the reciprocal right eigenvector condition number
      computed by SGEEVX and RCDVIN (the precomputed true value)
      is supplied as input. cond(RCONDV) is the condition number of
      RCONDV, and takes errors in computing RCONDV into account, so
      that the resulting quantity should be O(ULP). cond(RCONDV) is
      essentially given by norm(A)/RCONDE.

   (11)     |RCONDE - RCDEIN| / cond(RCONDE)

      RCONDE is the reciprocal eigenvalue condition number
      computed by SGEEVX and RCDEIN (the precomputed true value)
      is supplied as input.  cond(RCONDE) is the condition number
      of RCONDE, and takes errors in computing RCONDE into account,
      so that the resulting quantity should be O(ULP). cond(RCONDE)
      is essentially given by norm(A)/RCONDV.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em C\+O\+M\+P} & \begin{DoxyVerb}          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B\+A\+L\+A\+N\+C} & \begin{DoxyVerb}          BALANC is CHARACTER
          Describes the balancing option to be tested.
            = 'N' for no permuting or diagonal scaling
            = 'P' for permuting but no diagonal scaling
            = 'S' for no permuting but diagonal scaling
            = 'B' for permuting and diagonal scaling\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em J\+T\+Y\+P\+E} & \begin{DoxyVerb}          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of A. N must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          Used to hold the matrix whose eigenvalues are to be
          computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension (LDA,N)
          Another copy of the test matrix A, modified by SGEEVX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL array, dimension (N)

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R1} & \begin{DoxyVerb}          WR1 is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I1} & \begin{DoxyVerb}          WI1 is REAL array, dimension (N)

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when SGEEVX only computes a partial
          eigendecomposition, i.e. not the eigenvalues and left
          and right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+L} & \begin{DoxyVerb}          VL is REAL array, dimension (LDVL,N)
          VL holds the computed left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+L} & \begin{DoxyVerb}          LDVL is INTEGER
          Leading dimension of VL. Must be at least max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+R} & \begin{DoxyVerb}          VR is REAL array, dimension (LDVR,N)
          VR holds the computed right eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+R} & \begin{DoxyVerb}          LDVR is INTEGER
          Leading dimension of VR. Must be at least max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+R\+E} & \begin{DoxyVerb}          LRE is REAL array, dimension (LDLRE,N)
          LRE holds the computed right or left eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+L\+R\+E} & \begin{DoxyVerb}          LDLRE is INTEGER
          Leading dimension of LRE. Must be at least max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+V} & \begin{DoxyVerb}          RCONDV is REAL array, dimension (N)
          RCONDV holds the computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+V1} & \begin{DoxyVerb}          RCNDV1 is REAL array, dimension (N)
          RCNDV1 holds more computed reciprocal condition numbers
          for eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+V\+I\+N} & \begin{DoxyVerb}          RCDVIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition numbers for eigenvectors to be compared with
          RCONDV.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+O\+N\+D\+E} & \begin{DoxyVerb}          RCONDE is REAL array, dimension (N)
          RCONDE holds the computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+C\+N\+D\+E1} & \begin{DoxyVerb}          RCNDE1 is REAL array, dimension (N)
          RCNDE1 holds more computed reciprocal condition numbers
          for eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+E\+I\+N} & \begin{DoxyVerb}          RCDEIN is REAL array, dimension (N)
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition numbers for eigenvalues to be compared with
          RCONDE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E} & \begin{DoxyVerb}          SCALE is REAL array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em S\+C\+A\+L\+E1} & \begin{DoxyVerb}          SCALE1 is REAL array, dimension (N)
          Holds information describing balancing of matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (11)
          The values computed by the 11 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK.  This must be at least
          3*N, and 6*N+N**2 if tests 9, 10 or 11 are to be performed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (2*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  successful exit.
          If <0, input parameter -INFO had an incorrect value.
          If >0, SGEEVX returned an error code, the absolute
                 value of which is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga35b38ff82fbc9f1d0f4e0eba2f7c497f}{}\index{real@{real}!sget24@{sget24}}
\index{sget24@{sget24}!real@{real}}
\subsubsection[{sget24}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget24 (
\begin{DoxyParamCaption}
\item[{{\bf logical}}]{C\+O\+M\+P, }
\item[{integer}]{J\+T\+Y\+P\+E, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{integer}]{N\+O\+U\+N\+I\+T, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( lda, $\ast$ )}]{H, }
\item[{real, dimension( lda, $\ast$ )}]{H\+T, }
\item[{real, dimension( $\ast$ )}]{W\+R, }
\item[{real, dimension( $\ast$ )}]{W\+I, }
\item[{real, dimension( $\ast$ )}]{W\+R\+T, }
\item[{real, dimension( $\ast$ )}]{W\+I\+T, }
\item[{real, dimension( $\ast$ )}]{W\+R\+T\+M\+P, }
\item[{real, dimension( $\ast$ )}]{W\+I\+T\+M\+P, }
\item[{real, dimension( ldvs, $\ast$ )}]{V\+S, }
\item[{integer}]{L\+D\+V\+S, }
\item[{real, dimension( ldvs, $\ast$ )}]{V\+S1, }
\item[{real}]{R\+C\+D\+E\+I\+N, }
\item[{real}]{R\+C\+D\+V\+I\+N, }
\item[{integer}]{N\+S\+L\+C\+T, }
\item[{integer, dimension( $\ast$ )}]{I\+S\+L\+C\+T, }
\item[{real, dimension( 17 )}]{R\+E\+S\+U\+L\+T, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{{\bf logical}, dimension( $\ast$ )}]{B\+W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga35b38ff82fbc9f1d0f4e0eba2f7c497f}


{\bfseries S\+G\+E\+T24} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SGET24 checks the nonsymmetric eigenvalue (Schur form) problem
    expert driver SGEESX.

    If COMP = .FALSE., the first 13 of the following tests will be
    be performed on the input matrix A, and also tests 14 and 15
    if LWORK is sufficiently large.
    If COMP = .TRUE., all 17 test will be performed.

    (1)     0 if T is in Schur form, 1/ulp otherwise
           (no sorting of eigenvalues)

    (2)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (no sorting of eigenvalues).

    (3)     | I - VS VS' | / ( n ulp ) (no sorting of eigenvalues).

    (4)     0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            (no sorting of eigenvalues)

    (5)     0     if T(with VS) = T(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (6)     0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            (no sorting of eigenvalues)

    (7)     0 if T is in Schur form, 1/ulp otherwise
            (with sorting of eigenvalues)

    (8)     | A - VS T VS' | / ( n |A| ulp )

      Here VS is the matrix of Schur eigenvectors, and T is in Schur
      form  (with sorting of eigenvalues).

    (9)     | I - VS VS' | / ( n ulp ) (with sorting of eigenvalues).

    (10)    0     if WR+sqrt(-1)*WI are eigenvalues of T
            1/ulp otherwise
            If workspace sufficient, also compare WR, WI with and
            without reciprocal condition numbers
            (with sorting of eigenvalues)

    (11)    0     if T(with VS) = T(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare T with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (12)    0     if eigenvalues(with VS) = eigenvalues(without VS),
            1/ulp otherwise
            If workspace sufficient, also compare VS with and without
            reciprocal condition numbers
            (with sorting of eigenvalues)

    (13)    if sorting worked and SDIM is the number of
            eigenvalues which were SELECTed
            If workspace sufficient, also compare SDIM with and
            without reciprocal condition numbers

    (14)    if RCONDE the same no matter if VS and/or RCONDV computed

    (15)    if RCONDV the same no matter if VS and/or RCONDE computed

    (16)  |RCONDE - RCDEIN| / cond(RCONDE)

       RCONDE is the reciprocal average eigenvalue condition number
       computed by SGEESX and RCDEIN (the precomputed true value)
       is supplied as input.  cond(RCONDE) is the condition number
       of RCONDE, and takes errors in computing RCONDE into account,
       so that the resulting quantity should be O(ULP). cond(RCONDE)
       is essentially given by norm(A)/RCONDV.

    (17)  |RCONDV - RCDVIN| / cond(RCONDV)

       RCONDV is the reciprocal right invariant subspace condition
       number computed by SGEESX and RCDVIN (the precomputed true
       value) is supplied as input. cond(RCONDV) is the condition
       number of RCONDV, and takes errors in computing RCONDV into
       account, so that the resulting quantity should be O(ULP).
       cond(RCONDV) is essentially given by norm(A)/RCONDE.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em C\+O\+M\+P} & \begin{DoxyVerb}          COMP is LOGICAL
          COMP describes which input tests to perform:
            = .FALSE. if the computed condition numbers are not to
                      be tested against RCDVIN and RCDEIN
            = .TRUE.  if they are to be compared\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em J\+T\+Y\+P\+E} & \begin{DoxyVerb}          JTYPE is INTEGER
          Type of input matrix. Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          If COMP = .FALSE., the random number generator seed
          used to produce matrix.
          If COMP = .TRUE., ISEED(1) = the number of the example.
          Used to label output if error occurs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+H\+R\+E\+S\+H} & \begin{DoxyVerb}          THRESH is REAL
          A test will count as "failed" if the "error", computed as
          described above, exceeds THRESH.  Note that the error
          is scaled to be O(1), so THRESH should be a reasonably
          small multiple of 1, e.g., 10 or 100.  In particular,
          it should not depend on the precision (single vs. double)
          or the size of the matrix.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          NOUNIT is INTEGER
          The FORTRAN unit number for printing out error messages
          (e.g., if a routine returns INFO not equal to 0.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of A. N must be at least 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          Used to hold the matrix whose eigenvalues are to be
          computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A, and H. LDA must be at
          least 1 and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension (LDA, N)
          Another copy of the test matrix A, modified by SGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em H\+T} & \begin{DoxyVerb}          HT is REAL array, dimension (LDA, N)
          Yet another copy of the test matrix A, modified by SGEESX.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL array, dimension (N)

          The real and imaginary parts of the eigenvalues of A.
          On exit, WR + WI*i are the eigenvalues of the matrix in A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R\+T} & \begin{DoxyVerb}          WRT is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I\+T} & \begin{DoxyVerb}          WIT is REAL array, dimension (N)

          Like WR, WI, these arrays contain the eigenvalues of A,
          but those computed when SGEESX only computes a partial
          eigendecomposition, i.e. not Schur vectors\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+R\+T\+M\+P} & \begin{DoxyVerb}          WRTMP is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+I\+T\+M\+P} & \begin{DoxyVerb}          WITMP is REAL array, dimension (N)

          Like WR, WI, these arrays contain the eigenvalues of A,
          but sorted by increasing real part.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S} & \begin{DoxyVerb}          VS is REAL array, dimension (LDVS, N)
          VS holds the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V\+S} & \begin{DoxyVerb}          LDVS is INTEGER
          Leading dimension of VS. Must be at least max(1, N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V\+S1} & \begin{DoxyVerb}          VS1 is REAL array, dimension (LDVS, N)
          VS1 holds another copy of the computed Schur vectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+E\+I\+N} & \begin{DoxyVerb}          RCDEIN is REAL
          When COMP = .TRUE. RCDEIN holds the precomputed reciprocal
          condition number for the average of selected eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+D\+V\+I\+N} & \begin{DoxyVerb}          RCDVIN is REAL
          When COMP = .TRUE. RCDVIN holds the precomputed reciprocal
          condition number for the selected right invariant subspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+S\+L\+C\+T} & \begin{DoxyVerb}          NSLCT is INTEGER
          When COMP = .TRUE. the number of selected eigenvalues
          corresponding to the precomputed values RCDEIN and RCDVIN.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+L\+C\+T} & \begin{DoxyVerb}          ISLCT is INTEGER array, dimension (NSLCT)
          When COMP = .TRUE. ISLCT selects the eigenvalues of the
          input matrix corresponding to the precomputed values RCDEIN
          and RCDVIN. For I=1, ... ,NSLCT, if ISLCT(I) = J, then the
          eigenvalue with the J-th largest real part is selected.
          Not referenced if COMP = .FALSE.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (17)
          The values computed by the 17 tests described above.
          The values are currently limited to 1/ulp, to avoid
          overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The number of entries in WORK to be passed to SGEESX. This
          must be at least 3*N, and N+N**2 if tests 14--16 are to
          be performed.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (N*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+O\+R\+K} & \begin{DoxyVerb}          BWORK is LOGICAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          If 0,  successful exit.
          If <0, input parameter -INFO had an incorrect value.
          If >0, SGEESX returned an error code, the absolute
                 value of which is returned.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga3ecf18b5f5029225a7ddd4a1c42208f2}{}\index{real@{real}!sget31@{sget31}}
\index{sget31@{sget31}!real@{real}}
\subsubsection[{sget31}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget31 (
\begin{DoxyParamCaption}
\item[{real}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer, dimension( 2 )}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga3ecf18b5f5029225a7ddd4a1c42208f2}


{\bfseries S\+G\+E\+T31} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET31 tests SLALN2, a routine for solving

    (ca A - w D)X = sB

 where A is an NA by NA matrix (NA=1 or 2 only), w is a real (NW=1) or
 complex (NW=2) constant, ca is a real constant, D is an NA by NA real
 diagonal matrix, and B is an NA by NW matrix (when NW=2 the second
 column of B contains the imaginary part of the solution).  The code
 returns X and s, where s is a scale factor, less than or equal to 1,
 which is chosen to avoid overflow in X.

 If any singular values of ca A-w D are less than another input
 parameter SMIN, they are perturbed up to SMIN.

 The test condition is that the scaled residual

     norm( (ca A-w D)*X - s*B ) /
           ( max( ulp*norm(ca A-w D), SMIN )*norm(X) )

 should be on the order of 1.  Here, ulp is the machine precision.
 Also, it is verified that SCALE is less than or equal to 1, and that
 XNORM = infinity-norm(X).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER array, dimension (3)
          NINFO(1) = number of examples with INFO less than 0
          NINFO(2) = number of examples with INFO greater than 0\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaed4fdc62ebe7c28b1c0f06c7c7c53850}{}\index{real@{real}!sget32@{sget32}}
\index{sget32@{sget32}!real@{real}}
\subsubsection[{sget32}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget32 (
\begin{DoxyParamCaption}
\item[{real}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaed4fdc62ebe7c28b1c0f06c7c7c53850}


{\bfseries S\+G\+E\+T32} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET32 tests SLASY2, a routine for solving

         op(TL)*X + ISGN*X*op(TR) = SCALE*B

 where TL is N1 by N1, TR is N2 by N2, and N1,N2 =1 or 2 only.
 X and B are N1 by N2, op() is an optional transpose, an
 ISGN = 1 or -1. SCALE is chosen less than or equal to 1 to
 avoid overflow in X.

 The test condition is that the scaled residual

 norm( op(TL)*X + ISGN*X*op(TR) = SCALE*B )
      / ( max( ulp*norm(TL), ulp*norm(TR)) * norm(X), SMLNUM )

 should be on the order of 1. Here, ulp is the machine precision.
 Also, it is verified that SCALE is less than or equal to 1, and
 that XNORM = infinity-norm(X).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER
          Number of examples returned with INFO.NE.0.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga3a331380ca2ad1894f1324093ca0b6bc}{}\index{real@{real}!sget33@{sget33}}
\index{sget33@{sget33}!real@{real}}
\subsubsection[{sget33}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget33 (
\begin{DoxyParamCaption}
\item[{real}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga3a331380ca2ad1894f1324093ca0b6bc}


{\bfseries S\+G\+E\+T33} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET33 tests SLANV2, a routine for putting 2 by 2 blocks into
 standard form.  In other words, it computes a two by two rotation
 [[C,S];[-S,C]] where in

    [ C S ][T(1,1) T(1,2)][ C -S ] = [ T11 T12 ]
    [-S C ][T(2,1) T(2,2)][ S  C ]   [ T21 T22 ]

 either
    1) T21=0 (real eigenvalues), or
    2) T11=T22 and T21*T12<0 (complex conjugate eigenvalues).
 We also  verify that the residual is small.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER
          Number of examples returned with INFO .NE. 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga982b1b2bcfb91803ffe5fe2c9ed62a19}{}\index{real@{real}!sget34@{sget34}}
\index{sget34@{sget34}!real@{real}}
\subsubsection[{sget34}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget34 (
\begin{DoxyParamCaption}
\item[{real}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer, dimension( 2 )}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga982b1b2bcfb91803ffe5fe2c9ed62a19}


{\bfseries S\+G\+E\+T34} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET34 tests SLAEXC, a routine for swapping adjacent blocks (either
 1 by 1 or 2 by 2) on the diagonal of a matrix in real Schur form.
 Thus, SLAEXC computes an orthogonal matrix Q such that

     Q' * [ A B ] * Q  = [ C1 B1 ]
          [ 0 C ]        [ 0  A1 ]

 where C1 is similar to C and A1 is similar to A.  Both A and C are
 assumed to be in standard form (equal diagonal entries and
 offdiagonal with differing signs) and A1 and C1 are returned with the
 same properties.

 The test code verifies these last last assertions, as well as that
 the residual in the above equation is small.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER array, dimension (2)
          NINFO(J) is the number of examples where INFO=J occurred.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gad00416cde934f3821bd9cbe854ddbd1e}{}\index{real@{real}!sget35@{sget35}}
\index{sget35@{sget35}!real@{real}}
\subsubsection[{sget35}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget35 (
\begin{DoxyParamCaption}
\item[{real}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gad00416cde934f3821bd9cbe854ddbd1e}


{\bfseries S\+G\+E\+T35} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET35 tests STRSYL, a routine for solving the Sylvester matrix
 equation

    op(A)*X + ISGN*X*op(B) = scale*C,

 A and B are assumed to be in Schur canonical form, op() represents an
 optional transpose, and ISGN can be -1 or +1.  Scale is an output
 less than or equal to 1, chosen to avoid overflow in X.

 The test code verifies that the following residual is order 1:

    norm(op(A)*X + ISGN*X*op(B) - scale*C) /
        (EPS*max(norm(A),norm(B))*norm(X))\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER
          Number of examples where INFO is nonzero.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga142bffda1c42659908f951ac51744638}{}\index{real@{real}!sget36@{sget36}}
\index{sget36@{sget36}!real@{real}}
\subsubsection[{sget36}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget36 (
\begin{DoxyParamCaption}
\item[{real}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T, }
\item[{integer}]{N\+I\+N}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga142bffda1c42659908f951ac51744638}


{\bfseries S\+G\+E\+T36} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET36 tests STREXC, a routine for moving blocks (either 1 by 1 or
 2 by 2) on the diagonal of a matrix in real Schur form.  Thus, SLAEXC
 computes an orthogonal matrix Q such that

    Q' * T1 * Q  = T2

 and where one of the diagonal blocks of T1 (the one at row IFST) has
 been moved to position ILST.

 The test code verifies that the residual Q'*T1*Q-T2 is small, that T2
 is in Schur form, and that the final position of the IFST block is
 ILST (within +-1).

 The test matrices are read from a file with logical unit number NIN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER array, dimension (3)
          NINFO(J) is the number of examples where INFO=J.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          Input logical unit number.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gac812301fb70fec79ae94eb13b0fa1466}{}\index{real@{real}!sget37@{sget37}}
\index{sget37@{sget37}!real@{real}}
\subsubsection[{sget37}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget37 (
\begin{DoxyParamCaption}
\item[{real, dimension( 3 )}]{R\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{L\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T, }
\item[{integer}]{N\+I\+N}
\end{DoxyParamCaption}
)}\label{group__single__eig_gac812301fb70fec79ae94eb13b0fa1466}


{\bfseries S\+G\+E\+T37} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET37 tests STRSNA, a routine for estimating condition numbers of
 eigenvalues and/or right eigenvectors of a matrix.

 The test matrices are read from a file with logical unit number NIN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL array, dimension (3)
          Value of the largest test ratio.
          RMAX(1) = largest ratio comparing different calls to STRSNA
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If SGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If SHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If STRSNA returns INFO nonzero on example i, LMAX(3)=i\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times SGEHRD returned INFO nonzero
          NINFO(2) = No. of times SHSEQR returned INFO nonzero
          NINFO(3) = No. of times STRSNA returned INFO nonzero\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          Input logical unit number\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga15b379af6192edfd74986d7ef1b2e822}{}\index{real@{real}!sget38@{sget38}}
\index{sget38@{sget38}!real@{real}}
\subsubsection[{sget38}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget38 (
\begin{DoxyParamCaption}
\item[{real, dimension( 3 )}]{R\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{L\+M\+A\+X, }
\item[{integer, dimension( 3 )}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T, }
\item[{integer}]{N\+I\+N}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga15b379af6192edfd74986d7ef1b2e822}


{\bfseries S\+G\+E\+T38} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET38 tests STRSEN, a routine for estimating condition numbers of a
 cluster of eigenvalues and/or its associated right invariant subspace

 The test matrices are read from a file with logical unit number NIN.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL array, dimension (3)
          Values of the largest test ratios.
          RMAX(1) = largest residuals from SHST01 or comparing
                    different calls to STRSEN
          RMAX(2) = largest error in reciprocal condition
                    numbers taking their conditioning into account
          RMAX(3) = largest error in reciprocal condition
                    numbers not taking their conditioning into
                    account (may be larger than RMAX(2))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER array, dimension (3)
          LMAX(i) is example number where largest test ratio
          RMAX(i) is achieved. Also:
          If SGEHRD returns INFO nonzero on example i, LMAX(1)=i
          If SHSEQR returns INFO nonzero on example i, LMAX(2)=i
          If STRSEN returns INFO nonzero on example i, LMAX(3)=i\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER array, dimension (3)
          NINFO(1) = No. of times SGEHRD returned INFO nonzero
          NINFO(2) = No. of times SHSEQR returned INFO nonzero
          NINFO(3) = No. of times STRSEN returned INFO nonzero\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+I\+N} & \begin{DoxyVerb}          NIN is INTEGER
          Input logical unit number.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gada7ad6b7b5fd36f8101d62c7b3d378dc}{}\index{real@{real}!sget39@{sget39}}
\index{sget39@{sget39}!real@{real}}
\subsubsection[{sget39}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget39 (
\begin{DoxyParamCaption}
\item[{real}]{R\+M\+A\+X, }
\item[{integer}]{L\+M\+A\+X, }
\item[{integer}]{N\+I\+N\+F\+O, }
\item[{integer}]{K\+N\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gada7ad6b7b5fd36f8101d62c7b3d378dc}


{\bfseries S\+G\+E\+T39} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET39 tests SLAQTR, a routine for solving the real or
 special complex quasi upper triangular system

      op(T)*p = scale*c,
 or
      op(T + iB)*(p+iq) = scale*(c+id),

 in real arithmetic. T is upper quasi-triangular.
 If it is complex, then the first diagonal block of T must be
 1 by 1, B has the special structure

                B = [ b(1) b(2) ... b(n) ]
                    [       w            ]
                    [           w        ]
                    [              .     ]
                    [                 w  ]

 op(A) = A or A', where A' denotes the conjugate transpose of
 the matrix A.

 On input, X = [ c ].  On output, X = [ p ].
               [ d ]                  [ q ]

 Scale is an output less than or equal to 1, chosen to avoid
 overflow in X.
 This subroutine is specially designed for the condition number
 estimation in the eigenproblem routine STRSNA.

 The test code verifies that the following residual is order 1:

      ||(T+i*B)*(x1+i*x2) - scale*(d1+i*d2)||
    -----------------------------------------
        max(ulp*(||T||+||B||)*(||x1||+||x2||),
            (||T||+||B||)*smlnum/ulp,
            smlnum)

 (The (||T||+||B||)*smlnum/ulp term accounts for possible
  (gradual or nongradual) underflow in x1 and x2.)\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em R\+M\+A\+X} & \begin{DoxyVerb}          RMAX is REAL
          Value of the largest test ratio.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em L\+M\+A\+X} & \begin{DoxyVerb}          LMAX is INTEGER
          Example number where largest test ratio achieved.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+I\+N\+F\+O} & \begin{DoxyVerb}          NINFO is INTEGER
          Number of examples where INFO is nonzero.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+N\+T} & \begin{DoxyVerb}          KNT is INTEGER
          Total number of examples tested.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gac817155b9a60030bdc313807c2a10f76}{}\index{real@{real}!sget51@{sget51}}
\index{sget51@{sget51}!real@{real}}
\subsubsection[{sget51}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget51 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gac817155b9a60030bdc313807c2a10f76}


{\bfseries S\+G\+E\+T51} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      SGET51  generally checks a decomposition of the form

              A = U B V'

      where ' means transpose and U and V are orthogonal.

      Specifically, if ITYPE=1

              RESULT = | A - U B V' | / ( |A| n ulp )

      If ITYPE=2, then:

              RESULT = | A - B | / ( |A| n ulp )

      If ITYPE=3, then:

              RESULT = | I - UU' | / ( n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          =1: RESULT = | A - U B V' | / ( |A| n ulp )
          =2: RESULT = | A - B | / ( |A| n ulp )
          =3: RESULT = | I - UU' | / ( n ulp )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, SGET51 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          The original (unfactored) matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB, N)
          The factored matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension (LDV, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.
          Not referenced if ITYPE=2\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (2*N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL
          The values computed by the test specified by ITYPE.  The
          value is currently limited to 1/ulp, to avoid overflow.
          Errors are flagged by RESULT=10/ulp.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaccd03e1eb309d22da705f8bd9a6b0b61}{}\index{real@{real}!sget52@{sget52}}
\index{sget52@{sget52}!real@{real}}
\subsubsection[{sget52}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget52 (
\begin{DoxyParamCaption}
\item[{{\bf logical}}]{L\+E\+F\+T, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( {\bf lde}, $\ast$ )}]{E, }
\item[{integer}]{L\+D\+E, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+R, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A\+I, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaccd03e1eb309d22da705f8bd9a6b0b61}


{\bfseries S\+G\+E\+T52} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET52  does an eigenvector check for the generalized eigenvalue
 problem.

 The basic test for right eigenvectors is:

                           | b(j) A E(j) -  a(j) B E(j) |
         RESULT(1) = max   -------------------------------
                      j    n ulp max( |b(j) A|, |a(j) B| )

 using the 1-norm.  Here, a(j)/b(j) = w is the j-th generalized
 eigenvalue of A - w B, or, equivalently, b(j)/a(j) = m is the j-th
 generalized eigenvalue of m A - B.

 For real eigenvalues, the test is straightforward.  For complex
 eigenvalues, E(j) and a(j) are complex, represented by
 Er(j) + i*Ei(j) and ar(j) + i*ai(j), resp., so the test for that
 eigenvector becomes

                 max( |Wr|, |Wi| )
     --------------------------------------------
     n ulp max( |b(j) A|, (|ar(j)|+|ai(j)|) |B| )

 where

     Wr = b(j) A Er(j) - ar(j) B Er(j) + ai(j) B Ei(j)

     Wi = b(j) A Ei(j) - ai(j) B Er(j) - ar(j) B Ei(j)

                         T   T  _
 For left eigenvectors, A , B , a, and b  are used.

 SGET52 also tests the normalization of E.  Each eigenvector is
 supposed to be normalized so that the maximum "absolute value"
 of its elements is 1, where in this case, "absolute value"
 of a complex value x is  |Re(x)| + |Im(x)| ; let us call this
 maximum "absolute value" norm of a vector v  M(v). 
 if a(j)=b(j)=0, then the eigenvector is set to be the jth coordinate
 vector.  The normalization test is:

         RESULT(2) =      max       | M(v(j)) - 1 | / ( n ulp )
                    eigenvectors v(j)\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em L\+E\+F\+T} & \begin{DoxyVerb}          LEFT is LOGICAL
          =.TRUE.:  The eigenvectors in the columns of E are assumed
                    to be *left* eigenvectors.
          =.FALSE.: The eigenvectors in the columns of E are assumed
                    to be *right* eigenvectors.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrices.  If it is zero, SGET52 does
          nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          The matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB, N)
          The matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (LDE, N)
          The matrix of eigenvectors.  It must be O( 1 ).  Complex
          eigenvalues and eigenvectors always come in pairs, the
          eigenvalue and its conjugate being stored in adjacent
          elements of ALPHAR, ALPHAI, and BETA.  Thus, if a(j)/b(j)
          and a(j+1)/b(j+1) are a complex conjugate pair of
          generalized eigenvalues, then E(,j) contains the real part
          of the eigenvector and E(,j+1) contains the imaginary part.
          Note that whether E(,j) is a real eigenvector or part of a
          complex one is specified by whether ALPHAI(j) is zero or not.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+E} & \begin{DoxyVerb}          LDE is INTEGER
          The leading dimension of E.  It must be at least 1 and at
          least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+L\+P\+H\+A\+R} & \begin{DoxyVerb}          ALPHAR is REAL array, dimension (N)
          The real parts of the values a(j) as described above, which,
          along with b(j), define the generalized eigenvalues.
          Complex eigenvalues always come in complex conjugate pairs
          a(j)/b(j) and a(j+1)/b(j+1), which are stored in adjacent
          elements in ALPHAR, ALPHAI, and BETA.  Thus, if the j-th
          and (j+1)-st eigenvalues form a pair, ALPHAR(j+1)/BETA(j+1)
          is assumed to be equal to ALPHAR(j)/BETA(j).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+L\+P\+H\+A\+I} & \begin{DoxyVerb}          ALPHAI is REAL array, dimension (N)
          The imaginary parts of the values a(j) as described above,
          which, along with b(j), define the generalized eigenvalues.
          If ALPHAI(j)=0, then the eigenvalue is real, otherwise it
          is part of a complex conjugate pair.  Complex eigenvalues
          always come in complex conjugate pairs a(j)/b(j) and
          a(j+1)/b(j+1), which are stored in adjacent elements in
          ALPHAR, ALPHAI, and BETA.  Thus, if the j-th and (j+1)-st
          eigenvalues form a pair, ALPHAI(j+1)/BETA(j+1) is assumed to
          be equal to  -ALPHAI(j)/BETA(j).  Also, nonzero values in
          ALPHAI are assumed to always come in adjacent pairs.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL array, dimension (N)
          The values b(j) as described above, which, along with a(j),
          define the generalized eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N**2+N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The values computed by the test described above.  If A E or
          B E is likely to overflow, then RESULT(1:2) is set to
          10 / ulp.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga5fa2eab03c0b6a8a406b804107622c1f}{}\index{real@{real}!sget53@{sget53}}
\index{sget53@{sget53}!real@{real}}
\subsubsection[{sget53}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget53 (
\begin{DoxyParamCaption}
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real}]{S\+C\+A\+L\+E, }
\item[{real}]{W\+R, }
\item[{real}]{W\+I, }
\item[{real}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga5fa2eab03c0b6a8a406b804107622c1f}


{\bfseries S\+G\+E\+T53} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET53  checks the generalized eigenvalues computed by SLAG2.

 The basic test for an eigenvalue is:

                              | det( s A - w B ) |
     RESULT =  ---------------------------------------------------
               ulp max( s norm(A), |w| norm(B) )*norm( s A - w B )

 Two "safety checks" are performed:

 (1)  ulp*max( s*norm(A), |w|*norm(B) )  must be at least
      safe_minimum.  This insures that the test performed is
      not essentially  det(0*A + 0*B)=0.

 (2)  s*norm(A) + |w|*norm(B) must be less than 1/safe_minimum.
      This insures that  s*A - w*B  will not overflow.

 If these tests are not passed, then  s  and  w  are scaled and
 tested anyway, if this is possible.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, 2)
          The 2x2 matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 2.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB, N)
          The 2x2 upper-triangular matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of B.  It must be at least 2.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+C\+A\+L\+E} & \begin{DoxyVerb}          SCALE is REAL
          The "scale factor" s in the formula  s A - w B .  It is
          assumed to be non-negative.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em W\+R} & \begin{DoxyVerb}          WR is REAL
          The real part of the eigenvalue  w  in the formula
          s A - w B .\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em W\+I} & \begin{DoxyVerb}          WI is REAL
          The imaginary part of the eigenvalue  w  in the formula
          s A - w B .\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL
          If INFO is 2 or less, the value computed by the test
             described above.
          If INFO=3, this will just be 1/ulp.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          =0:  The input data pass the "safety checks".
          =1:  s*norm(A) + |w|*norm(B) > 1/safe_minimum.
          =2:  ulp*max( s*norm(A), |w|*norm(B) ) < safe_minimum
          =3:  same as INFO=2, but  s  and  w  could not be scaled so
               as to compute the test.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga445a7d10a693e781798a410681ab92a6}{}\index{real@{real}!sget54@{sget54}}
\index{sget54@{sget54}!real@{real}}
\subsubsection[{sget54}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sget54 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( lds, $\ast$ )}]{S, }
\item[{integer}]{L\+D\+S, }
\item[{real, dimension( ldt, $\ast$ )}]{T, }
\item[{integer}]{L\+D\+T, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga445a7d10a693e781798a410681ab92a6}


{\bfseries S\+G\+E\+T54} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGET54 checks a generalized decomposition of the form

          A = U*S*V'  and B = U*T* V'

 where ' means transpose and U and V are orthogonal.

 Specifically,

  RESULT = ||( A - U*S*V', B - U*T*V' )|| / (||( A, B )||*n*ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, SGET54 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          The original (unfactored) matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB, N)
          The original (unfactored) matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of B.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension (LDS, N)
          The factored matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+S} & \begin{DoxyVerb}          LDS is INTEGER
          The leading dimension of S.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T} & \begin{DoxyVerb}          T is REAL array, dimension (LDT, N)
          The factored matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+T} & \begin{DoxyVerb}          LDT is INTEGER
          The leading dimension of T.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension (LDV, N)
          The orthogonal matrix on the left-hand side in the
          decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (3*N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL
          The value RESULT, It is currently limited to 1/ulp, to
          avoid overflow. Errors are flagged by RESULT=10/ulp.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaa51af534646f9b5375c14c87ededdfbd}{}\index{real@{real}!sglmts@{sglmts}}
\index{sglmts@{sglmts}!real@{real}}
\subsubsection[{sglmts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sglmts (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{real, dimension( lda, $\ast$ )}]{A\+F, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{D\+F, }
\item[{real, dimension( $\ast$ )}]{X, }
\item[{real, dimension( $\ast$ )}]{U, }
\item[{real, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaa51af534646f9b5375c14c87ededdfbd}


{\bfseries S\+G\+L\+M\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGLMTS tests SGGGLM - a subroutine for solving the generalized
 linear model problem.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of rows of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of columns of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of columns of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,M)
          The N-by-M matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (LDA,M)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF. LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,P)
          The N-by-P matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (LDB,P)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF. LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension( N )
          On input, the left hand side of the GLM.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+F} & \begin{DoxyVerb}          DF is REAL array, dimension( N )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension( M )
          solution vector X in the GLM problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension( P )
          solution vector U in the GLM problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL
          The test ratio:
                           norm( d - A*x - B*u )
            RESULT = -----------------------------------------
                     (norm(A)+norm(B))*(norm(x)+norm(u))*EPS\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga412f58b485b08b55197171f8c070dcee}{}\index{real@{real}!sgqrts@{sgqrts}}
\index{sgqrts@{sgqrts}!real@{real}}
\subsubsection[{sgqrts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sgqrts (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{real, dimension( lda, $\ast$ )}]{A\+F, }
\item[{real, dimension( lda, $\ast$ )}]{Q, }
\item[{real, dimension( lda, $\ast$ )}]{R, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{real, dimension( ldb, $\ast$ )}]{Z, }
\item[{real, dimension( ldb, $\ast$ )}]{T, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+W\+K, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U\+B, }
\item[{real, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{real, dimension( 4 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga412f58b485b08b55197171f8c070dcee}


{\bfseries S\+G\+Q\+R\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGQRTS tests SGGQRF, which computes the GQR factorization of an
 N-by-M matrix A and a N-by-P matrix B: A = Q*R and B = Q*T*Z.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of rows of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of columns of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of columns of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,M)
          The N-by-M matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (LDA,N)
          Details of the GQR factorization of A and B, as returned
          by SGGQRF, see SGGQRF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDA,N)
          The M-by-M orthogonal matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is REAL array, dimension (LDA,MAX(M,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+A} & \begin{DoxyVerb}          TAUA is REAL array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by SGGQRF.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,P)
          On entry, the N-by-P matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by SGGQRF, see SGGQRF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension (LDB,P)
          The P-by-P orthogonal matrix Z.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is REAL array, dimension (LDB,max(P,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+K} & \begin{DoxyVerb}          BWK is REAL array, dimension (LDB,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+B} & \begin{DoxyVerb}          TAUB is REAL array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by SGGRQF.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK, LWORK >= max(N,M,P)**2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (max(N,M,P))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - Q'*A ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Z - Q'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( M*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga38549b2e96321b31dceb6b549fba78dc}{}\index{real@{real}!sgrqts@{sgrqts}}
\index{sgrqts@{sgrqts}!real@{real}}
\subsubsection[{sgrqts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sgrqts (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{real, dimension( lda, $\ast$ )}]{A\+F, }
\item[{real, dimension( lda, $\ast$ )}]{Q, }
\item[{real, dimension( lda, $\ast$ )}]{R, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{real, dimension( ldb, $\ast$ )}]{Z, }
\item[{real, dimension( ldb, $\ast$ )}]{T, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+W\+K, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U\+B, }
\item[{real, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{real, dimension( 4 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga38549b2e96321b31dceb6b549fba78dc}


{\bfseries S\+G\+R\+Q\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGRQTS tests SGGRQF, which computes the GRQ factorization of an
 M-by-N matrix A and a P-by-N matrix B: A = R*Q and B = Z*T*Q.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The M-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (LDA,N)
          Details of the GRQ factorization of A and B, as returned
          by SGGRQF, see SGGRQF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDA,N)
          The N-by-N orthogonal matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is REAL array, dimension (LDA,MAX(M,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF, R and Q.
          LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+A} & \begin{DoxyVerb}          TAUA is REAL array, dimension (min(M,N))
          The scalar factors of the elementary reflectors, as returned
          by SGGQRC.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,N)
          On entry, the P-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (LDB,N)
          Details of the GQR factorization of A and B, as returned
          by SGGRQF, see SGGRQF for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension (LDB,P)
          The P-by-P orthogonal matrix Z.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T} & \begin{DoxyVerb}          T is REAL array, dimension (LDB,max(P,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+W\+K} & \begin{DoxyVerb}          BWK is REAL array, dimension (LDB,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF, Z and T.
          LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+A\+U\+B} & \begin{DoxyVerb}          TAUB is REAL array, dimension (min(P,N))
          The scalar factors of the elementary reflectors, as returned
          by SGGRQF.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK, LWORK >= max(M,P,N)**2.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (4)
          The test ratios:
            RESULT(1) = norm( R - A*Q' ) / ( MAX(M,N)*norm(A)*ULP)
            RESULT(2) = norm( T*Q - Z'*B ) / (MAX(P,N)*norm(B)*ULP)
            RESULT(3) = norm( I - Q'*Q ) / ( N*ULP )
            RESULT(4) = norm( I - Z'*Z ) / ( P*ULP )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga7832a2929b4429ee218f59c00dab4956}{}\index{real@{real}!sgsvts@{sgsvts}}
\index{sgsvts@{sgsvts}!real@{real}}
\subsubsection[{sgsvts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sgsvts (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{real, dimension( lda, $\ast$ )}]{A\+F, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( $\ast$ )}]{A\+L\+P\+H\+A, }
\item[{real, dimension( $\ast$ )}]{B\+E\+T\+A, }
\item[{real, dimension( ldr, $\ast$ )}]{R, }
\item[{integer}]{L\+D\+R, }
\item[{integer, dimension( $\ast$ )}]{I\+W\+O\+R\+K, }
\item[{real, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{real, dimension( 6 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga7832a2929b4429ee218f59c00dab4956}


{\bfseries S\+G\+S\+V\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SGSVTS tests SGGSVD, which computes the GSVD of an M-by-N matrix A
 and a P-by-N matrix B:
              U'*A*Q = D1*R and V'*B*Q = D2*R.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,M)
          The M-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (LDA,N)
          Details of the GSVD of A and B, as returned by SGGSVD,
          see SGGSVD for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A and AF.
          LDA >= max( 1,M ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,P)
          On entry, the P-by-N matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (LDB,N)
          Details of the GSVD of A and B, as returned by SGGSVD,
          see SGGSVD for further details.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B and BF.
          LDB >= max(1,P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension(LDU,M)
          The M by M orthogonal matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U. LDU >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension(LDV,M)
          The P by P orthogonal matrix V.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of the array V. LDV >= max(1,P).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension(LDQ,N)
          The N by N orthogonal matrix Q.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q. LDQ >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+L\+P\+H\+A} & \begin{DoxyVerb}          ALPHA is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL array, dimension (N)

          The generalized singular value pairs of A and B, the
          ``diagonal'' matrices D1 and D2 are constructed from
          ALPHA and BETA, see subroutine SGGSVD for details.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R} & \begin{DoxyVerb}          R is REAL array, dimension(LDQ,N)
          The upper triangular matrix R.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+R} & \begin{DoxyVerb}          LDR is INTEGER
          The leading dimension of the array R. LDR >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+W\+O\+R\+K} & \begin{DoxyVerb}          IWORK is INTEGER array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK,
          LWORK >= max(M,P,N)*max(M,P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (max(M,P,N))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (6)
          The test ratios:
          RESULT(1) = norm( U'*A*Q - D1*R ) / ( MAX(M,N)*norm(A)*ULP)
          RESULT(2) = norm( V'*B*Q - D2*R ) / ( MAX(P,N)*norm(B)*ULP)
          RESULT(3) = norm( I - U'*U ) / ( M*ULP )
          RESULT(4) = norm( I - V'*V ) / ( P*ULP )
          RESULT(5) = norm( I - Q'*Q ) / ( N*ULP )
          RESULT(6) = 0        if ALPHA is in decreasing order;
                    = ULPINV   otherwise.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gac3cc6f97fd6bdc607aab5f8bd0034054}{}\index{real@{real}!shst01@{shst01}}
\index{shst01@{shst01}!real@{real}}
\subsubsection[{shst01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine shst01 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{I\+L\+O, }
\item[{integer}]{I\+H\+I, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldh, $\ast$ )}]{H, }
\item[{integer}]{L\+D\+H, }
\item[{real, dimension( ldq, $\ast$ )}]{Q, }
\item[{integer}]{L\+D\+Q, }
\item[{real, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gac3cc6f97fd6bdc607aab5f8bd0034054}


{\bfseries S\+H\+S\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SHST01 tests the reduction of a general matrix A to upper Hessenberg
 form:  A = Q*H*Q'.  Two test ratios are computed;

 RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
 RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )

 The matrix Q is assumed to be given explicitly as it would be
 following SGEHRD + SORGHR.

 In this version, ILO and IHI are not used and are assumed to be 1 and
 N, respectively.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+L\+O} & \begin{DoxyVerb}          ILO is INTEGER\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+H\+I} & \begin{DoxyVerb}          IHI is INTEGER

          A is assumed to be upper triangular in rows and columns
          1:ILO-1 and IHI+1:N, so Q differs from the identity only in
          rows and columns ILO+1:IHI.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The original n by n matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em H} & \begin{DoxyVerb}          H is REAL array, dimension (LDH,N)
          The upper Hessenberg matrix H from the reduction A = Q*H*Q'
          as computed by SGEHRD.  H is assumed to be zero below the
          first subdiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+H} & \begin{DoxyVerb}          LDH is INTEGER
          The leading dimension of the array H.  LDH >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Q} & \begin{DoxyVerb}          Q is REAL array, dimension (LDQ,N)
          The orthogonal matrix Q from the reduction A = Q*H*Q' as
          computed by SGEHRD + SORGHR.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Q} & \begin{DoxyVerb}          LDQ is INTEGER
          The leading dimension of the array Q.  LDQ >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The length of the array WORK.  LWORK >= 2*N*N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          RESULT(1) = norm( A - Q*H*Q' ) / ( norm(A) * N * EPS )
          RESULT(2) = norm( I - Q'*Q ) / ( N * EPS )\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gac380bedffc2273fb83d72d857a28876a}{}\index{real@{real}!slafts@{slafts}}
\index{slafts@{slafts}!real@{real}}
\subsubsection[{slafts}]{\setlength{\rightskip}{0pt plus 5cm}subroutine slafts (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{T\+Y\+P\+E, }
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{integer}]{I\+M\+A\+T, }
\item[{integer}]{N\+T\+E\+S\+T\+S, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real}]{T\+H\+R\+E\+S\+H, }
\item[{integer}]{I\+O\+U\+N\+I\+T, }
\item[{integer}]{I\+E}
\end{DoxyParamCaption}
)}\label{group__single__eig_gac380bedffc2273fb83d72d857a28876a}


{\bfseries S\+L\+A\+F\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SLAFTS tests the result vector against the threshold value to
    see which tests for this matrix type failed to pass the threshold.
    Output is to the file given by unit IOUNIT.\end{DoxyVerb}
 \begin{DoxyVerb}  TYPE   - CHARACTER*3
           On entry, TYPE specifies the matrix type to be used in the
           printed messages.
           Not modified.

  N      - INTEGER
           On entry, N specifies the order of the test matrix.
           Not modified.

  IMAT   - INTEGER
           On entry, IMAT specifies the type of the test matrix.
           A listing of the different types is printed by SLAHD2
           to the output file if a test fails to pass the threshold.
           Not modified.

  NTESTS - INTEGER
           On entry, NTESTS is the number of tests performed on the
           subroutines in the path given by TYPE.
           Not modified.

  RESULT - REAL               array of dimension( NTESTS )
           On entry, RESULT contains the test ratios from the tests
           performed in the calling program.
           Not modified.

  ISEED  - INTEGER            array of dimension( 4 )
           Contains the random seed that generated the matrix used
           for the tests whose ratios are in RESULT.
           Not modified.

  THRESH - REAL
           On entry, THRESH specifies the acceptable threshold of the
           test ratios.  If RESULT( K ) > THRESH, then the K-th test
           did not pass the threshold and a message will be printed.
           Not modified.

  IOUNIT - INTEGER
           On entry, IOUNIT specifies the unit number of the file
           to which the messages are printed.
           Not modified.

  IE     - INTEGER
           On entry, IE contains the number of tests which have
           failed to pass the threshold so far.
           Updated on exit if any of the ratios in RESULT also fail.\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaed2b768a1738ac80fc4df77690614cd9}{}\index{real@{real}!slahd2@{slahd2}}
\index{slahd2@{slahd2}!real@{real}}
\subsubsection[{slahd2}]{\setlength{\rightskip}{0pt plus 5cm}subroutine slahd2 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+O\+U\+N\+I\+T, }
\item[{character$\ast$3}]{P\+A\+T\+H}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaed2b768a1738ac80fc4df77690614cd9}


{\bfseries S\+L\+A\+H\+D2} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SLAHD2 prints header information for the different test paths.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+O\+U\+N\+I\+T} & \begin{DoxyVerb}          IOUNIT is INTEGER.
          On entry, IOUNIT specifies the unit number to which the
          header information should be printed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3.
          On entry, PATH contains the name of the path for which the
          header information is to be printed.  Current paths are

             SHS, CHS:  Non-symmetric eigenproblem.
             SST, CST:  Symmetric eigenproblem.
             SSG, CSG:  Symmetric Generalized eigenproblem.
             SBD, CBD:  Singular Value Decomposition (SVD)
             SBB, CBB:  General Banded reduction to bidiagonal form

          These paths also are supplied in double precision (replace
          leading S by D and leading C by Z in path names).\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga3cbcfa1d9632a6c7fbf5611dc86826ab}{}\index{real@{real}!slarfy@{slarfy}}
\index{slarfy@{slarfy}!real@{real}}
\subsubsection[{slarfy}]{\setlength{\rightskip}{0pt plus 5cm}subroutine slarfy (
\begin{DoxyParamCaption}
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{real, dimension( $\ast$ )}]{V, }
\item[{integer}]{I\+N\+C\+V, }
\item[{real}]{T\+A\+U, }
\item[{real, dimension( ldc, $\ast$ )}]{C, }
\item[{integer}]{L\+D\+C, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga3cbcfa1d9632a6c7fbf5611dc86826ab}


{\bfseries S\+L\+A\+R\+F\+Y} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SLARFY applies an elementary reflector, or Householder matrix, H,
 to an n x n symmetric matrix C, from both the left and the right.

 H is represented in the form

    H = I - tau * v * v'

 where  tau  is a scalar and  v  is a vector.

 If  tau  is  zero, then  H  is taken to be the unit matrix.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          symmetric matrix C is stored.
          = 'U':  Upper triangle
          = 'L':  Lower triangle\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of rows and columns of the matrix C.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension
                  (1 + (N-1)*abs(INCV))
          The vector v as described above.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+N\+C\+V} & \begin{DoxyVerb}          INCV is INTEGER
          The increment between successive elements of v.  INCV must
          not be zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is REAL
          The value tau as described above.\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em C} & \begin{DoxyVerb}          C is REAL array, dimension (LDC, N)
          On entry, the matrix C.
          On exit, C is overwritten by H * C * H'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+C} & \begin{DoxyVerb}          LDC is INTEGER
          The leading dimension of the array C.  LDC >= max( 1, N ).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N)\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga67befe1509ef6eaf403bedf1c4bf4058}{}\index{real@{real}!slarhs@{slarhs}}
\index{slarhs@{slarhs}!real@{real}}
\subsubsection[{slarhs}]{\setlength{\rightskip}{0pt plus 5cm}subroutine slarhs (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{character}]{X\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{character}]{T\+R\+A\+N\+S, }
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{integer}]{K\+L, }
\item[{integer}]{K\+U, }
\item[{integer}]{N\+R\+H\+S, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldx, $\ast$ )}]{X, }
\item[{integer}]{L\+D\+X, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga67befe1509ef6eaf403bedf1c4bf4058}


{\bfseries S\+L\+A\+R\+H\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SLARHS chooses a set of NRHS random solution vectors and sets
 up the right hand sides for the linear system
    op( A ) * X = B,
 where op( A ) may be A or A' (transpose of A).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The type of the real matrix A.  PATH may be given in any
          combination of upper and lower case.  Valid types include
             xGE:  General m x n matrix
             xGB:  General banded matrix
             xPO:  Symmetric positive definite, 2-D storage
             xPP:  Symmetric positive definite packed
             xPB:  Symmetric positive definite banded
             xSY:  Symmetric indefinite, 2-D storage
             xSP:  Symmetric indefinite packed
             xSB:  Symmetric indefinite banded
             xTR:  Triangular
             xTP:  Triangular packed
             xTB:  Triangular banded
             xQR:  General m x n matrix
             xLQ:  General m x n matrix
             xQL:  General m x n matrix
             xRQ:  General m x n matrix
          where the leading character indicates the precision.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em X\+T\+Y\+P\+E} & \begin{DoxyVerb}          XTYPE is CHARACTER*1
          Specifies how the exact solution X will be determined:
          = 'N':  New solution; generate a random X.
          = 'C':  Computed; use value of X on entry.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          matrix A is stored, if A is symmetric.
          = 'U':  Upper triangular
          = 'L':  Lower triangular\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+A\+N\+S} & \begin{DoxyVerb}          TRANS is CHARACTER*1
          Specifies the operation applied to the matrix A.
          = 'N':  System is  A * x = b
          = 'T':  System is  A'* x = b
          = 'C':  System is  A'* x = b\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number or rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+L} & \begin{DoxyVerb}          KL is INTEGER
          Used only if A is a band matrix; specifies the number of
          subdiagonals of A if A is a general band matrix or if A is
          symmetric or triangular and UPLO = 'L'; specifies the number
          of superdiagonals of A if A is symmetric or triangular and
          UPLO = 'U'.  0 <= KL <= M-1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+U} & \begin{DoxyVerb}          KU is INTEGER
          Used only if A is a general band matrix or if A is
          triangular.

          If PATH = xGB, specifies the number of superdiagonals of A,
          and 0 <= KU <= N-1.

          If PATH = xTR, xTP, or xTB, specifies whether or not the
          matrix has unit diagonal:
          = 1:  matrix has non-unit diagonal (default)
          = 2:  matrix has unit diagonal\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+R\+H\+S} & \begin{DoxyVerb}          NRHS is INTEGER
          The number of right hand side vectors in the system A*X = B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The test matrix whose type is given by PATH.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.
          If PATH = xGB, LDA >= KL+KU+1.
          If PATH = xPB, xSB, xHB, or xTB, LDA >= KL+1.
          Otherwise, LDA >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em X} & \begin{DoxyVerb}          X is or output) REAL array, dimension(LDX,NRHS)
          On entry, if XTYPE = 'C' (for 'Computed'), then X contains
          the exact solution to the system of linear equations.
          On exit, if XTYPE = 'N' (for 'New'), then X is initialized
          with random values.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+X} & \begin{DoxyVerb}          LDX is INTEGER
          The leading dimension of the array X.  If TRANS = 'N',
          LDX >= max(1,N); if TRANS = 'T', LDX >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,NRHS)
          The right hand side vector(s) for the system of equations,
          computed from B = op(A) * X, where op(A) is determined by
          TRANS.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  If TRANS = 'N',
          LDB >= max(1,M); if TRANS = 'T', LDB >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          The seed vector for the random number generator (used in
          SLATMS).  Modified on exit.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga9540564c76aed17bc8b26a879ee5ca46}{}\index{real@{real}!slatb9@{slatb9}}
\index{slatb9@{slatb9}!real@{real}}
\subsubsection[{slatb9}]{\setlength{\rightskip}{0pt plus 5cm}subroutine slatb9 (
\begin{DoxyParamCaption}
\item[{character$\ast$3}]{P\+A\+T\+H, }
\item[{integer}]{I\+M\+A\+T, }
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{N, }
\item[{character}]{T\+Y\+P\+E, }
\item[{integer}]{K\+L\+A, }
\item[{integer}]{K\+U\+A, }
\item[{integer}]{K\+L\+B, }
\item[{integer}]{K\+U\+B, }
\item[{real}]{A\+N\+O\+R\+M, }
\item[{real}]{B\+N\+O\+R\+M, }
\item[{integer}]{M\+O\+D\+E\+A, }
\item[{integer}]{M\+O\+D\+E\+B, }
\item[{real}]{C\+N\+D\+N\+M\+A, }
\item[{real}]{C\+N\+D\+N\+M\+B, }
\item[{character}]{D\+I\+S\+T\+A, }
\item[{character}]{D\+I\+S\+T\+B}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga9540564c76aed17bc8b26a879ee5ca46}


{\bfseries S\+L\+A\+T\+B9} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SLATB9 sets parameters for the matrix generator based on the type of
 matrix to be generated.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em P\+A\+T\+H} & \begin{DoxyVerb}          PATH is CHARACTER*3
          The LAPACK path name.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+M\+A\+T} & \begin{DoxyVerb}          IMAT is INTEGER
          An integer key describing which matrix to generate for this
          path.
          = 1:   A: diagonal, B: upper triangular
          = 2:   A: upper triangular, B: upper triangular
          = 3:   A: lower triangular, B: upper triangular
          Else:  A: general dense, B: general dense\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows in the matrix to be generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns in the matrix to be generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em T\+Y\+P\+E} & \begin{DoxyVerb}          TYPE is CHARACTER*1
          The type of the matrix to be generated:
          = 'S':  symmetric matrix;
          = 'P':  symmetric positive (semi)definite matrix;
          = 'N':  nonsymmetric matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+L\+A} & \begin{DoxyVerb}          KLA is INTEGER
          The lower band width of the matrix to be generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+U\+A} & \begin{DoxyVerb}          KUA is INTEGER
          The upper band width of the matrix to be generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+L\+B} & \begin{DoxyVerb}          KLB is INTEGER
          The lower band width of the matrix to be generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em K\+U\+B} & \begin{DoxyVerb}          KUA is INTEGER
          The upper band width of the matrix to be generated.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+N\+O\+R\+M} & \begin{DoxyVerb}          ANORM is REAL
          The desired norm of the matrix to be generated.  The diagonal
          matrix of singular values or eigenvalues is scaled by this
          value.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+N\+O\+R\+M} & \begin{DoxyVerb}          BNORM is REAL
          The desired norm of the matrix to be generated.  The diagonal
          matrix of singular values or eigenvalues is scaled by this
          value.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em M\+O\+D\+E\+A} & \begin{DoxyVerb}          MODEA is INTEGER
          A key indicating how to choose the vector of eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em M\+O\+D\+E\+B} & \begin{DoxyVerb}          MODEB is INTEGER
          A key indicating how to choose the vector of eigenvalues.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C\+N\+D\+N\+M\+A} & \begin{DoxyVerb}          CNDNMA is REAL
          The desired condition number.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C\+N\+D\+N\+M\+B} & \begin{DoxyVerb}          CNDNMB is REAL
          The desired condition number.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+I\+S\+T\+A} & \begin{DoxyVerb}          DISTA is CHARACTER*1
          The type of distribution to be used by the random number
          generator.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+I\+S\+T\+B} & \begin{DoxyVerb}          DISTB is CHARACTER*1
          The type of distribution to be used by the random number
          generator.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gae46d8275d9069151d2cf111296204a54}{}\index{real@{real}!slatm4@{slatm4}}
\index{slatm4@{slatm4}!real@{real}}
\subsubsection[{slatm4}]{\setlength{\rightskip}{0pt plus 5cm}subroutine slatm4 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{integer}]{N, }
\item[{integer}]{N\+Z1, }
\item[{integer}]{N\+Z2, }
\item[{integer}]{I\+S\+I\+G\+N, }
\item[{real}]{A\+M\+A\+G\+N, }
\item[{real}]{R\+C\+O\+N\+D, }
\item[{real}]{T\+R\+I\+A\+N\+G, }
\item[{integer}]{I\+D\+I\+S\+T, }
\item[{integer, dimension( 4 )}]{I\+S\+E\+E\+D, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A}
\end{DoxyParamCaption}
)}\label{group__single__eig_gae46d8275d9069151d2cf111296204a54}


{\bfseries S\+L\+A\+T\+M4} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SLATM4 generates basic square matrices, which may later be
 multiplied by others in order to produce test matrices.  It is
 intended mainly to be used to test the generalized eigenvalue
 routines.

 It first generates the diagonal and (possibly) subdiagonal,
 according to the value of ITYPE, NZ1, NZ2, ISIGN, AMAGN, and RCOND.
 It then fills in the upper triangle with random numbers, if TRIANG is
 non-zero.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          The "type" of matrix on the diagonal and sub-diagonal.
          If ITYPE < 0, then type abs(ITYPE) is generated and then
             swapped end for end (A(I,J) := A'(N-J,N-I).)  See also
             the description of AMAGN and ISIGN.

          Special types:
          = 0:  the zero matrix.
          = 1:  the identity.
          = 2:  a transposed Jordan block.
          = 3:  If N is odd, then a k+1 x k+1 transposed Jordan block
                followed by a k x k identity block, where k=(N-1)/2.
                If N is even, then k=(N-2)/2, and a zero diagonal entry
                is tacked onto the end.

          Diagonal types.  The diagonal consists of NZ1 zeros, then
             k=N-NZ1-NZ2 nonzeros.  The subdiagonal is zero.  ITYPE
             specifies the nonzero diagonal entries as follows:
          = 4:  1, ..., k
          = 5:  1, RCOND, ..., RCOND
          = 6:  1, ..., 1, RCOND
          = 7:  1, a, a^2, ..., a^(k-1)=RCOND
          = 8:  1, 1-d, 1-2*d, ..., 1-(k-1)*d=RCOND
          = 9:  random numbers chosen from (RCOND,1)
          = 10: random numbers with distribution IDIST (see SLARND.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+Z1} & \begin{DoxyVerb}          NZ1 is INTEGER
          If abs(ITYPE) > 3, then the first NZ1 diagonal entries will
          be zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N\+Z2} & \begin{DoxyVerb}          NZ2 is INTEGER
          If abs(ITYPE) > 3, then the last NZ2 diagonal entries will
          be zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+S\+I\+G\+N} & \begin{DoxyVerb}          ISIGN is INTEGER
          = 0: The sign of the diagonal and subdiagonal entries will
               be left unchanged.
          = 1: The diagonal and subdiagonal entries will have their
               sign changed at random.
          = 2: If ITYPE is 2 or 3, then the same as ISIGN=1.
               Otherwise, with probability 0.5, odd-even pairs of
               diagonal entries A(2*j-1,2*j-1), A(2*j,2*j) will be
               converted to a 2x2 block by pre- and post-multiplying
               by distinct random orthogonal rotations.  The remaining
               diagonal entries will have their sign changed at random.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+M\+A\+G\+N} & \begin{DoxyVerb}          AMAGN is REAL
          The diagonal and subdiagonal entries will be multiplied by
          AMAGN.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em R\+C\+O\+N\+D} & \begin{DoxyVerb}          RCOND is REAL
          If abs(ITYPE) > 4, then the smallest diagonal entry will be
          entry will be RCOND.  RCOND must be between 0 and 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+R\+I\+A\+N\+G} & \begin{DoxyVerb}          TRIANG is REAL
          The entries above the diagonal will be random numbers with
          magnitude bounded by TRIANG (i.e., random numbers multiplied
          by TRIANG.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em I\+D\+I\+S\+T} & \begin{DoxyVerb}          IDIST is INTEGER
          Specifies the type of distribution to be used to generate a
          random matrix.
          = 1:  UNIFORM( 0, 1 )
          = 2:  UNIFORM( -1, 1 )
          = 3:  NORMAL ( 0, 1 )\end{DoxyVerb}
\\
\hline
\mbox{\tt in,out}  & {\em I\+S\+E\+E\+D} & \begin{DoxyVerb}          ISEED is INTEGER array, dimension (4)
          On entry ISEED specifies the seed of the random number
          generator.  The values of ISEED are changed on exit, and can
          be used in the next call to SLATM4 to continue the same
          random number sequence.
          Note: ISEED(4) should be odd, for the random number generator
          used at present.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          Array to be computed.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          Leading dimension of A.  Must be at least 1 and at least N.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga895e457eb85e862c2a2caa9f12c060e2}{}\index{real@{real}!slctes@{slctes}}
\index{slctes@{slctes}!real@{real}}
\subsubsection[{slctes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf logical} {\bf function} slctes (
\begin{DoxyParamCaption}
\item[{real}]{Z\+R, }
\item[{real}]{Z\+I, }
\item[{real}]{D}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga895e457eb85e862c2a2caa9f12c060e2}


{\bfseries S\+L\+C\+T\+E\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SLCTES returns .TRUE. if the eigenvalue (ZR/D) + sqrt(-1)*(ZI/D)
 is to be selected (specifically, in this subroutine, if the real
 part of the eigenvalue is negative), and otherwise it returns
 .FALSE..

 It is used by the test routine SDRGES to test whether the driver
 routine SGGES succesfully sorts eigenvalues.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Z\+R} & \begin{DoxyVerb}          ZR is REAL
          The numerator of the real part of a complex eigenvalue
          (ZR/D) + i*(ZI/D).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Z\+I} & \begin{DoxyVerb}          ZI is REAL
          The numerator of the imaginary part of a complex eigenvalue
          (ZR/D) + i*(ZI).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL
          The denominator part of a complex eigenvalue
          (ZR/D) + i*(ZI/D).\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gabe65b08f429234a57b6b3253ec7da694}{}\index{real@{real}!slctsx@{slctsx}}
\index{slctsx@{slctsx}!real@{real}}
\subsubsection[{slctsx}]{\setlength{\rightskip}{0pt plus 5cm}{\bf logical} {\bf function} slctsx (
\begin{DoxyParamCaption}
\item[{real}]{A\+R, }
\item[{real}]{A\+I, }
\item[{real}]{B\+E\+T\+A}
\end{DoxyParamCaption}
)}\label{group__single__eig_gabe65b08f429234a57b6b3253ec7da694}


{\bfseries S\+L\+C\+T\+S\+X} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} This function is used to determine what eigenvalues will be
 selected.  If this is part of the test driver SDRGSX, do not
 change the code UNLESS you are testing input examples and not
 using the built-in examples.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em A\+R} & \begin{DoxyVerb}          AR is REAL
          The numerator of the real part of a complex eigenvalue
          (AR/BETA) + i*(AI/BETA).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+I} & \begin{DoxyVerb}          AI is REAL
          The numerator of the imaginary part of a complex eigenvalue
          (AR/BETA) + i*(AI).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B\+E\+T\+A} & \begin{DoxyVerb}          BETA is REAL
          The denominator part of a complex eigenvalue
          (AR/BETA) + i*(AI/BETA).\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga20ea4c39bd0bee5f869b9f9131c0c53d}{}\index{real@{real}!slsets@{slsets}}
\index{slsets@{slsets}!real@{real}}
\subsubsection[{slsets}]{\setlength{\rightskip}{0pt plus 5cm}subroutine slsets (
\begin{DoxyParamCaption}
\item[{integer}]{M, }
\item[{integer}]{P, }
\item[{integer}]{N, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{real, dimension( lda, $\ast$ )}]{A\+F, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{real, dimension( ldb, $\ast$ )}]{B\+F, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( $\ast$ )}]{C, }
\item[{real, dimension( $\ast$ )}]{C\+F, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{D\+F, }
\item[{real, dimension( $\ast$ )}]{X, }
\item[{real, dimension( lwork )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga20ea4c39bd0bee5f869b9f9131c0c53d}


{\bfseries S\+L\+S\+E\+T\+S} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SLSETS tests SGGLSE - a subroutine for solving linear equality
 constrained least square problem (LSE).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix A.  M >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em P} & \begin{DoxyVerb}          P is INTEGER
          The number of rows of the matrix B.  P >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrices A and B.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA,N)
          The M-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em A\+F} & \begin{DoxyVerb}          AF is REAL array, dimension (LDA,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the arrays A, AF, Q and R.
          LDA >= max(M,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB,N)
          The P-by-N matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em B\+F} & \begin{DoxyVerb}          BF is REAL array, dimension (LDB,N)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the arrays B, BF, V and S.
          LDB >= max(P,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em C} & \begin{DoxyVerb}          C is REAL array, dimension( M )
          the vector C in the LSE problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em C\+F} & \begin{DoxyVerb}          CF is REAL array, dimension( M )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension( P )
          the vector D in the LSE problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em D\+F} & \begin{DoxyVerb}          DF is REAL array, dimension( P )\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em X} & \begin{DoxyVerb}          X is REAL array, dimension( N )
          solution vector X in the LSE problem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The dimension of the array WORK.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+W\+O\+R\+K} & \begin{DoxyVerb}          RWORK is REAL array, dimension (M)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The test ratios:
            RESULT(1) = norm( A*x - c )/ norm(A)*norm(X)*EPS
            RESULT(2) = norm( B*x - d )/ norm(B)*norm(X)*EPS\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga117c87e8771c05b0d10909b2a7176979}{}\index{real@{real}!sort01@{sort01}}
\index{sort01@{sort01}!real@{real}}
\subsubsection[{sort01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sort01 (
\begin{DoxyParamCaption}
\item[{character}]{R\+O\+W\+C\+O\+L, }
\item[{integer}]{M, }
\item[{integer}]{N, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+I\+D}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga117c87e8771c05b0d10909b2a7176979}


{\bfseries S\+O\+R\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SORT01 checks that the matrix U is orthogonal by computing the ratio

    RESID = norm( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = norm( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 Alternatively, if there isn't sufficient workspace to form
 I - U*U' or I - U'*U, the ratio is computed as

    RESID = abs( I - U*U' ) / ( n * EPS ), if ROWCOL = 'R',
 or
    RESID = abs( I - U'*U ) / ( m * EPS ), if ROWCOL = 'C'.

 where EPS is the machine precision.  ROWCOL is used only if m = n;
 if m > n, ROWCOL is assumed to be 'C', and if m < n, ROWCOL is
 assumed to be 'R'.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em R\+O\+W\+C\+O\+L} & \begin{DoxyVerb}          ROWCOL is CHARACTER
          Specifies whether the rows or columns of U should be checked
          for orthogonality.  Used only if M = N.
          = 'R':  Check for orthogonal rows of U
          = 'C':  Check for orthogonal columns of U\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of rows of the matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The number of columns of the matrix U.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU,N)
          The orthogonal matrix U.  U is checked for orthogonal columns
          if m > n or if m = n and ROWCOL = 'C'.  U is checked for
          orthogonal rows if m < n or if m = n and ROWCOL = 'R'.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of the array U.  LDU >= max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*(N+1) if ROWCOL = 'C' or M*(M+1) if
          ROWCOL = 'R', but the test will be done even if LWORK is 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+I\+D} & \begin{DoxyVerb}          RESID is REAL
          RESID = norm( I - U * U' ) / ( n * EPS ), if ROWCOL = 'R', or
          RESID = norm( I - U' * U ) / ( m * EPS ), if ROWCOL = 'C'.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gacdb40a265d764f2ce962040de230c2f1}{}\index{real@{real}!sort03@{sort03}}
\index{sort03@{sort03}!real@{real}}
\subsubsection[{sort03}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sort03 (
\begin{DoxyParamCaption}
\item[{character$\ast$( $\ast$ )}]{R\+C, }
\item[{integer}]{M\+U, }
\item[{integer}]{M\+V, }
\item[{integer}]{N, }
\item[{integer}]{K, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+W\+O\+R\+K, }
\item[{real}]{R\+E\+S\+U\+L\+T, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_gacdb40a265d764f2ce962040de230c2f1}


{\bfseries S\+O\+R\+T03} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SORT03 compares two orthogonal matrices U and V to see if their
 corresponding rows or columns span the same spaces.  The rows are
 checked if RC = 'R', and the columns are checked if RC = 'C'.

 RESULT is the maximum of

    | V*V' - I | / ( MV ulp ), if RC = 'R', or

    | V'*V - I | / ( MV ulp ), if RC = 'C',

 and the maximum over rows (or columns) 1 to K of

    | U(i) - S*V(i) |/ ( N ulp )

 where S is +-1 (chosen to minimize the expression), U(i) is the i-th
 row (column) of U, and V(i) is the i-th row (column) of V.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em R\+C} & \begin{DoxyVerb}          RC is CHARACTER*1
          If RC = 'R' the rows of U and V are to be compared.
          If RC = 'C' the columns of U and V are to be compared.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+U} & \begin{DoxyVerb}          MU is INTEGER
          The number of rows of U if RC = 'R', and the number of
          columns if RC = 'C'.  If MU = 0 SORT03 does nothing.
          MU must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M\+V} & \begin{DoxyVerb}          MV is INTEGER
          The number of rows of V if RC = 'R', and the number of
          columns if RC = 'C'.  If MV = 0 SORT03 does nothing.
          MV must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          If RC = 'R', the number of columns in the matrices U and V,
          and if RC = 'C', the number of rows in U and V.  If N = 0
          SORT03 does nothing.  N must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K} & \begin{DoxyVerb}          K is INTEGER
          The number of rows or columns of U and V to compare.
          0 <= K <= max(MU,MV).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU,N)
          The first matrix to compare.  If RC = 'R', U is MU by N, and
          if RC = 'C', U is N by MU.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  If RC = 'R', LDU >= max(1,MU),
          and if RC = 'C', LDU >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension (LDV,N)
          The second matrix to compare.  If RC = 'R', V is MV by N, and
          if RC = 'C', V is N by MV.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  If RC = 'R', LDV >= max(1,MV),
          and if RC = 'C', LDV >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LWORK)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+W\+O\+R\+K} & \begin{DoxyVerb}          LWORK is INTEGER
          The length of the array WORK.  For best performance, LWORK
          should be at least N*N if RC = 'C' or M*M if RC = 'R', but
          the tests will be done even if LWORK is 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL
          The value computed by the test described above.  RESULT is
          limited to 1/ulp to avoid overflow.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          0  indicates a successful exit
          -k indicates the k-th parameter had an illegal value\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gaf79abbc26c3852094a0788e7a5a67daf}{}\index{real@{real}!ssbt21@{ssbt21}}
\index{ssbt21@{ssbt21}!real@{real}}
\subsubsection[{ssbt21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine ssbt21 (
\begin{DoxyParamCaption}
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+A, }
\item[{integer}]{K\+S, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gaf79abbc26c3852094a0788e7a5a67daf}


{\bfseries S\+S\+B\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSBT21  generally checks a decomposition of the form

         A = U S U'

 where ' means transpose, A is symmetric banded, U is
 orthogonal, and S is diagonal (if KS=0) or symmetric
 tridiagonal (if KS=1).

 Specifically:

         RESULT(1) = | A - U S U' | / ( |A| n ulp ) *andC>         RESULT(2) = | I - UU' | / ( n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, SSBT21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+A} & \begin{DoxyVerb}          KA is INTEGER
          The bandwidth of the matrix A.  It must be at least zero.  If
          it is larger than N-1, then max( 0, N-1 ) will be used.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+S} & \begin{DoxyVerb}          KS is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least min( KA, N-1 ).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KS=0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, N)
          The orthogonal matrix in the decomposition, expressed as a
          dense matrix (i.e., not as a product of Householder
          transformations, Givens transformations, etc.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N**2+N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga2e1600d5ba10895a2ed94275d190b187}{}\index{real@{real}!ssgt01@{ssgt01}}
\index{ssgt01@{ssgt01}!real@{real}}
\subsubsection[{ssgt01}]{\setlength{\rightskip}{0pt plus 5cm}subroutine ssgt01 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( ldb, $\ast$ )}]{B, }
\item[{integer}]{L\+D\+B, }
\item[{real, dimension( ldz, $\ast$ )}]{Z, }
\item[{integer}]{L\+D\+Z, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( $\ast$ )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga2e1600d5ba10895a2ed94275d190b187}


{\bfseries S\+S\+G\+T01} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSGT01 checks a decomposition of the form

    A Z   =  B Z D or
    A B Z =  Z D or
    B A Z =  Z D

 where A is a symmetric matrix, B is
 symmetric positive definite, Z is orthogonal, and D is diagonal.

 One of the following test ratios is computed:

 ITYPE = 1:  RESULT(1) = | A Z - B Z D | / ( |A| |Z| n ulp )

 ITYPE = 2:  RESULT(1) = | A B Z - Z D | / ( |A| |Z| n ulp )

 ITYPE = 3:  RESULT(1) = | B A Z - Z D | / ( |A| |Z| n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          The form of the symmetric generalized eigenproblem.
          = 1:  A*z = (lambda)*B*z
          = 2:  A*B*z = (lambda)*z
          = 3:  B*A*z = (lambda)*z\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER*1
          Specifies whether the upper or lower triangular part of the
          symmetric matrices A and B is stored.
          = 'U':  Upper triangular
          = 'L':  Lower triangular\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The order of the matrix A.  N >= 0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of eigenvalues found.  0 <= M <= N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          The original symmetric matrix A.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of the array A.  LDA >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (LDB, N)
          The original symmetric positive definite matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+B} & \begin{DoxyVerb}          LDB is INTEGER
          The leading dimension of the array B.  LDB >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Z} & \begin{DoxyVerb}          Z is REAL array, dimension (LDZ, M)
          The computed eigenvectors of the generalized eigenproblem.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+Z} & \begin{DoxyVerb}          LDZ is INTEGER
          The leading dimension of the array Z.  LDZ >= max(1,N).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension (M)
          The computed eigenvalues of the generalized eigenproblem.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N*N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (1)
          The test ratio as described above.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga9051201041524e344b189e8504011c6f}{}\index{real@{real}!sslect@{sslect}}
\index{sslect@{sslect}!real@{real}}
\subsubsection[{sslect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf logical} {\bf function} sslect (
\begin{DoxyParamCaption}
\item[{real}]{Z\+R, }
\item[{real}]{Z\+I}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga9051201041524e344b189e8504011c6f}


{\bfseries S\+S\+L\+E\+C\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSLECT returns .TRUE. if the eigenvalue ZR+sqrt(-1)*ZI is to be
 selected, and otherwise it returns .FALSE.
 It is used by SCHK41 to test if SGEES succesfully sorts eigenvalues,
 and by SCHK43 to test if SGEESX succesfully sorts eigenvalues.

 The common block /SSLCT/ controls how eigenvalues are selected.
 If SELOPT = 0, then SSLECT return .TRUE. when ZR is less than zero,
 and .FALSE. otherwise.
 If SELOPT is at least 1, SSLECT returns SELVAL(SELOPT) and adds 1
 to SELOPT, cycling back to 1 at SELMAX.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Z\+R} & \begin{DoxyVerb}          ZR is REAL
          The real part of a complex eigenvalue ZR + i*ZI.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em Z\+I} & \begin{DoxyVerb}          ZI is REAL
          The imaginary part of a complex eigenvalue ZR + i*ZI.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gad6ad2fe75e582845dea427676497bbca}{}\index{real@{real}!sspt21@{sspt21}}
\index{sspt21@{sspt21}!real@{real}}
\subsubsection[{sspt21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sspt21 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{real, dimension( $\ast$ )}]{A\+P, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( $\ast$ )}]{V\+P, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gad6ad2fe75e582845dea427676497bbca}


{\bfseries S\+S\+P\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSPT21  generally checks a decomposition of the form

         A = U S U'

 where ' means transpose, A is symmetric (stored in packed format), U
 is orthogonal, and S is diagonal (if KBAND=0) or symmetric
 tridiagonal (if KBAND=1).  If ITYPE=1, then U is represented as a
 dense matrix, otherwise the U is expressed as a product of
 Householder transformations, whose vectors are stored in the array
 "V" and whose scaling constants are in "TAU"; we shall use the
 letter "V" to refer to the product of Householder transformations
 (which should be equal to U).

 Specifically, if ITYPE=1, then:

         RESULT(1) = | A - U S U' | / ( |A| n ulp ) *andC>         RESULT(2) = | I - UU' | / ( n ulp )

 If ITYPE=2, then:

         RESULT(1) = | A - V S V' | / ( |A| n ulp )

 If ITYPE=3, then:

         RESULT(1) = | I - VU' | / ( n ulp )

 Packed storage means that, for example, if UPLO='U', then the columns
 of the upper triangle of A are stored one after another, so that
 A(1,j+1) immediately follows A(j,j) in the array AP.  Similarly, if
 UPLO='L', then the columns of the lower triangle of A are stored one
 after another in AP, so that A(j+1,j+1) immediately follows A(n,j)
 in the array AP.  This means that A(i,j) is stored in:

    AP( i + j*(j-1)/2 )                 if UPLO='U'

    AP( i + (2*n-j)*(j-1)/2 )           if UPLO='L'

 The array VP bears the same relation to the matrix V that A does to
 AP.

 For ITYPE > 1, the transformation U is expressed as a product
 of Householder transformations:

    If UPLO='U', then  V = H(n-1)...H(1),  where

        H(j) = I  -  tau(j) v(j) v(j)'

    and the first j-1 elements of v(j) are stored in V(1:j-1,j+1),
    (i.e., VP( j*(j+1)/2 + 1 : j*(j+1)/2 + j-1 ) ),
    the j-th element is 1, and the last n-j elements are 0.

    If UPLO='L', then  V = H(1)...H(n-1),  where

        H(j) = I  -  tau(j) v(j) v(j)'

    and the first j elements of v(j) are 0, the (j+1)-st is 1, and the
    (j+2)-nd through n-th elements are stored in V(j+2:n,j) (i.e.,
    in VP( (2*n-j)*(j-1)/2 + j+2 : (2*n-j)*(j-1)/2 + n ) .)\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC>             RESULT(2) = | I - UU' | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V' | / ( |A| n ulp )

          3: U expressed both as a dense orthogonal matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - VU' | / ( n ulp )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER
          If UPLO='U', AP and VP are considered to contain the upper
          triangle of A and V.
          If UPLO='L', AP and VP are considered to contain the lower
          triangle of A and V.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, SSPT21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+P} & \begin{DoxyVerb}          AP is REAL array, dimension (N*(N+1)/2)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and contains the columns of just the upper
          triangle (UPLO='U') or only the lower triangle (UPLO='L'),
          packed one after another.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V\+P} & \begin{DoxyVerb}          VP is REAL array, dimension (N*(N+1)/2)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the orthogonal matrix
          in the decomposition, as described in purpose.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is REAL array, dimension (N)
          If ITYPE >= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE < 2, then TAU is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N**2+N)
          Workspace.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga455b022ce67894011ee08a1a4b0eb1ad}{}\index{real@{real}!sstech@{sstech}}
\index{sstech@{sstech}!real@{real}}
\subsubsection[{sstech}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sstech (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{real, dimension( $\ast$ )}]{A, }
\item[{real, dimension( $\ast$ )}]{B, }
\item[{real, dimension( $\ast$ )}]{E\+I\+G, }
\item[{real}]{T\+O\+L, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga455b022ce67894011ee08a1a4b0eb1ad}


{\bfseries S\+S\+T\+E\+C\+H} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    Let T be the tridiagonal matrix with diagonal entries A(1) ,...,
    A(N) and offdiagonal entries B(1) ,..., B(N-1)).  SSTECH checks to
    see if EIG(1) ,..., EIG(N) are indeed accurate eigenvalues of T.
    It does this by expanding each EIG(I) into an interval
    [SVD(I) - EPS, SVD(I) + EPS], merging overlapping intervals if
    any, and using Sturm sequences to count and verify whether each
    resulting interval has the correct number of eigenvalues (using
    SSTECT).  Here EPS = TOL*MACHEPS*MAXEIG, where MACHEPS is the
    machine precision and MAXEIG is the absolute value of the largest
    eigenvalue. If each interval contains the correct number of
    eigenvalues, INFO = 0 is returned, otherwise INFO is the index of
    the first eigenvalue in the first bad interval.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of the tridiagonal matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (N)
          The diagonal entries of the tridiagonal matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (N-1)
          The offdiagonal entries of the tridiagonal matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E\+I\+G} & \begin{DoxyVerb}          EIG is REAL array, dimension (N)
          The purported eigenvalues to be checked.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+O\+L} & \begin{DoxyVerb}          TOL is REAL
          Error tolerance for checking, a multiple of the
          machine precision.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          0  if the eigenvalues are all correct (to within
             1 +- TOL*MACHEPS*MAXEIG)
          >0 if the interval containing the INFO-th eigenvalue
             contains the incorrect number of eigenvalues.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga1f72bc4c21b1b37d449ec5911e36d7d1}{}\index{real@{real}!sstect@{sstect}}
\index{sstect@{sstect}!real@{real}}
\subsubsection[{sstect}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sstect (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{real, dimension( $\ast$ )}]{A, }
\item[{real, dimension( $\ast$ )}]{B, }
\item[{real}]{S\+H\+I\+F\+T, }
\item[{integer}]{N\+U\+M}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga1f72bc4c21b1b37d449ec5911e36d7d1}


{\bfseries S\+S\+T\+E\+C\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}    SSTECT counts the number NUM of eigenvalues of a tridiagonal
    matrix T which are less than or equal to SHIFT. T has
    diagonal entries A(1), ... , A(N), and offdiagonal entries
    B(1), ..., B(N-1).
    See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
    Matrix", Report CS41, Computer Science Dept., Stanford
    University, July 21, 1966\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of the tridiagonal matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (N)
          The diagonal entries of the tridiagonal matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em B} & \begin{DoxyVerb}          B is REAL array, dimension (N-1)
          The offdiagonal entries of the tridiagonal matrix T.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+H\+I\+F\+T} & \begin{DoxyVerb}          SHIFT is REAL
          The shift, used as described under Purpose.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+U\+M} & \begin{DoxyVerb}          NUM is INTEGER
          The number of eigenvalues of T less than or equal
          to SHIFT.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga7e0e860e3759067b5e3ace2787d8415d}{}\index{real@{real}!sstt21@{sstt21}}
\index{sstt21@{sstt21}!real@{real}}
\subsubsection[{sstt21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sstt21 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{real, dimension( $\ast$ )}]{A\+D, }
\item[{real, dimension( $\ast$ )}]{A\+E, }
\item[{real, dimension( $\ast$ )}]{S\+D, }
\item[{real, dimension( $\ast$ )}]{S\+E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga7e0e860e3759067b5e3ace2787d8415d}


{\bfseries S\+S\+T\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSTT21 checks a decomposition of the form

    A = U S U'

 where ' means transpose, A is symmetric tridiagonal, U is orthogonal,
 and S is diagonal (if KBAND=0) or symmetric tridiagonal (if KBAND=1).
 Two tests are performed:

    RESULT(1) = | A - U S U' | / ( |A| n ulp )

    RESULT(2) = | I - UU' | / ( n ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, SSTT21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+D} & \begin{DoxyVerb}          AD is REAL array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be symmetric tridiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+E} & \begin{DoxyVerb}          AE is REAL array, dimension (N-1)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be symmetric tridiagonal.  AE(1) is the (1,2)
          and (2,1) element, AE(2) is the (2,3) and (3,2) element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+D} & \begin{DoxyVerb}          SD is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+E} & \begin{DoxyVerb}          SE is REAL array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is the
          (1,2) and (2,1) element, SE(2) is the (2,3) and (3,2)
          element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, N)
          The orthogonal matrix in the decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (N*(N+1))\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga939255a845788e786a4a5b786f878a22}{}\index{real@{real}!sstt22@{sstt22}}
\index{sstt22@{sstt22}!real@{real}}
\subsubsection[{sstt22}]{\setlength{\rightskip}{0pt plus 5cm}subroutine sstt22 (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{real, dimension( $\ast$ )}]{A\+D, }
\item[{real, dimension( $\ast$ )}]{A\+E, }
\item[{real, dimension( $\ast$ )}]{S\+D, }
\item[{real, dimension( $\ast$ )}]{S\+E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldwork, $\ast$ )}]{W\+O\+R\+K, }
\item[{integer}]{L\+D\+W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga939255a845788e786a4a5b786f878a22}


{\bfseries S\+S\+T\+T22} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSTT22  checks a set of M eigenvalues and eigenvectors,

     A U = U S

 where A is symmetric tridiagonal, the columns of U are orthogonal,
 and S is diagonal (if KBAND=0) or symmetric tridiagonal (if KBAND=1).
 Two tests are performed:

    RESULT(1) = | U' A U - S | / ( |A| m ulp )

    RESULT(2) = | I - U'U | / ( m ulp )\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, SSTT22 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em M} & \begin{DoxyVerb}          M is INTEGER
          The number of eigenpairs to check.  If it is zero, SSTT22
          does nothing.  It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix S.  It may only be zero or one.
          If zero, then S is diagonal, and SE is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+D} & \begin{DoxyVerb}          AD is REAL array, dimension (N)
          The diagonal of the original (unfactored) matrix A.  A is
          assumed to be symmetric tridiagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+E} & \begin{DoxyVerb}          AE is REAL array, dimension (N)
          The off-diagonal of the original (unfactored) matrix A.  A
          is assumed to be symmetric tridiagonal.  AE(1) is ignored,
          AE(2) is the (1,2) and (2,1) element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+D} & \begin{DoxyVerb}          SD is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix S.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+E} & \begin{DoxyVerb}          SE is REAL array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix S.
          Not referenced if KBSND=0.  If KBAND=1, then AE(1) is
          ignored, SE(2) is the (1,2) and (2,1) element, etc.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, N)
          The orthogonal matrix in the decomposition.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (LDWORK, M+1)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+W\+O\+R\+K} & \begin{DoxyVerb}          LDWORK is INTEGER
          The leading dimension of WORK.  LDWORK must be at least
          max(1,M).\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga27173aa839453594dfc1a893dff10f60}{}\index{real@{real}!ssvdch@{ssvdch}}
\index{ssvdch@{ssvdch}!real@{real}}
\subsubsection[{ssvdch}]{\setlength{\rightskip}{0pt plus 5cm}subroutine ssvdch (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{real, dimension( $\ast$ )}]{S, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( $\ast$ )}]{S\+V\+D, }
\item[{real}]{T\+O\+L, }
\item[{integer}]{I\+N\+F\+O}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga27173aa839453594dfc1a893dff10f60}


{\bfseries S\+S\+V\+D\+C\+H} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSVDCH checks to see if SVD(1) ,..., SVD(N) are accurate singular
 values of the bidiagonal matrix B with diagonal entries
 S(1) ,..., S(N) and superdiagonal entries E(1) ,..., E(N-1)).
 It does this by expanding each SVD(I) into an interval
 [SVD(I) * (1-EPS) , SVD(I) * (1+EPS)], merging overlapping intervals
 if any, and using Sturm sequences to count and verify whether each
 resulting interval has the correct number of singular values (using
 SSVDCT). Here EPS=TOL*MAX(N/10,1)*MACHEP, where MACHEP is the
 machine precision. The routine assumes the singular values are sorted
 with SVD(1) the largest and SVD(N) smallest.  If each interval
 contains the correct number of singular values, INFO = 0 is returned,
 otherwise INFO is the index of the first singular value in the first
 bad interval.\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension (N)
          The diagonal entries of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (N-1)
          The superdiagonal entries of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+V\+D} & \begin{DoxyVerb}          SVD is REAL array, dimension (N)
          The computed singular values to be checked.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+O\+L} & \begin{DoxyVerb}          TOL is REAL
          Error tolerance for checking, a multiplier of the
          machine precision.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em I\+N\+F\+O} & \begin{DoxyVerb}          INFO is INTEGER
          =0 if the singular values are all correct (to within
             1 +- TOL*MACHEPS)
          >0 if the interval containing the INFO-th singular value
             contains the incorrect number of singular values.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga1f89a00fd5baa9f3d801169211b98930}{}\index{real@{real}!ssvdct@{ssvdct}}
\index{ssvdct@{ssvdct}!real@{real}}
\subsubsection[{ssvdct}]{\setlength{\rightskip}{0pt plus 5cm}subroutine ssvdct (
\begin{DoxyParamCaption}
\item[{integer}]{N, }
\item[{real, dimension( $\ast$ )}]{S, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real}]{S\+H\+I\+F\+T, }
\item[{integer}]{N\+U\+M}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga1f89a00fd5baa9f3d801169211b98930}


{\bfseries S\+S\+V\+D\+C\+T} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSVDCT counts the number NUM of eigenvalues of a 2*N by 2*N
 tridiagonal matrix T which are less than or equal to SHIFT.  T is
 formed by putting zeros on the diagonal and making the off-diagonals
 equal to S(1), E(1), S(2), E(2), ... , E(N-1), S(N).  If SHIFT is
 positive, NUM is equal to N plus the number of singular values of a
 bidiagonal matrix B less than or equal to SHIFT.  Here B has diagonal
 entries S(1), ..., S(N) and superdiagonal entries E(1), ... E(N-1).
 If SHIFT is negative, NUM is equal to the number of singular values
 of B greater than or equal to -SHIFT.

 See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
 Matrix", Report CS41, Computer Science Dept., Stanford University,
 July 21, 1966\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The dimension of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S} & \begin{DoxyVerb}          S is REAL array, dimension (N)
          The diagonal entries of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array of dimension (N-1)
          The superdiagonal entries of the bidiagonal matrix B.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em S\+H\+I\+F\+T} & \begin{DoxyVerb}          SHIFT is REAL
          The shift, used as described under Purpose.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em N\+U\+M} & \begin{DoxyVerb}          NUM is INTEGER
          The number of eigenvalues of T less than or equal to SHIFT.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga8f56dead1fe2a44da7b5e261280a441e}{}\index{real@{real}!ssxt1@{ssxt1}}
\index{ssxt1@{ssxt1}!real@{real}}
\subsubsection[{ssxt1}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf function} ssxt1 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+J\+O\+B, }
\item[{real, dimension( $\ast$ )}]{D1, }
\item[{integer}]{N1, }
\item[{real, dimension( $\ast$ )}]{D2, }
\item[{integer}]{N2, }
\item[{real}]{A\+B\+S\+T\+O\+L, }
\item[{real}]{U\+L\+P, }
\item[{real}]{U\+N\+F\+L}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga8f56dead1fe2a44da7b5e261280a441e}


{\bfseries S\+S\+X\+T1} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSXT1  computes the difference between a set of eigenvalues.
 The result is returned as the function value.

 IJOB = 1:   Computes   max { min | D1(i)-D2(j) | }
                         i     j

 IJOB = 2:   Computes   max { min | D1(i)-D2(j) | /
                         i     j
                              ( ABSTOL + |D1(i)|*ULP ) }\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+J\+O\+B} & \begin{DoxyVerb}          IJOB is INTEGER
          Specifies the type of tests to be performed.  (See above.)\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D1} & \begin{DoxyVerb}          D1 is REAL array, dimension (N1)
          The first array.  D1 should be in increasing order, i.e.,
          D1(j) <= D1(j+1).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N1} & \begin{DoxyVerb}          N1 is INTEGER
          The length of D1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D2} & \begin{DoxyVerb}          D2 is REAL array, dimension (N2)
          The second array.  D2 should be in increasing order, i.e.,
          D2(j) <= D2(j+1).\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N2} & \begin{DoxyVerb}          N2 is INTEGER
          The length of D2.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em A\+B\+S\+T\+O\+L} & \begin{DoxyVerb}          ABSTOL is REAL
          The absolute tolerance, used as a measure of the error.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+L\+P} & \begin{DoxyVerb}          ULP is REAL
          Machine precision.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+N\+F\+L} & \begin{DoxyVerb}          UNFL is REAL
          The smallest positive number whose reciprocal does not
          overflow.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_gacd0abbe15d93a0180c975f8b2af5f801}{}\index{real@{real}!ssyt21@{ssyt21}}
\index{ssyt21@{ssyt21}!real@{real}}
\subsubsection[{ssyt21}]{\setlength{\rightskip}{0pt plus 5cm}subroutine ssyt21 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_gacd0abbe15d93a0180c975f8b2af5f801}


{\bfseries S\+S\+Y\+T21} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb} SSYT21 generally checks a decomposition of the form

    A = U S U'

 where ' means transpose, A is symmetric, U is orthogonal, and S is
 diagonal (if KBAND=0) or symmetric tridiagonal (if KBAND=1).

 If ITYPE=1, then U is represented as a dense matrix; otherwise U is
 expressed as a product of Householder transformations, whose vectors
 are stored in the array "V" and whose scaling constants are in "TAU".
 We shall use the letter "V" to refer to the product of Householder
 transformations (which should be equal to U).

 Specifically, if ITYPE=1, then:

    RESULT(1) = | A - U S U' | / ( |A| n ulp ) *andC>    RESULT(2) = | I - UU' | / ( n ulp )

 If ITYPE=2, then:

    RESULT(1) = | A - V S V' | / ( |A| n ulp )

 If ITYPE=3, then:

    RESULT(1) = | I - VU' | / ( n ulp )

 For ITYPE > 1, the transformation U is expressed as a product
 V = H(1)...H(n-2),  where H(j) = I  -  tau(j) v(j) v(j)' and each
 vector v(j) has its first j elements 0 and the remaining n-j elements
 stored in V(j+1:n,j).\end{DoxyVerb}
 
\end{DoxyParagraph}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em I\+T\+Y\+P\+E} & \begin{DoxyVerb}          ITYPE is INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC>             RESULT(2) = | I - UU' | / ( n ulp )

          2: U expressed as a product V of Housholder transformations:
             RESULT(1) = | A - V S V' | / ( |A| n ulp )

          3: U expressed both as a dense orthogonal matrix and
             as a product of Housholder transformations:
             RESULT(1) = | I - VU' | / ( n ulp )\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U\+P\+L\+O} & \begin{DoxyVerb}          UPLO is CHARACTER
          If UPLO='U', the upper triangle of A and V will be used and
          the (strictly) lower triangle will not be referenced.
          If UPLO='L', the lower triangle of A and V will be used and
          the (strictly) upper triangle will not be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em N} & \begin{DoxyVerb}          N is INTEGER
          The size of the matrix.  If it is zero, SSYT21 does nothing.
          It must be at least zero.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em K\+B\+A\+N\+D} & \begin{DoxyVerb}          KBAND is INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em \hyperlink{classA}{A}} & \begin{DoxyVerb}          A is REAL array, dimension (LDA, N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+A} & \begin{DoxyVerb}          LDA is INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em D} & \begin{DoxyVerb}          D is REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em E} & \begin{DoxyVerb}          E is REAL array, dimension (N-1)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is the (1,2) and (2,1) element, E(2) is the (2,3) and
          (3,2) element, etc.
          Not referenced if KBAND=0.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em U} & \begin{DoxyVerb}          U is REAL array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+U} & \begin{DoxyVerb}          LDU is INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em V} & \begin{DoxyVerb}          V is REAL array, dimension (LDV, N)
          If ITYPE=2 or 3, the columns of this array contain the
          Householder vectors used to describe the orthogonal matrix
          in the decomposition.  If UPLO='L', then the vectors are in
          the lower triangle, if UPLO='U', then in the upper
          triangle.
          *NOTE* If ITYPE=2 or 3, V is modified and restored.  The
          subdiagonal (if UPLO='L') or the superdiagonal (if UPLO='U')
          is set to one, and later reset to its original value, during
          the course of the calculation.
          If ITYPE=1, then it is neither referenced nor modified.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em L\+D\+V} & \begin{DoxyVerb}          LDV is INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.\end{DoxyVerb}
\\
\hline
\mbox{\tt in}  & {\em T\+A\+U} & \begin{DoxyVerb}          TAU is REAL array, dimension (N)
          If ITYPE >= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE < 2, then TAU is not referenced.\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em W\+O\+R\+K} & \begin{DoxyVerb}          WORK is REAL array, dimension (2*N**2)\end{DoxyVerb}
\\
\hline
\mbox{\tt out}  & {\em R\+E\+S\+U\+L\+T} & \begin{DoxyVerb}          RESULT is REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if ITYPE=1.\end{DoxyVerb}
 \\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
\hypertarget{group__single__eig_ga4031914169fb1a0ddfd7dd67359c8b4f}{}\index{real@{real}!ssyt22@{ssyt22}}
\index{ssyt22@{ssyt22}!real@{real}}
\subsubsection[{ssyt22}]{\setlength{\rightskip}{0pt plus 5cm}subroutine ssyt22 (
\begin{DoxyParamCaption}
\item[{integer}]{I\+T\+Y\+P\+E, }
\item[{character}]{U\+P\+L\+O, }
\item[{integer}]{N, }
\item[{integer}]{M, }
\item[{integer}]{K\+B\+A\+N\+D, }
\item[{real, dimension( lda, $\ast$ )}]{A, }
\item[{integer}]{L\+D\+A, }
\item[{real, dimension( $\ast$ )}]{D, }
\item[{real, dimension( $\ast$ )}]{E, }
\item[{real, dimension( ldu, $\ast$ )}]{U, }
\item[{integer}]{L\+D\+U, }
\item[{real, dimension( ldv, $\ast$ )}]{V, }
\item[{integer}]{L\+D\+V, }
\item[{real, dimension( $\ast$ )}]{T\+A\+U, }
\item[{real, dimension( $\ast$ )}]{W\+O\+R\+K, }
\item[{real, dimension( 2 )}]{R\+E\+S\+U\+L\+T}
\end{DoxyParamCaption}
)}\label{group__single__eig_ga4031914169fb1a0ddfd7dd67359c8b4f}


{\bfseries S\+S\+Y\+T22} 

\begin{DoxyParagraph}{Purpose\+: }
\begin{DoxyVerb}      SSYT22  generally checks a decomposition of the form

              A U = U S

      where A is symmetric, the columns of U are orthonormal, and S
      is diagonal (if KBAND=0) or symmetric tridiagonal (if
      KBAND=1).  If ITYPE=1, then U is represented as a dense matrix,
      otherwise the U is expressed as a product of Householder
      transformations, whose vectors are stored in the array "V" and
      whose scaling constants are in "TAU"; we shall use the letter
      "V" to refer to the product of Householder transformations
      (which should be equal to U).

      Specifically, if ITYPE=1, then:

              RESULT(1) = | U' A U - S | / ( |A| m ulp ) *andC>              RESULT(2) = | I - U'U | / ( m ulp )\end{DoxyVerb}
 \begin{DoxyVerb}  ITYPE   INTEGER
          Specifies the type of tests to be performed.
          1: U expressed as a dense orthogonal matrix:
             RESULT(1) = | A - U S U' | / ( |A| n ulp )   *andC>             RESULT(2) = | I - UU' | / ( n ulp )

  UPLO    CHARACTER
          If UPLO='U', the upper triangle of A will be used and the
          (strictly) lower triangle will not be referenced.  If
          UPLO='L', the lower triangle of A will be used and the
          (strictly) upper triangle will not be referenced.
          Not modified.

  N       INTEGER
          The size of the matrix.  If it is zero, SSYT22 does nothing.
          It must be at least zero.
          Not modified.

  M       INTEGER
          The number of columns of U.  If it is zero, SSYT22 does
          nothing.  It must be at least zero.
          Not modified.

  KBAND   INTEGER
          The bandwidth of the matrix.  It may only be zero or one.
          If zero, then S is diagonal, and E is not referenced.  If
          one, then S is symmetric tri-diagonal.
          Not modified.

  A       REAL array, dimension (LDA , N)
          The original (unfactored) matrix.  It is assumed to be
          symmetric, and only the upper (UPLO='U') or only the lower
          (UPLO='L') will be referenced.
          Not modified.

  LDA     INTEGER
          The leading dimension of A.  It must be at least 1
          and at least N.
          Not modified.

  D       REAL array, dimension (N)
          The diagonal of the (symmetric tri-) diagonal matrix.
          Not modified.

  E       REAL array, dimension (N)
          The off-diagonal of the (symmetric tri-) diagonal matrix.
          E(1) is ignored, E(2) is the (1,2) and (2,1) element, etc.
          Not referenced if KBAND=0.
          Not modified.

  U       REAL array, dimension (LDU, N)
          If ITYPE=1 or 3, this contains the orthogonal matrix in
          the decomposition, expressed as a dense matrix.  If ITYPE=2,
          then it is not referenced.
          Not modified.

  LDU     INTEGER
          The leading dimension of U.  LDU must be at least N and
          at least 1.
          Not modified.

  V       REAL array, dimension (LDV, N)
          If ITYPE=2 or 3, the lower triangle of this array contains
          the Householder vectors used to describe the orthogonal
          matrix in the decomposition.  If ITYPE=1, then it is not
          referenced.
          Not modified.

  LDV     INTEGER
          The leading dimension of V.  LDV must be at least N and
          at least 1.
          Not modified.

  TAU     REAL array, dimension (N)
          If ITYPE >= 2, then TAU(j) is the scalar factor of
          v(j) v(j)' in the Householder transformation H(j) of
          the product  U = H(1)...H(n-2)
          If ITYPE < 2, then TAU is not referenced.
          Not modified.

  WORK    REAL array, dimension (2*N**2)
          Workspace.
          Modified.

  RESULT  REAL array, dimension (2)
          The values computed by the two tests described above.  The
          values are currently limited to 1/ulp, to avoid overflow.
          RESULT(1) is always modified.  RESULT(2) is modified only
          if LDU is at least N.
          Modified.\end{DoxyVerb}
 
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Univ. of Tennessee 

Univ. of California Berkeley 

Univ. of Colorado Denver 

N\+A\+G Ltd. 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
November 2011 
\end{DoxyDate}
