\hypertarget{namespacesetuptools_1_1package__index}{}\section{setuptools.\+package\+\_\+index Namespace Reference}
\label{namespacesetuptools_1_1package__index}\index{setuptools.\+package\+\_\+index@{setuptools.\+package\+\_\+index}}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
tuple \hyperlink{namespacesetuptools_1_1package__index_ae9fd86dcfb551a9677fc24bca75a6008}{E\+G\+G\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T} = re.\+compile(\hyperlink{indexexpr_8h_ac434fd11cc2493608d8d91424d60c17e}{r}'$^\wedge$egg=(\mbox{[}-\/\hyperlink{classA}{A}-\/Za-\/z0-\/9\+\_\+.\mbox{]}+)\$')
\item 
tuple \hyperlink{namespacesetuptools_1_1package__index_a225aa76e4bbf555ddb21de9273d51867}{H\+R\+E\+F}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}PyPI and direct package downloading\end{DoxyVerb}
 

\subsection{Variable Documentation}
\hypertarget{namespacesetuptools_1_1package__index_ae9fd86dcfb551a9677fc24bca75a6008}{}\index{setuptools\+::package\+\_\+index@{setuptools\+::package\+\_\+index}!E\+G\+G\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T@{E\+G\+G\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T}}
\index{E\+G\+G\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T@{E\+G\+G\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T}!setuptools\+::package\+\_\+index@{setuptools\+::package\+\_\+index}}
\subsubsection[{E\+G\+G\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T}]{\setlength{\rightskip}{0pt plus 5cm}tuple setuptools.\+package\+\_\+index.\+E\+G\+G\+\_\+\+F\+R\+A\+G\+M\+E\+N\+T = re.\+compile({\bf r}'$^\wedge$egg=(\mbox{[}-\/{\bf A}-\/Za-\/z0-\/9\+\_\+.\mbox{]}+)\$')}\label{namespacesetuptools_1_1package__index_ae9fd86dcfb551a9677fc24bca75a6008}
\hypertarget{namespacesetuptools_1_1package__index_a225aa76e4bbf555ddb21de9273d51867}{}\index{setuptools\+::package\+\_\+index@{setuptools\+::package\+\_\+index}!H\+R\+E\+F@{H\+R\+E\+F}}
\index{H\+R\+E\+F@{H\+R\+E\+F}!setuptools\+::package\+\_\+index@{setuptools\+::package\+\_\+index}}
\subsubsection[{H\+R\+E\+F}]{\setlength{\rightskip}{0pt plus 5cm}tuple setuptools.\+package\+\_\+index.\+H\+R\+E\+F}\label{namespacesetuptools_1_1package__index_a225aa76e4bbf555ddb21de9273d51867}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = re.compile(\textcolor{stringliteral}{"""href\(\backslash\)\(\backslash\)s*=\(\backslash\)\(\backslash\)s*['"]?([^'"> ]+)"""}, re.I)
2 \textcolor{comment}{# this is here to fix emacs' cruddy broken syntax highlighting}
3 PYPI\_MD5 = re.compile(
4     \textcolor{stringliteral}{'<a href="([^"#]+)">([^<]+)</a>\(\backslash\)n\(\backslash\)s+\(\backslash\)\(\backslash\)(<a (?:title="MD5 hash"\(\backslash\)n\(\backslash\)s+)'}    \textcolor{stringliteral}{'href="[^?]+\(\backslash\)?
      :action=show\_md5&amp;digest=([0-9a-f]\{32\})">md5</a>\(\backslash\)\(\backslash\))'})URL\_SCHEME = re.compile(\textcolor{stringliteral}{'([-+.a-z0-9]\{2,\}):'},re.I).matchEXTENSIONS = \textcolor{stringliteral}{
      ".tar.gz .tar.bz2 .tar .zip .tgz"}.split()\_\_all\_\_ = [    \textcolor{stringliteral}{'PackageIndex'}, \textcolor{stringliteral}{'distros\_for\_url'}, \textcolor{stringliteral}{'
      parse\_bdist\_wininst'},    \textcolor{stringliteral}{'interpret\_distro\_name'},]\_SOCKET\_TIMEOUT = 15\textcolor{keyword}{def }parse\_bdist\_wininst(name):    \textcolor{stringliteral}{"""Return
       (base,pyversion) or (None,None) for possible .exe name"""}    lower = name.lower()    base, py\_ver, plat = \textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}, \textcolor{keywordtype}{
      None}    \textcolor{keywordflow}{if} lower.endswith(\textcolor{stringliteral}{'.exe'}):        \textcolor{keywordflow}{if} lower.endswith(\textcolor{stringliteral}{'.win32.exe'}):            base = name[:-10]     
             plat = \textcolor{stringliteral}{'win32'}        \textcolor{keywordflow}{elif} lower.startswith(\textcolor{stringliteral}{'.win32-py'},-16):            py\_ver = name[-7:-4]        
          base = name[:-16]            plat = \textcolor{stringliteral}{'win32'}        \textcolor{keywordflow}{elif} lower.endswith(\textcolor{stringliteral}{'.win-amd64.exe'}):            
      base = name[:-14]            plat = \textcolor{stringliteral}{'win-amd64'}        \textcolor{keywordflow}{elif} lower.startswith(\textcolor{stringliteral}{'.win-amd64-py'},-20):            
      py\_ver = name[-7:-4]            base = name[:-20]            plat = \textcolor{stringliteral}{'win-amd64'}    \textcolor{keywordflow}{return} base,py\_ver,platdef
       egg\_info\_for\_url(url):    scheme, server, path, parameters, query, fragment = urlparse(url)    base = 
      unquote(path.split(\textcolor{stringliteral}{'/'})[-1])    \textcolor{keywordflow}{if} server==\textcolor{stringliteral}{'sourceforge.net'} \textcolor{keywordflow}{and} base==\textcolor{stringliteral}{'download'}:    \textcolor{comment}{# XXX Yuck        base =
       unquote(path.split('/')[-2])    if '#' in base: base, fragment = base.split('#',1)    return base,fragmentdef
       distros\_for\_url(url, metadata=None):    """Yield egg or source distribution objects that might be found at a
       URL"""    base, fragment = egg\_info\_for\_url(url)    for dist in distros\_for\_location(url, base, metadata):
       yield dist    if fragment:        match = EGG\_FRAGMENT.match(fragment)        if match:            for dist
       in interpret\_distro\_name(                url, match.group(1), metadata, precedence = CHECKOUT\_DIST          
        ):                yield distdef distros\_for\_location(location, basename, metadata=None):    """Yield egg
       or source distribution objects based on basename"""    if basename.endswith('.egg.zip'):        basename =
       basename[:-4]    # strip the .zip    if basename.endswith('.egg') and '-' in basename:        # only one,
       unambiguous interpretation        return [Distribution.from\_location(location, basename, metadata)]    if
       basename.endswith('.exe'):        win\_base, py\_ver, platform = parse\_bdist\_wininst(basename)        if win\_base is
       not None:            return interpret\_distro\_name(                location, win\_base, metadata, py\_ver,
       BINARY\_DIST, platform            )    # Try source distro extensions (.zip, .tgz, etc.)    #    for ext in
       EXTENSIONS:        if basename.endswith(ext):            basename = basename[:-len(ext)]            return
       interpret\_distro\_name(location, basename, metadata)    return []  # no extension matcheddef
       distros\_for\_filename(filename, metadata=None):    """Yield possible egg or source distribution objects based on a filename"""   
       return distros\_for\_location(        normalize\_path(filename), os.path.basename(filename), metadata    )def
       interpret\_distro\_name(        location, basename, metadata, py\_version=None, precedence=SOURCE\_DIST,       
       platform=None        ):    """Generate alternative interpretations of a source distro name}
5 
6     Note: \textcolor{keywordflow}{if} `location` \textcolor{keywordflow}{is} a filesystem filename, you should call
7     ``\hyperlink{namespacepkg__resources_addc9d89b8b9ce3c9edcf2a55805bfe95}{pkg\_resources.normalize\_path}()`` on it before passing it to this
8     routine!
9     \textcolor{stringliteral}{"""    # Generate alternative interpretations of a source distro name    # Because some packages are
       ambiguous as to name/versions split    # e.g. "adns-python-1.1.0", "egenix-mx-commercial", etc.    # So, we
       generate each possible interepretation (e.g. "adns, python-1.1.0"    # "adns-python, 1.1.0", and "
      adns-python-1.1.0, no version").  In practice,    # the spurious interpretations should be ignored, because in the event
          # there's also an "adns" package, the spurious "python-1.1.0" version will    # compare lower than any
       numeric version number, and is therefore unlikely    # to match a request for it.  It's still a potential
       problem, though, and    # in the long run PyPI and the distutils should go for "safe" names and    # versions
       in distribution archive names (sdist and bdist).    parts = basename.split('-')    if not py\_version:       
       for i,p in enumerate(parts[2:]):            if len(p)==5 and p.startswith('py2.'):                return #
       It's a bdist\_dumb, not an sdist -- bail out    for p in range(1,len(parts)+1):        yield Distribution(    
              location, metadata, '-'.join(parts[:p]), '-'.join(parts[p:]),            py\_version=py\_version,
       precedence = precedence,            platform = platform        )# From Python 2.7 docsdef
       unique\_everseen(iterable, key=None):    "List unique elements, preserving order. Remember all elements ever seen."    #
       unique\_everseen('AAAABBBCCDAABBB') --> A B C D    # unique\_everseen('ABBCcAD', str.lower) --> A B C D    seen = set() 
         seen\_add = seen.add    if key is None:        for element in filterfalse(seen.\_\_contains\_\_, iterable):   
               seen\_add(element)            yield element    else:        for element in iterable:            k =
       key(element)            if k not in seen:                seen\_add(k)                yield elementdef
       unique\_values(func):    """}
10     Wrap a function returning an iterable such that the resulting iterable
11     only ever yields unique items.
12     \textcolor{stringliteral}{"""    @wraps(func)    def wrapper(*args, **kwargs):        return unique\_everseen(func(*args,
       **kwargs))    return wrapperREL = re.compile("""}<([^>]*\(\backslash\)srel\(\backslash\)s*=\(\backslash\)s*[\textcolor{stringliteral}{'"]?([^'}\textcolor{stringliteral}{">]+)[^>]*)}
\end{DoxyCode}
