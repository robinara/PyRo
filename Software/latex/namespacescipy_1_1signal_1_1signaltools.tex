\hypertarget{namespacescipy_1_1signal_1_1signaltools}{}\section{scipy.\+signal.\+signaltools Namespace Reference}
\label{namespacescipy_1_1signal_1_1signaltools}\index{scipy.\+signal.\+signaltools@{scipy.\+signal.\+signaltools}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a1e29e81a0d22facdc833faa7052f73b1}{correlate}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_ab37875bbee2936c9441080f27b3599ce}{fftconvolve}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a1c46662badedd414df4119185906530e}{convolve}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a0372dc55a21c3341518cd3db8a700e4d}{order\+\_\+filter}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a7fa4ace1ce6efb0487ff79447531db71}{medfilt}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_aef763ec8579bf17ed3e8a1075ae6933f}{wiener}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_abed1aaf4f1dec67fdb5f65f222b87289}{convolve2d}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_aeeb2d86fde181c1dbdb04fd07e28c267}{correlate2d}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a3cbf1a46967c8993eac73977c373b789}{medfilt2d}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_aee8683bd5f9e963b8a4ff66d55f249e4}{lfilter}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a150dbc1e54a79c247cc7cd3cf4629605}{lfiltic}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a8f9ae32df850efb661fcdcc5d51a4e04}{deconvolve}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a565c325a63c17a4a22bca39e9b118cf3}{hilbert}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a58de35cc81197d4561048c5d92b42494}{hilbert2}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a5031cf6249cf88725c8abf39f882330b}{cmplx\+\_\+sort}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_aeeb65ce1351c6affe49a763d5a379b13}{unique\+\_\+roots}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a436615752eb389357b2f867a6747132b}{invres}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a0086218fc9eb3a2e760b9444c3db01c8}{residue}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a4c1fd99470212f31ffc65d3123c82b17}{residuez}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a391f209e737d627085823daa4b145d6f}{invresz}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_ad7dad116f785f133e775b952dc17ec42}{resample}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a305117d7530b3a0ad64b8c12d3291f69}{vectorstrength}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a6291b0c88f4c89a588ca8cd650fcc7ff}{detrend}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_afd0e036099684901ab60fc54f34f20ea}{lfilter\+\_\+zi}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_ae981de4498e23cf542fa721f779017db}{filtfilt}
\item 
def \hyperlink{namespacescipy_1_1signal_1_1signaltools_a3e63e0059a3d5e0d9466604c0e127f8f}{decimate}
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
list \hyperlink{namespacescipy_1_1signal_1_1signaltools_a18b112c5f3754320389080c509ae3593}{\+\_\+\+\_\+all\+\_\+\+\_\+}
\item 
dictionary \hyperlink{namespacescipy_1_1signal_1_1signaltools_a892a22e92c69038066cb62110ed13dab}{\+\_\+modedict} = \{'valid'\+: 0, 'same'\+: 1, 'full'\+: 2\}
\item 
dictionary \hyperlink{namespacescipy_1_1signal_1_1signaltools_a8dd98af7a22a25e2c10b79108937681e}{\+\_\+boundarydict}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespacescipy_1_1signal_1_1signaltools_a5031cf6249cf88725c8abf39f882330b}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!cmplx\+\_\+sort@{cmplx\+\_\+sort}}
\index{cmplx\+\_\+sort@{cmplx\+\_\+sort}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{cmplx\+\_\+sort}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+cmplx\+\_\+sort (
\begin{DoxyParamCaption}
\item[{}]{p}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a5031cf6249cf88725c8abf39f882330b}
\hypertarget{namespacescipy_1_1signal_1_1signaltools_a1c46662badedd414df4119185906530e}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!convolve@{convolve}}
\index{convolve@{convolve}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{convolve}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+convolve (
\begin{DoxyParamCaption}
\item[{}]{in1, }
\item[{}]{in2, }
\item[{}]{mode = {\ttfamily 'full'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a1c46662badedd414df4119185906530e}
\begin{DoxyVerb}Convolve two N-dimensional arrays.

Convolve `in1` and `in2`, with the output size determined by the
`mode` argument.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`;
    if sizes of `in1` and `in2` are not equal then `in1` has to be the
    larger array.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

Returns
-------
convolve : array
    An N-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_abed1aaf4f1dec67fdb5f65f222b87289}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!convolve2d@{convolve2d}}
\index{convolve2d@{convolve2d}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{convolve2d}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+convolve2d (
\begin{DoxyParamCaption}
\item[{}]{in1, }
\item[{}]{in2, }
\item[{}]{mode = {\ttfamily 'full'}, }
\item[{}]{boundary = {\ttfamily 'fill'}, }
\item[{}]{fillvalue = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_abed1aaf4f1dec67fdb5f65f222b87289}
\begin{DoxyVerb}Convolve two 2-dimensional arrays.

Convolve `in1` and `in2` with output size determined by `mode`, and
boundary conditions determined by `boundary` and `fillvalue`.

Parameters
----------
in1, in2 : array_like
    Two-dimensional input arrays to be convolved.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

boundary : str {'fill', 'wrap', 'symm'}, optional
    A flag indicating how to handle boundaries:

    ``fill``
       pad input arrays with fillvalue. (default)
    ``wrap``
       circular boundary conditions.
    ``symm``
       symmetrical boundary conditions.

fillvalue : scalar, optional
    Value to fill pad input arrays with. Default is 0.

Returns
-------
out : ndarray
    A 2-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a1e29e81a0d22facdc833faa7052f73b1}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!correlate@{correlate}}
\index{correlate@{correlate}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{correlate}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+correlate (
\begin{DoxyParamCaption}
\item[{}]{in1, }
\item[{}]{in2, }
\item[{}]{mode = {\ttfamily 'full'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a1e29e81a0d22facdc833faa7052f73b1}
\begin{DoxyVerb}Cross-correlate two N-dimensional arrays.

Cross-correlate `in1` and `in2`, with the output size determined by the
`mode` argument.

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`;
    if sizes of `in1` and `in2` are not equal then `in1` has to be the
    larger array.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear cross-correlation
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

Returns
-------
correlate : array
    An N-dimensional array containing a subset of the discrete linear
    cross-correlation of `in1` with `in2`.

Notes
-----
The correlation z of two d-dimensional arrays x and y is defined as:

  z[...,k,...] = sum[..., i_l, ...]
                     x[..., i_l,...] * conj(y[..., i_l + k,...])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_aeeb2d86fde181c1dbdb04fd07e28c267}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!correlate2d@{correlate2d}}
\index{correlate2d@{correlate2d}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{correlate2d}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+correlate2d (
\begin{DoxyParamCaption}
\item[{}]{in1, }
\item[{}]{in2, }
\item[{}]{mode = {\ttfamily 'full'}, }
\item[{}]{boundary = {\ttfamily 'fill'}, }
\item[{}]{fillvalue = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_aeeb2d86fde181c1dbdb04fd07e28c267}
\begin{DoxyVerb}Cross-correlate two 2-dimensional arrays.

Cross correlate `in1` and `in2` with output size determined by `mode`, and
boundary conditions determined by `boundary` and `fillvalue`.

Parameters
----------
in1, in2 : array_like
    Two-dimensional input arrays to be convolved.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear cross-correlation
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

boundary : str {'fill', 'wrap', 'symm'}, optional
    A flag indicating how to handle boundaries:

    ``fill``
       pad input arrays with fillvalue. (default)
    ``wrap``
       circular boundary conditions.
    ``symm``
       symmetrical boundary conditions.

fillvalue : scalar, optional
    Value to fill pad input arrays with. Default is 0.

Returns
-------
correlate2d : ndarray
    A 2-dimensional array containing a subset of the discrete linear
    cross-correlation of `in1` with `in2`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a3e63e0059a3d5e0d9466604c0e127f8f}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!decimate@{decimate}}
\index{decimate@{decimate}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{decimate}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+decimate (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{q, }
\item[{}]{n = {\ttfamily None}, }
\item[{}]{ftype = {\ttfamily 'iir'}, }
\item[{}]{axis = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a3e63e0059a3d5e0d9466604c0e127f8f}
\begin{DoxyVerb}Downsample the signal by using a filter.

By default, an order 8 Chebyshev type I filter is used.  A 30 point FIR
filter with hamming window is used if `ftype` is 'fir'.

Parameters
----------
x : ndarray
    The signal to be downsampled, as an N-dimensional array.
q : int
    The downsampling factor.
n : int, optional
    The order of the filter (1 less than the length for 'fir').
ftype : str {'iir', 'fir'}, optional
    The type of the lowpass filter.
axis : int, optional
    The axis along which to decimate.

Returns
-------
y : ndarray
    The down-sampled signal.

See also
--------
resample\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a8f9ae32df850efb661fcdcc5d51a4e04}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!deconvolve@{deconvolve}}
\index{deconvolve@{deconvolve}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{deconvolve}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+deconvolve (
\begin{DoxyParamCaption}
\item[{}]{signal, }
\item[{}]{divisor}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a8f9ae32df850efb661fcdcc5d51a4e04}
\begin{DoxyVerb}Deconvolves `divisor` out of `signal`.

Parameters
----------
signal : array
    Signal input
divisor : array
    Divisor input

Returns
-------
q : array
    Quotient of the division
r : array
    Remainder

Examples
--------
>>> from scipy import signal
>>> sig = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1,])
>>> filter = np.array([1,1,0])
>>> res = signal.convolve(sig, filter)
>>> signal.deconvolve(res, filter)
(array([ 0.,  0.,  0.,  0.,  0.,  1.,  1.,  1.,  1.]),
 array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]))\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a6291b0c88f4c89a588ca8cd650fcc7ff}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!detrend@{detrend}}
\index{detrend@{detrend}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{detrend}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+detrend (
\begin{DoxyParamCaption}
\item[{}]{data, }
\item[{}]{axis = {\ttfamily -\/1}, }
\item[{}]{type = {\ttfamily '{\bf linear}'}, }
\item[{}]{bp = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a6291b0c88f4c89a588ca8cd650fcc7ff}
\begin{DoxyVerb}Remove linear trend along axis from data.

Parameters
----------
data : array_like
    The input data.
axis : int, optional
    The axis along which to detrend the data. By default this is the
    last axis (-1).
type : {'linear', 'constant'}, optional
    The type of detrending. If ``type == 'linear'`` (default),
    the result of a linear least-squares fit to `data` is subtracted
    from `data`.
    If ``type == 'constant'``, only the mean of `data` is subtracted.
bp : array_like of ints, optional
    A sequence of break points. If given, an individual linear fit is
    performed for each part of `data` between two break points.
    Break points are specified as indices into `data`.

Returns
-------
ret : ndarray
    The detrended input data.

Examples
--------
>>> from scipy import signal
>>> randgen = np.random.RandomState(9)
>>> npoints = 1e3
>>> noise = randgen.randn(npoints)
>>> x = 3 + 2*np.linspace(0, 1, npoints) + noise
>>> (signal.detrend(x) - noise).max() < 0.01
True\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_ab37875bbee2936c9441080f27b3599ce}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!fftconvolve@{fftconvolve}}
\index{fftconvolve@{fftconvolve}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{fftconvolve}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+fftconvolve (
\begin{DoxyParamCaption}
\item[{}]{in1, }
\item[{}]{in2, }
\item[{}]{mode = {\ttfamily \char`\"{}full\char`\"{}}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_ab37875bbee2936c9441080f27b3599ce}
\begin{DoxyVerb}Convolve two N-dimensional arrays using FFT.

Convolve `in1` and `in2` using the fast Fourier transform method, with
the output size determined by the `mode` argument.

This is generally much faster than `convolve` for large arrays (n > ~500),
but can be slower when only a few output values are needed, and can only
output float arrays (int or object array inputs will be cast to float).

Parameters
----------
in1 : array_like
    First input.
in2 : array_like
    Second input. Should have the same number of dimensions as `in1`;
    if sizes of `in1` and `in2` are not equal then `in1` has to be the
    larger array.
mode : str {'full', 'valid', 'same'}, optional
    A string indicating the size of the output:

    ``full``
       The output is the full discrete linear convolution
       of the inputs. (Default)
    ``valid``
       The output consists only of those elements that do not
       rely on the zero-padding.
    ``same``
       The output is the same size as `in1`, centered
       with respect to the 'full' output.

Returns
-------
out : array
    An N-dimensional array containing a subset of the discrete linear
    convolution of `in1` with `in2`.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_ae981de4498e23cf542fa721f779017db}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!filtfilt@{filtfilt}}
\index{filtfilt@{filtfilt}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{filtfilt}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+filtfilt (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{x, }
\item[{}]{axis = {\ttfamily -\/1}, }
\item[{}]{padtype = {\ttfamily 'odd'}, }
\item[{}]{padlen = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_ae981de4498e23cf542fa721f779017db}
\begin{DoxyVerb}A forward-backward filter.

This function applies a linear filter twice, once forward
and once backwards.  The combined filter has linear phase.

Before applying the filter, the function can pad the data along the
given axis in one of three ways: odd, even or constant.  The odd
and even extensions have the corresponding symmetry about the end point
of the data.  The constant extension extends the data with the values
at end points.  On both the forward and backwards passes, the
initial condition of the filter is found by using `lfilter_zi` and
scaling it by the end point of the extended data.

Parameters
----------
b : (N,) array_like
    The numerator coefficient vector of the filter.
a : (N,) array_like
    The denominator coefficient vector of the filter.  If a[0]
    is not 1, then both a and b are normalized by a[0].
x : array_like
    The array of data to be filtered.
axis : int, optional
    The axis of `x` to which the filter is applied.
    Default is -1.
padtype : str or None, optional
    Must be 'odd', 'even', 'constant', or None.  This determines the
    type of extension to use for the padded signal to which the filter
    is applied.  If `padtype` is None, no padding is used.  The default
    is 'odd'.
padlen : int or None, optional
    The number of elements by which to extend `x` at both ends of
    `axis` before applying the filter. This value must be less than
    `x.shape[axis]-1`.  `padlen=0` implies no padding.
    The default value is 3*max(len(a),len(b)).

Returns
-------
y : ndarray
    The filtered output, an array of type numpy.float64 with the same
    shape as `x`.

See Also
--------
lfilter_zi, lfilter

Examples
--------
First we create a one second signal that is the sum of two pure sine
waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.

>>> t = np.linspace(0, 1.0, 2001)
>>> xlow = np.sin(2 * np.pi * 5 * t)
>>> xhigh = np.sin(2 * np.pi * 250 * t)
>>> x = xlow + xhigh

Now create a lowpass Butterworth filter with a cutoff of 0.125 times
the Nyquist rate, or 125 Hz, and apply it to x with filtfilt.  The
result should be approximately xlow, with no phase shift.

>>> from scipy import signal
>>> b, a = signal.butter(8, 0.125)
>>> y = signal.filtfilt(b, a, x, padlen=150)
>>> np.abs(y - xlow).max()
9.1086182074789912e-06

We get a fairly clean result for this artificial example because
the odd extension is exact, and with the moderately long padding,
the filter's transients have dissipated by the time the actual data
is reached.  In general, transient effects at the edges are
unavoidable.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a565c325a63c17a4a22bca39e9b118cf3}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!hilbert@{hilbert}}
\index{hilbert@{hilbert}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{hilbert}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+hilbert (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{N = {\ttfamily None}, }
\item[{}]{axis = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a565c325a63c17a4a22bca39e9b118cf3}
\begin{DoxyVerb}Compute the analytic signal, using the Hilbert transform.

The transformation is done along the last axis by default.

Parameters
----------
x : array_like
    Signal data.  Must be real.
N : int, optional
    Number of Fourier components.  Default: ``x.shape[axis]``
axis : int, optional
    Axis along which to do the transformation.  Default: -1.

Returns
-------
xa : ndarray
    Analytic signal of `x`, of each 1-D array along `axis`

Notes
-----
The analytic signal ``x_a(t)`` of signal ``x(t)`` is:

.. math:: x_a = F^{-1}(F(x) 2U) = x + i y

where `F` is the Fourier transform, `U` the unit step function,
and `y` the Hilbert transform of `x`. [1]_

In other words, the negative half of the frequency spectrum is zeroed
out, turning the real-valued signal into a complex signal.  The Hilbert
transformed signal can be obtained from ``np.imag(hilbert(x))``, and the
original signal from ``np.real(hilbert(x))``.

References
----------
.. [1] Wikipedia, "Analytic signal".
       http://en.wikipedia.org/wiki/Analytic_signal\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a58de35cc81197d4561048c5d92b42494}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!hilbert2@{hilbert2}}
\index{hilbert2@{hilbert2}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{hilbert2}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+hilbert2 (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{N = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a58de35cc81197d4561048c5d92b42494}
\begin{DoxyVerb}Compute the '2-D' analytic signal of `x`

Parameters
----------
x : array_like
    2-D signal data.
N : int or tuple of two ints, optional
    Number of Fourier components. Default is ``x.shape``

Returns
-------
xa : ndarray
    Analytic signal of `x` taken along axes (0,1).

References
----------
.. [1] Wikipedia, "Analytic signal",
    http://en.wikipedia.org/wiki/Analytic_signal\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a436615752eb389357b2f867a6747132b}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!invres@{invres}}
\index{invres@{invres}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{invres}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+invres (
\begin{DoxyParamCaption}
\item[{}]{r, }
\item[{}]{p, }
\item[{}]{k, }
\item[{}]{tol = {\ttfamily 1e-\/3}, }
\item[{}]{rtype = {\ttfamily 'avg'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a436615752eb389357b2f867a6747132b}
\begin{DoxyVerb}Compute b(s) and a(s) from partial fraction expansion: r,p,k

If ``M = len(b)`` and ``N = len(a)``::

            b(s)     b[0] x**(M-1) + b[1] x**(M-2) + ... + b[M-1]
    H(s) = ------ = ----------------------------------------------
            a(s)     a[0] x**(N-1) + a[1] x**(N-2) + ... + a[N-1]

             r[0]       r[1]             r[-1]
         = -------- + -------- + ... + --------- + k(s)
           (s-p[0])   (s-p[1])         (s-p[-1])

If there are any repeated roots (closer than tol), then the partial
fraction expansion has terms like::

      r[i]      r[i+1]              r[i+n-1]
    -------- + ----------- + ... + -----------
    (s-p[i])  (s-p[i])**2          (s-p[i])**n

Parameters
----------
r : ndarray
    Residues.
p : ndarray
    Poles.
k : ndarray
    Coefficients of the direct polynomial term.
tol : float, optional
    The tolerance for two roots to be considered equal. Default is 1e-3.
rtype : {'max', 'min, 'avg'}, optional
    How to determine the returned root if multiple roots are within
    `tol` of each other.

      'max': pick the maximum of those roots.

      'min': pick the minimum of those roots.

      'avg': take the average of those roots.

See Also
--------
residue, unique_roots\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a391f209e737d627085823daa4b145d6f}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!invresz@{invresz}}
\index{invresz@{invresz}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{invresz}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+invresz (
\begin{DoxyParamCaption}
\item[{}]{r, }
\item[{}]{p, }
\item[{}]{k, }
\item[{}]{tol = {\ttfamily 1e-\/3}, }
\item[{}]{rtype = {\ttfamily 'avg'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a391f209e737d627085823daa4b145d6f}
\begin{DoxyVerb}Compute b(z) and a(z) from partial fraction expansion: r,p,k

If ``M = len(b)`` and ``N = len(a)``::

            b(z)     b[0] + b[1] z**(-1) + ... + b[M-1] z**(-M+1)
    H(z) = ------ = ----------------------------------------------
            a(z)     a[0] + a[1] z**(-1) + ... + a[N-1] z**(-N+1)

                 r[0]                   r[-1]
         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1)...
           (1-p[0]z**(-1))         (1-p[-1]z**(-1))

If there are any repeated roots (closer than tol), then the partial
fraction expansion has terms like::

         r[i]              r[i+1]                    r[i+n-1]
    -------------- + ------------------ + ... + ------------------
    (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n

See Also
--------
residuez, unique_roots\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_aee8683bd5f9e963b8a4ff66d55f249e4}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!lfilter@{lfilter}}
\index{lfilter@{lfilter}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{lfilter}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+lfilter (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{x, }
\item[{}]{axis = {\ttfamily -\/1}, }
\item[{}]{zi = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_aee8683bd5f9e963b8a4ff66d55f249e4}
\begin{DoxyVerb}Filter data along one-dimension with an IIR or FIR filter.

Filter a data sequence, `x`, using a digital filter.  This works for many
fundamental data types (including Object type).  The filter is a direct
form II transposed implementation of the standard difference equation
(see Notes).

Parameters
----------
b : array_like
    The numerator coefficient vector in a 1-D sequence.
a : array_like
    The denominator coefficient vector in a 1-D sequence.  If ``a[0]``
    is not 1, then both `a` and `b` are normalized by ``a[0]``.
x : array_like
    An N-dimensional input array.
axis : int
    The axis of the input data array along which to apply the
    linear filter. The filter is applied to each subarray along
    this axis.  Default is -1.
zi : array_like, optional
    Initial conditions for the filter delays.  It is a vector
    (or array of vectors for an N-dimensional input) of length
    ``max(len(a),len(b))-1``.  If `zi` is None or is not given then
    initial rest is assumed.  See `lfiltic` for more information.

Returns
-------
y : array
    The output of the digital filter.
zf : array, optional
    If `zi` is None, this is not returned, otherwise, `zf` holds the
    final filter delay values.

Notes
-----
The filter function is implemented as a direct II transposed structure.
This means that the filter implements::

   a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[nb]*x[n-nb]
                           - a[1]*y[n-1] - ... - a[na]*y[n-na]

using the following difference equations::

     y[m] = b[0]*x[m] + z[0,m-1]
     z[0,m] = b[1]*x[m] + z[1,m-1] - a[1]*y[m]
     ...
     z[n-3,m] = b[n-2]*x[m] + z[n-2,m-1] - a[n-2]*y[m]
     z[n-2,m] = b[n-1]*x[m] - a[n-1]*y[m]

where m is the output sample number and n=max(len(a),len(b)) is the
model order.

The rational transfer function describing this filter in the
z-transform domain is::

                         -1               -nb
             b[0] + b[1]z  + ... + b[nb] z
     Y(z) = ---------------------------------- X(z)
                         -1               -na
             a[0] + a[1]z  + ... + a[na] z\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_afd0e036099684901ab60fc54f34f20ea}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!lfilter\+\_\+zi@{lfilter\+\_\+zi}}
\index{lfilter\+\_\+zi@{lfilter\+\_\+zi}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{lfilter\+\_\+zi}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+lfilter\+\_\+zi (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_afd0e036099684901ab60fc54f34f20ea}
\begin{DoxyVerb}Compute an initial state `zi` for the lfilter function that corresponds
to the steady state of the step response.

A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.

Parameters
----------
b, a : array_like (1-D)
    The IIR filter coefficients. See `lfilter` for more
    information.

Returns
-------
zi : 1-D ndarray
    The initial state for the filter.

Notes
-----
A linear filter with order m has a state space representation (A, B, C, D),
for which the output y of the filter can be expressed as::

    z(n+1) = A*z(n) + B*x(n)
    y(n)   = C*z(n) + D*x(n)

where z(n) is a vector of length m, A has shape (m, m), B has shape
(m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is
a scalar).  lfilter_zi solves::

    zi = A*zi + B

In other words, it finds the initial condition for which the response
to an input of all ones is a constant.

Given the filter coefficients `a` and `b`, the state space matrices
for the transposed direct form II implementation of the linear filter,
which is the implementation used by scipy.signal.lfilter, are::

    A = scipy.linalg.companion(a).T
    B = b[1:] - a[1:]*b[0]

assuming `a[0]` is 1.0; if `a[0]` is not 1, `a` and `b` are first
divided by a[0].

Examples
--------
The following code creates a lowpass Butterworth filter. Then it
applies that filter to an array whose values are all 1.0; the
output is also all 1.0, as expected for a lowpass filter.  If the
`zi` argument of `lfilter` had not been given, the output would have
shown the transient signal.

>>> from numpy import array, ones
>>> from scipy.signal import lfilter, lfilter_zi, butter
>>> b, a = butter(5, 0.25)
>>> zi = lfilter_zi(b, a)
>>> y, zo = lfilter(b, a, ones(10), zi=zi)
>>> y
array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])

Another example:

>>> x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])
>>> y, zf = lfilter(b, a, x, zi=zi*x[0])
>>> y
array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,
    0.44399389,  0.35505241])

Note that the `zi` argument to `lfilter` was computed using
`lfilter_zi` and scaled by `x[0]`.  Then the output `y` has no
transient until the input drops from 0.5 to 0.0.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a150dbc1e54a79c247cc7cd3cf4629605}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!lfiltic@{lfiltic}}
\index{lfiltic@{lfiltic}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{lfiltic}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+lfiltic (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{y, }
\item[{}]{x = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a150dbc1e54a79c247cc7cd3cf4629605}
\begin{DoxyVerb}Construct initial conditions for lfilter.

Given a linear filter (b, a) and initial conditions on the output `y`
and the input `x`, return the initial conditions on the state vector zi
which is used by `lfilter` to generate the output given the input.

Parameters
----------
b : array_like
    Linear filter term.
a : array_like
    Linear filter term.
y : array_like
    Initial conditions.

    If ``N=len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``.

    If `y` is too short, it is padded with zeros.
x : array_like, optional
    Initial conditions.

    If ``M=len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``.

    If `x` is not given, its initial conditions are assumed zero.

    If `x` is too short, it is padded with zeros.

Returns
-------
zi : ndarray
    The state vector ``zi``.
    ``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``, where ``K = max(M,N)``.

See Also
--------
lfilter\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a7fa4ace1ce6efb0487ff79447531db71}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!medfilt@{medfilt}}
\index{medfilt@{medfilt}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{medfilt}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+medfilt (
\begin{DoxyParamCaption}
\item[{}]{volume, }
\item[{}]{kernel\+\_\+size = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a7fa4ace1ce6efb0487ff79447531db71}
\begin{DoxyVerb}Perform a median filter on an N-dimensional array.

Apply a median filter to the input array using a local window-size
given by `kernel_size`.

Parameters
----------
volume : array_like
    An N-dimensional input array.
kernel_size : array_like, optional
    A scalar or an N-length list giving the size of the median filter
    window in each dimension.  Elements of `kernel_size` should be odd.
    If `kernel_size` is a scalar, then this scalar is used as the size in
    each dimension. Default size is 3 for each dimension.

Returns
-------
out : ndarray
    An array the same size as input containing the median filtered
    result.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a3cbf1a46967c8993eac73977c373b789}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!medfilt2d@{medfilt2d}}
\index{medfilt2d@{medfilt2d}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{medfilt2d}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+medfilt2d (
\begin{DoxyParamCaption}
\item[{}]{input, }
\item[{}]{kernel\+\_\+size = {\ttfamily 3}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a3cbf1a46967c8993eac73977c373b789}
\begin{DoxyVerb}Median filter a 2-dimensional array.

Apply a median filter to the `input` array using a local window-size
given by `kernel_size` (must be odd).

Parameters
----------
input : array_like
    A 2-dimensional input array.
kernel_size : array_like, optional
    A scalar or a list of length 2, giving the size of the
    median filter window in each dimension.  Elements of
    `kernel_size` should be odd.  If `kernel_size` is a scalar,
    then this scalar is used as the size in each dimension.
    Default is a kernel of size (3, 3).

Returns
-------
out : ndarray
    An array the same size as input containing the median filtered
    result.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a0372dc55a21c3341518cd3db8a700e4d}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!order\+\_\+filter@{order\+\_\+filter}}
\index{order\+\_\+filter@{order\+\_\+filter}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{order\+\_\+filter}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+order\+\_\+filter (
\begin{DoxyParamCaption}
\item[{}]{a, }
\item[{}]{domain, }
\item[{}]{rank}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a0372dc55a21c3341518cd3db8a700e4d}
\begin{DoxyVerb}Perform an order filter on an N-dimensional array.

Perform an order filter on the array in.  The domain argument acts as a
mask centered over each pixel.  The non-zero elements of domain are
used to select elements surrounding each input pixel which are placed
in a list.   The list is sorted, and the output for that pixel is the
element corresponding to rank in the sorted list.

Parameters
----------
a : ndarray
    The N-dimensional input array.
domain : array_like
    A mask array with the same number of dimensions as `in`.
    Each dimension should have an odd number of elements.
rank : int
    A non-negative integer which selects the element from the
    sorted list (0 corresponds to the smallest element, 1 is the
    next smallest element, etc.).

Returns
-------
out : ndarray
    The results of the order filter in an array with the same
    shape as `in`.

Examples
--------
>>> from scipy import signal
>>> x = np.arange(25).reshape(5, 5)
>>> domain = np.identity(3)
>>> x
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])
>>> signal.order_filter(x, domain, 0)
array([[  0.,   0.,   0.,   0.,   0.],
       [  0.,   0.,   1.,   2.,   0.],
       [  0.,   5.,   6.,   7.,   0.],
       [  0.,  10.,  11.,  12.,   0.],
       [  0.,   0.,   0.,   0.,   0.]])
>>> signal.order_filter(x, domain, 2)
array([[  6.,   7.,   8.,   9.,   4.],
       [ 11.,  12.,  13.,  14.,   9.],
       [ 16.,  17.,  18.,  19.,  14.],
       [ 21.,  22.,  23.,  24.,  19.],
       [ 20.,  21.,  22.,  23.,  24.]])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_ad7dad116f785f133e775b952dc17ec42}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!resample@{resample}}
\index{resample@{resample}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{resample}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+resample (
\begin{DoxyParamCaption}
\item[{}]{x, }
\item[{}]{num, }
\item[{}]{t = {\ttfamily None}, }
\item[{}]{axis = {\ttfamily 0}, }
\item[{}]{window = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_ad7dad116f785f133e775b952dc17ec42}
\begin{DoxyVerb}Resample `x` to `num` samples using Fourier method along the given axis.

The resampled signal starts at the same value as `x` but is sampled
with a spacing of ``len(x) / num * (spacing of x)``.  Because a
Fourier method is used, the signal is assumed to be periodic.

Parameters
----------
x : array_like
    The data to be resampled.
num : int
    The number of samples in the resampled signal.
t : array_like, optional
    If `t` is given, it is assumed to be the sample positions
    associated with the signal data in `x`.
axis : int, optional
    The axis of `x` that is resampled.  Default is 0.
window : array_like, callable, string, float, or tuple, optional
    Specifies the window applied to the signal in the Fourier
    domain.  See below for details.

Returns
-------
resampled_x or (resampled_x, resampled_t)
    Either the resampled array, or, if `t` was given, a tuple
    containing the resampled array and the corresponding resampled
    positions.

Notes
-----
The argument `window` controls a Fourier-domain window that tapers
the Fourier spectrum before zero-padding to alleviate ringing in
the resampled values for sampled signals you didn't intend to be
interpreted as band-limited.

If `window` is a function, then it is called with a vector of inputs
indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).

If `window` is an array of the same length as `x.shape[axis]` it is
assumed to be the window to be applied directly in the Fourier
domain (with dc and low-frequency first).

For any other type of `window`, the function `scipy.signal.get_window`
is called to generate the window.

The first sample of the returned vector is the same as the first
sample of the input vector.  The spacing between samples is changed
from dx to:

    dx * len(x) / num

If `t` is not None, then it represents the old sample positions,
and the new sample positions will be returned as well as the new
samples.\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a0086218fc9eb3a2e760b9444c3db01c8}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!residue@{residue}}
\index{residue@{residue}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{residue}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+residue (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{tol = {\ttfamily 1e-\/3}, }
\item[{}]{rtype = {\ttfamily 'avg'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a0086218fc9eb3a2e760b9444c3db01c8}
\begin{DoxyVerb}Compute partial-fraction expansion of b(s) / a(s).

If ``M = len(b)`` and ``N = len(a)``, then the partial-fraction
expansion H(s) is defined as::

          b(s)     b[0] s**(M-1) + b[1] s**(M-2) + ... + b[M-1]
  H(s) = ------ = ----------------------------------------------
          a(s)     a[0] s**(N-1) + a[1] s**(N-2) + ... + a[N-1]

           r[0]       r[1]             r[-1]
       = -------- + -------- + ... + --------- + k(s)
         (s-p[0])   (s-p[1])         (s-p[-1])

If there are any repeated roots (closer together than `tol`), then H(s)
has terms like::

        r[i]      r[i+1]              r[i+n-1]
      -------- + ----------- + ... + -----------
      (s-p[i])  (s-p[i])**2          (s-p[i])**n

Returns
-------
r : ndarray
    Residues.
p : ndarray
    Poles.
k : ndarray
    Coefficients of the direct polynomial term.

See Also
--------
invres, numpy.poly, unique_roots\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a4c1fd99470212f31ffc65d3123c82b17}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!residuez@{residuez}}
\index{residuez@{residuez}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{residuez}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+residuez (
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{a, }
\item[{}]{tol = {\ttfamily 1e-\/3}, }
\item[{}]{rtype = {\ttfamily 'avg'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a4c1fd99470212f31ffc65d3123c82b17}
\begin{DoxyVerb}Compute partial-fraction expansion of b(z) / a(z).

If ``M = len(b)`` and ``N = len(a)``::

            b(z)     b[0] + b[1] z**(-1) + ... + b[M-1] z**(-M+1)
    H(z) = ------ = ----------------------------------------------
            a(z)     a[0] + a[1] z**(-1) + ... + a[N-1] z**(-N+1)

             r[0]                   r[-1]
     = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...
       (1-p[0]z**(-1))         (1-p[-1]z**(-1))

If there are any repeated roots (closer than tol), then the partial
fraction expansion has terms like::

         r[i]              r[i+1]                    r[i+n-1]
    -------------- + ------------------ + ... + ------------------
    (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n

See also
--------
invresz, unique_roots\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_aeeb65ce1351c6affe49a763d5a379b13}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!unique\+\_\+roots@{unique\+\_\+roots}}
\index{unique\+\_\+roots@{unique\+\_\+roots}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{unique\+\_\+roots}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+unique\+\_\+roots (
\begin{DoxyParamCaption}
\item[{}]{p, }
\item[{}]{tol = {\ttfamily 1e-\/3}, }
\item[{}]{rtype = {\ttfamily '{\bf min}'}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_aeeb65ce1351c6affe49a763d5a379b13}
\begin{DoxyVerb}Determine unique roots and their multiplicities from a list of roots.

Parameters
----------
p : array_like
    The list of roots.
tol : float, optional
    The tolerance for two roots to be considered equal. Default is 1e-3.
rtype : {'max', 'min, 'avg'}, optional
    How to determine the returned root if multiple roots are within
    `tol` of each other.

      - 'max': pick the maximum of those roots.
      - 'min': pick the minimum of those roots.
      - 'avg': take the average of those roots.

Returns
-------
pout : ndarray
    The list of unique roots, sorted from low to high.
mult : ndarray
    The multiplicity of each root.

Notes
-----
This utility function is not specific to roots but can be used for any
sequence of values for which uniqueness and multiplicity has to be
determined. For a more general routine, see `numpy.unique`.

Examples
--------
>>> from scipy import signal
>>> vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]
>>> uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype='avg')

Check which roots have multiplicity larger than 1:

>>> uniq[mult > 1]
array([ 1.305])\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_a305117d7530b3a0ad64b8c12d3291f69}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!vectorstrength@{vectorstrength}}
\index{vectorstrength@{vectorstrength}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{vectorstrength}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+vectorstrength (
\begin{DoxyParamCaption}
\item[{}]{events, }
\item[{}]{period}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_a305117d7530b3a0ad64b8c12d3291f69}
\begin{DoxyVerb}Determine the vector strength of the events corresponding to the given
period.

The vector strength is a measure of phase synchrony, how well the
timing of the events is synchronized to a single period of a periodic
signal.

If multiple periods are used, calculate the vector strength of each.
This is called the "resonating vector strength".

Parameters
----------
events : 1D array_like
    An array of time points containing the timing of the events.
period : float or array_like
    The period of the signal that the events should synchronize to.
    The period is in the same units as `events`.  It can also be an array
    of periods, in which case the outputs are arrays of the same length.

Returns
-------
strength : float or 1D array
    The strength of the synchronization.  1.0 is perfect synchronization
    and 0.0 is no synchronization.  If `period` is an array, this is also
    an array with each element containing the vector strength at the
    corresponding period.
phase : float or array
    The phase that the events are most strongly synchronized to in radians.
    If `period` is an array, this is also an array with each element
    containing the phase for the corresponding period.

References
----------
van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector
    strength: Auditory system, electric fish, and noise.
    Chaos 21, 047508 (2011);
    doi: 10.1063/1.3670512
van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:
    biological and mathematical perspectives.  Biol Cybern.
    2013 Aug;107(4):385-96. doi: 10.1007/s00422-013-0561-7.
van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens
    when we vary the "probing" frequency while keeping the spike times
    fixed.  Biol Cybern. 2013 Aug;107(4):491-94.
    doi: 10.1007/s00422-013-0560-8
\end{DoxyVerb}
 \hypertarget{namespacescipy_1_1signal_1_1signaltools_aef763ec8579bf17ed3e8a1075ae6933f}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!wiener@{wiener}}
\index{wiener@{wiener}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{wiener}]{\setlength{\rightskip}{0pt plus 5cm}def scipy.\+signal.\+signaltools.\+wiener (
\begin{DoxyParamCaption}
\item[{}]{im, }
\item[{}]{mysize = {\ttfamily None}, }
\item[{}]{noise = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{namespacescipy_1_1signal_1_1signaltools_aef763ec8579bf17ed3e8a1075ae6933f}
\begin{DoxyVerb}Perform a Wiener filter on an N-dimensional array.

Apply a Wiener filter to the N-dimensional array `im`.

Parameters
----------
im : ndarray
    An N-dimensional array.
mysize : int or arraylike, optional
    A scalar or an N-length list giving the size of the Wiener filter
    window in each dimension.  Elements of mysize should be odd.
    If mysize is a scalar, then this scalar is used as the size
    in each dimension.
noise : float, optional
    The noise-power to use. If None, then noise is estimated as the
    average of the local variance of the input.

Returns
-------
out : ndarray
    Wiener filtered result with the same shape as `im`.\end{DoxyVerb}
 

\subsection{Variable Documentation}
\hypertarget{namespacescipy_1_1signal_1_1signaltools_a18b112c5f3754320389080c509ae3593}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+all\+\_\+\+\_\+@{\+\_\+\+\_\+all\+\_\+\+\_\+}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{\+\_\+\+\_\+all\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}list scipy.\+signal.\+signaltools.\+\_\+\+\_\+all\+\_\+\+\_\+}\label{namespacescipy_1_1signal_1_1signaltools_a18b112c5f3754320389080c509ae3593}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = [\textcolor{stringliteral}{'correlate'}, \textcolor{stringliteral}{'fftconvolve'}, \textcolor{stringliteral}{'convolve'}, \textcolor{stringliteral}{'convolve2d'}, \textcolor{stringliteral}{'correlate2d'},
2            \textcolor{stringliteral}{'order\_filter'}, \textcolor{stringliteral}{'medfilt'}, \textcolor{stringliteral}{'medfilt2d'}, \textcolor{stringliteral}{'wiener'}, \textcolor{stringliteral}{'lfilter'},
3            \textcolor{stringliteral}{'lfiltic'}, \textcolor{stringliteral}{'deconvolve'}, \textcolor{stringliteral}{'hilbert'}, \textcolor{stringliteral}{'hilbert2'}, \textcolor{stringliteral}{'cmplx\_sort'},
4            \textcolor{stringliteral}{'unique\_roots'}, \textcolor{stringliteral}{'invres'}, \textcolor{stringliteral}{'invresz'}, \textcolor{stringliteral}{'residue'}, \textcolor{stringliteral}{'residuez'},
5            \textcolor{stringliteral}{'resample'}, \textcolor{stringliteral}{'detrend'}, \textcolor{stringliteral}{'lfilter\_zi'}, \textcolor{stringliteral}{'filtfilt'}, \textcolor{stringliteral}{'decimate'},
6            \textcolor{stringliteral}{'vectorstrength'}]
\end{DoxyCode}
\hypertarget{namespacescipy_1_1signal_1_1signaltools_a8dd98af7a22a25e2c10b79108937681e}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!\+\_\+boundarydict@{\+\_\+boundarydict}}
\index{\+\_\+boundarydict@{\+\_\+boundarydict}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{\+\_\+boundarydict}]{\setlength{\rightskip}{0pt plus 5cm}dictionary scipy.\+signal.\+signaltools.\+\_\+boundarydict}\label{namespacescipy_1_1signal_1_1signaltools_a8dd98af7a22a25e2c10b79108937681e}
{\bfseries Initial value\+:}
\begin{DoxyCode}
1 = \{\textcolor{stringliteral}{'fill'}: 0, \textcolor{stringliteral}{'pad'}: 0, \textcolor{stringliteral}{'wrap'}: 2, \textcolor{stringliteral}{'circular'}: 2, \textcolor{stringliteral}{'symm'}: 1,
2                  \textcolor{stringliteral}{'symmetric'}: 1, \textcolor{stringliteral}{'reflect'}: 4\}
\end{DoxyCode}
\hypertarget{namespacescipy_1_1signal_1_1signaltools_a892a22e92c69038066cb62110ed13dab}{}\index{scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}!\+\_\+modedict@{\+\_\+modedict}}
\index{\+\_\+modedict@{\+\_\+modedict}!scipy\+::signal\+::signaltools@{scipy\+::signal\+::signaltools}}
\subsubsection[{\+\_\+modedict}]{\setlength{\rightskip}{0pt plus 5cm}dictionary scipy.\+signal.\+signaltools.\+\_\+modedict = \{'valid'\+: 0, 'same'\+: 1, 'full'\+: 2\}}\label{namespacescipy_1_1signal_1_1signaltools_a892a22e92c69038066cb62110ed13dab}
