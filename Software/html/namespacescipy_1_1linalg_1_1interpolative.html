<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.linalg.interpolative Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html">interpolative</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.linalg.interpolative Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aca9c667218677ace50bc00224f2e42ca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#aca9c667218677ace50bc00224f2e42ca">seed</a></td></tr>
<tr class="separator:aca9c667218677ace50bc00224f2e42ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89ebf29a1d595592b6495fbf642a372"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#ad89ebf29a1d595592b6495fbf642a372">rand</a></td></tr>
<tr class="separator:ad89ebf29a1d595592b6495fbf642a372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0d99cb8e077e6ed3463c1cef8af58c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a7e0d99cb8e077e6ed3463c1cef8af58c">interp_decomp</a></td></tr>
<tr class="separator:a7e0d99cb8e077e6ed3463c1cef8af58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e4297d91e2ce258ff27956302490b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a31e4297d91e2ce258ff27956302490b7">reconstruct_matrix_from_id</a></td></tr>
<tr class="separator:a31e4297d91e2ce258ff27956302490b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db48f192ba388b6d5cacafdd3d06129"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a3db48f192ba388b6d5cacafdd3d06129">reconstruct_interp_matrix</a></td></tr>
<tr class="separator:a3db48f192ba388b6d5cacafdd3d06129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c420fe02504293ddad029bc23eebe9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a98c420fe02504293ddad029bc23eebe9">reconstruct_skel_matrix</a></td></tr>
<tr class="separator:a98c420fe02504293ddad029bc23eebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6e062a7faa2169d3dc54e20ac0ea1b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a0f6e062a7faa2169d3dc54e20ac0ea1b">id_to_svd</a></td></tr>
<tr class="separator:a0f6e062a7faa2169d3dc54e20ac0ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722ea469f4b2d7c48a18da2dde6e14a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a722ea469f4b2d7c48a18da2dde6e14a5">estimate_spectral_norm</a></td></tr>
<tr class="separator:a722ea469f4b2d7c48a18da2dde6e14a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb388ccc6d3622c26aa7e99c7526c8a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a5eb388ccc6d3622c26aa7e99c7526c8a">estimate_spectral_norm_diff</a></td></tr>
<tr class="separator:a5eb388ccc6d3622c26aa7e99c7526c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ede274e125088f8db231b613a47320"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a61ede274e125088f8db231b613a47320">svd</a></td></tr>
<tr class="separator:a61ede274e125088f8db231b613a47320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbeca3cfa57ca575a66f35299dbe07d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a8fbeca3cfa57ca575a66f35299dbe07d">estimate_rank</a></td></tr>
<tr class="separator:a8fbeca3cfa57ca575a66f35299dbe07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2c56643bfab3d408976b53dc4ba6857f"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#a2c56643bfab3d408976b53dc4ba6857f">_DTYPE_ERROR</a> = ValueError(&quot;invalid <a class="el" href="constants_8h.html#a1a68120273996c880f8fd414afd17eb4">input</a> dtype (<a class="el" href="constants_8h.html#a1a68120273996c880f8fd414afd17eb4">input</a> must be float64 or complex128)&quot;)</td></tr>
<tr class="separator:a2c56643bfab3d408976b53dc4ba6857f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59bb08f7183a0e5957d8d528116ce16"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1interpolative.html#ad59bb08f7183a0e5957d8d528116ce16">_TYPE_ERROR</a> = TypeError(&quot;invalid <a class="el" href="constants_8h.html#a1a68120273996c880f8fd414afd17eb4">input</a> <a class="el" href="fftw__dct_8c.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a> (must be array or LinearOperator)&quot;)</td></tr>
<tr class="separator:ad59bb08f7183a0e5957d8d528116ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8fbeca3cfa57ca575a66f35299dbe07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.estimate_rank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate matrix rank to a specified relative precision using randomized
methods.

The matrix `A` can be given as either a :class:`numpy.ndarray` or a
:class:`scipy.sparse.linalg.LinearOperator`, with different algorithms used
for each case. If `A` is of type :class:`numpy.ndarray`, then the output
rank is typically about 8 higher than the actual numerical rank.

..  This function automatically detects the form of the input parameters and
    passes them to the appropriate backend. For details,
    see :func:`backend.idd_estrank`, :func:`backend.idd_findrank`,
    :func:`backend.idz_estrank`, and :func:`backend.idz_findrank`.

Parameters
----------
A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator`
    Matrix whose rank is to be estimated, given as either a
    :class:`numpy.ndarray` or a :class:`scipy.sparse.linalg.LinearOperator`
    with the `rmatvec` method (to apply the matrix adjoint).
eps : float
    Relative error for numerical rank definition.

Returns
-------
int
    Estimated matrix rank.
</pre> 
</div>
</div>
<a class="anchor" id="a722ea469f4b2d7c48a18da2dde6e14a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.estimate_spectral_norm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of a matrix by the randomized power method.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`backend.idd_snorm` and
    :func:`backend.idz_snorm`.

Parameters
----------
A : :class:`scipy.sparse.linalg.LinearOperator`
    Matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the
    `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).
its : int
    Number of power method iterations.

Returns
-------
float
    Spectral norm estimate.
</pre> 
</div>
</div>
<a class="anchor" id="a5eb388ccc6d3622c26aa7e99c7526c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.estimate_spectral_norm_diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of the difference of two matrices by the randomized
power method.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`backend.idd_diffsnorm` and
    :func:`backend.idz_diffsnorm`.

Parameters
----------
A : :class:`scipy.sparse.linalg.LinearOperator`
    First matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the
    `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).
B : :class:`scipy.sparse.linalg.LinearOperator`
    Second matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with
    the `matvec` and `rmatvec` methods (to apply the matrix and its adjoint).
its : int
    Number of power method iterations.

Returns
-------
float
    Spectral norm estimate of matrix difference.
</pre> 
</div>
</div>
<a class="anchor" id="a0f6e062a7faa2169d3dc54e20ac0ea1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.id_to_svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert ID to SVD.

The SVD reconstruction of a matrix with skeleton matrix `B` and ID indices and
coefficients `idx` and `proj`, respectively, is::

    U, S, V = id_to_svd(B, idx, proj)
    A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))

See also :func:`svd`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`backend.idd_id2svd` and
    :func:`backend.idz_id2svd`.

Parameters
----------
B : :class:`numpy.ndarray`
    Skeleton matrix.
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.

Returns
-------
U : :class:`numpy.ndarray`
    Left singular vectors.
S : :class:`numpy.ndarray`
    Singular values.
V : :class:`numpy.ndarray`
    Right singular vectors.
</pre> 
</div>
</div>
<a class="anchor" id="a7e0d99cb8e077e6ed3463c1cef8af58c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.interp_decomp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps_or_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rand</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a matrix.

An ID of a matrix `A` is a factorization defined by a rank `k`, a column
index array `idx`, and interpolation coefficients `proj` such that::

    numpy.dot(A[:,idx[:k]], proj) = A[:,idx[k:]]

The original matrix can then be reconstructed as::

    numpy.hstack([A[:,idx[:k]],
                                numpy.dot(A[:,idx[:k]], proj)]
                            )[:,numpy.argsort(idx)]

or via the routine :func:`reconstruct_matrix_from_id`. This can
equivalently be written as::

    numpy.dot(A[:,idx[:k]],
                        numpy.hstack([numpy.eye(k), proj])
                      )[:,np.argsort(idx)]

in terms of the skeleton and interpolation matrices::

    B = A[:,idx[:k]]

and::

    P = numpy.hstack([numpy.eye(k), proj])[:,np.argsort(idx)]

respectively. See also :func:`reconstruct_interp_matrix` and
:func:`reconstruct_skel_matrix`.

The ID can be computed to any relative precision or rank (depending on the
value of `eps_or_k`). If a precision is specified (`eps_or_k &lt; 1`), then
this function has the output signature::

    k, idx, proj = interp_decomp(A, eps_or_k)

Otherwise, if a rank is specified (`eps_or_k &gt;= 1`), then the output
signature is::

    idx, proj = interp_decomp(A, eps_or_k)

..  This function automatically detects the form of the input parameters
    and passes them to the appropriate backend. For details, see
    :func:`backend.iddp_id`, :func:`backend.iddp_aid`,
    :func:`backend.iddp_rid`, :func:`backend.iddr_id`,
    :func:`backend.iddr_aid`, :func:`backend.iddr_rid`,
    :func:`backend.idzp_id`, :func:`backend.idzp_aid`,
    :func:`backend.idzp_rid`, :func:`backend.idzr_id`,
    :func:`backend.idzr_aid`, and :func:`backend.idzr_rid`.

Parameters
----------
A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator` with `rmatvec`
    Matrix to be factored
eps_or_k : float or int
    Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of
    approximation.
rand : bool, optional
    Whether to use random sampling if `A` is of type :class:`numpy.ndarray`
    (randomized algorithms are always used if `A` is of type
    :class:`scipy.sparse.linalg.LinearOperator`).

Returns
-------
k : int
    Rank required to achieve specified relative precision if
    `eps_or_k &lt; 1`.
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.
</pre> 
</div>
</div>
<a class="anchor" id="ad89ebf29a1d595592b6495fbf642a372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.rand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate standard uniform pseudorandom numbers via a very efficient lagged
Fibonacci method.

This routine is used for all random number generation in this package and
can affect ID and SVD results.

Parameters
----------
shape
    Shape of output array</pre> 
</div>
</div>
<a class="anchor" id="a3db48f192ba388b6d5cacafdd3d06129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.reconstruct_interp_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct interpolation matrix from ID.

The interpolation matrix can be reconstructed from the ID indices and
coefficients `idx` and `proj`, respectively, as::

    P = numpy.hstack([numpy.eye(proj.shape[0]), proj])[:,numpy.argsort(idx)]

The original matrix can then be reconstructed from its skeleton matrix `B`
via::

    numpy.dot(B, P)

See also :func:`reconstruct_matrix_from_id` and
:func:`reconstruct_skel_matrix`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`backend.idd_reconint` and
    :func:`backend.idz_reconint`.

Parameters
----------
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.

Returns
-------
:class:`numpy.ndarray`
    Interpolation matrix.
</pre> 
</div>
</div>
<a class="anchor" id="a31e4297d91e2ce258ff27956302490b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.reconstruct_matrix_from_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct matrix from its ID.

A matrix `A` with skeleton matrix `B` and ID indices and coefficients `idx`
and `proj`, respectively, can be reconstructed as::

    numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)]

See also :func:`reconstruct_interp_matrix` and
:func:`reconstruct_skel_matrix`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`backend.idd_reconid` and
    :func:`backend.idz_reconid`.

Parameters
----------
B : :class:`numpy.ndarray`
    Skeleton matrix.
idx : :class:`numpy.ndarray`
    Column index array.
proj : :class:`numpy.ndarray`
    Interpolation coefficients.

Returns
-------
:class:`numpy.ndarray`
    Reconstructed matrix.
</pre> 
</div>
</div>
<a class="anchor" id="a98c420fe02504293ddad029bc23eebe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.reconstruct_skel_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct skeleton matrix from ID.

The skeleton matrix can be reconstructed from the original matrix `A` and its
ID rank and indices `k` and `idx`, respectively, as::

    B = A[:,idx[:k]]

The original matrix can then be reconstructed via::

    numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)]

See also :func:`reconstruct_matrix_from_id` and
:func:`reconstruct_interp_matrix`.

..  This function automatically detects the matrix data type and calls the
    appropriate backend. For details, see :func:`backend.idd_copycols` and
    :func:`backend.idz_copycols`.

Parameters
----------
A : :class:`numpy.ndarray`
    Original matrix.
k : int
    Rank of ID.
idx : :class:`numpy.ndarray`
    Column index array.

Returns
-------
:class:`numpy.ndarray`
    Skeleton matrix.
</pre> 
</div>
</div>
<a class="anchor" id="aca9c667218677ace50bc00224f2e42ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.seed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Seed the internal random number generator used in this ID package.

The generator is a lagged Fibonacci method with 55-element internal state.

Parameters
----------
seed : int, sequence, 'default', optional
    If 'default', the random seed is reset to a default value.

    If `seed` is a sequence containing 55 floating-point numbers
    in range [0,1], these are used to set the internal state of
    the generator.

    If the value is an integer, the internal state is obtained
    from `numpy.random.RandomState` (MT19937) with the integer
    used as the initial seed.

    If `seed` is omitted (None), `numpy.random` is used to
    initialize the generator.</pre> 
</div>
</div>
<a class="anchor" id="a61ede274e125088f8db231b613a47320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg.interpolative.svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps_or_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rand</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a matrix via an ID.

An SVD of a matrix `A` is a factorization::

    A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))

where `U` and `V` have orthonormal columns and `S` is nonnegative.

The SVD can be computed to any relative precision or rank (depending on the
value of `eps_or_k`).

See also :func:`interp_decomp` and :func:`id_to_svd`.

..  This function automatically detects the form of the input parameters and
    passes them to the appropriate backend. For details, see
    :func:`backend.iddp_svd`, :func:`backend.iddp_asvd`,
    :func:`backend.iddp_rsvd`, :func:`backend.iddr_svd`,
    :func:`backend.iddr_asvd`, :func:`backend.iddr_rsvd`,
    :func:`backend.idzp_svd`, :func:`backend.idzp_asvd`,
    :func:`backend.idzp_rsvd`, :func:`backend.idzr_svd`,
    :func:`backend.idzr_asvd`, and :func:`backend.idzr_rsvd`.

Parameters
----------
A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator`
    Matrix to be factored, given as either a :class:`numpy.ndarray` or a
    :class:`scipy.sparse.linalg.LinearOperator` with the `matvec` and
    `rmatvec` methods (to apply the matrix and its adjoint).
eps_or_k : float or int
    Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of
    approximation.
rand : bool, optional
    Whether to use random sampling if `A` is of type :class:`numpy.ndarray`
    (randomized algorithms are always used if `A` is of type
    :class:`scipy.sparse.linalg.LinearOperator`).

Returns
-------
U : :class:`numpy.ndarray`
    Left singular vectors.
S : :class:`numpy.ndarray`
    Singular values.
V : :class:`numpy.ndarray`
    Right singular vectors.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a2c56643bfab3d408976b53dc4ba6857f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.linalg.interpolative._DTYPE_ERROR = ValueError(&quot;invalid <a class="el" href="constants_8h.html#a1a68120273996c880f8fd414afd17eb4">input</a> dtype (<a class="el" href="constants_8h.html#a1a68120273996c880f8fd414afd17eb4">input</a> must be float64 or complex128)&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad59bb08f7183a0e5957d8d528116ce16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.linalg.interpolative._TYPE_ERROR = TypeError(&quot;invalid <a class="el" href="constants_8h.html#a1a68120273996c880f8fd414afd17eb4">input</a> <a class="el" href="fftw__dct_8c.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a> (must be array or LinearOperator)&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:12 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
