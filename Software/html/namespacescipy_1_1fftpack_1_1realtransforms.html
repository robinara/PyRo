<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.fftpack.realtransforms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1fftpack.html">fftpack</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html">realtransforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.fftpack.realtransforms Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a76672c2a5542cad3c7bafb9214207888"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a76672c2a5542cad3c7bafb9214207888">dct</a></td></tr>
<tr class="separator:a76672c2a5542cad3c7bafb9214207888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f8de358ca45ab64b0810b4160402c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a90f8de358ca45ab64b0810b4160402c9">idct</a></td></tr>
<tr class="separator:a90f8de358ca45ab64b0810b4160402c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b625068c8ca210c932d6d260e093b3e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a4b625068c8ca210c932d6d260e093b3e">dst</a></td></tr>
<tr class="separator:a4b625068c8ca210c932d6d260e093b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0ae30a12dec902a76522a5f01ce1ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#acc0ae30a12dec902a76522a5f01ce1ed">idst</a></td></tr>
<tr class="separator:acc0ae30a12dec902a76522a5f01ce1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa4bca32192554733abe6d839cc8cfa5e"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#aa4bca32192554733abe6d839cc8cfa5e">__all__</a> = ['<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a76672c2a5542cad3c7bafb9214207888">dct</a>', '<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a90f8de358ca45ab64b0810b4160402c9">idct</a>', '<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a4b625068c8ca210c932d6d260e093b3e">dst</a>', '<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#acc0ae30a12dec902a76522a5f01ce1ed">idst</a>']</td></tr>
<tr class="separator:aa4bca32192554733abe6d839cc8cfa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Real spectrum tranforms (DCT, DST, MDCT)
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a76672c2a5542cad3c7bafb9214207888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.fftpack.realtransforms.dct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_x</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Discrete Cosine Transform of arbitrary type sequence x.

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DCT (see Notes). Default type is 2.
n : int, optional
    Length of the transform.
axis : int, optional
    Axis over which to compute the transform.
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True the contents of x can be destroyed. (default=False)

Returns
-------
y : ndarray of real
    The transformed input array.

See Also
--------
idct : Inverse DCT

Notes
-----
For a single dimension array ``x``, ``dct(x, norm='ortho')`` is equal to
MATLAB ``dct(x)``.

There are theoretically 8 types of the DCT, only the first 3 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.

**Type I**

There are several definitions of the DCT-I; we use the following
(for ``norm=None``)::

                                     N-2
  y[k] = x[0] + (-1)**k x[N-1] + 2 * sum x[n]*cos(pi*k*n/(N-1))
                                     n=1

Only None is supported as normalization mode for DCT-I. Note also that the
DCT-I is only supported for input size &gt; 1

**Type II**

There are several definitions of the DCT-II; we use the following
(for ``norm=None``)::


            N-1
  y[k] = 2* sum x[n]*cos(pi*k*(2n+1)/(2*N)), 0 &lt;= k &lt; N.
            n=0

If ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor `f`::

  f = sqrt(1/(4*N)) if k = 0,
  f = sqrt(1/(2*N)) otherwise.

Which makes the corresponding matrix of coefficients orthonormal
(``OO' = Id``).

**Type III**

There are several definitions, we use the following
(for ``norm=None``)::

                    N-1
  y[k] = x[0] + 2 * sum x[n]*cos(pi*(k+0.5)*n/N), 0 &lt;= k &lt; N.
                    n=1

or, for ``norm='ortho'`` and 0 &lt;= k &lt; N::

                                      N-1
  y[k] = x[0] / sqrt(N) + sqrt(2/N) * sum x[n]*cos(pi*(k+0.5)*n/N)
                                      n=1

The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor `2N`. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.

References
----------
.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
       Makhoul, `IEEE Transactions on acoustics, speech and signal
       processing` vol. 28(1), pp. 27-34,
       http://dx.doi.org/10.1109/TASSP.1980.1163351 (1980).
.. [2] Wikipedia, "Discrete cosine transform",
       http://en.wikipedia.org/wiki/Discrete_cosine_transform

Examples
--------
The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:

&gt;&gt;&gt; fft(array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
&gt;&gt;&gt; dct(array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</pre> 
</div>
</div>
<a class="anchor" id="a4b625068c8ca210c932d6d260e093b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.fftpack.realtransforms.dst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_x</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Discrete Sine Transform of arbitrary type sequence x.

.. versionadded:: 0.11.0

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DST (see Notes). Default type is 2.
n : int, optional
    Length of the transform.
axis : int, optional
    Axis over which to compute the transform.
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True the contents of x can be destroyed. (default=False)

Returns
-------
dst : ndarray of reals
    The transformed input array.

See Also
--------
idst : Inverse DST

Notes
-----
For a single dimension array ``x``.

There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
3 types are implemented in scipy.

**Type I**

There are several definitions of the DST-I; we use the following
for ``norm=None``.  DST-I assumes the input is odd around n=-1 and n=N. ::

             N-1
  y[k] = 2 * sum x[n]*sin(pi*(k+1)*(n+1)/(N+1))
             n=0

Only None is supported as normalization mode for DCT-I. Note also that the
DCT-I is only supported for input size &gt; 1
The (unnormalized) DCT-I is its own inverse, up to a factor `2(N+1)`.

**Type II**

There are several definitions of the DST-II; we use the following
for ``norm=None``.  DST-II assumes the input is odd around n=-1/2 and
n=N-1/2; the output is odd around k=-1 and even around k=N-1 ::

            N-1
  y[k] = 2* sum x[n]*sin(pi*(k+1)*(n+0.5)/N), 0 &lt;= k &lt; N.
            n=0

if ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor `f` ::

    f = sqrt(1/(4*N)) if k == 0
    f = sqrt(1/(2*N)) otherwise.

**Type III**

There are several definitions of the DST-III, we use the following
(for ``norm=None``).  DST-III assumes the input is odd around n=-1
and even around n=N-1 ::

                             N-2
  y[k] = x[N-1]*(-1)**k + 2* sum x[n]*sin(pi*(k+0.5)*(n+1)/N), 0 &lt;= k &lt; N.
                             n=0

The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor `2N`.  The orthonormalized DST-III is exactly the inverse of
the orthonormalized DST-II.

References
----------
.. [1] Wikipedia, "Discrete sine transform",
       http://en.wikipedia.org/wiki/Discrete_sine_transform</pre> 
</div>
</div>
<a class="anchor" id="a90f8de358ca45ab64b0810b4160402c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.fftpack.realtransforms.idct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_x</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DCT (see Notes). Default type is 2.
n : int, optional
    Length of the transform.
axis : int, optional
    Axis over which to compute the transform.
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True the contents of x can be destroyed. (default=False)

Returns
-------
idct : ndarray of real
    The transformed input array.

See Also
--------
dct : Forward DCT

Notes
-----
For a single dimension array `x`, ``idct(x, norm='ortho')`` is equal to
MATLAB ``idct(x)``.

'The' IDCT is the IDCT of type 2, which is the same as DCT of type 3.

IDCT of type 1 is the DCT of type 1, IDCT of type 2 is the DCT of type
3, and IDCT of type 3 is the DCT of type 2. For the definition of these
types, see `dct`.

Examples
--------
The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:

&gt;&gt;&gt; ifft(array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
&gt;&gt;&gt; idct(array([ 30.,  -8.,   6.,  -2.]), 1) / 6
array([  4.,   3.,   5.,  10.])</pre> 
</div>
</div>
<a class="anchor" id="acc0ae30a12dec902a76522a5f01ce1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.fftpack.realtransforms.idst </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_x</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Inverse Discrete Sine Transform of an arbitrary type sequence.

.. versionadded:: 0.11.0

Parameters
----------
x : array_like
    The input array.
type : {1, 2, 3}, optional
    Type of the DST (see Notes). Default type is 2.
n : int, optional
    Length of the transform.
axis : int, optional
    Axis over which to compute the transform.
norm : {None, 'ortho'}, optional
    Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
    If True the contents of x can be destroyed. (default=False)

Returns
-------
idst : ndarray of real
    The transformed input array.

See Also
--------
dst : Forward DST

Notes
-----
'The' IDST is the IDST of type 2, which is the same as DST of type 3.

IDST of type 1 is the DST of type 1, IDST of type 2 is the DST of type
3, and IDST of type 3 is the DST of type 2. For the definition of these
types, see `dst`.</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aa4bca32192554733abe6d839cc8cfa5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.fftpack.realtransforms.__all__ = ['<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a76672c2a5542cad3c7bafb9214207888">dct</a>', '<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a90f8de358ca45ab64b0810b4160402c9">idct</a>', '<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#a4b625068c8ca210c932d6d260e093b3e">dst</a>', '<a class="el" href="namespacescipy_1_1fftpack_1_1realtransforms.html#acc0ae30a12dec902a76522a5f01ce1ed">idst</a>']</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:26:55 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
