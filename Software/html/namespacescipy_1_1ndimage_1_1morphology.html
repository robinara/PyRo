<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.ndimage.morphology Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1ndimage.html">ndimage</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html">morphology</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.ndimage.morphology Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a243de7395c0bb4289df930f188c83dac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a243de7395c0bb4289df930f188c83dac">iterate_structure</a></td></tr>
<tr class="separator:a243de7395c0bb4289df930f188c83dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922ee701102af4c8ec474616de017af3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a922ee701102af4c8ec474616de017af3">generate_binary_structure</a></td></tr>
<tr class="separator:a922ee701102af4c8ec474616de017af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c8293c1bd5bfea8af1bf3af3628a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#ae73c8293c1bd5bfea8af1bf3af3628a7">binary_erosion</a></td></tr>
<tr class="separator:ae73c8293c1bd5bfea8af1bf3af3628a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4833d1652c340012546d6ffee4f1a19c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a4833d1652c340012546d6ffee4f1a19c">binary_dilation</a></td></tr>
<tr class="separator:a4833d1652c340012546d6ffee4f1a19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab260e60f50d14fcc0398ed5c942acea7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#ab260e60f50d14fcc0398ed5c942acea7">binary_opening</a></td></tr>
<tr class="separator:ab260e60f50d14fcc0398ed5c942acea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c44029fb38a136a4857e1bd8b2e9e4b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a1c44029fb38a136a4857e1bd8b2e9e4b">binary_closing</a></td></tr>
<tr class="separator:a1c44029fb38a136a4857e1bd8b2e9e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d48edbebc30cabfbbe38d0b1aed23f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a74d48edbebc30cabfbbe38d0b1aed23f">binary_hit_or_miss</a></td></tr>
<tr class="separator:a74d48edbebc30cabfbbe38d0b1aed23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da493a296e56ae34ad6c24e19596694"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a1da493a296e56ae34ad6c24e19596694">binary_propagation</a></td></tr>
<tr class="separator:a1da493a296e56ae34ad6c24e19596694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2524bac6b2cef8e396c6df2207003e46"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a2524bac6b2cef8e396c6df2207003e46">binary_fill_holes</a></td></tr>
<tr class="separator:a2524bac6b2cef8e396c6df2207003e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a7684ebf91074d01d01a21c8c1e3fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#aa5a7684ebf91074d01d01a21c8c1e3fe">grey_erosion</a></td></tr>
<tr class="separator:aa5a7684ebf91074d01d01a21c8c1e3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2797039bf4c5ecf1c5325486d2d2a9a3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a2797039bf4c5ecf1c5325486d2d2a9a3">grey_dilation</a></td></tr>
<tr class="separator:a2797039bf4c5ecf1c5325486d2d2a9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c94356038bb7c8160c0ebbe9961865"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#ad2c94356038bb7c8160c0ebbe9961865">grey_opening</a></td></tr>
<tr class="separator:ad2c94356038bb7c8160c0ebbe9961865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca27b5c4bf8c5f31da94b6fe9ed84618"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#aca27b5c4bf8c5f31da94b6fe9ed84618">grey_closing</a></td></tr>
<tr class="separator:aca27b5c4bf8c5f31da94b6fe9ed84618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b250101c90d40b2de24bbafe9e456a8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a6b250101c90d40b2de24bbafe9e456a8">morphological_gradient</a></td></tr>
<tr class="separator:a6b250101c90d40b2de24bbafe9e456a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7616378b49db68c1226516a3cab54adf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a7616378b49db68c1226516a3cab54adf">morphological_laplace</a></td></tr>
<tr class="separator:a7616378b49db68c1226516a3cab54adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c956aece0670c09720de47ca8d9203"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a50c956aece0670c09720de47ca8d9203">white_tophat</a></td></tr>
<tr class="separator:a50c956aece0670c09720de47ca8d9203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e8af16251eeec0f7b62be209932d39"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a56e8af16251eeec0f7b62be209932d39">black_tophat</a></td></tr>
<tr class="separator:a56e8af16251eeec0f7b62be209932d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64dbb993fb6557a0689c6cad2efe85c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#af64dbb993fb6557a0689c6cad2efe85c">distance_transform_bf</a></td></tr>
<tr class="separator:af64dbb993fb6557a0689c6cad2efe85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd735f088e7d13288ba9d0c6da58b3e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a4bd735f088e7d13288ba9d0c6da58b3e">distance_transform_cdt</a></td></tr>
<tr class="separator:a4bd735f088e7d13288ba9d0c6da58b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bbbdb599ff1793aa9a4a4141e2953c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a95bbbdb599ff1793aa9a4a4141e2953c">distance_transform_edt</a></td></tr>
<tr class="separator:a95bbbdb599ff1793aa9a4a4141e2953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a51ef986225fadb5aa25aa062dba80eea"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1ndimage_1_1morphology.html#a51ef986225fadb5aa25aa062dba80eea">__all__</a></td></tr>
<tr class="separator:a51ef986225fadb5aa25aa062dba80eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1c44029fb38a136a4857e1bd8b2e9e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.binary_closing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional binary closing with the given structuring element.

The *closing* of an input image by a structuring element is the
*erosion* of the *dilation* of the image by the structuring element.

Parameters
----------
input : array_like
    Binary array_like to be closed. Non-zero (True) elements form
    the subset to be closed.
structure : array_like, optional
    Structuring element used for the closing. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one (i.e., only
    nearest neighbors are connected to the center, diagonally-connected
    elements are not considered neighbors).
iterations : {int, float}, optional
    The dilation step of the closing, then the erosion step are each
    repeated `iterations` times (one, by default). If iterations is
    less than 1, each operations is repeated until the result does
    not change anymore.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.

Returns
-------
binary_closing : ndarray of bools
    Closing of the input by the structuring element.

See also
--------
grey_closing, binary_opening, binary_dilation, binary_erosion,
generate_binary_structure

Notes
-----
*Closing* [1]_ is a mathematical morphology operation [2]_ that
consists in the succession of a dilation and an erosion of the
input with the same structuring element. Closing therefore fills
holes smaller than the structuring element.

Together with *opening* (`binary_opening`), closing can be used for
noise removal.

References
----------
.. [1] http://en.wikipedia.org/wiki/Closing_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((5,5), dtype=np.int)
&gt;&gt;&gt; a[1:-1, 1:-1] = 1; a[2,2] = 0
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Closing removes small holes
&gt;&gt;&gt; ndimage.binary_closing(a).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Closing is the erosion of the dilation of the input
&gt;&gt;&gt; ndimage.binary_dilation(a).astype(np.int)
array([[0, 1, 1, 1, 0],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [0, 1, 1, 1, 0]])
&gt;&gt;&gt; ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])


&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1:6, 2:5] = 1; a[1:3,3] = 0
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; # In addition to removing holes, closing can also
&gt;&gt;&gt; # coarsen boundaries with fine hollows.
&gt;&gt;&gt; ndimage.binary_closing(a).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_closing(a, structure=np.ones((2,2))).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a4833d1652c340012546d6ffee4f1a19c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.binary_dilation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>border_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>brute_force</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional binary dilation with the given structuring element.

Parameters
----------
input : array_like
    Binary array_like to be dilated. Non-zero (True) elements form
    the subset to be dilated.
structure : array_like, optional
    Structuring element used for the dilation. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one.
iterations : {int, float}, optional
    The dilation is repeated `iterations` times (one, by default).
    If iterations is less than 1, the dilation is repeated until the
    result does not change anymore.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
border_value : int (cast to 0 or 1)
    Value at the border in the output array.

Returns
-------
binary_dilation : ndarray of bools
    Dilation of the input by the structuring element.

See also
--------
grey_dilation, binary_erosion, binary_closing, binary_opening,
generate_binary_structure

Notes
-----
Dilation [1]_ is a mathematical morphology operation [2]_ that uses a
structuring element for expanding the shapes in an image. The binary
dilation of an image by a structuring element is the locus of the points
covered by the structuring element, when its center lies within the
non-zero points of the image.

References
----------
.. [1] http://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((5, 5))
&gt;&gt;&gt; a[2, 2] = 1
&gt;&gt;&gt; a
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(a)
array([[False, False, False, False, False],
       [False, False,  True, False, False],
       [False,  True,  True,  True, False],
       [False, False,  True, False, False],
       [False, False, False, False, False]], dtype=bool)
&gt;&gt;&gt; ndimage.binary_dilation(a).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; # 3x3 structuring element with connectivity 1, used by default
&gt;&gt;&gt; struct1 = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; struct1
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; # 3x3 structuring element with connectivity 2
&gt;&gt;&gt; struct2 = ndimage.generate_binary_structure(2, 2)
&gt;&gt;&gt; struct2
array([[ True,  True,  True],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
&gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct2).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1,\\
... iterations=2).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 1.,  1.,  1.,  1.,  1.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.]])</pre> 
</div>
</div>
<a class="anchor" id="ae73c8293c1bd5bfea8af1bf3af3628a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.binary_erosion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>border_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>brute_force</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional binary erosion with a given structuring element.

Binary erosion is a mathematical morphology operation used for image
processing.

Parameters
----------
input : array_like
    Binary image to be eroded. Non-zero (True) elements form
    the subset to be eroded.
structure : array_like, optional
    Structuring element used for the erosion. Non-zero elements are
    considered True. If no structuring element is provided, an element
    is generated with a square connectivity equal to one.
iterations : {int, float}, optional
    The erosion is repeated `iterations` times (one, by default).
    If iterations is less than 1, the erosion is repeated until the
    result does not change anymore.
mask : array_like, optional
    If a mask is given, only those elements with a True value at
    the corresponding mask element are modified at each iteration.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.
border_value : int (cast to 0 or 1)
    Value at the border in the output array.

Returns
-------
binary_erosion : ndarray of bools
    Erosion of the input by the structuring element.

See also
--------
grey_erosion, binary_dilation, binary_closing, binary_opening,
generate_binary_structure

Notes
-----
Erosion [1]_ is a mathematical morphology operation [2]_ that uses a
structuring element for shrinking the shapes in an image. The binary
erosion of an image by a structuring element is the locus of the points
where a superimposition of the structuring element centered on the point
is entirely contained in the set of non-zero elements of the image.

References
----------
.. [1] http://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1:6, 2:5] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_erosion(a).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; #Erosion removes objects smaller than the structure
&gt;&gt;&gt; ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a2524bac6b2cef8e396c6df2207003e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.binary_fill_holes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fill the holes in binary objects.


Parameters
----------
input : array_like
    n-dimensional binary array with holes to be filled
structure : array_like, optional
    Structuring element used in the computation; large-size elements
    make computations faster but may miss holes separated from the
    background by thin regions. The default element (with a square
    connectivity equal to one) yields the intuitive result where all
    holes in the input have been filled.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int, tuple of ints, optional
    Position of the structuring element.

Returns
-------
out : ndarray
    Transformation of the initial image `input` where holes have been
    filled.

See also
--------
binary_dilation, binary_propagation, label

Notes
-----
The algorithm used in this function consists in invading the complementary
of the shapes in `input` from the outer boundary of the image,
using binary dilations. Holes are not connected to the boundary and are
therefore not invaded. The result is the complementary subset of the
invaded region.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology


Examples
--------
&gt;&gt;&gt; a = np.zeros((5, 5), dtype=int)
&gt;&gt;&gt; a[1:4, 1:4] = 1
&gt;&gt;&gt; a[2,2] = 0
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_fill_holes(a).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Too big structuring element
&gt;&gt;&gt; ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a74d48edbebc30cabfbbe38d0b1aed23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.binary_hit_or_miss </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure1</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure2</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin2</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional binary hit-or-miss transform.

The hit-or-miss transform finds the locations of a given pattern
inside the input image.

Parameters
----------
input : array_like (cast to booleans)
    Binary image where a pattern is to be detected.
structure1 : array_like (cast to booleans), optional
    Part of the structuring element to be fitted to the foreground
    (non-zero elements) of `input`. If no value is provided, a
    structure of square connectivity 1 is chosen.
structure2 : array_like (cast to booleans), optional
    Second part of the structuring element that has to miss completely
    the foreground. If no value is provided, the complementary of
    `structure1` is taken.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin1 : int or tuple of ints, optional
    Placement of the first part of the structuring element `structure1`,
    by default 0 for a centered structure.
origin2 : int or tuple of ints, optional
    Placement of the second part of the structuring element `structure2`,
    by default 0 for a centered structure. If a value is provided for
    `origin1` and not for `origin2`, then `origin2` is set to `origin1`.

Returns
-------
binary_hit_or_miss : ndarray
    Hit-or-miss transform of `input` with the given structuring
    element (`structure1`, `structure2`).

See also
--------
ndimage.morphology, binary_erosion

References
----------
.. [1] http://en.wikipedia.org/wiki/Hit-or-miss_transform

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0],
       [0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])
&gt;&gt;&gt; structure1
array([[1, 0, 0],
       [0, 1, 1],
       [0, 1, 1]])
&gt;&gt;&gt; # Find the matches of structure1 in the array a
&gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Change the origin of the filter
&gt;&gt;&gt; # origin1=1 is equivalent to origin1=(1,1) here
&gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1,\\
... origin1=1).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="ab260e60f50d14fcc0398ed5c942acea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.binary_opening </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional binary opening with the given structuring element.

The *opening* of an input image by a structuring element is the
*dilation* of the *erosion* of the image by the structuring element.

Parameters
----------
input : array_like
    Binary array_like to be opened. Non-zero (True) elements form
    the subset to be opened.
structure : array_like, optional
    Structuring element used for the opening. Non-zero elements are
    considered True. If no structuring element is provided an element
    is generated with a square connectivity equal to one (i.e., only
    nearest neighbors are connected to the center, diagonally-connected
    elements are not considered neighbors).
iterations : {int, float}, optional
    The erosion step of the opening, then the dilation step are each
    repeated `iterations` times (one, by default). If `iterations` is
    less than 1, each operation is repeated until the result does
    not change anymore.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.

Returns
-------
binary_opening : ndarray of bools
    Opening of the input by the structuring element.

See also
--------
grey_opening, binary_closing, binary_erosion, binary_dilation,
generate_binary_structure

Notes
-----
*Opening* [1]_ is a mathematical morphology operation [2]_ that
consists in the succession of an erosion and a dilation of the
input with the same structuring element. Opening therefore removes
objects smaller than the structuring element.

Together with *closing* (`binary_closing`), opening can be used for
noise removal.

References
----------
.. [1] http://en.wikipedia.org/wiki/Opening_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((5,5), dtype=np.int)
&gt;&gt;&gt; a[1:4, 1:4] = 1; a[4, 4] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 1]])
&gt;&gt;&gt; # Opening removes small objects
&gt;&gt;&gt; ndimage.binary_opening(a, structure=np.ones((3,3))).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Opening can also smooth corners
&gt;&gt;&gt; ndimage.binary_opening(a).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; # Opening is the dilation of the erosion of the input
&gt;&gt;&gt; ndimage.binary_erosion(a).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(np.int)
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a1da493a296e56ae34ad6c24e19596694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.binary_propagation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>border_value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional binary propagation with the given structuring element.

Parameters
----------
input : array_like
    Binary image to be propagated inside `mask`.
structure : array_like
    Structuring element used in the successive dilations. The output
    may depend on the structuring element, especially if `mask` has
    several connex components. If no structuring element is
    provided, an element is generated with a squared connectivity equal
    to one.
mask : array_like
    Binary mask defining the region into which `input` is allowed to
    propagate.
output : ndarray, optional
    Array of the same shape as input, into which the output is placed.
    By default, a new array is created.
origin : int or tuple of ints, optional
    Placement of the filter, by default 0.

Returns
-------
binary_propagation : ndarray
    Binary propagation of `input` inside `mask`.

Notes
-----
This function is functionally equivalent to calling binary_dilation
with the number of iterations less then one: iterative dilation until
the result does not change anymore.

The succession of an erosion and propagation inside the original image
can be used instead of an *opening* for deleting small objects while
keeping the contours of larger objects untouched.

References
----------
.. [1] http://cmm.ensmp.fr/~serra/cours/pdf/en/ch6en.pdf, slide 15.
.. [2] http://www.qi.tnw.tudelft.nl/Courses/FIP/noframes/fip-Morpholo.html#Heading102

Examples
--------
&gt;&gt;&gt; input = np.zeros((8, 8), dtype=np.int)
&gt;&gt;&gt; input[2, 2] = 1
&gt;&gt;&gt; mask = np.zeros((8, 8), dtype=np.int)
&gt;&gt;&gt; mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1
&gt;&gt;&gt; input
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; mask
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 1],
       [0, 0, 0, 0, 0, 0, 1, 1]])
&gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask,\\
... structure=np.ones((3,3))).astype(np.int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]])

&gt;&gt;&gt; # Comparison between opening and erosion+propagation
&gt;&gt;&gt; a = np.zeros((6,6), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1; a[0, 0] = 1; a[5, 5] = 1
&gt;&gt;&gt; a
array([[1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 1]])
&gt;&gt;&gt; ndimage.binary_opening(a).astype(np.int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; b = ndimage.binary_erosion(a)
&gt;&gt;&gt; b.astype(int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.binary_propagation(b, mask=a).astype(np.int)
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a56e8af16251eeec0f7b62be209932d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.black_tophat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional black tophat filter.

Parameters
----------
input : array_like
    Input.
size : tuple of ints
    Shape of a flat and full structuring element used for the filter.
    Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the black tophat filter.
structure : array of ints, optional
    Structuring element used for the filter. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
black_tophat : ndarray
    Result of the filter of `input` with `structure`.

See also
--------
white_tophat, grey_opening, grey_closing</pre> 
</div>
</div>
<a class="anchor" id="af64dbb993fb6557a0689c6cad2efe85c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.distance_transform_bf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>&quot;euclidean&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sampling</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_distances</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_indices</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Distance transform function by a brute force algorithm.

This function calculates the distance transform of the `input`, by
replacing each background element (zero values), with its
shortest distance to the foreground (any element non-zero).

In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.

Parameters
----------
input : array_like
    Input
metric : str, optional
    Three types of distance metric are supported: 'euclidean', 'taxicab'
    and 'chessboard'.
sampling : {int, sequence of ints}, optional
    This parameter is only used in the case of the euclidean `metric`
    distance transform.

    The sampling along each axis can be given by the `sampling` parameter
    which should be a sequence of length equal to the input rank, or a
    single number in which the `sampling` is assumed to be equal along all
    axes.
return_distances : bool, optional
    The `return_distances` flag can be used to indicate if the distance
    transform is returned.

    The default is True.
return_indices : bool, optional
    The `return_indices` flags can be used to indicate if the feature
    transform is returned.

    The default is False.
distances : float64 ndarray, optional
    Optional output array to hold distances (if `return_distances` is
    True).
indices : int64 ndarray, optional
    Optional output array to hold indices (if `return_indices` is True).

Returns
-------
distances : ndarray
    Distance array if `return_distances` is True.
indices : ndarray
    Indices array if `return_indices` is True.

Notes
-----
This function employs a slow brute force algorithm, see also the
function distance_transform_cdt for more efficient taxicab and
chessboard algorithms.</pre> 
</div>
</div>
<a class="anchor" id="a4bd735f088e7d13288ba9d0c6da58b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.distance_transform_cdt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>'chessboard'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_distances</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_indices</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Distance transform for chamfer type of transforms.

Parameters
----------
input : array_like
    Input
metric : {'chessboard', 'taxicab'}, optional
    The `metric` determines the type of chamfering that is done. If the
    `metric` is equal to 'taxicab' a structure is generated using
    generate_binary_structure with a squared distance equal to 1. If
    the `metric` is equal to 'chessboard', a `metric` is generated
    using generate_binary_structure with a squared distance equal to
    the dimensionality of the array. These choices correspond to the
    common interpretations of the 'taxicab' and the 'chessboard'
    distance metrics in two dimensions.

    The default for `metric` is 'chessboard'.
return_distances, return_indices : bool, optional
    The `return_distances`, and `return_indices` flags can be used to
    indicate if the distance transform, the feature transform, or both
    must be returned.

    If the feature transform is returned (``return_indices=True``),
    the index of the closest background element is returned along
    the first axis of the result.

    The `return_distances` default is True, and the
    `return_indices` default is False.
distances, indices : ndarrays of int32, optional
    The `distances` and `indices` arguments can be used to give optional
    output arrays that must be the same shape as `input`.</pre> 
</div>
</div>
<a class="anchor" id="a95bbbdb599ff1793aa9a4a4141e2953c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.distance_transform_edt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sampling</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_distances</em> = <code><a class="el" href="libqhull_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_indices</em> = <code><a class="el" href="libqhull_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Exact euclidean distance transform.

In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.

Parameters
----------
input : array_like
    Input data to transform. Can be any type but will be converted
    into binary: 1 wherever input equates to True, 0 elsewhere.
sampling : float or int, or sequence of same, optional
    Spacing of elements along each dimension. If a sequence, must be of
    length equal to the input rank; if a single number, this is used for
    all axes. If not specified, a grid spacing of unity is implied.
return_distances : bool, optional
    Whether to return distance matrix. At least one of
    return_distances/return_indices must be True. Default is True.
return_indices : bool, optional
    Whether to return indices matrix. Default is False.
distance : ndarray, optional
    Used for output of distance array, must be of type float64.
indices : ndarray, optional
    Used for output of indices, must be of type int32.

Returns
-------
distance_transform_edt : ndarray or list of ndarrays
    Either distance matrix, index matrix, or a list of the two,
    depending on `return_x` flags and `distance` and `indices`
    input parameters.

Notes
-----
The euclidean distance transform gives values of the euclidean
distance::

                n
  y_i = sqrt(sum (x[i]-b[i])**2)
                i

where b[i] is the background point (value 0) with the smallest
Euclidean distance to input points x[i], and n is the
number of dimensions.

Examples
--------
&gt;&gt;&gt; a = np.array(([0,1,1,1,1],
                  [0,0,1,1,1],
                  [0,1,1,1,1],
                  [0,1,1,1,0],
                  [0,1,1,0,0]))
&gt;&gt;&gt; from scipy import ndimage
&gt;&gt;&gt; ndimage.distance_transform_edt(a)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
       [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
       [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])

With a sampling of 2 units along x, 1 along y:

&gt;&gt;&gt; ndimage.distance_transform_edt(a, sampling=[2,1])
array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],
       [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],
       [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])

Asking for indices as well:

&gt;&gt;&gt; edt, inds = ndimage.distance_transform_edt(a, return_indices=True)
&gt;&gt;&gt; inds
array([[[0, 0, 1, 1, 3],
        [1, 1, 1, 1, 3],
        [2, 2, 1, 3, 3],
        [3, 3, 4, 4, 3],
        [4, 4, 4, 4, 4]],
       [[0, 0, 1, 1, 4],
        [0, 1, 1, 1, 4],
        [0, 0, 1, 4, 4],
        [0, 0, 3, 3, 4],
        [0, 0, 3, 3, 4]]])

With arrays provided for inplace outputs:

&gt;&gt;&gt; indices = np.zeros(((np.ndim(a),) + a.shape), dtype=np.int32)
&gt;&gt;&gt; ndimage.distance_transform_edt(a, return_indices=True, indices=indices)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
       [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
       [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
       [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
       [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])
&gt;&gt;&gt; indices
array([[[0, 0, 1, 1, 3],
        [1, 1, 1, 1, 3],
        [2, 2, 1, 3, 3],
        [3, 3, 4, 4, 3],
        [4, 4, 4, 4, 4]],
       [[0, 0, 1, 1, 4],
        [0, 1, 1, 1, 4],
        [0, 0, 1, 4, 4],
        [0, 0, 3, 3, 4],
        [0, 0, 3, 3, 4]]])</pre> 
</div>
</div>
<a class="anchor" id="a922ee701102af4c8ec474616de017af3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.generate_binary_structure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a binary structure for binary morphological operations.

Parameters
----------
rank : int
     Number of dimensions of the array to which the structuring element
     will be applied, as returned by `np.ndim`.
connectivity : int
     `connectivity` determines which elements of the output array belong
     to the structure, i.e. are considered as neighbors of the central
     element. Elements up to a squared distance of `connectivity` from
     the center are considered neighbors. `connectivity` may range from 1
     (no diagonal elements are neighbors) to `rank` (all elements are
     neighbors).

Returns
-------
output : ndarray of bools
     Structuring element which may be used for binary morphological
     operations, with `rank` dimensions and all dimensions equal to 3.

See also
--------
iterate_structure, binary_dilation, binary_erosion

Notes
-----
`generate_binary_structure` can only create structuring elements with
dimensions equal to 3, i.e. minimal dimensions. For larger structuring
elements, that are useful e.g. for eroding large objects, one may either
use   `iterate_structure`, or create directly custom arrays with
numpy functions such as `numpy.ones`.

Examples
--------
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; struct
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; a = np.zeros((5,5))
&gt;&gt;&gt; a[2, 2] = 1
&gt;&gt;&gt; a
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype)
&gt;&gt;&gt; b
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
&gt;&gt;&gt; ndimage.binary_dilation(b, structure=struct).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 1.,  1.,  1.,  1.,  1.],
       [ 0.,  1.,  1.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.]])
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 2)
&gt;&gt;&gt; struct
array([[ True,  True,  True],
       [ True,  True,  True],
       [ True,  True,  True]], dtype=bool)
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(3, 1)
&gt;&gt;&gt; struct # no diagonal elements
array([[[False, False, False],
        [False,  True, False],
        [False, False, False]],
       [[False,  True, False],
        [ True,  True,  True],
        [False,  True, False]],
       [[False, False, False],
        [False,  True, False],
        [False, False, False]]], dtype=bool)</pre> 
</div>
</div>
<a class="anchor" id="aca27b5c4bf8c5f31da94b6fe9ed84618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.grey_closing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional greyscale closing.

A greyscale closing consists in the succession of a greyscale dilation,
and a greyscale erosion.

Parameters
----------
input : array_like
    Array over which the grayscale closing is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    closing. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale closing.
structure : array of ints, optional
    Structuring element used for the grayscale closing. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the closing may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_closing : ndarray
    Result of the grayscale closing of `input` with `structure`.

See also
--------
binary_closing, grey_dilation, grey_erosion, grey_opening,
generate_binary_structure

Notes
-----
The action of a grayscale closing with a flat structuring element amounts
to smoothen deep local minima, whereas binary closing fills small holes.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.arange(36).reshape((6,6))
&gt;&gt;&gt; a[3,3] = 0
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20,  0, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
&gt;&gt;&gt; ndimage.grey_closing(a, size=(3,3))
array([[ 7,  7,  8,  9, 10, 11],
       [ 7,  7,  8,  9, 10, 11],
       [13, 13, 14, 15, 16, 17],
       [19, 19, 20, 20, 22, 23],
       [25, 25, 26, 27, 28, 29],
       [31, 31, 32, 33, 34, 35]])
&gt;&gt;&gt; # Note that the local minimum a[3,3] has disappeared</pre> 
</div>
</div>
<a class="anchor" id="a2797039bf4c5ecf1c5325486d2d2a9a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.grey_dilation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate a greyscale dilation, using either a structuring element,
or a footprint corresponding to a flat structuring element.

Grayscale dilation is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a maximum filter over a sliding window.

Parameters
----------
input : array_like
    Array over which the grayscale dilation is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    dilation. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale dilation. Non-zero values give the set of
    neighbors of the center over which the maximum is chosen.
structure : array of ints, optional
    Structuring element used for the grayscale dilation. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the dilation may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_dilation : ndarray
    Grayscale dilation of `input`.

See also
--------
binary_dilation, grey_erosion, grey_closing, grey_opening
generate_binary_structure, ndimage.maximum_filter

Notes
-----
The grayscale dilation of an image input by a structuring element s defined
over a domain E is given by:

(input+s)(x) = max {input(y) + s(x-y), for y in E}

In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale dilation computes the maximum of the
input image inside a sliding window defined by E.

Grayscale dilation [1]_ is a *mathematical morphology* operation [2]_.

References
----------
.. [1] http://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1
&gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_dilation(a, footprint=np.ones((3,3)))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; s = ndimage.generate_binary_structure(2,1)
&gt;&gt;&gt; s
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; ndimage.grey_dilation(a, footprint=s)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 1, 3, 2, 1, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3)))
array([[1, 1, 1, 1, 1, 1, 1],
       [1, 2, 4, 4, 4, 2, 1],
       [1, 2, 4, 4, 4, 2, 1],
       [1, 2, 4, 4, 4, 3, 1],
       [1, 2, 2, 3, 3, 3, 1],
       [1, 2, 2, 3, 3, 3, 1],
       [1, 1, 1, 1, 1, 1, 1]])</pre> 
</div>
</div>
<a class="anchor" id="aa5a7684ebf91074d01d01a21c8c1e3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.grey_erosion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate a greyscale erosion, using either a structuring element,
or a footprint corresponding to a flat structuring element.

Grayscale erosion is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a minimum filter over a sliding window.

Parameters
----------
input : array_like
    Array over which the grayscale erosion is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    erosion. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale erosion. Non-zero values give the set of
    neighbors of the center over which the minimum is chosen.
structure : array of ints, optional
    Structuring element used for the grayscale erosion. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the erosion may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
output : ndarray
    Grayscale erosion of `input`.

See also
--------
binary_erosion, grey_dilation, grey_opening, grey_closing
generate_binary_structure, ndimage.minimum_filter

Notes
-----
The grayscale erosion of an image input by a structuring element s defined
over a domain E is given by:

(input+s)(x) = min {input(y) - s(x-y), for y in E}

In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale erosion computes the minimum of the
input image inside a sliding window defined by E.

Grayscale erosion [1]_ is a *mathematical morphology* operation [2]_.

References
----------
.. [1] http://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[1:6, 1:6] = 3
&gt;&gt;&gt; a[4,4] = 2; a[2,3] = 1
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 3, 3, 1, 3, 3, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 3, 3, 3, 2, 3, 0],
       [0, 3, 3, 3, 3, 3, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 3, 2, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; footprint = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; footprint
array([[False,  True, False],
       [ True,  True,  True],
       [False,  True, False]], dtype=bool)
&gt;&gt;&gt; # Diagonally-connected elements are not considered neighbors
&gt;&gt;&gt; ndimage.grey_erosion(a, size=(3,3), footprint=footprint)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 3, 1, 2, 0, 0],
       [0, 0, 3, 2, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="ad2c94356038bb7c8160c0ebbe9961865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.grey_opening </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional greyscale opening.

A greyscale opening consists in the succession of a greyscale erosion,
and a greyscale dilation.

Parameters
----------
input : array_like
    Array over which the grayscale opening is to be computed.
size : tuple of ints
    Shape of a flat and full structuring element used for the grayscale
    opening. Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the grayscale opening.
structure : array of ints, optional
    Structuring element used for the grayscale opening. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the opening may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
grey_opening : ndarray
    Result of the grayscale opening of `input` with `structure`.

See also
--------
binary_opening, grey_dilation, grey_erosion, grey_closing
generate_binary_structure

Notes
-----
The action of a grayscale opening with a flat structuring element amounts
to smoothen high local maxima, whereas binary opening erases small objects.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.arange(36).reshape((6,6))
&gt;&gt;&gt; a[3, 3] = 50
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 50, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
&gt;&gt;&gt; ndimage.grey_opening(a, size=(3,3))
array([[ 0,  1,  2,  3,  4,  4],
       [ 6,  7,  8,  9, 10, 10],
       [12, 13, 14, 15, 16, 16],
       [18, 19, 20, 22, 22, 22],
       [24, 25, 26, 27, 28, 28],
       [24, 25, 26, 27, 28, 28]])
&gt;&gt;&gt; # Note that the local maximum a[3,3] has disappeared</pre> 
</div>
</div>
<a class="anchor" id="a243de7395c0bb4289df930f188c83dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.iterate_structure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Iterate a structure by dilating it with itself.

Parameters
----------
structure : array_like
   Structuring element (an array of bools, for example), to be dilated with
   itself.
iterations : int
   number of dilations performed on the structure with itself
origin : optional
    If origin is None, only the iterated structure is returned. If
    not, a tuple of the iterated structure and the modified origin is
    returned.

Returns
-------
iterate_structure : ndarray of bools
    A new structuring element obtained by dilating `structure`
    (`iterations` - 1) times with itself.

See also
--------
generate_binary_structure

Examples
--------
&gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1)
&gt;&gt;&gt; struct.astype(int)
array([[0, 1, 0],
       [1, 1, 1],
       [0, 1, 0]])
&gt;&gt;&gt; ndimage.iterate_structure(struct, 2).astype(int)
array([[0, 0, 1, 0, 0],
       [0, 1, 1, 1, 0],
       [1, 1, 1, 1, 1],
       [0, 1, 1, 1, 0],
       [0, 0, 1, 0, 0]])
&gt;&gt;&gt; ndimage.iterate_structure(struct, 3).astype(int)
array([[0, 0, 0, 1, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 1, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a6b250101c90d40b2de24bbafe9e456a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.morphological_gradient </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional morphological gradient.

The morphological gradient is calculated as the difference between a
dilation and an erosion of the input with a given structuring element.

Parameters
----------
input : array_like
    Array over which to compute the morphlogical gradient.
size : tuple of ints
    Shape of a flat and full structuring element used for the mathematical
    morphology operations. Optional if `footprint` or `structure` is
    provided. A larger `size` yields a more blurred gradient.
footprint : array of ints, optional
    Positions of non-infinite elements of a flat structuring element
    used for the morphology operations. Larger footprints
    give a more blurred morphological gradient.
structure : array of ints, optional
    Structuring element used for the morphology operations.
    `structure` may be a non-flat structuring element.
output : array, optional
    An array used for storing the ouput of the morphological gradient
    may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'. Default
    is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default 0

Returns
-------
morphological_gradient : ndarray
    Morphological gradient of `input`.

See also
--------
grey_dilation, grey_erosion, ndimage.gaussian_gradient_magnitude

Notes
-----
For a flat structuring element, the morphological gradient
computed at a given point corresponds to the maximal difference
between elements of the input among the elements covered by the
structuring element centered on the point.

References
----------
.. [1] http://en.wikipedia.org/wiki/Mathematical_morphology

Examples
--------
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1
&gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; # The morphological gradient is computed as the difference
&gt;&gt;&gt; # between a dilation and an erosion
&gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3)) -\\
...  ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; a = np.zeros((7,7), dtype=np.int)
&gt;&gt;&gt; a[2:5, 2:5] = 1
&gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3
&gt;&gt;&gt; a
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 3, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 2, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 3, 3, 1, 0],
       [0, 1, 3, 2, 3, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 1, 1, 2, 2, 2, 0],
       [0, 0, 0, 0, 0, 0, 0]])</pre> 
</div>
</div>
<a class="anchor" id="a7616378b49db68c1226516a3cab54adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.morphological_laplace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional morphological laplace.

Parameters
----------
input : array_like
    Input.
size : int or sequence of ints, optional
    See `structure`.
footprint : bool or ndarray, optional
    See `structure`.
structure : structure
    Either `size`, `footprint`, or the `structure` must be provided.
output : ndarray
    An output array can optionally be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
    The mode parameter determines how the array borders are handled.
    For 'constant' mode, values beyond borders are set to be `cval`.
    Default is 'reflect'.
cval : scalar, optional
    Value to fill past edges of input if mode is 'constant'.
    Default is 0.0
origin : origin
    The origin parameter controls the placement of the filter.

Returns
-------
morphological_laplace : ndarray
    Output</pre> 
</div>
</div>
<a class="anchor" id="a50c956aece0670c09720de47ca8d9203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.ndimage.morphology.white_tophat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>footprint</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>structure</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>&quot;reflect&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cval</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>origin</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Multi-dimensional white tophat filter.

Parameters
----------
input : array_like
    Input.
size : tuple of ints
    Shape of a flat and full structuring element used for the filter.
    Optional if `footprint` or `structure` is provided.
footprint : array of ints, optional
    Positions of elements of a flat structuring element
    used for the white tophat filter.
structure : array of ints, optional
    Structuring element used for the filter. `structure`
    may be a non-flat structuring element.
output : array, optional
    An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
    The `mode` parameter determines how the array borders are
    handled, where `cval` is the value when mode is equal to
    'constant'. Default is 'reflect'
cval : scalar, optional
    Value to fill past edges of input if `mode` is 'constant'.
    Default is 0.0.
origin : scalar, optional
    The `origin` parameter controls the placement of the filter.
    Default is 0.

Returns
-------
output : ndarray
    Result of the filter of `input` with `structure`.

See also
--------
black_tophat</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a51ef986225fadb5aa25aa062dba80eea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list scipy.ndimage.morphology.__all__</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno"><a class="line" href="namespacescipy_1_1ndimage_1_1morphology.html">    1</a></span>&#160;= [<span class="stringliteral">&#39;iterate_structure&#39;</span>, <span class="stringliteral">&#39;generate_binary_structure&#39;</span>, <span class="stringliteral">&#39;binary_erosion&#39;</span>,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;           <span class="stringliteral">&#39;binary_dilation&#39;</span>, <span class="stringliteral">&#39;binary_opening&#39;</span>, <span class="stringliteral">&#39;binary_closing&#39;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;           <span class="stringliteral">&#39;binary_hit_or_miss&#39;</span>, <span class="stringliteral">&#39;binary_propagation&#39;</span>, <span class="stringliteral">&#39;binary_fill_holes&#39;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;           <span class="stringliteral">&#39;grey_erosion&#39;</span>, <span class="stringliteral">&#39;grey_dilation&#39;</span>, <span class="stringliteral">&#39;grey_opening&#39;</span>, <span class="stringliteral">&#39;grey_closing&#39;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;           <span class="stringliteral">&#39;morphological_gradient&#39;</span>, <span class="stringliteral">&#39;morphological_laplace&#39;</span>, <span class="stringliteral">&#39;white_tophat&#39;</span>,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;           <span class="stringliteral">&#39;black_tophat&#39;</span>, <span class="stringliteral">&#39;distance_transform_bf&#39;</span>, <span class="stringliteral">&#39;distance_transform_cdt&#39;</span>,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;           <span class="stringliteral">&#39;distance_transform_edt&#39;</span>]</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:12 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
