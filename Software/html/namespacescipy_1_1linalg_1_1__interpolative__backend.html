<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PyRo: scipy.linalg._interpolative_backend Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PyRo
   &#160;<span id="projectnumber">0.0.3</span>
   </div>
   <div id="projectbrief">PyRo is a device-oriented programming environment available via libraries for Python. Pyro is currently under alpha development with ongoing testing and prototyping of the environment architecture.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html">_interpolative_backend</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scipy.linalg._interpolative_backend Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abdf4970dd776dde170dd23634a8a3bc1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#abdf4970dd776dde170dd23634a8a3bc1">id_srand</a></td></tr>
<tr class="separator:abdf4970dd776dde170dd23634a8a3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48392c83034ae715a0a682d66e1dac73"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a48392c83034ae715a0a682d66e1dac73">id_srandi</a></td></tr>
<tr class="separator:a48392c83034ae715a0a682d66e1dac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99d114e4189b5aa3c8f5414792268b8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ac99d114e4189b5aa3c8f5414792268b8">id_srando</a></td></tr>
<tr class="separator:ac99d114e4189b5aa3c8f5414792268b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08e4887437e875c6428867e7f4de414"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ae08e4887437e875c6428867e7f4de414">idd_frm</a></td></tr>
<tr class="separator:ae08e4887437e875c6428867e7f4de414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0a382694d49adf39338c9e630651f0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a7d0a382694d49adf39338c9e630651f0">idd_sfrm</a></td></tr>
<tr class="separator:a7d0a382694d49adf39338c9e630651f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca49ffbbae1baa2b1b850dd22ae47eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#abca49ffbbae1baa2b1b850dd22ae47eb">idd_frmi</a></td></tr>
<tr class="separator:abca49ffbbae1baa2b1b850dd22ae47eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d894046b8bbc02fb010721a5219eeb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a43d894046b8bbc02fb010721a5219eeb">idd_sfrmi</a></td></tr>
<tr class="separator:a43d894046b8bbc02fb010721a5219eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6955ec84fb3b1e6ff9a49df50c9c7d98"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a6955ec84fb3b1e6ff9a49df50c9c7d98">iddp_id</a></td></tr>
<tr class="separator:a6955ec84fb3b1e6ff9a49df50c9c7d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dfbe8ca92a351adf393f357310f791"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a60dfbe8ca92a351adf393f357310f791">iddr_id</a></td></tr>
<tr class="separator:a60dfbe8ca92a351adf393f357310f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f507e3e97bed7552bb6dea4a15506d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a41f507e3e97bed7552bb6dea4a15506d">idd_reconid</a></td></tr>
<tr class="separator:a41f507e3e97bed7552bb6dea4a15506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c304ab5823c072e2db53e951755e2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ae6c304ab5823c072e2db53e951755e2e">idd_reconint</a></td></tr>
<tr class="separator:ae6c304ab5823c072e2db53e951755e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61213c255e403a143fe331d7e9eed166"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a61213c255e403a143fe331d7e9eed166">idd_copycols</a></td></tr>
<tr class="separator:a61213c255e403a143fe331d7e9eed166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb21f295e4ce26f23461ae2a72a17f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a1fb21f295e4ce26f23461ae2a72a17f7">idd_id2svd</a></td></tr>
<tr class="separator:a1fb21f295e4ce26f23461ae2a72a17f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fac5ea301701c676ba57d400e5c7cd1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a8fac5ea301701c676ba57d400e5c7cd1">idd_snorm</a></td></tr>
<tr class="separator:a8fac5ea301701c676ba57d400e5c7cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea828f8de938c5d69ad3b20b1a6bd3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a3ea828f8de938c5d69ad3b20b1a6bd3c">idd_diffsnorm</a></td></tr>
<tr class="separator:a3ea828f8de938c5d69ad3b20b1a6bd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67611059c81c4c2ab70bce88653938ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a67611059c81c4c2ab70bce88653938ef">iddr_svd</a></td></tr>
<tr class="separator:a67611059c81c4c2ab70bce88653938ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b0517a2bf9ed90d91d2f458f2de0a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a40b0517a2bf9ed90d91d2f458f2de0a2">iddp_svd</a></td></tr>
<tr class="separator:a40b0517a2bf9ed90d91d2f458f2de0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b47b577719e12bd2509d2668d2462d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a3b47b577719e12bd2509d2668d2462d7">iddp_aid</a></td></tr>
<tr class="separator:a3b47b577719e12bd2509d2668d2462d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893bbbf179dd8274882b13a86d2a7699"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a893bbbf179dd8274882b13a86d2a7699">idd_estrank</a></td></tr>
<tr class="separator:a893bbbf179dd8274882b13a86d2a7699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5147f1d2945ff0ee9bfec51346f1e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a7c5147f1d2945ff0ee9bfec51346f1e6">iddp_asvd</a></td></tr>
<tr class="separator:a7c5147f1d2945ff0ee9bfec51346f1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77423f7f0f45af44bab1904faf34dd3b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a77423f7f0f45af44bab1904faf34dd3b">iddp_rid</a></td></tr>
<tr class="separator:a77423f7f0f45af44bab1904faf34dd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58dcc26fae67723492e64bcf1b31b8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ab58dcc26fae67723492e64bcf1b31b8f">idd_findrank</a></td></tr>
<tr class="separator:ab58dcc26fae67723492e64bcf1b31b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a06f15e3ec853078a5f3327bed48736"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a1a06f15e3ec853078a5f3327bed48736">iddp_rsvd</a></td></tr>
<tr class="separator:a1a06f15e3ec853078a5f3327bed48736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552191ae5b3129dd0fc14fe580557c7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a552191ae5b3129dd0fc14fe580557c7d">iddr_aid</a></td></tr>
<tr class="separator:a552191ae5b3129dd0fc14fe580557c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19019a7a844846dcf9ee63fcb9ecc947"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a19019a7a844846dcf9ee63fcb9ecc947">iddr_aidi</a></td></tr>
<tr class="separator:a19019a7a844846dcf9ee63fcb9ecc947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd076c3ef03cc0c28c6b3426508e009"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a0bd076c3ef03cc0c28c6b3426508e009">iddr_asvd</a></td></tr>
<tr class="separator:a0bd076c3ef03cc0c28c6b3426508e009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5bab5444a55d571766e87a932323bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a4b5bab5444a55d571766e87a932323bc">iddr_rid</a></td></tr>
<tr class="separator:a4b5bab5444a55d571766e87a932323bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba830a96a00470b98f8bcf38be8ce245"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#aba830a96a00470b98f8bcf38be8ce245">iddr_rsvd</a></td></tr>
<tr class="separator:aba830a96a00470b98f8bcf38be8ce245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fc07a1f2a9cae415de27f553d820c5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a56fc07a1f2a9cae415de27f553d820c5">idz_frm</a></td></tr>
<tr class="separator:a56fc07a1f2a9cae415de27f553d820c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1cd826e8803684c11faf76e3cc7e9b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#adf1cd826e8803684c11faf76e3cc7e9b">idz_sfrm</a></td></tr>
<tr class="separator:adf1cd826e8803684c11faf76e3cc7e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058b3beb0f177777c522459f2e381212"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a058b3beb0f177777c522459f2e381212">idz_frmi</a></td></tr>
<tr class="separator:a058b3beb0f177777c522459f2e381212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e8e14641d8b0227709ad4d53baaf57"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a00e8e14641d8b0227709ad4d53baaf57">idz_sfrmi</a></td></tr>
<tr class="separator:a00e8e14641d8b0227709ad4d53baaf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372f28d27c3b6eaa5d3b83ab767f9fee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a372f28d27c3b6eaa5d3b83ab767f9fee">idzp_id</a></td></tr>
<tr class="separator:a372f28d27c3b6eaa5d3b83ab767f9fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5fa9e95f506cbabfa4b9d37a1459d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ace5fa9e95f506cbabfa4b9d37a1459d1">idzr_id</a></td></tr>
<tr class="separator:ace5fa9e95f506cbabfa4b9d37a1459d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add479a081a218c034929d886229a5210"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#add479a081a218c034929d886229a5210">idz_reconid</a></td></tr>
<tr class="separator:add479a081a218c034929d886229a5210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9a9761e7f021cd5999a7d7722ca73e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a1c9a9761e7f021cd5999a7d7722ca73e">idz_reconint</a></td></tr>
<tr class="separator:a1c9a9761e7f021cd5999a7d7722ca73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a6635270fe518308f9017f33a42da7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ae1a6635270fe518308f9017f33a42da7">idz_copycols</a></td></tr>
<tr class="separator:ae1a6635270fe518308f9017f33a42da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975748e797644f8ecc7633f4b0284c58"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a975748e797644f8ecc7633f4b0284c58">idz_id2svd</a></td></tr>
<tr class="separator:a975748e797644f8ecc7633f4b0284c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df03a3e76b4a6324868c960069db548"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a5df03a3e76b4a6324868c960069db548">idz_snorm</a></td></tr>
<tr class="separator:a5df03a3e76b4a6324868c960069db548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332dc0bdafc459264d890b9921c1ece9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a332dc0bdafc459264d890b9921c1ece9">idz_diffsnorm</a></td></tr>
<tr class="separator:a332dc0bdafc459264d890b9921c1ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad763182b50bafccd8b19813af99b5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#aacad763182b50bafccd8b19813af99b5">idzr_svd</a></td></tr>
<tr class="separator:aacad763182b50bafccd8b19813af99b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada491d9225bf786bf8d157dd511b60bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ada491d9225bf786bf8d157dd511b60bf">idzp_svd</a></td></tr>
<tr class="separator:ada491d9225bf786bf8d157dd511b60bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0438e58b9a19d09fea6ed427eda3178"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ab0438e58b9a19d09fea6ed427eda3178">idzp_aid</a></td></tr>
<tr class="separator:ab0438e58b9a19d09fea6ed427eda3178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954d53e7a2c8883f6ea52b55cda97caa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a954d53e7a2c8883f6ea52b55cda97caa">idz_estrank</a></td></tr>
<tr class="separator:a954d53e7a2c8883f6ea52b55cda97caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d26bb7f6e677ccae6e2dc4fc7669ce9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a7d26bb7f6e677ccae6e2dc4fc7669ce9">idzp_asvd</a></td></tr>
<tr class="separator:a7d26bb7f6e677ccae6e2dc4fc7669ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385fe6daf2aa6476835d3f5c5cc5242a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a385fe6daf2aa6476835d3f5c5cc5242a">idzp_rid</a></td></tr>
<tr class="separator:a385fe6daf2aa6476835d3f5c5cc5242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d42c836f4469489c49354b81f3caf8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a15d42c836f4469489c49354b81f3caf8">idz_findrank</a></td></tr>
<tr class="separator:a15d42c836f4469489c49354b81f3caf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064d49757c29991183b84f9cfab9482b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a064d49757c29991183b84f9cfab9482b">idzp_rsvd</a></td></tr>
<tr class="separator:a064d49757c29991183b84f9cfab9482b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1edc81e778e224983a017a8df5c0847"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ab1edc81e778e224983a017a8df5c0847">idzr_aid</a></td></tr>
<tr class="separator:ab1edc81e778e224983a017a8df5c0847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13d358a6118326d06b4007d1ace71eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#ae13d358a6118326d06b4007d1ace71eb">idzr_aidi</a></td></tr>
<tr class="separator:ae13d358a6118326d06b4007d1ace71eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c3f66c2f52e00d9fdf07f62c77f994"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a74c3f66c2f52e00d9fdf07f62c77f994">idzr_asvd</a></td></tr>
<tr class="separator:a74c3f66c2f52e00d9fdf07f62c77f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389c640a37e9ea4fc8588bcf2b040acb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a389c640a37e9ea4fc8588bcf2b040acb">idzr_rid</a></td></tr>
<tr class="separator:a389c640a37e9ea4fc8588bcf2b040acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dffe1a101e7683cc0f7f341b72d00c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a84dffe1a101e7683cc0f7f341b72d00c">idzr_rsvd</a></td></tr>
<tr class="separator:a84dffe1a101e7683cc0f7f341b72d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6cc03696964433e44dc6bc073d197cff"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1linalg_1_1__interpolative__backend.html#a6cc03696964433e44dc6bc073d197cff">_RETCODE_ERROR</a> = RuntimeError(&quot;nonzero <a class="el" href="stencilops_8h.html#afee67e5c8680c1bb9a8cb7bef7bfcc55">return</a> code&quot;)</td></tr>
<tr class="separator:a6cc03696964433e44dc6bc073d197cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abdf4970dd776dde170dd23634a8a3bc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.id_srand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate standard uniform pseudorandom numbers via a very efficient lagged
Fibonacci method.

:param n:
    Number of pseudorandom numbers to generate.
:type n: int

:return:
    Pseudorandom numbers.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a48392c83034ae715a0a682d66e1dac73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.id_srandi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize seed values for :func:`id_srand` (any appropriately random
numbers will do).

:param t:
    Array of 55 seed values.
:type t: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="ac99d114e4189b5aa3c8f5414792268b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.id_srando </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reset seed values to their original values.
</pre> 
</div>
</div>
<a class="anchor" id="a61213c255e403a143fe331d7e9eed166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_copycols </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct skeleton matrix from real ID.

:param A:
    Original matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`

:return:
    Skeleton matrix.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a3ea828f8de938c5d69ad3b20b1a6bd3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_diffsnorm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of the difference of two real matrices by the
randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the transpose of the first matrix to a vector, with
    call signature `y = matvect(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matvect: function
:param matvect2:
    Function to apply the transpose of the second matrix to a vector, with
    call signature `y = matvect2(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matvect2: function
:param matvec:
    Function to apply the first matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param matvec2:
    Function to apply the second matrix to a vector, with call signature
    `y = matvec2(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec2: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate of matrix difference.
:rtype: float
</pre> 
</div>
</div>
<a class="anchor" id="a893bbbf179dd8274882b13a86d2a7699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_estrank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate rank of a real matrix to a specified relative precision using
random sampling.

The output rank is typically about 8 higher than the actual rank.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank estimate.
:rtype: int
</pre> 
</div>
</div>
<a class="anchor" id="ab58dcc26fae67723492e64bcf1b31b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_findrank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate rank of a real matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function

:return:
    Rank estimate.
:rtype: int
</pre> 
</div>
</div>
<a class="anchor" id="ae08e4887437e875c6428867e7f4de414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_frm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform real vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idd_sfrm`, this routine works best when the length of
the transformed vector is the power-of-two integer output by
:func:`idd_frmi`, or when the length is not specified but instead
determined a posteriori from the output. The returned transformed vector is
randomly permuted.

:param n:
    Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from
    :func:`idd_frmi`; `n` is also the length of the output vector.
:type n: int
:param w:
    Initialization array constructed by :func:`idd_frmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="abca49ffbbae1baa2b1b850dd22ae47eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_frmi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize data for :func:`idd_frm`.

:param m:
    Length of vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n &lt;= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idd_frm`.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a1fb21f295e4ce26f23461ae2a72a17f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_id2svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert real ID to SVD.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a41f507e3e97bed7552bb6dea4a15506d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_reconid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct matrix from real ID.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Reconstructed matrix.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="ae6c304ab5823c072e2db53e951755e2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_reconint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct interpolation matrix from real ID.

:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Interpolation matrix.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a7d0a382694d49adf39338c9e630651f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_sfrm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform real vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idd_frm`, this routine works best when the length of
the transformed vector is known a priori.

:param l:
    Length of transformed vector, satisfying `l &lt;= n`.
:type l: int
:param n:
    Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from
    :func:`idd_sfrmi`.
:type n: int
:param w:
    Initialization array constructed by :func:`idd_sfrmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a43d894046b8bbc02fb010721a5219eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_sfrmi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize data for :func:`idd_sfrm`.

:param l:
    Length of output transformed vector.
:type l: int
:param m:
    Length of the vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n &lt;= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idd_sfrm`.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a8fac5ea301701c676ba57d400e5c7cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idd_snorm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of a real matrix by the randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate.
:rtype: float
</pre> 
</div>
</div>
<a class="anchor" id="a3b47b577719e12bd2509d2668d2462d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddp_aid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a real matrix to a specified relative precision using random
sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a7c5147f1d2945ff0ee9bfec51346f1e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddp_asvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a real matrix to a specified relative precision using random
sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a6955ec84fb3b1e6ff9a49df50c9c7d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddp_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a real matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a77423f7f0f45af44bab1904faf34dd3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddp_rid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a real matrix to a specified relative precision using random
matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a1a06f15e3ec853078a5f3327bed48736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddp_rsvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a real matrix to a specified relative precision using random
matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a40b0517a2bf9ed90d91d2f458f2de0a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddp_svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a real matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a552191ae5b3129dd0fc14fe580557c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddr_aid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a real matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a19019a7a844846dcf9ee63fcb9ecc947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddr_aidi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize array for :func:`iddr_aid`.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param k:
    Rank of ID.
:type k: int

:return:
    Initialization array to be used by :func:`iddr_aid`.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a0bd076c3ef03cc0c28c6b3426508e009"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddr_asvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a real matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a60dfbe8ca92a351adf393f357310f791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddr_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a real matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a4b5bab5444a55d571766e87a932323bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddr_rid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a real matrix to a specified rank using random matrix-vector
multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="aba830a96a00470b98f8bcf38be8ce245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddr_rsvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a real matrix to a specified rank using random matrix-vector
multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matvect:
    Function to apply the matrix transpose to a vector, with call signature
    `y = matvect(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvect: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a67611059c81c4c2ab70bce88653938ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.iddr_svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a real matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="ae1a6635270fe518308f9017f33a42da7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_copycols </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct skeleton matrix from complex ID.

:param A:
    Original matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`

:return:
    Skeleton matrix.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a332dc0bdafc459264d890b9921c1ece9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_diffsnorm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of the difference of two complex matrices by the
randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the adjoint of the first matrix to a vector, with
    call signature `y = matveca(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matveca: function
:param matveca2:
    Function to apply the adjoint of the second matrix to a vector, with
    call signature `y = matveca2(x)`, where `x` and `y` are the input and
    output vectors, respectively.
:type matveca2: function
:param matvec:
    Function to apply the first matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param matvec2:
    Function to apply the second matrix to a vector, with call signature
    `y = matvec2(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec2: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate of matrix difference.
:rtype: float
</pre> 
</div>
</div>
<a class="anchor" id="a954d53e7a2c8883f6ea52b55cda97caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_estrank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate rank of a complex matrix to a specified relative precision using
random sampling.

The output rank is typically about 8 higher than the actual rank.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank estimate.
:rtype: int
</pre> 
</div>
</div>
<a class="anchor" id="a15d42c836f4469489c49354b81f3caf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_findrank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate rank of a complex matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function

:return:
    Rank estimate.
:rtype: int
</pre> 
</div>
</div>
<a class="anchor" id="a56fc07a1f2a9cae415de27f553d820c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_frm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform complex vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idz_sfrm`, this routine works best when the length of
the transformed vector is the power-of-two integer output by
:func:`idz_frmi`, or when the length is not specified but instead
determined a posteriori from the output. The returned transformed vector is
randomly permuted.

:param n:
    Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from
    :func:`idz_frmi`; `n` is also the length of the output vector.
:type n: int
:param w:
    Initialization array constructed by :func:`idz_frmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a058b3beb0f177777c522459f2e381212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_frmi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize data for :func:`idz_frm`.

:param m:
    Length of vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n &lt;= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idz_frm`.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a975748e797644f8ecc7633f4b0284c58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_id2svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert complex ID to SVD.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="add479a081a218c034929d886229a5210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_reconid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct matrix from complex ID.

:param B:
    Skeleton matrix.
:type B: :class:`numpy.ndarray`
:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Reconstructed matrix.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a1c9a9761e7f021cd5999a7d7722ca73e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_reconint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct interpolation matrix from complex ID.

:param idx:
    Column index array.
:type idx: :class:`numpy.ndarray`
:param proj:
    Interpolation coefficients.
:type proj: :class:`numpy.ndarray`

:return:
    Interpolation matrix.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="adf1cd826e8803684c11faf76e3cc7e9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_sfrm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform complex vector via a composition of Rokhlin's random transform,
random subselection, and an FFT.

In contrast to :func:`idz_frm`, this routine works best when the length of
the transformed vector is known a priori.

:param l:
    Length of transformed vector, satisfying `l &lt;= n`.
:type l: int
:param n:
    Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from
    :func:`idz_sfrmi`.
:type n: int
:param w:
    Initialization array constructed by :func:`idd_sfrmi`.
:type w: :class:`numpy.ndarray`
:param x:
    Vector to be transformed.
:type x: :class:`numpy.ndarray`

:return:
    Transformed vector.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a00e8e14641d8b0227709ad4d53baaf57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_sfrmi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize data for :func:`idz_sfrm`.

:param l:
    Length of output transformed vector.
:type l: int
:param m:
    Length of the vector to be transformed.
:type m: int

:return:
    Greatest power-of-two integer `n` satisfying `n &lt;= m`.
:rtype: int
:return:
    Initialization array to be used by :func:`idz_sfrm`.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a5df03a3e76b4a6324868c960069db548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idz_snorm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>its</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Estimate spectral norm of a complex matrix by the randomized power method.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param its:
    Number of power method iterations.
:type its: int

:return:
    Spectral norm estimate.
:rtype: float
</pre> 
</div>
</div>
<a class="anchor" id="ab0438e58b9a19d09fea6ed427eda3178"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzp_aid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a complex matrix to a specified relative precision using
random sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a7d26bb7f6e677ccae6e2dc4fc7669ce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzp_asvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a complex matrix to a specified relative precision using
random sampling.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a372f28d27c3b6eaa5d3b83ab767f9fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzp_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a complex matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a385fe6daf2aa6476835d3f5c5cc5242a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzp_rid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a complex matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function

:return:
    Rank of ID.
:rtype: int
:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a064d49757c29991183b84f9cfab9482b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzp_rsvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a complex matrix to a specified relative precision using
random matrix-vector multiplication.

:param eps:
    Relative precision.
:type eps: float
:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="ada491d9225bf786bf8d157dd511b60bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzp_svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a complex matrix to a specified relative precision.

:param eps:
    Relative precision.
:type eps: float
:param A:
    Matrix.
:type A: :class:`numpy.ndarray`

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="ab1edc81e778e224983a017a8df5c0847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzr_aid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a complex matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="ae13d358a6118326d06b4007d1ace71eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzr_aidi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialize array for :func:`idzr_aid`.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param k:
    Rank of ID.
:type k: int

:return:
    Initialization array to be used by :func:`idzr_aid`.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a74c3f66c2f52e00d9fdf07f62c77f994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzr_asvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a complex matrix to a specified rank using random sampling.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="ace5fa9e95f506cbabfa4b9d37a1459d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzr_id </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a complex matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a389c640a37e9ea4fc8588bcf2b040acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzr_rid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute ID of a complex matrix to a specified rank using random
matrix-vector multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param k:
    Rank of ID.
:type k: int

:return:
    Column index array.
:rtype: :class:`numpy.ndarray`
:return:
    Interpolation coefficients.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="a84dffe1a101e7683cc0f7f341b72d00c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzr_rsvd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matveca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a complex matrix to a specified rank using random
matrix-vector multiplication.

:param m:
    Matrix row dimension.
:type m: int
:param n:
    Matrix column dimension.
:type n: int
:param matveca:
    Function to apply the matrix adjoint to a vector, with call signature
    `y = matveca(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matveca: function
:param matvec:
    Function to apply the matrix to a vector, with call signature
    `y = matvec(x)`, where `x` and `y` are the input and output vectors,
    respectively.
:type matvec: function
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<a class="anchor" id="aacad763182b50bafccd8b19813af99b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scipy.linalg._interpolative_backend.idzr_svd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute SVD of a complex matrix to a specified rank.

:param A:
    Matrix.
:type A: :class:`numpy.ndarray`
:param k:
    Rank of SVD.
:type k: int

:return:
    Left singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Right singular vectors.
:rtype: :class:`numpy.ndarray`
:return:
    Singular values.
:rtype: :class:`numpy.ndarray`
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a6cc03696964433e44dc6bc073d197cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple scipy.linalg._interpolative_backend._RETCODE_ERROR = RuntimeError(&quot;nonzero <a class="el" href="stencilops_8h.html#afee67e5c8680c1bb9a8cb7bef7bfcc55">return</a> code&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 3 2014 15:27:10 for PyRo by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
